<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">

<script type="text/javascript" src="theme/scripts/jquery-1.4.2.min.js"></script>

<link type="text/css" rel="stylesheet" href="hl-code/styles/shCore.css"/>
<link type="text/css" rel="stylesheet" href="hl-code/styles/shCoreRDark.css"/>
<link type="text/css" rel="stylesheet" href="hl-code/styles/shThemeRDark.css"/>
<script type="text/javascript" src="hl-code/scripts/shCore.js"></script>
<script type="text/javascript" src="hl-code/scripts/shAutoloader.js"></script>

<link type="text/css" rel="stylesheet" href="theme/styles/style.css" />

<script type="text/javascript" src="theme/scripts/script.js"></script>


<title>Concepts</title>
</head>
<body>




<h1>Concepts</h1>
<div class="toc">
<ul>
<li><a href="#toc_1">类型系统</a>
<ul>
<li><a href="#toc_1.1">命名规范</a>
<ul>
<li><a href="#toc_1.1.1">类</a>
<li><a href="#toc_1.1.2">源代码</a>
<li><a href="#toc_1.1.3">方法与变量</a>
<li><a href="#toc_1.1.4">属性</a>
</ul>
<li><a href="#toc_1.2">实践</a>
<ul>
<li><a href="#toc_1.2.1">声明</a>
<li><a href="#toc_1.2.2">配置</a>
<li><a href="#toc_1.2.3">静态成员</a>
</ul>
<li><a href="#toc_1.3">异常处理与调试</a>
</ul>
<li><a href="#toc_2">MVC架构</a>
</ul>
</div>

<h1 id="toc_1">类型系统</h1>

<h2 id="toc_1.1">命名规范</h2>

<h3 id="toc_1.1.1">类</h3>

<p>
类名只有字母数字，大写开头。命名空间可以有多层，最外层命名空间开头大写。只有Sencha官方发布的可以用<code>Ext</code>作为最外层命名空间。
</p>

<p>
驼峰风格，不能有连着两个字符大写。
</p>

<h3 id="toc_1.1.2">源代码</h3>

<p>
“源代码文件与目录”严格对应“类名与命名空间”。
</p>

<h3 id="toc_1.1.3">方法与变量</h3>

<p>
同类，但以小写开头。
</p>

<h3 id="toc_1.1.4">属性</h3>

<p>
同上。但要注意静态属性以大写开头：
</p>

<pre class="brush: javascript">
Ext.MessageBox.YES = "Yes"
Ext.MessageBox.NO = "No"
MyCompany.alien.Math.PI = "4.13"
</pre>



<h2 id="toc_1.2">实践</h2>

<h3 id="toc_1.2.1">声明</h3>

<p>
使用<code>Ext.define</code>定义类：
</p>

<pre class="brush: javascript">
Ext.define(className, members, onClassCreated);
</pre>

<dl>
<dt>className      </dt>
<dd>类名。</dd>
<dt>members        </dt>
<dd>一组类成员的键值对。</dd>
<dt>onClassCreated </dt>
<dd>（可选）回调函数。</dd>
</dl>

<p>
例子：
</p>

<pre class="brush: javascript">
Ext.define( 'My.sample.Person', {
    name: 'Unknown',
    constructor: function(name) {
        if (name) {
            this.name = name;
        }
    },
    eat: function(foodType) {
        alert(this.name + " is eating: " + foodType);
    }
});

var aaron = Ext.create('My.sample.Person', 'Aaron');
aaron.eat("Salad"); // alert("Aaron is eating: Salad");
</pre>

<p>
上面用<code>Ext.create</code>方法创建实例，而不推荐用<code>new My.sample.Person()</code>。<code>Ext.create</code>是动态加载的实例。第一个参数是类名，后面的参数给类的构造函数。
</p>

<h3 id="toc_1.2.2">配置</h3>

<p>
<code>config</code>成员通过<code>Ext.Class</code>的预处理器在类被创建前初始化：
</p>

<ul>
<li>
<code>config</code>成员和类的其他成员放在一起。

<li>
<code>config</code>成员会在类创建期间自动生成没有被显式定义的getter/setter与相关方法。

<li>
对每个<code>config</code>成员自动生成<code>apply</code>方法。在自动生成的<code>setter</code>方法设值前加入处理逻辑。

</ul>

<p>
例子：
</p>

<pre class="brush: javascript">
Ext.define('My.own.Window', {
   /** @readonly */
    isWindow: true,

    config: {
        title: 'Title Here',

        bottomBar: {
            enabled: true,
            height: 50,
            resizable: false
        }
    },

    constructor: function(config) {
        this.initConfig(config);
    },

    applyTitle: function(title) {
        if (!Ext.isString(title) || title.length === 0) {
            alert('Error: Title must be a valid non-empty string');
        }
        else {
            return title;
        }
    },

    applyBottomBar: function(bottomBar) {
        if (bottomBar &amp;&amp; bottomBar.enabled) {
            if (!this.bottomBar) {
                return Ext.create('My.own.WindowBottomBar', bottomBar);
            }
            else {
                this.bottomBar.setConfig(bottomBar);
            }
        }
    }
});
</pre>

<p>
调用方法：
</p>

<pre class="brush: javascript">
var myWindow = Ext.create('My.own.Window', {
    title: 'Hello World',
    bottomBar: {
        height: 60
    }
});

alert(myWindow.getTitle()); // alerts "Hello World"

myWindow.setTitle('Something New');

alert(myWindow.getTitle()); // alerts "Something New"

myWindow.setTitle(null); // alerts "Error: Title must be a valid non-empty string"

myWindow.setBottomBar({ height: 100 }); // Bottom bar's height is changed to 100
</pre>

<h3 id="toc_1.2.3">静态成员</h3>

<p>
定义静态成员：
</p>

<pre class="brush: javascript">
Ext.define('Computer', {
    statics: {
        instanceCount: 0,
        factory: function(brand) {
            // 'this' in static methods refer to the class itself
            return new this({brand: brand});
        }
    },

    config: {
        brand: null
    },

    constructor: function(config) {
        this.initConfig(config);

        // the 'self' property of an instance refers to its class
        this.self.instanceCount ++;
    }
});

var dellComputer = Computer.factory('Dell');
var appleComputer = Computer.factory('Mac');

alert(appleComputer.getBrand()); // using the auto-generated getter to get the value of a config property. Alerts "Mac"

alert(Computer.instanceCount); // Alerts "2"
</pre>

<h2 id="toc_1.3">异常处理与调试</h2>

<p>
抛异常时使用<code>Ext.getDisplayName()</code>取得任何方法的显示名。
</p>

<pre class="brush: javascript">
throw new Error('['+ Ext.getDisplayName(arguments.callee) +'] Some message here');
</pre>

<p>
任何由<code>Ext.define()</code>定义的类型抛出异常可以看到类名与方法名。
</p>









<h1 id="toc_2">MVC架构</h1>



<pre class="brush: javascript">
</pre>



<pre class="brush: javascript">
</pre>



<pre class="brush: javascript">
</pre>



<pre class="brush: javascript">
</pre>



<pre class="brush: javascript">
</pre>



<pre class="brush: javascript">
</pre>



<pre class="brush: javascript">
</pre>



<pre class="brush: javascript">
</pre>



<pre class="brush: javascript">
</pre>



<pre class="brush: javascript">
</pre>



<pre class="brush: javascript">
</pre>



<pre class="brush: javascript">
</pre>



<pre class="brush: javascript">
</pre>



<pre class="brush: javascript">
</pre>



<pre class="brush: javascript">
</pre>



<pre class="brush: javascript">
</pre>



<pre class="brush: javascript">
</pre>



<pre class="brush: javascript">
</pre>



<pre class="brush: javascript">
</pre>



<pre class="brush: javascript">
</pre>



<pre class="brush: javascript">
</pre>


</body>
</html>
