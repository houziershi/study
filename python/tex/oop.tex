\chapter{OOP与类}

	一个模块只能有一个实例，当一个模块的代码被修改以后必须重新加载模块才能生效；类可以同时创建多个实例（即对象）。

	\section{最简单的Python类}

		Python的类模型相当动态，类与实例只是命名空间对象。
		
		可以仅用pass作为占位语句生成一个没有任何成员的class，这样的class仅仅是一个空的命名空间对象。可以在以后通过赋值给这个类加上新的成员：

		\lstinputlisting[label=ch12:baseOOP, caption=类与实例]{py/expoo00.py}


	\section{类与实例的基本概念}
		
		类与类的实例都是对象。类是一个对象，该类的每个实例又各对应了一个关联到该类对象的实例对象。
		
		class语句会创建一个类对象并赋值给变量名。class语句块内的语句会创建数据对象和方法对象赋值给类的成员变量。类的成员只属于该类，不属于该类的实例。

		像调用函数一样调用类对象会创建该类的实例对象。每个实例对象根据具体类的创建属性并获得自己的命名空间，每个成员都有自己的实例。

		通过实例调用方法时，会把这个实例对象作为第一个参数self传递给方法。

		实例对象的\verb|__class__|属性记录了这个实例的类对象。

		\lstinputlisting[label=ch12:baseOOP, caption=类与实例]{py/expoo003.py}

	\section{类的属性与方法}

		python中把数据保存在对象中，相关的操作（方法）在类中。对于类和对象，无论数据还是方法都作为变量处理。

		对象的数据成员（无论是数据还是函数）在没有被第一次赋值之前，都不能被访问（就像是没有被声明的变量一样）。同样地也可以简章地通过赋值给变量增加一个成员。

		类对象与实例对象的\verb|__dict__|属性是大多数基于类的对象的命名空间字典。

		\lstinputlisting[label=ch12:funcandattr, caption=类的属性与方法]{py/expoop002.py}

	\section{类的继承}
		
		子类会继承父类的成员。如果当多重继承时遇到重名成员，优先级按声明继承时从左到右顺序。

		类对象的成员\verb|__bases__|是超类构成的元组

		\lstinputlisting[label=ch12:subclass, caption=类继承]{py/expoo01.py}

	\section{运算符重载}

		两头是下划线的方法名（\verb|__方法名__|）表示对运算符的重载。如：
		
		\verb|__add__|表示重载\verb|+|运算。

		\verb|__mul__|表示重载\verb|*|运算。

		对于没有定义或是继承的操作符，表示该操作不被支持。

		\lstinputlisting[label=ch12:reloadOpt, caption=运算符重载]{py/expoo05.py}

