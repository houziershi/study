
= 参数类型化 =

类型化参数能实现编写泛型类和特质。Scala中的泛型实例都应该写明具体类型（如：Set[Int]，Set[Int]），而不像Java中可以不带泛型类型。

== 开发纯函数式队列 ==

函数式的队列是不可变的，添加元素操作会返回一个新的队列。三个基本方法：

* `head`返回队列的第一个元素。
* `tail`返回第一个元素以外的队列。
* `append`返回在尾部添加指定元素的列队。

理想情况下，希望三种基本操作都可以在常量时间中完成。

一个实现方案是以`List`作为功能表达类型，可以用现成的`head`和`tail`方法。`append`方法调用连接操作：

{{{class="brush: scala"
  class SlowAppendQueue[T](elems: List[T]) { // Not efficient
    def head = elems.head
    def tail = new SlowAppendQueue(elems.tail)
    def append(x: T) = new SlowAppendQueue(elems ::: List(x))
  }
}}}

但这样`append`操作的时间会按元素的数量而增加，那换一种思路，把列表倒过来排序，这样会让原来最后加进来的元素出现在列表的最前面：

{{{class="brush: scala"
  class SlowHeadQueue[T](smele: List[T]) { // Not efficient
    // smele is elems reversed
    def head = smele.last
    def tail = new SlowHeadQueue(smele.init)
    def append(x: T) = new SlowHeadQueue(x :: smele)
  }
}}}

现在表现也倒过来了：`append`操作时间为常量，但`head`和`tail`耗时与元素数量成正比了。

试一下结合两种列表的方案：

用两个列表`leading`放前面一半；`trailing`放后一半反向排的元素。这样全部内容就是`leading ::: trailing.reverse`。

添加新元素：`i :: trailing`，这样常量时间就可以完成。但这样前一半的`leading`就不放进内容了，所以在对空的`leading`进行第一次`head`或`tail`操作前都要把`trailing`反转并复制给`leading`。这个操作被定义为`mirror`。

虽然`mirror`操作与队列长度成正比，但是这只发生在`leading`为空时才会被调用。因为如果`leading`不为空它将直接返回。

{{{class="brush: scala"
  class Queue[T](
    private val leading: List[T],
    private val trailing: List[T]
  ) {
    private def mirror =
      if (leading.isEmpty)
        new Queue(trailing.reverse, Nil)
      else
        this

    def head = mirror.leading.head

    def tail = {
      val q = mirror
      new Queue(q.leading.tail, q.trailing)
    }

    def append(x: T) =
      new Queue(leading, x :: trailing)
  }
}}}

== 信息隐藏 ==

前面的`Queue`实现暴露了太多实现细节，比如构造器的两个参数还有一个是反转的。

=== 私有构造器及工厂方法 ===

{{{class="brush: scala"
  class Queue[T] private (
    private val leading: List[T],
    private val trailing: List[T]
  )
}}}

这样防止外部调用主构造器：

{{{class="brush: scala"
  scala> new Queue(List(1, 2), List(3))
  <console>:6: error: constructor Queue cannot be accessed in
    object $iw
         new Queue(List(1, 2), List(3))
         ^
}}}

客户代码只能调用辅助构造器：

{{{class="brush: scala"
  def this() = this(Nil, Nil)
}}}

改良一下，让它可以带上初始队列元素列表：

{{{class="brush: scala"
  def this(elems: T*) = this(elems.toList, Nil)
}}}

其中的`T*`是重复参数标记，在前面“函数与闭包”一章中已经介绍。

还有一种让客户代码构造的方法是在类定义同一个文件内建立伴生类的工厂方法：

{{{class="brush: scala"
  object Queue {
    // constructs a queue with initial elements `xs'
    def apply[T](xs: T*) = new Queue[T](xs.toList, Nil)
  }
}}}

=== 可选方案：私有类 ===

除了私有构造器和私有成员，还可以直接隐藏掉类本身，只提供暴露类公共接口的特质：

{{{class="brush: scala"
  trait Queue[T] {
    def head: T
    def tail: Queue[T]
    def append(x: T): Queue[T]
  }

  object Queue {

    def apply[T](xs: T*): Queue[T] =
      new QueueImpl[T](xs.toList, Nil)

    private class QueueImpl[T](
      private val leading: List[T],
      private val trailing: List[T]
    ) extends Queue[T] {

      def mirror =
        if (leading.isEmpty)
          new QueueImpl(trailing.reverse, Nil)
        else
          this

      def head: T = mirror.leading.head

      def tail: QueueImpl[T] = {
        val q = mirror
        new QueueImpl(q.leading.tail, q.trailing)
      }

      def append(x: T) =
        new QueueImpl(leading, x :: trailing)
    }
  }
}}}


== 变化型注解 ==

上面的`Queue`物质创建实例时一定要加类型参数：

{{{class="brush: scala"
  scala> def doesNotCompile(q: Queue) {}
  <console>:5: error: trait Queue takes type parameters
         def doesNotCompile(q: Queue) {}

  scala> def doesCompile(q: Queue[AnyRef]) {}
  doesCompile: (Queue[AnyRef])Unit
}}}

Scala的泛型在默认情况下是非协变的（nonvariant），即`Queue[String]`不是`Queue[AnyRef]`的子类。但还是可以设置为协变（covariant）的。

用`+`表明子类型化协变，即`Queue[String]`是`Queue[AnyRef]`的子类：

{{{class="brush: scala"
  trait Queue[+T] { ... }
}}}

用`-`表示逆变（contravariant）子类型化，如果`T`类型是`S`的子类型，将隐含`Queue[S]`是`Queue[T]`的子类型：

{{{class="brush: scala"
  trait Queue[-T] { ... }
}}}

在纯函数式中，许多类型都是自然协变的。然而一旦引入了可变数据，情况就改变了。假设一个简单的只能读写一个元素的单元格（Cell）类型：

{{{class="brush: scala"
  class Cell[T](init: T) {
    private[this] var current = init
    def get = current
    def set(x: T) { current = x }
  }
}}}

上面的`Cell`是非协变的。我们现成假设它是协变的，声明为`Cell[+T]`并发送给Scala编译器。于是我们可以构建如下存在问题的语句序列：

{{{class="brush: scala"
  val c1 = new Cell[String]("abc")
}}}

建立`String`放在`c1`中，OK。

{{{class="brush: scala"
  val c2: Cell[Any] = c1
}}}

`c2`类型是`Cell[Any]`，也OK。

{{{class="brush: scala"
  c2.set(1)
}}}

`c2`里存数字，也OK。

{{{class="brush: scala"
  val s: String = c1.get
}}}

`c1`里的字符串，赋给字符串也OK。

上面四行都OK，但是看看这四行放在一起，就出问题了：

{{{class="brush: scala"
  val c1 = new Cell[String]("abc")
  val c2: Cell[Any] = c1
  c2.set(1)
  val s: String = c1.get

  Cell.scala:7: error: covariant type T occurs in
  contravariant position in type T of value x
     def set(x: T) = current = x
                ^
}}}

这四行代码是要把整数`1`赋值给字符串`s`，这样破坏了类型声明。问题出在第二行，`Cell[Any]`和`Cell[String]`的类型的协变引起了错误。

=== 变化型和数组 ===

以前面的`Cell`类为例与Java中的数组比较，Java中的数组是协变的：

{{{class="brush: scala"
  // this is Java
  String[] a1 = { "abc" };
  Object[] a2 = a1;
  a2[0] = new Integer(17);
  String s = a1[0];
}}}

虽然可以通过编译，但是运行时第四行会报错。Java运行时保存了数组元素类型，在更新时对新元素进行合法性校验。类型错误时抛出`ArrayStore`：

{{{class="brush: scala"
  Exception in thread "main" java.lang.ArrayStoreException:
  java.lang.Integer
          at JavaArrays.main(JavaArrays.java:8)
}}}

这样看起来好像即没有用又浪费性能。按James Gosling的说法是希望有一个通用处理数组的简单方法，如需要排序所有元素时：

{{{class="brush: scala"
  void sort(Object[] a, Comparator cmp) { ... }
}}}

这样确保任意参数类型的数组都可以传入排序方法。当然后来Java有了泛型以后数组的协变不再有用了，为了向以前老版本兼容才留着。

Scala中数组是不可协变的：

{{{class="brush: scala"
  scala> val a1 = Array("abc")
  a1: Array[java.lang.String] = Array(abc)

  scala> val a2: Array[Any] = a1
  <console>:5: error: type mismatch;
   found : Array[java.lang.String]
   required: Array[Any]
         val a2: Array[Any] = a1
                              ^
}}}

但有时还是要数组能泛型手段与Java遗留方法进行交互。所以Scala允许把`T`类型的数组造型为任意`T`的超类的数组：

{{{class="brush: scala"
  scala> val a2: Array[Object] =
       | a1.asInstanceOf[Array[Object]]
  a2: Array[java.lang.Object] = Array(abc)
}}}

== 检查变化型注解 ==

再看几个不合适的协变例子：

把前面的队列改成协变的，然后创建指定元素类型为`Int`的队列。并重载`append`方法使其在添加前先输出它参数的平方根：

{{{class="brush: scala"
  class StrangeIntQueue extends Queue[Int] {
    override def append(x: Int) = {
      println(Math.sqrt(x))
      super.append(x)
    }
  }
}}}

假设上面的代码是协变的，对应以下的调用：

{{{class="brush: scala"
  val x: Queue[Any] = new StrangeIntQueue
  x.append("abc")
}}}

上面的因为协变所以第一行是有效的，但第二行就有问题了……对字符串求平方根……

在更加广泛的情况下，只要把泛型作为方法参数类型，包含它的类或特质就有可能不能与这个类型参数一直协变，对于队列来说，`append`方法违反了以下情况：

{{{class="brush: scala"
  class Queue[+T] {
    def append(x: T) = 
     ...
  }
}}}

所以编译器会报错：

{{{class="brush: scala"
  Queues.scala:11: error: covariant type T occurs in
  contravariant position in type T of value x
    def append(x: T) = 
               ^
}}}

不要对可重新赋值的字段使用`+`的协变参数类型。如`var x:T`在Scala里被看作自带`getter`方法`def x:T`、`def x_= (y:T)`，所以将不是协变的。

=== 变化型注解的验证方式 ===

深入讲述一些概念前，首选，我们把类和物质都简单称为“类”。然后对于这些类可能会用到类型参数的地方被分为正、负、中立。编译器检查类的类型参数的每一个用法。

`+`的类型参数只能被用在正的位置上，`-`的类型参数只能用在负的位置上。没有变化型注解的类型可以用于任何位置，所以它是唯一能被用在类结构体的中性位置上的类型参数。

编译器对位置分类是从类型声明开始进入更深的内嵌层。处于声明类最顶层被划为正的位置。默认情况下内层位置的分类会和外层一致。

但总有例外：方法值参数位置是方法外部的位置的翻转类别，这里正位置传为负，负转为正，而中性位置仍然保持中性。

除了方法值参数位置外，方法的类型参数的当前类别也会被翻转。而类型参数的位置，如`C[Arg]`中的`Arg`也有可以被翻转，这取决于对应类型参数的变化型：

如果`C`的类型参数标了`+`号，那么类别不变；如果标了`-`号，则当前类别被翻转；如果`C`的类型参数没有变化型注解，那么当前类型将改为中性。

下面的例子比较生编硬造，下面类型定义中的若干位置变化弄被标了正`+`或`-`负：

类型参数`W`与两个值参数`volume`和`listener`的位置都是负的。

<img src='images/19.01.png' />

注意`meow`的结果类型，第一个`Cat[U, T]`参数的位置是负的。因为`Cat`的第一个类型参数`[T]`被标了`-`。这个参数中的类型`U`重新转为正的位置（两次翻转），而参数中的类型`T`仍然是负位置。

总的来说：人脑想跟上变化型位置的变化是很困难的，所以Scala编译器自动来完成这项工作。计算机变化型过程中，编译器检查每个类型参数是否仅用于分类正确的位置上。

就上面的例子来说，`T`仅用在负位置上，而`U`仅用于正的位置上。所以这个`Cat`类是正确的。

== 下界 ==

{{{class="brush: scala"
}}}

{{{class="brush: scala"
}}}

{{{class="brush: scala"
}}}

{{{class="brush: scala"
}}}

{{{class="brush: scala"
}}}

{{{class="brush: scala"
}}}

{{{class="brush: scala"
}}}

{{{class="brush: scala"
}}}

{{{class="brush: scala"
}}}

{{{class="brush: scala"
}}}

{{{class="brush: scala"
}}}

{{{class="brush: scala"
}}}

{{{class="brush: scala"
}}}

{{{class="brush: scala"
}}}

{{{class="brush: scala"
}}}

{{{class="brush: scala"
}}}

{{{class="brush: scala"
}}}

{{{class="brush: scala"
}}}

{{{class="brush: scala"
}}}

{{{class="brush: scala"
}}}

{{{class="brush: scala"
}}}

{{{class="brush: scala"
}}}

{{{class="brush: scala"
}}}

{{{class="brush: scala"
}}}

{{{class="brush: scala"
}}}

{{{class="brush: scala"
}}}

{{{class="brush: scala"
}}}

{{{class="brush: scala"
}}}

{{{class="brush: scala"
}}}

{{{class="brush: scala"
}}}

{{{class="brush: scala"
}}}

{{{class="brush: scala"
}}}

{{{class="brush: scala"
}}}

{{{class="brush: scala"
}}}

{{{class="brush: scala"
}}}

{{{class="brush: scala"
}}}

{{{class="brush: scala"
}}}

{{{class="brush: scala"
}}}

{{{class="brush: scala"
}}}

{{{class="brush: scala"
}}}

{{{class="brush: scala"
}}}

{{{class="brush: scala"
}}}

{{{class="brush: scala"
}}}

{{{class="brush: scala"
}}}

{{{class="brush: scala"
}}}

{{{class="brush: scala"
}}}

{{{class="brush: scala"
}}}

{{{class="brush: scala"
}}}

{{{class="brush: scala"
}}}

{{{class="brush: scala"
}}}

{{{class="brush: scala"
}}}

{{{class="brush: scala"
}}}

{{{class="brush: scala"
}}}

{{{class="brush: scala"
}}}

{{{class="brush: scala"
}}}

{{{class="brush: scala"
}}}

{{{class="brush: scala"
}}}

{{{class="brush: scala"
}}}

{{{class="brush: scala"
}}}

{{{class="brush: scala"
}}}

{{{class="brush: scala"
}}}

{{{class="brush: scala"
}}}

{{{class="brush: scala"
}}}

{{{class="brush: scala"
}}}

{{{class="brush: scala"
}}}

{{{class="brush: scala"
}}}

{{{class="brush: scala"
}}}

{{{class="brush: scala"
}}}

{{{class="brush: scala"
}}}

{{{class="brush: scala"
}}}

{{{class="brush: scala"
}}}

{{{class="brush: scala"
}}}

{{{class="brush: scala"
}}}

{{{class="brush: scala"
}}}

{{{class="brush: scala"
}}}

{{{class="brush: scala"
}}}
