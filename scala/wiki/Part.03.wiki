%title Part III

%toc Part III

= 参数类型化 =

类型化参数能实现编写泛型类和特质。Scala中的泛型实例都应该写明具体类型（如：Set[Int]，Set[Int]），而不像Java中可以不带泛型类型。

== 开发纯函数式队列 ==

函数式的队列是不可变的，添加元素操作会返回一个新的队列。三个基本方法：

* `head`返回队列的第一个元素。
* `tail`返回第一个元素以外的队列。
* `append`返回在尾部添加指定元素的列队。

理想情况下，希望三种基本操作都可以在常量时间中完成。

一个实现方案是以`List`作为功能表达类型，可以用现成的`head`和`tail`方法。`append`方法调用连接操作：

{{{class="brush: scala"
  class SlowAppendQueue[T](elems: List[T]) { // Not efficient
    def head = elems.head
    def tail = new SlowAppendQueue(elems.tail)
    def append(x: T) = new SlowAppendQueue(elems ::: List(x))
  }
}}}

但这样`append`操作的时间会按元素的数量而增加，那换一种思路，把列表倒过来排序，这样会让原来最后加进来的元素出现在列表的最前面：

{{{class="brush: scala"
  class SlowHeadQueue[T](smele: List[T]) { // Not efficient
    // smele is elems reversed
    def head = smele.last
    def tail = new SlowHeadQueue(smele.init)
    def append(x: T) = new SlowHeadQueue(x :: smele)
  }
}}}

现在表现也倒过来了：`append`操作时间为常量，但`head`和`tail`耗时与元素数量成正比了。

试一下结合两种列表的方案：

用两个列表`leading`放前面一半；`trailing`放后一半反向排的元素。这样全部内容就是`leading ::: trailing.reverse`。

添加新元素：`i :: trailing`，这样常量时间就可以完成。但这样前一半的`leading`就不放进内容了，所以在对空的`leading`进行第一次`head`或`tail`操作前都要把`trailing`反转并复制给`leading`。这个操作被定义为`mirror`。

虽然`mirror`操作与队列长度成正比，但是这只发生在`leading`为空时才会被调用。因为如果`leading`不为空它将直接返回。

{{{class="brush: scala"
  class Queue[T](
    private val leading: List[T],
    private val trailing: List[T]
  ) {
    private def mirror =
      if (leading.isEmpty)
        new Queue(trailing.reverse, Nil)
      else
        this

    def head = mirror.leading.head

    def tail = {
      val q = mirror
      new Queue(q.leading.tail, q.trailing)
    }

    def append(x: T) =
      new Queue(leading, x :: trailing)
  }
}}}

== 信息隐藏 ==

前面的`Queue`实现暴露了太多实现细节，比如构造器的两个参数还有一个是反转的。

=== 私有构造器及工厂方法 ===

{{{class="brush: scala"
  class Queue[T] private (
    private val leading: List[T],
    private val trailing: List[T]
  )
}}}

这样防止外部调用主构造器：

{{{class="brush: scala"
  scala> new Queue(List(1, 2), List(3))
  <console>:6: error: constructor Queue cannot be accessed in
    object $iw
         new Queue(List(1, 2), List(3))
         ^
}}}

客户代码只能调用辅助构造器：

{{{class="brush: scala"
  def this() = this(Nil, Nil)
}}}

改良一下，让它可以带上初始队列元素列表：

{{{class="brush: scala"
  def this(elems: T*) = this(elems.toList, Nil)
}}}

其中的`T*`是重复参数标记，在前面“函数与闭包”一章中已经介绍。

还有一种让客户代码构造的方法是在类定义同一个文件内建立伴生类的工厂方法：

{{{class="brush: scala"
  object Queue {
    // constructs a queue with initial elements `xs'
    def apply[T](xs: T*) = new Queue[T](xs.toList, Nil)
  }
}}}

=== 可选方案：私有类 ===

除了私有构造器和私有成员，还可以直接隐藏掉类本身，只提供暴露类公共接口的特质：

{{{class="brush: scala"
  trait Queue[T] {
    def head: T
    def tail: Queue[T]
    def append(x: T): Queue[T]
  }

  object Queue {

    def apply[T](xs: T*): Queue[T] =
      new QueueImpl[T](xs.toList, Nil)

    private class QueueImpl[T](
      private val leading: List[T],
      private val trailing: List[T]
    ) extends Queue[T] {

      def mirror =
        if (leading.isEmpty)
          new QueueImpl(trailing.reverse, Nil)
        else
          this

      def head: T = mirror.leading.head

      def tail: QueueImpl[T] = {
        val q = mirror
        new QueueImpl(q.leading.tail, q.trailing)
      }

      def append(x: T) =
        new QueueImpl(leading, x :: trailing)
    }
  }
}}}


== 变化型注解 ==

上面的`Queue`物质创建实例时一定要加类型参数：

{{{class="brush: scala"
  scala> def doesNotCompile(q: Queue) {}
  <console>:5: error: trait Queue takes type parameters
         def doesNotCompile(q: Queue) {}

  scala> def doesCompile(q: Queue[AnyRef]) {}
  doesCompile: (Queue[AnyRef])Unit
}}}

Scala的泛型在默认情况下是非协变的（nonvariant），即`Queue[String]`不是`Queue[AnyRef]`的子类。但还是可以设置为协变（covariant）的。

用`+`表明子类型化协变，即`Queue[String]`是`Queue[AnyRef]`的子类：

{{{class="brush: scala"
  trait Queue[+T] { ... }
}}}

用`-`表示逆变（contravariant）子类型化，如果`T`类型是`S`的子类型，将隐含`Queue[S]`是`Queue[T]`的子类型：

{{{class="brush: scala"
  trait Queue[-T] { ... }
}}}

在纯函数式中，许多类型都是自然协变的。然而一旦引入了可变数据，情况就改变了。假设一个简单的只能读写一个元素的单元格（Cell）类型：

{{{class="brush: scala"
  class Cell[T](init: T) {
    private[this] var current = init
    def get = current
    def set(x: T) { current = x }
  }
}}}

上面的`Cell`是非协变的。我们现成假设它是协变的，声明为`Cell[+T]`并发送给Scala编译器。于是我们可以构建如下存在问题的语句序列：

{{{class="brush: scala"
  val c1 = new Cell[String]("abc")
}}}

建立`String`放在`c1`中，OK。

{{{class="brush: scala"
  val c2: Cell[Any] = c1
}}}

`c2`类型是`Cell[Any]`，也OK。

{{{class="brush: scala"
  c2.set(1)
}}}

`c2`里存数字，也OK。

{{{class="brush: scala"
  val s: String = c1.get
}}}

`c1`里的字符串，赋给字符串也OK。

上面四行都OK，但是看看这四行放在一起，就出问题了：

{{{class="brush: scala"
  val c1 = new Cell[String]("abc")
  val c2: Cell[Any] = c1
  c2.set(1)
  val s: String = c1.get

  Cell.scala:7: error: covariant type T occurs in
  contravariant position in type T of value x
     def set(x: T) = current = x
                ^
}}}

这四行代码是要把整数`1`赋值给字符串`s`，这样破坏了类型声明。问题出在第二行，`Cell[Any]`和`Cell[String]`的类型的协变引起了错误。

=== 变化型和数组 ===

以前面的`Cell`类为例与Java中的数组比较，Java中的数组是协变的：

{{{class="brush: scala"
  // this is Java
  String[] a1 = { "abc" };
  Object[] a2 = a1;
  a2[0] = new Integer(17);
  String s = a1[0];
}}}

虽然可以通过编译，但是运行时第四行会报错。Java运行时保存了数组元素类型，在更新时对新元素进行合法性校验。类型错误时抛出`ArrayStore`：

{{{class="brush: scala"
  Exception in thread "main" java.lang.ArrayStoreException:
  java.lang.Integer
          at JavaArrays.main(JavaArrays.java:8)
}}}

这样看起来好像即没有用又浪费性能。按James Gosling的说法是希望有一个通用处理数组的简单方法，如需要排序所有元素时：

{{{class="brush: scala"
  void sort(Object[] a, Comparator cmp) { ... }
}}}

这样确保任意参数类型的数组都可以传入排序方法。当然后来Java有了泛型以后数组的协变不再有用了，为了向以前老版本兼容才留着。

Scala中数组是不可协变的：

{{{class="brush: scala"
  scala> val a1 = Array("abc")
  a1: Array[java.lang.String] = Array(abc)

  scala> val a2: Array[Any] = a1
  <console>:5: error: type mismatch;
   found : Array[java.lang.String]
   required: Array[Any]
         val a2: Array[Any] = a1
                              ^
}}}

但有时还是要数组能泛型手段与Java遗留方法进行交互。所以Scala允许把`T`类型的数组造型为任意`T`的超类的数组：

{{{class="brush: scala"
  scala> val a2: Array[Object] =
       | a1.asInstanceOf[Array[Object]]
  a2: Array[java.lang.Object] = Array(abc)
}}}

== 检查变化型注解 ==

再看几个不合适的协变例子：

把前面的队列改成协变的，然后创建指定元素类型为`Int`的队列。并重载`append`方法使其在添加前先输出它参数的平方根：

{{{class="brush: scala"
  class StrangeIntQueue extends Queue[Int] {
    override def append(x: Int) = {
      println(Math.sqrt(x))
      super.append(x)
    }
  }
}}}

假设上面的代码是协变的，对应以下的调用：

{{{class="brush: scala"
  val x: Queue[Any] = new StrangeIntQueue
  x.append("abc")
}}}

上面的因为协变所以第一行是有效的，但第二行就有问题了……对字符串求平方根……

在更加广泛的情况下，只要把泛型作为方法参数类型，包含它的类或特质就有可能不能与这个类型参数一直协变，对于队列来说，`append`方法违反了以下情况：

{{{class="brush: scala"
  class Queue[+T] {
    def append(x: T) = 
     ...
  }
}}}

所以编译器会报错：

{{{class="brush: scala"
  Queues.scala:11: error: covariant type T occurs in
  contravariant position in type T of value x
    def append(x: T) = 
               ^
}}}

不要对可重新赋值的字段使用`+`的协变参数类型。如`var x:T`在Scala里被看作自带`getter`方法`def x:T`、`def x_= (y:T)`，所以将不是协变的。

=== 变化型注解的验证方式 ===

深入讲述一些概念前，首选，我们把类和物质都简单称为“类”。然后对于这些类可能会用到类型参数的地方被分为正、负、中立。编译器检查类的类型参数的每一个用法。

`+`的类型参数只能被用在正的位置上，`-`的类型参数只能用在负的位置上。没有变化型注解的类型可以用于任何位置，所以它是唯一能被用在类结构体的中性位置上的类型参数。

编译器对位置分类是从类型声明开始进入更深的内嵌层。处于声明类最顶层被划为正的位置。默认情况下内层位置的分类会和外层一致。

但总有例外：方法值参数位置是方法外部的位置的翻转类别，这里正位置传为负，负转为正，而中性位置仍然保持中性。

除了方法值参数位置外，方法的类型参数的当前类别也会被翻转。而类型参数的位置，如`C[Arg]`中的`Arg`也有可以被翻转，这取决于对应类型参数的变化型：

如果`C`的类型参数标了`+`号，那么类别不变；如果标了`-`号，则当前类别被翻转；如果`C`的类型参数没有变化型注解，那么当前类型将改为中性。

下面的例子比较生编硬造，下面类型定义中的若干位置变化弄被标了正`+`或`-`负：

类型参数`W`与两个值参数`volume`和`listener`的位置都是负的。

<img src='images/19.01.png' />

注意`meow`的结果类型，第一个`Cat[U, T]`参数的位置是负的。因为`Cat`的第一个类型参数`[T]`被标了`-`。这个参数中的类型`U`重新转为正的位置（两次翻转），而参数中的类型`T`仍然是负位置。

总的来说：人脑想跟上变化型位置的变化是很困难的，所以Scala编译器自动来完成这项工作。计算机变化型过程中，编译器检查每个类型参数是否仅用于分类正确的位置上。

就上面的例子来说，`T`仅用在负位置上，而`U`仅用于正的位置上。所以这个`Cat`类是正确的。

== 下界 ==

在之前的“可选方案：私有类”这一节中展示的是没有办法协变的实现`Queue[T]`。因为类型`T`作为参数出现在`append`方法中，而这个位置是负的。

所幸有一个办法：可能通过把`append`变为金矿以使其泛型化并使用它的类型参数的下界：

{{{class="brush: scala"
  class Queue[+T] (private val leading: List[T],
      private val trailing: List[T] ) {
    def append[U >: T](x: U) = 
      new Queue[U](leading, x :: trailing) // ...
  }
}}}

`append`方法指定的类型参数`U`，并通过语法`U >: T`定义了`T`为`U`的下界，即：`U`必须是`T`的超类。返回类型也成了`Queue[U]`。

要注意对于同一个类来说，即是超类也是子类。所以`T`是`U`下界，用`T`传入也是可以的。

例子：对于`Fruit`和两个子类`Orange`和`Apple`，可以把`Orange`对象传入`Queue[Apple]`而返回`Queue[Fruit]`。

从技术角度来看，这里的情况发生了下界的翻转：类型参数`U`处于负位置（1次翻转），面下界`>: T`处于正的位置（两次翻转）。


=== 逆变 ===

前面所有的例子不是协变的就是非协变的。还有一些情况下会有逆变：

{{{class="brush: scala"
  trait OutputChannel[-T] {
    def write(x: T)
  }
}}}

举例来说：这种情况下`AnyRef`作为`String`的子类型。如：把一个`OutputChannel[AnyRef]`赋给`OutputChannel[String]`是安全的，反过来把一个`OutputChannel[String]`赋给`OutputChannel[AnyRef]`却是不安全的。

当然这要有前提：`AnyRef`要支持`String`在这这里会用到的操作。

Scala函数物质中协变与逆变混在一起用的情况会比较多。对于`S => T`类型的函数会定义`Function[S, T]`，这时对参数`A`逆变而对结果`B`协变就是一种有用的策略：

{{{class="brush: scala"
  trait Function1[-S, +T] {
    def apply(x: S): T
  }
}}}

应用的例子：

父类出版物的构造函数有一个标题参数，子类书的构造函数会调用父类的构造函数。

{{{class="brush: scala"
class Publication(val title: String)
class Book(title: String) extends Publication(title)
}}}

单例对象`Library`定义了书的集，以及打印书单的方法`printBookList`的唯一参数是以`Book => AnyRef`类型的方法为参数。

{{{class="brush: scala"
object Library {
 val books: Set[Book] =
   Set(
     new Book("Programming in Scala"),
     new Book("Walden")
   )
 def printBookList(info: Book => AnyRef) {
   for (book <- books) println(info(book))
 }
}
}}}

单例对象`Customer`定义了方法`getTitle`根据出版物取得标题。最后一行调用`Library`的打印书单方法：

{{{class="brush: scala"
object Customer extends Application {
 def getTitle(p: Publication): String = p.title
 Library.printBookList(getTitle)
}
}}}

`printBookList`中的`println`方法会用到`toString`，这对所有`String`及`AnyRef`子类都有用，这里用到了函数结果类型的协变。

再来看`printBookList`的参数：指定的类型是`Book => AnyRef`，但实际调用时给的时`Publication => String`。参数是父类（`Book`的父类`Publication`）而结果是子类（`AnyRef`的子类`String`）。

== 对象私有数据 ==

之前的`Queue`类待改进内容：当`leading`列表为空时如果重复调用`head`，那么`mirror`操作会重复地把`trailing`复制到`leading`列表。

改动：

`leading`和`trailing`都是可变变量，`mirror`操作在当前列表上产生副作用而不是返回新的队列。由于它们都是对外不可见的私有变量，所以`Queue`还是算纯函数对象。

{{{class="brush: scala"
 class Queue[+T] private (
   private[this] var leading: List[T], 
   private[this] var trailing: List[T]
 ) {

   private def mirror() = 
     if (leading.isEmpty) {
       while (!trailing.isEmpty) {
         leading = trailing.head :: leading
         trailing = trailing.tail
       }
     }

   def head: T = { 
     mirror()
     leading.head 
   }

   def tail: Queue[T] = { 
     mirror()
     new Queue(leading.tail, trailing) 
   }

   def append[U >: T](x: U) = 
     new Queue[U](leading, x :: trailing)
 }
}}}

在两个可变私有成员变量的情况下`Queue`还可以使用协变。因为对于对象的私有值访问来说不可能有比定义的对象类型更弱的静态类型对象引用。

所以Scala的类型变化检查对于对象私有成员，在遇到带有`+`或`-`的类型参数只出现在具有相同变化型分类的位置上时，会被忽略。

所以如果去掉`private`修饰符的`[this]`限定会编译不过：

{{{class="brush: scala"
  Queues.scala:1: error: covariant type T occurs in 
  contravariant position in type List[T] of parameter of
  setter leading_=
  class Queue[+T] private (private var leading: List[T],
                                       ^
  Queues.scala:1: error: covariant type T occurs in 
  contravariant position in type List[T] of parameter of
  setter trailing_=
                           private var trailing: List[T]) {
                                       ^
}}}

上面分别报错的原因是：协变类型`T`出现在setter函数`leading_=`参数类型List[T]的逆变位置上；协变类型`T`出现在setter函数`trailing_=`参数类型List[T]的逆变位置上。

== 上界 ==

之前在“使用列表”章的第一节“列表字面量”中实现一个归并排序的方法。它的第一个参数是比较函数，第二个柯里化的参数是要排序的列表。对这个函数的另一种组织方法大概 就是把列表类型混入到`ordered`特质中。

通过把`Ordered`特质混入到类中并实现抽象的比较方法`Compare`，就可以对实例进行比较：

{{{class="brush: scala"
  class Person(val firstName: String, val lastName: String)
      extends Ordered[Person] {

    def compare(that: Person) = {
      val lastNameComparison =
        lastName.compareToIgnoreCase(that.lastName)
      if (lastNameComparison != 0)
        lastNameComparison
      else
        firstName.compareToIgnoreCase(that.firstName)
    }

    override def toString = firstName +" "+ lastName
  }
}}}

{{{class="brush: scala"
  scala> val robert = new Person("Robert", "Jones")
  robert: Person = Robert Jones

  scala> val sally = new Person("Sally", "Smith")
  sally: Person = Sally Smith

  scala> robert < sally
  res0: Boolean = true
}}}

为了让列表类型混入到`Ordered`中，需要使用上界，符号`<:`。

`T <:  Ordered[T]`表明类型必须是`Ordered`的子类型。比如`Person`，因为`Person`混入了`Ordered`特质：

{{{class="brush: scala"
  def orderedMergeSort[T <: Ordered[T]](xs: List[T]): List[T] = {
    def merge(xs: List[T], ys: List[T]): List[T] =
      (xs, ys) match {
        case (Nil, _) => ys
        case (_, Nil) => xs
        case (x :: xs1, y :: ys1) =>
          if (x < y) x :: merge(xs1, ys)
          else y :: merge(xs, ys1)
      }
    val n = xs.length / 2
    if (n == 0) xs
    else {
      val (ys, zs) = xs splitAt n
      merge(orderedMergeSort(ys), orderedMergeSort(zs))
    }
  }
}}}

使用：

{{{class="brush: scala"
  scala> val people = List(
       |   new Person("Larry", "Wall"),
       |   new Person("Anders", "Hejlsberg"),
       |   new Person("Guido", "van Rossum"),
       |   new Person("Alan", "Kay"),
       |   new Person("Yukihiro", "Matsumoto")
       | )
  people: List[Person] = List(Larry Wall, Anders Hejlsberg,
    Guido van Rossum, Alan Kay, Yukihiro Matsumoto)


  scala> val sortedPeople = orderedMergeSort(people)
  sortedPeople: List[Person] = List(Anders Hejlsberg, Alan Kay,
    Yukihiro Matsumoto, Guido van Rossum, Larry Wall)
}}}

以上的解决方案还是有限制，比如不能适应整数列表。因为`Int`不是`Ordered[Int]`的子类：

{{{class="brush: scala"
  scala> val wontCompile = orderedMergeSort(List(3, 2, 1))
  <console>:5: error: inferred type arguments [Int] do
     not conform to method orderedMergeSort's type
       parameter bounds [T <: Ordered[T]]
         val wontCompile = orderedMergeSort(List(3, 2, 1))
                           ^
}}}

在以后的“隐式类型转换和参数”的“视界”一节中介绍通过采用隐式参数与检查约束来实现更加通用的方案。



= 抽象成员 =

Scala中不仅可以指定方法为抽象，还可以声明字段甚至抽象类型为类和特质的成员。

== 抽象成员的快速浏览 ==

在特质中分别对类型（T）、方法（transform）、val（initial）、var（current）的抽象声明：

{{{class="brush: scala"
  trait Abstract {
    type T
    def transform(x: T): T
    val initial: T
    var current: T
  }
}}}

实现：

{{{class="brush: scala"
  class Concrete extends Abstract {
    type T = String
    def transform(x: String) = x + x
    val initial = "hi"
    var current = initial
  }
}}}

== 类型成员 ==

（略）

== 抽象val ==

val是不可变的，抽象的val指定了类型与变量名，不指定值：

{{{class="brush: scala"
  val initial: String
}}}

实现时指定值：

{{{class="brush: scala"
  val initial = "hi"
}}}

如果不知道类中定义的确切内容，但是确定对于每个实例来说值都是不可变的。在这样的情况下可以使用抽象的val声明，格式类似于无参数方法声明：

{{{class="brush: scala"
  def initial: String
}}}

客户代码将使用统一的`obj.initial`方法引用val及方法。如果`initial`是抽象val，那么客户就可以保证每次引用都将得到同样的值。如果`initial`是抽象方法那就无法保证，因为在不同的实现中`initial`可以被实现为每次调用都返回不同的值。

换名话说抽象的val限制了合法实现的方式：任何实现都必须是`val`类型的定义不可以是`var`。另一方面，抽象方法声明可以被实现为具体的方法定义或具体的`val`定义。

所以在下面的代码中，`Apple`是合法的子类面`BadApple`不是：

{{{class="brush: scala"
  abstract class Fruit {
    val v: String // `v' for value
    def m: String // `m' for method
  }

  abstract class Apple extends Fruit {
    val v: String
    val m: String // OK to override a `def' with a `val'
  }

  abstract class BadApple extends Fruit {
    def v: String // ERROR: cannot override a `val' with a `def'
    def m: String
  }
}}}

== 抽象var ==

在特质里使用，只声明类型与名称，没有初始值：

{{{class="brush: scala"
  trait AbstractTime {
    var hour: Int
    var minute: Int
  }
}}}

也会有自动扩展的`getter`与`setter`方法，相当于：

{{{class="brush: scala"
  trait AbstractTime {
    def hour: Int          // getter for `hour'
    def hour_=(x: Int)     // setter for `hour'
    def minute: Int        // getter for `minute'
    def minute_=(x: Int)   // setter for `minute'
  }
}}}

== 初始化抽象val ==

结合特质来使用，抽象val可以让子类扩展提供父类没有的参数与细节。因为特质缺省能用来传递参数的构造器。

拿前面的实数类来作例子，以下特质：

{{{class="brush: scala"
  trait RationalTrait { 
    val numerArg: Int 
    val denomArg: Int 
  } 
}}}

为了实例化这个特质，先要实现val。在这里我们要用到新的`new`语法结构：

{{{class="brush: scala"
  new RationalTrait {
    val numerArg = 1
    val denomArg = 2
  }
}}}

上面的代码会产混入了物质的匿名类实例，类似于`new Rational(1, 2)`。当然区别还是有的：

{{{class="brush: scala"
  new Rational(expr1, expr2)
}}}

上面的两个表达式会在类初始化前计算，而相反的：

{{{class="brush: scala"
  new RationalTrait {
    val numerArg = expr1
    val denomArg = expr2
  }
}}}

上面的两个表达式会作为匿名类初始化的一部分计算。而匿名类初始化在`RationalTrait`之后执行，所以`numerArg`和`denomArg`的值在`RationalTrait`初始化期间还没有准备好，都是`Int`类型的默认值`0`。

所以对下面的代码来说，这会成为一个问题，因为其中定义了经过约分后的分子与分母：

{{{class="brush: scala"
  trait RationalTrait { 
    val numerArg: Int 
    val denomArg: Int 
    require(denomArg != 0)
    private val g = gcd(numerArg, denomArg)
    val numer = numerArg / g
    val denom = denomArg / g
    private def gcd(a: Int, b: Int): Int = 
      if (b == 0) a else gcd(b, a % b)
    override def toString = numer +"/"+ denom
  }
}}}

如果尝试使用某种分子和分母的表达式面不是简单的字面量实例化这个特质，会引起以下错误：

{{{class="brush: scala"
  scala> val x = 2
  x: Int = 2

  scala> new RationalTrait {
       |   val numerArg = 1 * x
       |   val denomArg = 2 * x
       | }
  java.lang.IllegalArgumentException: requirement failed
          at scala.Predef$.require(Predef.scala:107)
          at RationalTrait$class.$init$(<console>:7)
          at $anon$1.<init>(<console>:7)
          ....
}}}

解决方案有两个，分别是预初始化字段和懒加载val。


=== fields预初始化字段 ===

给字段定义加上花括号，放在超类的构造器之前：

{{{class="brush: scala"
  scala> new { 
       |   val numerArg = 1 * x
       |   val denomArg = 2 * x 
       | } with RationalTrait
  res15: java.lang.Object with RationalTrait = 1/2
}}}

不仅匿名类可以用预加载，有名称的类和对象也可以。

注意要放在关键字`extends`后面：

{{{class="brush: scala"
  object twoThirds extends {
    val numerArg = 2
    val denomArg = 3
  } with RationalTrait
}}}

由于预初始化的字段的超类构造器调用前被初始化，所以不能引用正在被构造的对象。所以对于`this`实际指向的是正被构造的类或对象的对象，而来是被构造的对象本身：

{{{class="brush: scala"
  scala> new {
     |   val numerArg = 1
     |   val denomArg = this.numerArg * 2
     | } with RationalTrait
  <console>:8: error: value numerArg is not a
       member of object $iw
           val denomArg = this.numerArg * 2
                               ^
}}}

`$iw`是合成对象，解释器把用户输出语句放在这个对象中。

{{{class="brush: scala"
  class RationalClass(n: Int, d: Int) extends {
    val numerArg = n
    val denomArg = d
  } with RationalTrait {
    def + (that: RationalClass) = new RationalClass(
      numer * that.denom + that.numer * denom,
      denom * that.denom
    )
  }
}}}



=== 懒加载val ===

懒加载让表达式在`val`第一次被使用的时候才计算机。格式为把`lazy`修饰加在`val`上。

普通情况下初始化与类初始化一起的：

{{{class="brush: scala"
  scala> object Demo {
       |   val x = { println("initializing x"); "done" }
       | }
  defined module Demo


  scala> Demo
  initializing x
  res19: Demo.type = Demo$@97d1ff

  scala> Demo.x
  res20: java.lang.String = done
}}}

使用了懒加载以后，`val`的初始化延迟到第一次使用时：

{{{class="brush: scala"
  scala> object Demo {
       |   lazy val x = { println("initializing x"); "done" }
       | }
  defined module Demo

  scala> Demo
  res21: Demo.type = Demo$@d81341

  scala> Demo.x
  initializing x
  res22: java.lang.String = done
}}}

上面的情况有点像是用`def`把`x`定义为一个无参的方法，不同于`def`的是计算只进行一次。

通过上面两个例子可以看出，单例对象的初始化也很像懒加载。它们在第一次被使用时进行初始化。

通过懒加载重新实现`RationalTrait`，与前一版本的主要变化是`require`子句从物质的方法体移动到了计算`numerArg`和`denomArg`最大公约数的私有字段`g`的初始化器中。所以这个版本中`LasyRationalTrait`初始化器已经用不干啥事儿了：

{{{class="brush: scala"
  trait LazyRationalTrait { 
    val numerArg: Int 
    val denomArg: Int 
    lazy val numer = numerArg / g
    lazy val denom = denomArg / g
    override def toString = numer +"/"+ denom
    private lazy val g = {
      require(denomArg != 0)
      gcd(numerArg, denomArg)
    }
    private def gcd(a: Int, b: Int): Int = 
      if (b == 0) a else gcd(b, a % b)
  }


  scala> val x = 2
  x: Int = 2

  scala> new LazyRationalTrait {
       |   val numerArg = 1 * x
       |   val denomArg = 2 * x
       | }
  res1: java.lang.Object with LazyRationalTrait = 1/2
}}}

在特质中的两个懒加载对象`number`和`denom`是在`toString`方法调用时才初始化。计算它们的表达式要用到同样是懒加载的`g`。

应用懒加载还是要注意副作用，在有副作用的情况下跟踪加载顺序是很重要的事情。无副作用的纯函数式应用配合懒加载是相当合适的。

== 抽象类型 ==

抽象类型声明`type T`应用在尚不可知的类型上，不同的子类可以提供不同的`T`实现。

以一个动物食性的例子来解释应用环境，动物吃食物：

{{{class="brush: scala"
  class Food
  abstract class Animal {
    def eat(food: Food)
  }
}}}

会在想让它们的子类牛吃草时遇到麻烦。`eat`方法不能重写，因为参数不能从`Food`转为子类`Grass`：

{{{class="brush: scala"
  class Grass extends Food
  class Cow extends Animal {
    override def eat(food: Grass) {} // This won't compile
  }

  BuggyAnimals.scala:7: error: class Cow needs to be
  abstract, since method eat in class Animal of type
      (Food)Unit is not defined
  class Cow extends Animal {
        ^
  BuggyAnimals.scala:8: error: method eat overrides nothing
    override def eat(food: Grass) {}
                 ^
}}}

这样看来类型检查太严格了，应该允许子类？但是如果这样做的话又会失去类型检验保障。

比如说喂牛吃鱼：

{{{class="brush: scala"
  class Food
  abstract class Animal {
    def eat(food: Food)
  }
  class Grass extends Food
  class Cow extends Animal {
    override def eat(food: Grass) {} // This won't compile,
  }                                  // but if it did,...
  class Fish extends Food
  val bessy: Animal = new Cow
  bessy eat (new Fish)     // ...you could feed fish to cows.
}}}

更加精确的方式是能按不同的动物决定食物的种类，父类中指定动物只能吃食物：

{{{class="brush: scala"
  class Food
  abstract class Animal {
    type SuitableFood <: Food
    def eat(food: SuitableFood)
  }
}}}

`SuitableFood`被定义为抽象类，而且有上界`Food`。以后动物类中指定具体的食物子类：

{{{class="brush: scala"
  class Grass extends Food
  class Cow extends Animal {
    type SuitableFood = Grass
    override def eat(food: Grass) {}
  }
}}}

现在得到了比较合适的类型检查：

{{{class="brush: scala"
  scala> class Fish extends Food
  defined class Fish

  scala> val bessy: Animal = new Cow
  bessy: Animal = Cow@674bf6

  scala> bessy eat (new Fish)
  <console>:10: error: type mismatch;
   found   : Fish
   required: bessy.SuitableFood
         bessy eat (new Fish)
                    ^
}}}



== 路径依赖类型 ==

看一下前面例子的最后一条错误信息。它说明需要的类型是`bessy.SuitableFood`，这里的`SuitableFood`是`bessy`引用的对象的成员。

这样的类型被称为路径依赖类型，路径指的是对象的引用。不同路径将产不同的类型：

{{{class="brush: scala"
  class DogFood extends Food
  class Dog extends Animal {
    type SuitableFood = DogFood
    override def eat(food: DogFood) {}
  }

  scala> val bessy = new Cow
  bessy: Cow = Cow@10cd6d

  scala> val lassie = new Dog
  bootsie: Dog = Dog@d11fa6

  scala> lassie eat (new bessy.SuitableFood)
  <console>:13: error: type mismatch;
   found   : Grass
   required: DogFood
         lassie eat (new bessy.SuitableFood)
                     ^
}}}

`bessy.SuitableFood`不能匹配`lassie.SuitableFood`，但如果同样是`Dog`的话，情况又不同。因为`Dog`的`SuitableFood`被定义为`DogFood`类的别名，所以实际上是一样的：

{{{class="brush: scala"
  scala> val bootsie = new Dog
  bootsie: Dog = Dog@54ca71

  scala> lassie eat (new bootsie.SuitableFood)
}}}

路径依赖有点像Java里的内部类，但区别是：路径依赖表达了外在的对象，而内部类表达了外在的类。Java的内部类在Scala表达为两个类：

{{{class="brush: scala"
  class Outer {
    class Inner
  }
}}}

与Java的`Outer.Inner`不同，Scala中表达为`Outer#Inner`。`.`语法留给对象使用：

{{{class="brush: scala"
  val o1 = new Outer
  val o2 = new Outer
}}}

虽然`o1.Inner`和`o2.Inner`是不同的两个路径依赖类型，但两个都能匹配更加通用的`Outer#Inner`。

和Java中一样，Scala的内部类实例也有对外部类实例的引用。所以不能只有内部类实例面没有外部类实例。有两个方式实例化内部类：

1）直接在外部类方法体中实例化，这样可以用`this`引用外部类对象。

2）使用路径依赖类型。如`o1.Inner`。返回的内部类有对`01`的引用。例子如下：

{{{class="brush: scala"
  scala> new o1.Inner
  res1: o1.Inner = Outer$Inner@13727f
}}}

相对的，类型`Outer#Inner`是没有指向对象的引用的，所以不能创建它的实例：

{{{class="brush: scala"
  scala> new Outer#Inner
  <console>:6: error: Outer is not a legal prefix for
    a constructor
         new Outer#Inner
                   ^
}}}


== 枚举 ==

标准库中的类`scala.Enumeration`用来扩展枚举类：

{{{class="brush: scala"
  object Color extends Enumeration {
    val Red = Value
    val Green = Value
    val Blue = Value
  }
}}}

还可以简化：

{{{class="brush: scala"
  object Color extends Enumeration {
    val Red, Green, Blue = Value
  }
}}}

可以`Color`的全部成员，然后直接写颜色名：

{{{class="brush: scala"
  import Color._
}}}

前面定义的`Red`、`Green`和`Blue`这些值的类型为`Enumeration`定义的内部类，名为`Value`。同名无参数方法`Value`返回该类的新对象，即`Color.Red`类的值类型是`Color.Value`。而且是依赖路径的。如：

{{{class="brush: scala"
  object Direction extends Enumeration {
    val North, East, South, West = Value
  }
}}}

上面就定义了一个完全不同的类型，因为路径不同。

还可以重载`Value`方法把名称与值对应起来：

{{{class="brush: scala"
  object Direction extends Enumeration {
    val North = Value("North")
    val East = Value("East")
    val South = Value("South")
    val West = Value("West")
  }
}}}

遍历：

{{{class="brush: scala"
  scala> for (d <- Direction) print(d +" ")
  North East South West 
}}}

枚举的值从`0`开始增加，用成员方法`id`可以取出值：

{{{class="brush: scala"
  scala> Direction.East.id
  res5: Int = 1
}}}

反过来也可以通过非零整数取得`id`：

{{{class="brush: scala"
  scala> Direction(1)
  res6: Direction.Value = East
}}}

== 案例研究：货币 ==

设计一个货币类能处理不同的货币。定义抽象类可以扩展为具体不同的货币。当然第一个版本肯定是不完善的：

{{{class="brush: scala"
  // A first (faulty) design of the Currency class
  abstract class Currency {
    val amount: Long
    def designation: String 
    override def toString = amount +" "+ designation
    def + (that: Currency): Currency = ...
    def * (x: Double): Currency = ...
  }
}}}

`amount`和`designation`分别代表金额的符号。其他方法还有加法和乘法操作。这个版本的问题是，在语法上两个不同的子类可以相加：

{{{class="brush: scala"
  abstract class Dollar extends Currency {
    def designation = "USD"
  }
  abstract class Euro extends Currency {
    def designation = "Euro"
  }
}}}

这样不同货币的相加是有问题的。所以下一个改进版本用抽象类型来标明末知的类型：

{{{class="brush: scala"
  abstract class AbstractCurrency {
    type Currency <: AbstractCurrency
    val amount: Long
    def designation: String 
    override def toString = amount +" "+ designation
    def + (that: Currency): Currency = ...
    def * (x: Double): Currency = ...
  }
}}}

每个子类都要把`Currency`指定为这个类自身，扩展实现是类似于这样：

{{{class="brush: scala"
  abstract class Dollar extends AbstractCurrency {
    type Currency = Dollar
    def designation = "USD"
  }
}}}

这个版本的问题在于加法与乘法的定义。首先想到的把金额转为正确类型的货币的方法可能是这样的：

{{{class="brush: scala"
  def + (that: Currency): Currency = new Currency {
    val amount = this.amount + that.amount
  }
}}}

但这通不过编译，因为Scala不能用抽象类型创建实例，也不能用抽象类型作为其他类型的父类：

{{{class="brush: scala"
  error: class type required
    def + (that: Currency): Currency = new Currency {
}}}

使用工厂方法是个解决方案：用声明抽象方法代替直接创建抽象类的实例：

{{{class="brush: scala"
  abstract class AbstractCurrency {
    type Currency <: AbstractCurrency // abstract type
    def make(amount: Long): Currency  // factory method
    ...                               // rest of class
  }
}}}

但这样有别的问题，因为这样不得不把工厂方法放到`AbstractCurrency`类中，所有的实例都有了创建货币的能力：

{{{class="brush: scala"
  myDollar.make(100)  // here are a hundred more!
}}}

所以把工厂方法移到一个新的类中，新的类叫`CurrencyZone`。把`AbstractCurrency`和`Currency`也作为它的内部类：

{{{class="brush: scala"
  abstract class CurrencyZone {
    type Currency <: AbstractCurrency
    def make(x: Long): Currency
    abstract class AbstractCurrency {
      val amount: Long
      def designation: String 
      override def toString = amount +" "+ designation
      def + (that: Currency): Currency = 
        make(this.amount + that.amount)
      def * (x: Double): Currency = 
        make((this.amount * x).toLong)
    }
  }
}}}

这样按不同货币来扩展：

{{{class="brush: scala"
  object US extends CurrencyZone {
    abstract class Dollar extends AbstractCurrency {
      def designation = "USD"
    }
    type Currency = Dollar
    def make(x: Long) = new Dollar { val amount = x }
  }
}}}

`US`中定义了类`Dollar`。它的类型是`US.Dollar`。

继续改进设计：关于单位，单位不仅是美元，还有美分。所以让`amount`以美分为单位更加合适。所以用多一个字段`CurrencyUnit`记录单位：

{{{class="brush: scala"
  class CurrencyZone { 
    ... 
    val CurrencyUnit: Currency 
  } 
}}}

子类里再加上两个方法直接把1美元代表100美分的逻辑描述出来：

{{{class="brush: scala"
  object US extends CurrencyZone {
    abstract class Dollar extends AbstractCurrency {
      def designation = "USD"
    }
    type Currency = Dollar
    def make(cents: Long) = new Dollar {
      val amount = cents
    }
    val Cent = make(1)
    val Dollar = make(100)
    val CurrencyUnit = Dollar
  }
}}}

还有显示问题，用多数内部类型上都带的`format`方法格式化美元与美分的小数显示，如“`10.23 USD`”：

{{{class="brush: scala"
    ((amount.toDouble / CurrencyUnit.amount.toDouble)
     formatted ("%."+ decimals(CurrencyUnit.amount) +"f")
     +" "+ designation)
}}}

输出字符的长度是通过`decimals`方法得出的。`decimals`方法返回十进制数字所要占用的字符长度。如对于`decimals(10)`代表0到9，会占用一个字符，而`decimals`(100)是0到99会占用两个字符。`decimals`方法通过简单递归实现：

{{{class="brush: scala"
  private def decimals(n: Long): Int = 
    if (n == 1) 0 else 1 + decimals(n / 10)
}}}

相对的看一下欧元的实现：

{{{class="brush: scala"
  object Europe extends CurrencyZone {
    abstract class Euro extends AbstractCurrency {
      def designation = "EUR"
    }
    type Currency = Euro
    def make(cents: Long) = new Euro {
      val amount = cents
    }
    val Cent = make(1)
    val Euro = make(100)
    val CurrencyUnit = Euro
  }

  object Japan extends CurrencyZone {
    abstract class Yen extends AbstractCurrency {
      def designation = "JPY"
    }
    type Currency = Yen
    def make(yen: Long) = new Yen {
      val amount = yen
    }
    val Yen = make(1)
    val CurrencyUnit = Yen
  }
}}}

再改进一下，增加汇率的功能。先用一个新的对象来记录汇率：

{{{class="brush: scala"
  object Converter {
    var exchangeRate = Map(
      "USD" -> Map("USD" -> 1.0   , "EUR" -> 0.7596, 
                   "JPY" -> 1.211 , "CHF" -> 1.223),
      "EUR" -> Map("USD" -> 1.316 , "EUR" -> 1.0   , 
                   "JPY" -> 1.594 , "CHF" -> 1.623),
      "JPY" -> Map("USD" -> 0.8257, "EUR" -> 0.6272, 
                   "JPY" -> 1.0   , "CHF" -> 1.018),
      "CHF" -> Map("USD" -> 0.8108, "EUR" -> 0.6160, 
                   "JPY" -> 0.982 , "CHF" -> 1.0  )
    )
  }
}}}

在货币中增加根据汇率来转换的功能。接收一个外币类型，把自己的金额转成这个外币的金额：

{{{class="brush: scala"
  def from(other: CurrencyZone#AbstractCurrency): Currency = 
    make(Math.round(
      other.amount.toDouble * Converter.exchangeRate
        (other.designation)(this.designation)))
}}}

参数是末知的`CurrencyZone#AbstractCurrency`，所以能处理任意外币类型。

全部的货币代码，假设都放在`org.stairwaybook.currencies`包中：

{{{class="brush: scala"
  abstract class CurrencyZone {

    type Currency <: AbstractCurrency
    def make(x: Long): Currency

    abstract class AbstractCurrency {

      val amount: Long
      def designation: String 

      def + (that: Currency): Currency = 
        make(this.amount + that.amount)
      def * (x: Double): Currency = 
        make((this.amount * x).toLong)
      def - (that: Currency): Currency = 
        make(this.amount - that.amount)
      def / (that: Double) = 
        make((this.amount / that).toLong)
      def / (that: Currency) = 
        this.amount.toDouble / that.amount

      def from(other: CurrencyZone#AbstractCurrency): Currency = 
        make(Math.round(
          other.amount.toDouble * Converter.exchangeRate
            (other.designation)(this.designation)))

      private def decimals(n: Long): Int = 
        if (n == 1) 0 else 1 + decimals(n / 10)

      override def toString = 
        ((amount.toDouble / CurrencyUnit.amount.toDouble)
         formatted ("%."+ decimals(CurrencyUnit.amount) +"f")
         +" "+ designation)
    }

    val CurrencyUnit: Currency
  }
}}}

调用的例子：

{{{class="brush: scala"
  scala> import org.stairwaybook.currencies._

  scala> Japan.Yen from US.Dollar * 100
  res16: Japan.Currency = 12110 JPY

  scala> Europe.Euro from res16
  res17: Europe.Currency = 75.95 EUR

  scala> US.Dollar from res17
  res18: US.Currency = 99.95 USD
}}}

相同类型的货币可以相加，不同类型的不可以相加：

{{{class="brush: scala"
  scala> US.Dollar * 100 + res18
  res19: currencies.US.Currency = 199.95


  scala> US.Dollar + Europe.Euro
  <console>:7: error: type mismatch;
   found   : currencies.Europe.Euro
   required: currencies.US.Currency
         US.Dollar + Europe.Euro
                            ^
}}}

类型抽象实现了不同货币不能相加的功能。像是1999年9月23日，混用英制单位和公制单位引起的火星航天器坠毁事件不会再重演了。




= 隐式转换和参数 =


{{{class="brush: scala"
}}}



{{{class="brush: scala"
}}}



{{{class="brush: scala"
}}}



{{{class="brush: scala"
}}}



{{{class="brush: scala"
}}}



{{{class="brush: scala"
}}}



{{{class="brush: scala"
}}}



{{{class="brush: scala"
}}}



{{{class="brush: scala"
}}}



{{{class="brush: scala"
}}}



{{{class="brush: scala"
}}}



{{{class="brush: scala"
}}}



{{{class="brush: scala"
}}}



{{{class="brush: scala"
}}}



{{{class="brush: scala"
}}}



{{{class="brush: scala"
}}}



{{{class="brush: scala"
}}}



{{{class="brush: scala"
}}}



{{{class="brush: scala"
}}}



{{{class="brush: scala"
}}}



{{{class="brush: scala"
}}}



{{{class="brush: scala"
}}}

