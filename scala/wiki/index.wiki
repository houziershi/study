
%title Scala入门

%toc Scala入门


= 配置 =


= 使用 =
 

== 简单脚本 ==

脚本文件，可以接收一个参数并输出欢迎信息：

{{{class="brush: scala" title="helloarg.scala"
/* 可以接收一个参数 */
println("Hello, " + args(0) + "!")
}}}

调用脚本：scala命令、文件名、参数

{{{class="brush: bash"
--(morgan-laptop:pts/8)-(13-03-14 23:28:27)-(~/workspace/study/scala/tmp)
\-(morgan:%) >>> scala helloarg.scala Jade
Hello, Jade!
}}}

可以通过循环处理多个参数的：

{{{class="brush: scala" title="pa.scala"
args.foreach( arg => println(arg) )
}}}

调用：

{{{class="brush: bash"
--(morgan-laptop:pts/8)-(13-03-14 23:49:39)-(~/workspace/study/scala/tmp)
\-(morgan:%) >>> scala pa.scala Scala is even more fun      
Scala
is
even
more
fun
}}}

== Scala程序 ==

先看一个工具类，它根据字符串来计算出检验和：
{{{class="brush: scala" title="Summer.scala"
import scala.collection.mutable.Map

class ChecksumAccumulator {
	private var sum = 0
	def add(b: Byte) { sum += b }
	def checksum(): Int =  ~(sum &0xFF) + 1
}

object ChecksumAccumulator {
	private val cache = Map[String, Int]()

	def calculate(s: String): Int =
		if( cache.contains(s) ) {
			cache(s)
		} else {
			val acc = new ChecksumAccumulator
			for (c <- s)
				acc.add(c.toByte)
			val cs = acc.checksum()
			cache += (s -> cs)
			cs
		}
}
}}}

然后是主程序。独立运行的程序一定要有`main`方法（仅有一个参数`Array[String]`而且结果类型为`Unit`）的单例对象。

{{{class="brush: scala" title="Summer.scala"
import ChecksumAccumulator.calculate

object Summer {

	def main(args: Array[String]) {
		for (arg <- args)
			println(arg + " -> " + calculate(arg))
	}

}
}}}

编译Scala程序：
{{{class="brush: bash"
--(morgan-laptop:pts/8)-(13-03-15 0:28:39)-(~/workspace/study/scala/tmp)
\-(morgan:%) >>> scalac ChecksumAccumulator.scala Summer.scala
}}}

有一个`fast Scala compiler`的后台进程可以在第一次被调用后一直跑在后台，节省一下每次编译的速度：
{{{class="brush: bash"
--(morgan-laptop:pts/8)-(13-03-15 0:29:11)-(~/workspace/study/scala/tmp)
\-(morgan:%) >>> fsc ChecksumAccumulator.scala Summer.scala   
}}}

可以关掉这个后台进程：
{{{class="brush: bash"
--(morgan-laptop:pts/8)-(13-03-15 0:29:11)-(~/workspace/study/scala/tmp)
\-(morgan:%) >>> fsc -shutdown
}}}

编译完后可以看到生成的`.class`文件：
{{{class="brush: bash"
--(morgan-laptop:pts/8)-(13-03-15 0:44:31)-(~/workspace/study/scala/tmp)
\-(morgan:%) >>> ls *.class
ChecksumAccumulator$$anonfun$calculate$1.class  ChecksumAccumulator$.class    Summer.class
ChecksumAccumulator.class                       Summer$$anonfun$main$1.class  Summer$.class
}}}

运行编译出来的类文件：
{{{class="brush: bash"
--(morgan-laptop:pts/8)-(13-03-15 0:30:58)-(~/workspace/study/scala/tmp)
\-(morgan:%) >>> scala Summer of love
of -> -213
love -> -182
}}}

还有一个加入的`Application`特质的方式实现应用程序，但是有局限：不能访问命令行参数、只能在单线程下用。所以不推荐用它。

形式类似于：
{{{class="brush: scala" title="myApp.scala"
object MyApp extends Application {
	println("Hello")
}	
}}}

== 脚本与程序的区别 ==

脚本必须以表达式结束，而程序以定义结尾。尝试以`scala`解释器运行程序会报错。



