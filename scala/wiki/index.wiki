
%title Scala入门

%toc Scala入门

= 配置 =

== 字符编码问题 ==

在默认字符编码为UTF-8的Linux下没问题。

Mac OS X系统的默认字符编码早就改成了UTF-8但它bundle的Java默认字符编码却一直是MacRoman。在启动REPL时传入参数`-Dfile.encoding=UTF-8`

用vim、emacs或者你习惯的文本编辑器打开scala命令，比如：
{{{class="brush: bash"
$ vim `which scala`
}}}

找到如下行：
{{{class="brush: bash"
[ -n "$JAVA_OPTS" ] || JAVA_OPTS="-Xmx256M -Xms32M"
}}}

把-D参数加到JAVA_OPTS里即可。

== Vim插件 ==

到[[https://github.com/scala/scala-dist][相关工具]]上下载，复制`tool-support/src/vim`到`.vim`目录下。


= 使用 =
 
== Scala Shell ==

使用进入REPL环境的方式：

{{{class="brush: bash"
--(morgan-laptop:pts/8)-(13-03-15 9:04:57)-(~/workspace/study/scala)
\-(morgan:%) >>> scala
Welcome to Scala version 2.9.2 (OpenJDK 64-Bit Server VM, Java 1.7.0_15).
Type in expressions to have them evaluated.
Type :help for more information.

scala> 
}}}

输入回车自动换行。

发现输错了，再按几个回车就退出了。

退出`Scala Shell`：`:quit`或`:q`

在REPL环境中只能一行一行读取，所以如果要换行的话，不能让一行在语法上看起来已经结束：

{{{class="brush: scala"
scala> if(x > 0) { 1
     | } else if(x == 0) 0 else -1
res1: Int = 1
}}}

另一个方法是在REPL中输入`:paste`粘贴代码，按下`Control + D`。

== 脚本 ==

脚本文件，可以接收一个参数并输出欢迎信息：

{{{class="brush: scala" title="helloarg.scala"
/* 可以接收一个参数 */
println("Hello, " + args(0) + "!")
}}}

调用脚本：scala命令、文件名、参数

{{{class="brush: bash"
--(morgan-laptop:pts/8)-(13-03-14 23:28:27)-(~/workspace/study/scala/tmp)
\-(morgan:%) >>> scala helloarg.scala Jade
Hello, Jade!
}}}

可以通过循环处理多个参数的：

{{{class="brush: scala" title="pa.scala"
args.foreach( arg => println(arg) )
}}}

调用：

{{{class="brush: bash"
--(morgan-laptop:pts/8)-(13-03-14 23:49:39)-(~/workspace/study/scala/tmp)
\-(morgan:%) >>> scala pa.scala Scala is even more fun      
Scala
is
even
more
fun
}}}

== Scala程序 ==

先看一个工具类，它根据字符串来计算出检验和：
{{{class="brush: scala" title="Summer.scala"
import scala.collection.mutable.Map

class ChecksumAccumulator {
	private var sum = 0
	def add(b: Byte) { sum += b }
	def checksum(): Int =  ~(sum &0xFF) + 1
}

object ChecksumAccumulator {
	private val cache = Map[String, Int]()

	def calculate(s: String): Int =
		if( cache.contains(s) ) {
			cache(s)
		} else {
			val acc = new ChecksumAccumulator
			for (c <- s)
				acc.add(c.toByte)
			val cs = acc.checksum()
			cache += (s -> cs)
			cs
		}
}
}}}

然后是主程序。独立运行的程序一定要有`main`方法（仅有一个参数`Array[String]`而且结果类型为`Unit`）的单例对象。

{{{class="brush: scala" title="Summer.scala"
import ChecksumAccumulator.calculate

object Summer {

	def main(args: Array[String]) {
		for (arg <- args)
			println(arg + " -> " + calculate(arg))
	}

}
}}}

编译Scala程序：
{{{class="brush: bash"
--(morgan-laptop:pts/8)-(13-03-15 0:28:39)-(~/workspace/study/scala/tmp)
\-(morgan:%) >>> scalac ChecksumAccumulator.scala Summer.scala
}}}

有一个`fast Scala compiler`的后台进程可以在第一次被调用后一直跑在后台，节省一下每次编译的速度：
{{{class="brush: bash"
--(morgan-laptop:pts/8)-(13-03-15 0:29:11)-(~/workspace/study/scala/tmp)
\-(morgan:%) >>> fsc ChecksumAccumulator.scala Summer.scala   
}}}

可以关掉这个后台进程：
{{{class="brush: bash"
--(morgan-laptop:pts/8)-(13-03-15 0:29:11)-(~/workspace/study/scala/tmp)
\-(morgan:%) >>> fsc -shutdown
}}}

编译完后可以看到生成的`.class`文件：
{{{class="brush: bash"
--(morgan-laptop:pts/8)-(13-03-15 0:44:31)-(~/workspace/study/scala/tmp)
\-(morgan:%) >>> ls *.class
ChecksumAccumulator$$anonfun$calculate$1.class  ChecksumAccumulator$.class    Summer.class
ChecksumAccumulator.class                       Summer$$anonfun$main$1.class  Summer$.class
}}}

运行编译出来的类文件：
{{{class="brush: bash"
--(morgan-laptop:pts/8)-(13-03-15 0:30:58)-(~/workspace/study/scala/tmp)
\-(morgan:%) >>> scala Summer of love
of -> -213
love -> -182
}}}

还有一个加入的`Application`特质的方式实现应用程序，但是有局限：不能访问命令行参数、只能在单线程下用。所以不推荐用它。

形式类似于：
{{{class="brush: scala" title="myApp.scala"
object MyApp extends Application {
	println("Hello")
}	
}}}

== 脚本与程序的区别 ==

脚本必须以表达式结束，而程序以定义结尾。尝试以`scala`解释器运行程序会报错。




= 入门 =


== 变量定义 ==

`val`不可变变量；`var`可变变量。格式：
{{{class="brush: scala"
// 基本格式
val msg: java.lang.String = "Hello"

// java.lang默认已经导入了
val msg: String = "Hello"

// 自动推导类型
val msg = "Hello"
}}}

== 语句定义 ==

Scala语句以分号结束，而且分号可以省略。默认一行结束了就是一行语句结束了，除非以下三种情况，会认为语句还没有结束：

* 行尾是一个不能放在行尾的字符。
* 下一行的开头是不能放在行头的字符。
* `()`和`[]`里，这里面不能放多条语句。

这是两个：
{{{class="brush: scala"
val s = "hello"; println(s)
}}}


{{{class="brush: scala"
if (x < 2)
	println("too small")
else
	println("ok")
}}}

这是两个：
{{{class="brush: scala"
x
+ y
}}}

一个：
{{{class="brush: scala"
(x
+ y)
}}}

一个：
{{{class="brush: scala"
x +
y +
z
}}}

== 函数定义 ==

取最大的函数，函数体的最后一行作为结果返回： 

{{{class="brush: scala"
def max(x: Int, y: Int): Int = {
	if (x > y) x else y
}
}}}

函数类型也能自动推导出来，可以省略。在递归函数的情况下，一定要明确地说明返回类型。如果函数体只有一行，那花括号也可以省略：

{{{class="brush: scala"
scala> def max(x: Int, y: Int) =  if (x > y) x else y
max: (x: Int, y: Int)Int
}}}


类型`Unit`对应Java中的`void`。即没有参数又没有返回结果的函数定义：

{{{class="brush: scala"
scala> def greet() = println("Hello")
greet: ()Unit
}}}


对于没有等号的方法来说返回类型一定是Unit。Scala可以把任何类型转为Unit，以下方法最后的String类结果会转为Unit并丢弃：

{{{class="brush: scala"
scala> def f(): Unit = "This String is lost!"
f: ()Unit
}}}

有花括号但没有等号的方法默认为Unit，有了等号但没有类型会由编译器自动推导：

{{{class="brush: scala"
scala> def f() {"This String is lost!"}
f: ()Unit

scala> def f() = {"This String get returned!"}
f: ()java.lang.String

scala> f
res2: java.lang.String = This String get returned!
}}}

== 函数字面量（Function Literal） ==

函数字面量用`=>`来分隔参数表与函数体：

{{{class="brush: scala"
(x:Int, y:Int) => x + y
}}}

通过函数字面量来迭代处理参数的例子：

{{{class="brush: scala"
args.foreach( (arg: String) => println(arg) )

//这里的String类型可以自动推导出来：
args.foreach( arg => println(arg) )

//在这种字面量只有一行而且只有一个参数情况下，可以省掉参数列表
args.foreach( println )
}}}


== for循环 ==

{{{class="brush: scala"
scala> for (i <- 0 to 10) print(i)
012345678910

}}}


== 方法与操作符 ==

下面的语句产一个从0到5的集合：

{{{class="brush: scala"
scala> 0 to 5
res9: scala.collection.immutable.Range.Inclusive = Range(0, 1, 2, 3, 4, 5)
}}}

其实这个`to`是一个方法的调用。Scala中对于方法调用时，如果方法只有一个参数的话可以省略括号，原本的样子是：

{{{class="brush: scala"
(0).to(5)
}}}

scala中没有操作符的重载，因为操作符也是方法的名字：

{{{class="brush: scala"
1 + 2
}}}
相当于：
{{{class="brush: scala"
(1).+(2)
}}}


= 标识符 =

Scala在构成标识符方面有四种非常灵活的规则： 

== 字母数字标识符（alphanumeric identifier） ==

字母数字标识符起始于一个字母或下划线，之后可以跟字母，数字，或下划线。‘$’字符也被当作是字母，但是被保留作为Scala编译器产生的标识符之用。用户程序里的标识符不应该包含‘$’字符，尽管能够编译通过；但是这样做有可能导致与Scala编译器产生的标识符发生名称冲撞。

Scala遵循Java的驼峰式标识符习俗。尽管下划线在标识符内是合法的，但在Scala程序里并不常用，部分原因是为了保持与Java一致，同样也由于下划线在Scala代码里有许多其它非标识符用法。因此，最好避免使用像`to_string`，`__init__`，或`name`这样的标识符。
 
标识符结尾使用下划线的一个结果就是，如果你尝试写一个这样的定义：`val name_: Int = `，你会收到一个编译器错误。编译器会认为你正常是定义一个叫做`name_:`的变量。要让它编译通过，你将需要在冒号之前插入一个额外的空格，如：`val name_ : Int = 1`。

字段，方法参数，本地变量，还有函数的驼峰式名称，应该以小写字母开始，如：`length`，`flatMap`，还有s。

类和特质的驼峰式名称应该以大写字母开始，如：`BigInt`，`List`，还有`UnbalancedTreeMap`。

Scala与Java的习惯不一致的地方在于常量名。Scala里，constant这个词并不等同于val。尽管val在被初始化之后的确保持不变，但它还是个变量。比方说，方法参数是val，但是每次方法被调用的时候这些val都可以代表不同的值。而常量更持久。比方说，`scala.Math.Pi`被定义为很接近实数π的双精度值，表示圆周和它的直径的比值。这个值不太可能改变，因此Pi显然是个常量。你还可以用常数去给一些你代码里作为幻数（magic number）要用到的值一个名字：文本值不具备解释能力，如果出现在多个地方将会变得极度糟糕。Java里，习惯上常量名全都是大写的，用下划线分隔单词，如`MAX_VALUE`或`PI`。Scala里，习惯只是第一个字母必须大写。因此，Java风格的常量名，如`X_OFFSET`，在Scala里也可以用，但是Scala的惯例是常数也用驼峰式风格，如`XOffset`。


== 操作符标识符（operator identifier） ==

由一个或多个操作符字符组成。操作符字符是一些如`+`，`:`，`?`，`~`或`#`的可打印的ASCII字符。以下是一些操作符标识符的例子： 

{{{class="brush: scala"
+ ++ ::: <?> :->
}}}

 Scala编译器将内部“粉碎”操作符标识符以转换成合法的内嵌`$`的Java标识符。例如，标识符`:->`将被内部表达为`$colon$minus$greater`。若你想从Java代码访问这个标识符，就应使用这个内部表达。 
 
Scala里的操作符标识符可以变得任意长，因此在Java和Scala间有一些小差别。Java里，输入`x<-y`将会被拆分成四个词汇符号，所以写成`x < - y`也没什么不同。Scala里，`<-`将被作为一个标识符拆分，而得到`x <- y`。如果你想要得到第一种解释，你要在`<`和`-`字符间加一个空格。这大概不会是实际应用中的问题，因为没什么人会在Java里写`x<-y`的时候不注意加空格或括号的。


== 混合标识符（mixed identifier） ==

混合标识符由字母数字组成，后面跟着下划线和一个操作符标识符。例如，`unary_+`被用做定义一元的`+`操作符的方法名。或者，`myvar_=`被用做定义赋值操作符的方法名。多说一句，混合标识符格式`myvar_=`是由Scala编译器产生的用来支持属性：`property`的；第十八章进一步说明。 


== 文本标识符（literal identifier） ==

文本标识符是用反引号包括的任意字串。如：

{{{class="brush: scala"  
`x` `<clinit>` `yield` 
}}}

它的思路是你可以把任何运行时认可的字串放在反引号之间当作标识符。结果总是Scala标识符。即使包含在反引号间的名称是Scala保留字，这个规则也是有效的。在Java的Thread类中访问静态的yield方法是其典型的用例。你不能写`Thread.yield()`因为yield是Scala的保留字。然而，你仍可以在反引号里引用方法的名称，例如：

{{{class="brush: scala" 
Thread.`yield`()
}}}



== 类型参数化数组 ==

长度为3的数组，存放的元素类型为`String`：

{{{class="brush: scala"
val gs: Array[String] = new Array[String](3)
}}}

{{{class="brush: scala"

scala> val gs = new Array[String](3)
gs: Array[String] = Array(null, null, null)

scala> gs(0) = "aa"
scala> gs(1) = "bb"
scala> gs(2) = "cc"

scala> gs.foreach(print)
aabbcc

scala> val ns = Array("11","22","33")
ns: Array[java.lang.String] = Array(11, 22, 33)

scala> ns.foreach(print)
112233
}}}


== apply与update方法 ==

对一个对象的后面加上括号的操作其实是调用了这个对象的`apply`方法。所以数组的元素索引操作其实是`apply`方法调用：

{{{class="brush: scala"
gs(0)
//相当于：
gs.apply(0)

val ns = Array("11","22","33")
//相当于：
val ns = Array.apply("11","22","33")
}}}

对带有括号并包括一到多个参数的变量赋值时，编译器使用对象的`update`方法对括号里的参数（索引值）和等号右边的对象执行调用：
{{{class="brush: scala"
gs(0) = "aa"
//相当于：
gs.update(0, "aa")
}}}


== 列表 ==

与`java.util.List`不同，`scala.List`是不可变的。不可变的对象更加符合函数式风格。

{{{class="brush: scala"
scala> val ll = List(1,2,3)
ll: List[Int] = List(1, 2, 3)
}}}

`::`把一个元素加到列表的头上； 用`:::`连起两个列表：

{{{class="brush: scala"
scala> 0 :: ll
res12: List[Int] = List(0, 1, 2, 3)

scala> val ll2 = List(4,5,6)
ll2: List[Int] = List(4, 5, 6)

scala> ll ::: ll2
res11: List[Int] = List(1, 2, 3, 4, 5, 6)
}}}

一个元素也没有的空列表用`Nil`表示，作为一个空的列表，它可以把其他的元素给串起来：

{{{class="brush: scala"
scala> val nl = 1 :: 2 :: 3 :: Nil
nl: List[Int] = List(1, 2, 3)
}}}

List只能把元素加在头上，如果要加在后面的话，一个方法是在加到头上以后再调用`reverse`方法；还有一个方案是使用ListBuffer，它有`append`方法。

=== 方法关联性 ===

所有以`:`结尾的方法其实是后一个操作数调用前一个操作数，所以：

{{{class="brush: scala"
0 :: ll
// 其实是
ll.::(0)

ll ::: ll2
// 其实是
ll2.:::(ll)
}}}

回到前面的串列表操作：

{{{class="brush: scala"
val nl = 1 :: 2 :: 3 :: Nil
}}}

如果没有最后的`Nil`，就变成了`3.::(2)`。因为数字没有`::`方法，这样就会报错。

=== List常用方法 ===

{{{class="brush: scala"
List() 或 Nil                          // 空List
List("Cool", "tools", "rule")          // 创建带有三个值"Cool"，"tools"和"rule"的新List[String]

val thrill = "Will"::"fill"::"until"::Nil  // 创建带有三个值"Will"，"fill"和"until"的新List[String]

List("a", "b") ::: List("c", "d")      // 叠加两个列表（返回带"a"，"b"，"c"和"d"的新List[String]）
thrill(2)                              // 返回在thrill列表上索引为2（基于0）的元素（返回"until"）
thrill.count(s => s.length == 4)       // 计算长度为4的String元素个数（返回2）
thrill.drop(2)                         // 返回去掉前2个元素的thrill列表（返回List("until")）
thrill.dropRight(2)                    // 返回去掉后2个元素的thrill列表（返回List("Will")）
thrill.exists(s => s == "until")       // 判断是否有值为"until"的字串元素在thrill里（返回true）
thrill.filter(s => s.length == 4)      // 依次返回所有长度为4的元素组成的列表（返回List("Will", "fill")）
thrill.forall(s => s.endsWith("1"))    // 辨别是否thrill列表里所有元素都以"l"结尾（返回true）
thrill.foreach(s => print(s))          // 对thrill列表每个字串执行print语句（"Willfilluntil"）
thrill.foreach(print)                  // 与前相同，不过更简洁（同上）
thrill.head                            // 返回thrill列表的第一个元素（返回"Will"）
thrill.init                            // 返回thrill列表除最后一个以外其他元素组成的列表（返回List("Will", "fill")）
thrill.isEmpty                         // 说明thrill列表是否为空（返回false）
thrill.last                            // 返回thrill列表的最后一个元素（返回"until"）
thrill.length                          // 返回thrill列表的元素数量（返回3）
thrill.map(s => s + "y")               // 返回由thrill列表里每一个String元素都加了"y"构成的列表（返回List("Willy", "filly", "untily")）
thrill.mkString(", ")                  // 用列表的元素创建字串（返回"will, fill, until"）
thrill.remove(s => s.length == 4)      // 返回去除了thrill列表中长度为4的元素后依次排列的元素列表（返回List("until")）
thrill.reverse                         // 返回含有thrill列表的逆序元素的列表（返回List("until", "fill", "Will")）

thrill.sort((s, t) => s.charAt(0).toLowerCase < t.charAt(0).toLowerCase)
// 返回包括thrill列表所有元素，并且第一个字符小写按照字母顺序排列的列表（返回List("fill", "until", "Will")）

thrill.tail                            // 返回除掉第一个元素的thrill列表（返回List("fill", "until")）
}}}


== 元组（Tuple） ==

元组像列表，但可以放不同类型的元素。这样类似于Java Bean，但写起来更加简单。元组的类型按字段个数来识别，有2个字段的就是`Tuple2`、3个就是`Tuple3`，Scala最多支持到`Tuple22`：

{{{class="brush: scala"
scala> val pair = (99, "Luft")
pair: (Int, java.lang.String) = (99,Luft)
}}}


访问字段通过`_序号`来实现。不能像数组一样用`()`的原因是：如果要用`apply`方法，那定义方法的时候就要声明返回类型，而同一个元组中元素的类型是不同的，所以写不出这个`apply`方法。

{{{class="brush: scala"
scala> print(pair._1)
99
scala> print(pair._2)
Luft
}}}


== 集（Set）和映射（Map） ==
对于Map和Set，Scala都分别提供了可变和不变的版本（放一不同的包里）。可变版本的操作会在本地修改，不可变的版本会返回一个新的对象。一般默认会使用不可变版本。

Set继承关系：


<img src="images/Selection_015.png" alt="Set继承关系" />

{{{class="brush: scala"
scala> var jetSet = Set("Boeing", "Airbus")
jetSet: scala.collection.immutable.Set[java.lang.String] = Set(Boeing, Airbus)

scala> jetSet += "Lear"

scala> println(jetSet.contains("Cessna"))
false

scala> println(jetSet)
Set(Boeing, Airbus, Lear)
}}}

有些情况下想要指定使用可变版本的：

{{{class="brush: scala"
scala> import scala.collection.mutable.Set
import scala.collection.mutable.Set

scala> val movieSet = Set("Hitch", "Poltergeist")
movieSet: scala.collection.mutable.Set[java.lang.String] = Set(Poltergeist, Hitch)

scala> movieSet += "Shrek"
res3: movieSet.type = Set(Shrek, Poltergeist, Hitch)

scala> println(movieSet)
Set(Shrek, Poltergeist, Hitch)
}}}

指定要使用HashSet：

{{{class="brush: scala"
scala> import scala.collection.immutable.HashSet
import scala.collection.immutable.HashSet

scala> val hashSet = HashSet("Tomatoes", "Chilies")
hashSet: scala.collection.immutable.HashSet[java.lang.String] = Set(Chilies, Tomatoes)

scala> println(hashSet + "Coriander")
Set(Chilies, Tomatoes, Coriander)
}}}


Map继承关系：


<img src="images/Selection_016.png" alt="Map继承关系" />


默认的Map用不可变的类型：

{{{class="brush: scala"
scala> val romanNumberal = Map( 1 -> "I", 2 -> "II", 3 -> "III",
     | 4 -> "IV", 5 -> "V")
romanNumberal: scala.collection.immutable.Map[Int,java.lang.String] = Map(5 -> V, 1 -> I, 2 -> II, 3 -> III, 4 -> IV)

scala> println(romanNumberal(4))
IV
}}}

使用一个可变的Map

{{{class="brush: scala"
scala> import scala.collection.mutable.Map
import scala.collection.mutable.Map

scala> val treasureMap = Map[Int, String]()
treasureMap: scala.collection.mutable.Map[Int,String] = Map()

scala> treasureMap += (1 -> "Go to inland.")
res6: treasureMap.type = Map(1 -> Go to inland.)

scala> treasureMap += (2 -> "Find big X on ground.")
res7: treasureMap.type = Map(1 -> Go to inland., 2 -> Find big X on ground.)

scala> treasureMap += (3 -> "Dig.")
res8: treasureMap.type = Map(3 -> Dig., 1 -> Go to inland., 2 -> Find big X on ground.)

scala> println(treasureMap(2))
Find big X on ground.
}}}



== 函数式风格 ==

函数式风格极力避免使用变量（就是用到变量也尽量用val这种不可变的变量）与副作用。

=== 典型的指令式风格 ===

先来看一个指令式的for循环：

{{{class="brush: scala"
scala> val args = Array("11","22","33")
args: Array[java.lang.String] = Array(11, 22, 33)

scala> def printArgs(args: Array[String]): Unit = {
     | var i = 0
     | while (i < args.length) {
     | println(args(i))
     | i += 1
     | }
     | }
printArgs: (args: Array[String])Unit
}}}

=== 去除变量的使用 ===

通过去掉val的使用变得更加函数式风格：

{{{class="brush: scala"
scala> def printArgs(args: Array[String]): Unit = {
     | for (arg <- args) println(arg)
     | }
printArgs: (args: Array[String])Unit
}}}

当然更优雅的风格是这样的：

{{{class="brush: scala"
scala> def printArgs(args: Array[String]): Unit = {
     | args.foreach(println)
     | }
printArgs: (args: Array[String])Unit
}}}

=== 去除副作用 ===

光去掉了变量的使用还不是函数式的。因为这个例子中还有副作用：打印到输出流。

所以我们在这里把字符串的格式化与打印输出分成两个功能来做：

{{{class="brush: scala"
scala> def formatArgs(args: Array[String]) = args.mkString("\n")
formatArgs: (args: Array[String])String

scala> println(formatArgs(args))
11
22
33
}}}

这样才真正算是函数式风格。鼓励程序员尽量设计出没有副作用，没有变量的代码。 



== 读取文本文件 ==

一个读取文本文件的方法，统计每个行里的字符数：

{{{class="brush: scala"
import scala.io.Source

if (args.length > 0) {
	for (line <- Source.fromFile(args(0)).getLines)
		println(line.length + " " + line)
} else {
	Console.err.println("Please enter filename")
}
}}}

执行一下：

{{{class="brush: scala"  title=".scala"
--(morgan-laptop:pts/5)-(13-03-16 17:49:53)-(~/workspace/study/scala/tmp)
\-(morgan:%) >>> scala readFile.scala readFile.scala
22 import scala.io.Source
0 
22 if (args.length > 0) {
48      for (line <- Source.fromFile(args(0)).getLines)
35              println(line.length + " " + line)
8 } else {
45      Console.err.println("Please enter filename")
1 }
}}}

执行的结束不错，但是没有排版……强化一下，先遍历一次得到最长的统计参数。

{{{class="brush: scala"
import scala.io.Source

def widthOfLength(s: String) = s.length.toString.length

if (args.length > 0) {
	val lines = Source.fromFile(args(0)).getLines.toList

	/* 找到最长的一行，不用for循环，
	   显得更加函数式一些 */
	val longestLine = lines.reduceLeft(
		(a, b) => if (a.length > b.length) a else b
	)
	val maxWidth = widthOfLength(longestLine)

	for (line <- lines) {
		val numSpaces = maxWidth - widthOfLength(line)
		val padding = " " * numSpaces
		println(padding + line.length + " | " + line)
	}
} else {
	Console.err.println("Please enter filename")
}
}}}

输出格式为：

{{{class="brush: scala"
--(morgan-laptop:pts/8)-(13-03-17 15:14:04)-(~/workspace/study/scala/tmp)
\-(morgan:%) >>> scala readFile.scala readFile.scala
22 | import scala.io.Source
 0 | 
55 | def widthOfLength(s: String) = s.length.toString.length
 0 | 
22 | if (args.length > 0) {
53 |    val lines = Source.fromFile(args(0)).getLines.toList
 0 | 
36 |    val longestLine = lines.reduceLeft(
45 |            (a, b) => if (a.length > b.length) a else b
 2 |    )
42 |    val maxWidth = widthOfLength(longestLine)
 0 | 
22 |    for (line <- lines) {
48 |            val numSpaces = maxWidth - widthOfLength(line)
31 |            val padding = " " * numSpaces
47 |            println(padding + line.length + " | " + line)
 2 |    }
 8 | } else {
45 |    Console.err.println("Please enter filename")
 1 | }
}}}



= 基本类型 =

基本类型包括`java.lang`包下的`String`和`scala`包下的`Byte`、`Short`、`Int`、`Long`、`Float`、`Double`、`Char`、`Boolean`。还有在`scala.runtime`包下对应的包装器类`Rich...`，如：`RichInt`。

== 字符串 ==

除了和Java一样的字符串字面量表示方式以外，Scala还提供了原始字符串（raw string）方便照原文解读： 

{{{class="brush: scala"
println("""Welcome to Ultamix 3000.
           Type "HELP" for help.""")
}}}

输出的内容包括所有的转义字符和空格：

{{{class="brush: scala"
Welcome to Ultamix 3000.
           Type "HELP" for help.
}}}

有些情况下希望在源代码里也能排版提好看一点，所以字符串里提供`stripMargin`方法可以通过管道符`|`来取得想要的部分：

{{{class="brush: scala"
println("""|Welcome to Ultamix 3000.
           |Type "HELP" for help.""".stripMargin)
}}}

{{{class="brush: scala"
Welcome to Ultamix 3000.
Type "HELP" for help.
}}}

== 符号 ==

格式为`'symb`，这里的`symb`可以是任何字母或数字。这种字面量被直接映射为类`scala.Symbol`的实例，解释器调用工厂方法`Symbol("symb")`产生。

符号变量什么事情都做不了，只能显示自己的名字，而且符号变量是被限定（interned）的，如果同一个字面量出现两次，其实指向的是同一个`Symble`实例：

{{{class="brush: scala"
scala> val s = 'aSymbol
s: Symbol = 'aSymbol

scala> s.name
res3: String = aSymbol
}}}

那符号能用来干嘛？比如说，下面的函数更新记录，`field`是字段名、`value`是值：

{{{class="brush: scala"
scala> def updateRecordByName(field: Symbol, value: Any){ }
updateRecordByName: (field: Symbol, value: Any)Unit

scala> updateRecordByName('pcOK, "OK Computer")
}}}



== 操作符与方法 ==

操作符也是普通方法的另一种写法，操作符的重载也就是方法的重载。

=== 中缀操作符（infix） ===

{{{class="brush: scala"
scala> val s = "Hello, world!"
s: java.lang.String = Hello, world!

scala> s indexOf 'o'
res6: Int = 4

scala> s indexOf ('o', 5)
res7: Int = 8
}}}

=== 前缀操作符 ===

前缀操作符以`unary_`开头，能有四种`+`、`-`、`!`、`~`：

{{{class="brush: scala"
scala> - 2.0
res8: Double = -2.0

scala> (2.0).unary_-
res9: Double = -2.0
}}}

其他的符号就算定义了也不能作为前置操作符解释，如果定义了`p.unary_*`，在调用`*p`会被Scala解释为`*.p`。

=== 后缀操作符 ===

后缀操作符其实就是没有参数的函数。一般习惯上没有副作用的话就加上括号，如：`println()`；如果没有副作用就不加括号，如：`String.toLowerCase`

{{{class="brush: scala"
scala> "Hello".toLowerCase
res10: java.lang.String = hello

scala> "Hello" toLowerCase
res11: java.lang.String = hello
}}}


== 对象相等性 ==

操作符`==`与`!=`不仅比较基本类型，也可以比较对象，甚至是不同类的对象也可以比较，也可以和`null`比不会有异常抛出：

{{{class="brush: scala"
scala>  1 == 2
res12: Boolean = false

scala> 1 != 2
res13: Boolean = true

scala> List(1, 2, 3) == List(1, 2, 3)
res14: Boolean = true

scala> List(1, 2, 3) == List(4, 5, 6)
res15: Boolean = false

scala> 1 == 1.0
res16: Boolean = true

scala> List(1, 2, 3) == "hello"
res17: Boolean = false

scala> List(1, 2, 3) == null
res18: Boolean = false

scala> null == List(1, 2, 3)
res19: Boolean = false

scala> ("he" + "llo") == "hello"
res20: Boolean = true
}}}



= 类 =

简单定义类与创建对象：

{{{class="brush: scala"
scala> class ChecksumAccumulator { }
defined class ChecksumAccumulator

scala> new ChecksumAccumulator
res0: ChecksumAccumulator = ChecksumAccumulator@91f1520

scala> class ChecksumAccumulator {
     | var sum = 0
     | }
defined class ChecksumAccumulator

scala> val acc = new ChecksumAccumulator
acc: ChecksumAccumulator = ChecksumAccumulator@501fdcfb

scala> val csa = new ChecksumAccumulator
csa: ChecksumAccumulator = ChecksumAccumulator@58f285cd
}}}

默认访问控制为public。

成员方法：

{{{class="brush: scala"
class ChecksumAccumulator {
	private var sum = 0
	
	def add(b: Byte): Unit = {
		sum += b
	}

	def checksum(): Int =  {
		return ~(sum & 0xFF) + 1
	}
}
}}}

Scala中参数都是val，不可变。

{{{class="brush: scala"
	def add(b: Byte): Unit = {
		// b = 1   // error, because b is val
		sum += b
	}
}}}

只有一行的方法体可以去掉花括号并放在函数头一行，方法会自动返回最后一行语句，不用加return：

{{{class="brush: scala"
class ChecksumAccumulator {
	private var sum = 0
	def add(b: Byte): Unit = sum += b
	def checksum(): Int =  ~(sum & 0xFF) + 1
}
}}}

没有返回的方法可以省略类型Unit与等号：

{{{class="brush: scala"
	def add(b: Byte): Unit = sum += b
	// 简化
	def add(b: Byte) { sum += b }
}}}



== 创建新类型 ==

分数（rational number）表示分子（numerator）和分母（denominator）的比率，其中分母不能为零。能让小数部分得到了完全表达，没有舍入或估算。要模型化分数的行为，包括允许它们执行加，减，乘还有除运算。

要加两个分数，首先要获得公分母，然后才能把两个分子相加。

要乘两个分数，可以简单的两个分子相乘，然后两个分母相乘。

除法是把右操作数分子分母调换，然后做乘法。

一个分数加到另外一个分数上，产生的结果是一个新的分数。而原来的数不会被“改变”。

== 主构造器：primary constructor ==

如果类没有主体，就不需要指定一对空的大括号（当然你如果想的话也可以）。

{{{class="brush: scala" title="Rational.scala"
class Rational(n: Int, d: Int)
}}}

在类名Rational之后括号里的n和d，被称为类参数（class parameter）。`n`和`d`并不是类中的字段，而是主构造器的两个参数。Scala编译器会收集这两个类参数并创造一个带同样的两个参数的主构造器（primary constructor）。Java类具有可以带参数的构造器，而Scala类可以直接带参数。


Scala编译器将把你放在类内部的任何不是字段的部分或者方法定义的代码，编译进主构造器。例如：

{{{class="brush: scala"
scala> class Rational(n: Int, d: Int) { println("Created "+n+"/"+d) }

scala> new Rational(1, 2)
Created 1/2 res0: Rational = Rational@a0b0f5
}}}

你可以像这样打印输出一条消息，因为打印语句也在主构造器中。

== 先决条件（precondition） ==

先决条件是对传递给方法或构造器的值的限制，是调用者必须满足的需求。使用`Predef`包中的`require`方法。如果传入的值为真，require将正常返回。反之，require将通过抛出IllegalArgumentException来阻止对象被构造。

{{{class="brush: scala"
class Rational(n: Int, d: Int) { 
	require(d != 0) 
}
}}}


== 字段 ==

要注意的是：

{{{class="brush: scala" title="Rational.scala"
scala> class Rational(n: Int, d: Int)
}}}

在前面主构造器部分已经提别提到：`n`和`d`并不是类中的字段，而是主构造器的两个参数。所以下面人代码是无法访问到`n`和`d`的：
{{{class="brush: scala"
def showRational(r: Rational): Rational = println("Rational: "+n+"/"+d) 
}}}

所以又增加了两个字段，分别是numer和denom，并用类参数n和d初始化它们：


{{{class="brush: scala" title="Rational.scala"
class Rational(n: Int, d: Int) {
	require(d != 0) 

	val numer: Int = n 
	val denom: Int = d 
}
}}}

在对象外面访问分子和分母：

{{{class="brush: scala"
scala> val r = new Rational(1, 2) 
r: Rational = 1 / 2 

scala> r.numer 
res7: Int = 1 

scala> r.denom 
res8: Int = 2
}}}


== 方法 ==

添加加法运算，得到另外一个分数后返回一个新对象为二者的和：

{{{class="brush: scala" title="Rational.scala"
class Rational(n: Int, d: Int) {
	require(d != 0) 

	val numer: Int = n 
	val denom: Int = d 

	def add(that: Rational): Rational = new Rational( 
		numer * that.denom + that.numer * denom, 
		denom * that.denom 
	)
}
}}}

加法操作：

{{{class="brush: scala"
scala> val oneHalf = new Rational(1, 2) 
oneHalf: Rational = 1/2 

scala> val twoThirds = new Rational(2, 3) 
twoThirds: Rational = 2/3 

scala> oneHalf add twoThirds 
res0: Rational = 7/6
}}}


== 自指向 ==

关键字this指向当前执行方法被调用的对象实例，或者如果使用在构造器里的话，就是正被构建的对象实例。

例如，我们考虑添加一个方法，lessThan，来测试给定的分数是否小于传入的参数： 

{{{class="brush: scala"
def lessThan(that: Rational) = 
	this.numer * that.denom < that.numer * this.denom 
}}}

这里，this.numer指向lessThan被调用的那个对象的分子。你也可以去掉this前缀而只是写numer；着两种写法是相同的。 

举一个不能缺少this的例子，考虑在Rational类里添加max方法返回指定分数和参数中的较大者： 

{{{class="brush: scala"
def max(that: Rational) = 
	if (this.lessThan(that)) that else this
}}}

这里，第一个this是冗余的，你写成(lessThan(that))也是一样的。但第二个this表示了当测试为假的时候的方法的结果；如果你省略它，就什么都返回不了了。


== 从构造器 ==

有些时候一个类里需要多个构造器。Scala里主构造器之外的构造器被称为从构造器（auxiliary constructor）。Scala的从构造器开始于`def this(...)`。

Java里，构造器的第一个动作必须要么调用同类里的另一个构造器，要么直接调用超类的构造器。Scala的类里面，只有主构造器可以调用超类的构造器。Scala里更严格的限制实际上是权衡了更高的简洁度和与Java构造器相比的简易性所付出的代价之后作出的设计。

比方说，分母为1的分数只写分子的话就更为简洁。如，对于5/1来说，可以只是写成5。因此，如果不是写成`Rational(5, 1)`，客户程序员简单地写成`Rational(5)`或许会更好看一些。这就需要给Rational添加一个只带一个参数分子的从构造器并预先设定分母为1。

{{{class="brush: scala"
class Rational(n: Int, d: Int) { 
	require(d != 0) 

	val numer: Int = n 
	val denom: Int = d 

	def this(n: Int) = this(n, 1)
}}}

Rational的从构造器主体几乎完全是调用主构造器，直接传递了它的唯一的参数n作为分子和1作为分母。



== 私有字段和方法 ==

分数的分子分母有时可以约掉，添加一个最大公约数的私有方法：

{{{class="brush: scala"
class Rational(n: Int, d: Int) { 
	require(d != 0) 

	private val g = gcd(n.abs, d.abs) 

	val numer = n / g 
	val denom = d / g 

	private def gcd(a: Int, b: Int): Int = 
		if (b == 0) a else gcd(b, a % b) 
}
}}}



== 定义操作符 ==

用通常的数学的符号替换add方法，同样实现一个*方法以实现乘法：

{{{class="brush: scala"
def +(that: Rational): Rational = new Rational( 
	numer * that.denom + that.numer * denom, 
	denom * that.denom 

def *(that: Rational): Rational = 
	new Rational(numer * that.numer, denom * that.denom)
}}}

使用

{{{class="brush: scala"
scala> val x = new Rational(1, 2)
x: Rational = 1/2

scala> val y = new Rational(2, 3) 
y: Rational = 2/3 

scala> x.+(y) 
res33: Rational = 7/6

scala> x + y 
res32: Rational = 7/6

}}}

而且实现的加法和乘法都带有优先级：

{{{class="brush: scala"
scala> x + x * y 
res34: Rational = 5/6 

scala> (x + x) * y 
res35: Rational = 2/3 

scala> x + (x * y) 
res36: Rational = 5/6
}}}



== 方法覆盖（override） ==

`override`修饰符标示了之前的方法定义被重载。Rational类里增加toString方法的方式重载：override缺省的实现，如： 

{{{class="brush: scala"
class Rational(n: Int, d: Int) { override def toString = n +"/"+ d } 
}}}

方法定义前的override修饰符标示了之前的方法定义被重载；第10章会更进一步说明。现在分数显示得很漂亮了，所以我们去掉了前一个版本的Rational类里面的println除错语句。你可以在解释器里测试Rational的新行为： 

{{{class="brush: scala"
scala> val x = new Rational(1, 3) 
x: Rational = 1/3 

scala> val y = new Rational(5, 7) 
y: Rational = 5/7
}}}



== 方法重载（overload） ==

方法的参数表不同产生重载。

给每个数学方法都有两个版本了：一个带分数做参数，另一个带整数。


{{{class="brush: scala"
def +(that: Rational): Rational = new Rational( 
    numer * that.denom + that.numer * denom, 
    denom * that.denom 
  ) 

def +(i: Int): Rational = new Rational(numer + i * denom, denom) 

def -(that: Rational): Rational = new Rational( 
    numer * that.denom - that.numer * denom, 
    denom * that.denom 
  ) 

def -(i: Int): Rational = new Rational(numer - i* denom, denom) 

def *(that: Rational): Rational = new Rational(
    numer * that.numer, 
    denom * that.denom
  ) 
 
def *(i: Int): Rational = new Rational(numer * i, denom) 

def /(that: Rational): Rational = new Rational(
   numer * that.denom, 
    denom * that.numer
  ) 
 
def /(i: Int): Rational = new Rational(numer, denom * i)
}}}


== 隐式转换 ==

虽然现在可以写`r * 2`了，但是不能用`2 * r`这样的写法：

{{{class="brush: scala"
scala> val x = new Rational(2, 3)

scala> 2 * r
error: overloaded method value * with alternatives:
  (x: Double)Double <and>
  (x: Float)Float <and>
  (x: Long)Long <and>
  (x: Int)Int <and>
  (x: Char)Int <and>
  (x: Short)Int <and>
  (x: Byte)Int
 cannot be applied to (this.Rational)
}}}

出错的原因是因为Int类上没有重载我们自己建的`Rational`类乘法。

解决的方案是告诉Scala如何把Int类转换为Rational类，再加上修饰符`implicit`通知Scala编译器可以自动调用：

{{{class="brush: scala"
scala> implicit def intToRational(x: Int) = new Rational(x)

scala> 2 * r
res16: Rational = 4/3
}}}

隐式转换只能在定义的作用范围内起作用，如果隐式方法被定义在`Rational`类中，就不在解释器的作用范围内，所以要把它定义在解释器内。

== 完整的Rational代码 ==

{{{class="brush: scala"
class Rational(n: Int, d: Int) { 
	require(d != 0) 

	private val g = gcd(n.abs, d.abs)
	val numer = n / g 
	val denom = d / g 

	def this(n: Int) = this(n, 1)

	def +(that: Rational): Rational = new Rational( 
    numer * that.denom + that.numer * denom, 
    denom * that.denom 
  ) 

  def +(i: Int): Rational = new Rational(numer + i * denom, denom) 

  def -(that: Rational): Rational = new Rational( 
      numer * that.denom - that.numer * denom, 
      denom * that.denom 
    ) 

  def -(i: Int): Rational = new Rational(numer - i* denom, denom) 

  def *(that: Rational): Rational = new Rational(
      numer * that.numer, 
      denom * that.denom
    ) 

  def *(i: Int): Rational = new Rational(numer * i, denom) 

  def /(that: Rational): Rational = new Rational(
     numer * that.denom, 
     denom * that.numer
    ) 

  def /(i: Int): Rational = new Rational(numer, denom * i)

	def lessThan(that: Rational) = 
		this.numer * that.denom < that.numer * this.denom 

	def max(that: Rational) = 
		if (this.lessThan(that)) that else this

	override def toString = n +"/"+ d

	private def gcd(a: Int, b: Int): Int = 
		if (b == 0) a else gcd(b, a % b) 
}

val x = new Rational(2, 3)
print("    x = ");  println(x)
print("x * x = ");  println(x * x)
print("x * 2 = ");  println(x * 2)

implicit def intToRational(x: Int) = new Rational(x)
print("2 * x = ");  println(2 * x)
}}}



= 单例对象 =

Scala中没有像Java那样的静态成员而是用单例对象（Singleton Object）来代替。

在定义格式基本上和类一样，除了了object关键字代替class：

{{{class="brush: scala"
object ObjNam{
	// ...
}
}}}

= 伴生对象 =

如果一个单例对象的名字和类一样，并且必须在同一个文件里。那它就是这个类的伴生对象（Companion Object），类是它的伴生类（Companion Class）。它们可以相互访问私有成员。

{{{class="brush: scala" title="ChecksumAccumulator.scala"
import scala.collection.mutable.Map

class ChecksumAccumulator {
	private var sum = 0
	def add(b: Byte) { sum += b }
	def checksum(): Int =  ~(sum & 0xFF) + 1
}

object ChecksumAccumulator {
	private val cache = Map[String, Int]()

	def caculate(s: String): Int = {
		if (cache.contains(s))
			cache(s)
		else {
			val acc = new ChecksumAccumulator
			for (c <- s)
				acc.add(c.toByte)
			val cs = acc.checksum()
			cache += (s -> cs)
			cs
		}
	}
}

}}}

直接通过调用方法：

{{{class="brush: scala"
val res1 = ChecksumAccumulator.caculate("Every value is an object")
println(res1)

val res2 = ChecksumAccumulator.caculate("So simple!")
println(res2)
}}}




= 内建控制结构 =

== if表达式 ==

if表达式返回执行分支的结果：

{{{class="brush: scala"
var filename = "default.txt"
if (!args.isEmpty)
	filename = args(0)
}}}

更加函数式地写法，去掉变量：

{{{class="brush: scala"
val filename = 
	if (!args.isEmpty) args(0)
	else "default.txt"
}}}

在没有副作用的情况下，用变量的目的就是为了存个值。而表达式就是算值的，所以直接拿表达式来用得了：

{{{class="brush: scala"
println(if (!args.isEmpty) args(0) else "default.txt")
}}}



== while循环 ==

用do-while算最大公约数：

{{{class="brush: scala"
def gcdLoop(x: Long, y: Long): Long = {
	var a = x; var b = y
	while (a != 0) {
		val temp = a; a = b % a; b = temp
	}
	b
}
}}}

用while-do读取文件：

{{{class="brush: scala"
var line = ""
do {
	line = readline()
		println("Read: " + line)
} while (line != "")
}}}

=== while循环与Unit ===

注意这里没有叫它“表达式”。原因是它不会有返回值（类型为`Unit`，写作“`()`”），所以不是表达式。

{{{class="brush: scala"
scala> def greet() { println("HI") }
greet: ()Unit

scala> greet() == ()
<console>:9: warning: comparing values of types Unit and Unit using `==' will always yield true
              greet() == ()
                      ^
HI
res1: Boolean = true

scala> () == ""
<console>:8: warning: comparing values of types Unit and java.lang.String using `==' will always yield false
              () == ""
                 ^
res2: Boolean = false

scala> () != ""
<console>:8: warning: comparing values of types Unit and java.lang.String using `!=' will always yield true
              () != ""
                 ^
res3: Boolean = true
}}}

注意上面的警告信息：Unit与Unit进行相等运算永远为true；与String相等运算永远false；与String不相等运算永远为true。

现在说到重点了：Scala中var赋值操作也是Unit，而不是和Java一样返回变量值。所以下面这种Java中一直用到的写法在Scala中是会出问题的：

{{{class="brush: scala"
var line = ""
while ((line = readline()) != "") {  // always true !!!
		println("Read: " + line)
} 
}}}


=== while循环与函数式风格 ===

由于while没有返回值，所以常常被函数式语言舍弃。例如对于同样一个求最大公约数的函数，对比一下指令式与函数式的区别。

指令式，用循环：
{{{class="brush: scala"
def gcdLoop(x: Long, y: Long): Long = {
	var a = x; var b = y
	while (a != 0) {
		val temp = a; a = b % a; b = temp
	}
	b
}
}}}

函数式，用递归：
{{{class="brush: scala"
def gcd(x: Long, y: Long): Long = if (y == 0) x else gcd(x, x % y)
}}}

while循环是没有返回值的，那就一定要用副作用：不是更新var就是写I/O之类的，不然浪费电么？


== for循环 ==

{{{class="brush: scala"
}}}

{{{class="brush: scala"
}}}


{{{class="brush: scala"
}}}

{{{class="brush: scala"
}}}


{{{class="brush: scala"
}}}

{{{class="brush: scala"
}}}


{{{class="brush: scala"
}}}

{{{class="brush: scala"
}}}


{{{class="brush: scala"
}}}

{{{class="brush: scala"
}}}


{{{class="brush: scala"
}}}

{{{class="brush: scala"
}}}

{{{class="brush: scala"
}}}

{{{class="brush: scala"
}}}
