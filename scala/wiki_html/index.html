<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">

<link type="text/css" rel="stylesheet" href="styles/style.css" />
<link type="text/css" rel="stylesheet" href="styles/shCore.css"/>
<link type="text/css" rel="stylesheet" href="styles/shCoreRDark.css"/>
<link type="text/css" rel="stylesheet" href="styles/shThemeRDark.css"/>

<script type="text/javascript" src="scripts/jquery-1.4.2.min.js"></script>
<script type="text/javascript" src="scripts/shCore.js"></script>
<script type="text/javascript" src="scripts/shAutoloader.js"></script>

<script type="text/javascript" src="scripts/default.js"></script>


<title>Scala入门</title>
</head>
<body>




<h1>Scala入门</h1>
<div class="toc">
<ul>
<li><a href="#toc_1">配置</a>
<ul>
<li><a href="#toc_1.1">字符编码问题</a>
<li><a href="#toc_1.2">Vim插件</a>
</ul>
<li><a href="#toc_2">使用</a>
<ul>
<li><a href="#toc_2.1">Scala Shell</a>
<li><a href="#toc_2.2">脚本</a>
<li><a href="#toc_2.3">Scala程序</a>
<li><a href="#toc_2.4">脚本与程序的区别</a>
</ul>
<li><a href="#toc_3">入门</a>
<ul>
<li><a href="#toc_3.1">变量定义</a>
<li><a href="#toc_3.2">语句定义</a>
<li><a href="#toc_3.3">函数定义</a>
<li><a href="#toc_3.4">函数字面量（Function Literal）</a>
<li><a href="#toc_3.5">for循环</a>
<li><a href="#toc_3.6">方法与操作符</a>
<li><a href="#toc_3.7">类型参数化数组</a>
<li><a href="#toc_3.8">apply与update方法</a>
<li><a href="#toc_3.9">列表</a>
<ul>
<li><a href="#toc_3.9.1">方法关联性</a>
<li><a href="#toc_3.9.2">List常用方法</a>
</ul>
<li><a href="#toc_3.10">元组（Tuple）</a>
<li><a href="#toc_3.11">集（Set）和映射（Map）</a>
<li><a href="#toc_3.12">函数式风格</a>
<ul>
<li><a href="#toc_3.12.1">典型的指令式风格</a>
<li><a href="#toc_3.12.2">去除变量的使用</a>
<li><a href="#toc_3.12.3">去除副作用</a>
</ul>
<li><a href="#toc_3.13">读取文本文件</a>
</ul>
<li><a href="#toc_4">基本类型</a>
<ul>
<li><a href="#toc_4.1">字符串</a>
<li><a href="#toc_4.2">符号</a>
<li><a href="#toc_4.3">操作符与方法</a>
<ul>
<li><a href="#toc_4.3.1">中缀操作符（infix）</a>
<li><a href="#toc_4.3.2">前缀操作符</a>
<li><a href="#toc_4.3.3">后缀操作符</a>
</ul>
<li><a href="#toc_4.4">对象相等性</a>
</ul>
<li><a href="#toc_5">类</a>
<ul>
<li><a href="#toc_5.1">访问控制</a>
<li><a href="#toc_5.2">成员方法</a>
</ul>
<li><a href="#toc_6">单例对象</a>
<li><a href="#toc_7">伴生对象</a>
</ul>
</div>

<h1 id="toc_1">配置</h1>

<h2 id="toc_1.1">字符编码问题</h2>

<p>
在默认字符编码为UTF-8的Linux下没问题。
</p>

<p>
Mac OS X系统的默认字符编码早就改成了UTF-8但它bundle的Java默认字符编码却一直是MacRoman。在启动REPL时传入参数<code>-Dfile.encoding=UTF-8</code>
</p>

<p>
用vim、emacs或者你习惯的文本编辑器打开scala命令，比如：
</p>
<pre class="brush: bash">
$ vim `which scala`
</pre>

<p>
找到如下行：
</p>
<pre class="brush: bash">
[ -n "$JAVA_OPTS" ] || JAVA_OPTS="-Xmx256M -Xms32M"
</pre>

<p>
把-D参数加到JAVA_OPTS里即可。
</p>

<h2 id="toc_1.2">Vim插件</h2>

<p>
到<a href="https://github.com/scala/scala-dist][相关工具">https://github.com/scala/scala-dist][相关工具</a>上下载，复制<code>tool-support/src/vim</code>到<code>.vim</code>目录下。
</p>


<h1 id="toc_2">使用</h1>
 
<h2 id="toc_2.1">Scala Shell</h2>

<p>
使用进入REPL环境的方式：
</p>

<pre class="brush: bash">
--(morgan-laptop:pts/8)-(13-03-15 9:04:57)-(~/workspace/study/scala)
\-(morgan:%) &gt;&gt;&gt; scala
Welcome to Scala version 2.9.2 (OpenJDK 64-Bit Server VM, Java 1.7.0_15).
Type in expressions to have them evaluated.
Type :help for more information.

scala&gt; 
</pre>

<p>
输入回车自动换行。
</p>

<p>
发现输错了，再按几个回车就退出了。
</p>

<p>
退出<code>Scala Shell</code>：<code>:quit</code>或<code>:q</code>
</p>

<p>
在REPL环境中只能一行一行读取，所以如果要换行的话，不能让一行在语法上看起来已经结束：
</p>

<pre class="brush: scala">
scala&gt; if(x &gt; 0) { 1
     | } else if(x == 0) 0 else -1
res1: Int = 1
</pre>

<p>
另一个方法是在REPL中输入<code>:paste</code>粘贴代码，按下<code>Control + D</code>。
</p>

<h2 id="toc_2.2">脚本</h2>

<p>
脚本文件，可以接收一个参数并输出欢迎信息：
</p>

<pre class="brush: scala" title="helloarg.scala">
/* 可以接收一个参数 */
println("Hello, " + args(0) + "!")
</pre>

<p>
调用脚本：scala命令、文件名、参数
</p>

<pre class="brush: bash">
--(morgan-laptop:pts/8)-(13-03-14 23:28:27)-(~/workspace/study/scala/tmp)
\-(morgan:%) &gt;&gt;&gt; scala helloarg.scala Jade
Hello, Jade!
</pre>

<p>
可以通过循环处理多个参数的：
</p>

<pre class="brush: scala" title="pa.scala">
args.foreach( arg =&gt; println(arg) )
</pre>

<p>
调用：
</p>

<pre class="brush: bash">
--(morgan-laptop:pts/8)-(13-03-14 23:49:39)-(~/workspace/study/scala/tmp)
\-(morgan:%) &gt;&gt;&gt; scala pa.scala Scala is even more fun      
Scala
is
even
more
fun
</pre>

<h2 id="toc_2.3">Scala程序</h2>

<p>
先看一个工具类，它根据字符串来计算出检验和：
</p>
<pre class="brush: scala" title="Summer.scala">
import scala.collection.mutable.Map

class ChecksumAccumulator {
	private var sum = 0
	def add(b: Byte) { sum += b }
	def checksum(): Int =  ~(sum &amp;0xFF) + 1
}

object ChecksumAccumulator {
	private val cache = Map[String, Int]()

	def calculate(s: String): Int =
		if( cache.contains(s) ) {
			cache(s)
		} else {
			val acc = new ChecksumAccumulator
			for (c &lt;- s)
				acc.add(c.toByte)
			val cs = acc.checksum()
			cache += (s -&gt; cs)
			cs
		}
}
</pre>

<p>
然后是主程序。独立运行的程序一定要有<code>main</code>方法（仅有一个参数<code>Array[String]</code>而且结果类型为<code>Unit</code>）的单例对象。
</p>

<pre class="brush: scala" title="Summer.scala">
import ChecksumAccumulator.calculate

object Summer {

	def main(args: Array[String]) {
		for (arg &lt;- args)
			println(arg + " -&gt; " + calculate(arg))
	}

}
</pre>

<p>
编译Scala程序：
</p>
<pre class="brush: bash">
--(morgan-laptop:pts/8)-(13-03-15 0:28:39)-(~/workspace/study/scala/tmp)
\-(morgan:%) &gt;&gt;&gt; scalac ChecksumAccumulator.scala Summer.scala
</pre>

<p>
有一个<code>fast Scala compiler</code>的后台进程可以在第一次被调用后一直跑在后台，节省一下每次编译的速度：
</p>
<pre class="brush: bash">
--(morgan-laptop:pts/8)-(13-03-15 0:29:11)-(~/workspace/study/scala/tmp)
\-(morgan:%) &gt;&gt;&gt; fsc ChecksumAccumulator.scala Summer.scala   
</pre>

<p>
可以关掉这个后台进程：
</p>
<pre class="brush: bash">
--(morgan-laptop:pts/8)-(13-03-15 0:29:11)-(~/workspace/study/scala/tmp)
\-(morgan:%) &gt;&gt;&gt; fsc -shutdown
</pre>

<p>
编译完后可以看到生成的<code>.class</code>文件：
</p>
<pre class="brush: bash">
--(morgan-laptop:pts/8)-(13-03-15 0:44:31)-(~/workspace/study/scala/tmp)
\-(morgan:%) &gt;&gt;&gt; ls *.class
ChecksumAccumulator$$anonfun$calculate$1.class  ChecksumAccumulator$.class    Summer.class
ChecksumAccumulator.class                       Summer$$anonfun$main$1.class  Summer$.class
</pre>

<p>
运行编译出来的类文件：
</p>
<pre class="brush: bash">
--(morgan-laptop:pts/8)-(13-03-15 0:30:58)-(~/workspace/study/scala/tmp)
\-(morgan:%) &gt;&gt;&gt; scala Summer of love
of -&gt; -213
love -&gt; -182
</pre>

<p>
还有一个加入的<code>Application</code>特质的方式实现应用程序，但是有局限：不能访问命令行参数、只能在单线程下用。所以不推荐用它。
</p>

<p>
形式类似于：
</p>
<pre class="brush: scala" title="myApp.scala">
object MyApp extends Application {
	println("Hello")
}	
</pre>

<h2 id="toc_2.4">脚本与程序的区别</h2>

<p>
脚本必须以表达式结束，而程序以定义结尾。尝试以<code>scala</code>解释器运行程序会报错。
</p>




<h1 id="toc_3">入门</h1>


<h2 id="toc_3.1">变量定义</h2>

<p>
<code>val</code>不可变变量；<code>var</code>可变变量。格式：
</p>
<pre class="brush: scala">
// 基本格式
val msg: java.lang.String = "Hello"

// java.lang默认已经导入了
val msg: String = "Hello"

// 自动推导类型
val msg = "Hello"
</pre>

<h2 id="toc_3.2">语句定义</h2>

<p>
Scala语句以分号结束，而且分号可以省略。默认一行结束了就是一行语句结束了，除非以下三种情况，会认为语句还没有结束：
</p>

<ul>
<li>
行尾是一个不能放在行尾的字符。

<li>
下一行的开头是不能放在行头的字符。

<li>
<code>()</code>和<code>[]</code>里，这里面不能放多条语句。

</ul>

<p>
这是两个：
</p>
<pre class="brush: scala">
val s = "hello"; println(s)
</pre>


<pre class="brush: scala">
if (x &lt; 2)
	println("too small")
else
	println("ok")
</pre>

<p>
这是两个：
</p>
<pre class="brush: scala">
x
+ y
</pre>

<p>
一个：
</p>
<pre class="brush: scala">
(x
+ y)
</pre>

<p>
一个：
</p>
<pre class="brush: scala">
x +
y +
z
</pre>

<h2 id="toc_3.3">函数定义</h2>

<p>
取最大的函数，函数体的最后一行作为结果返回： 
</p>

<pre class="brush: scala">
def max(x: Int, y: Int): Int = {
	if (x &gt; y) x else y
}
</pre>

<p>
函数类型也能自动推导出来，可以省略。在递归函数的情况下，一定要明确地说明返回类型。如果函数体只有一行，那花括号也可以省略：
</p>

<pre class="brush: scala">
scala&gt; def max(x: Int, y: Int) =  if (x &gt; y) x else y
max: (x: Int, y: Int)Int
</pre>


<p>
类型<code>Unit</code>对应Java中的<code>void</code>。即没有参数又没有返回结果的函数定义：
</p>

<pre class="brush: scala">
scala&gt; def greet() = println("Hello")
greet: ()Unit
</pre>


<p>
对于没有等号的方法来说返回类型一定是Unit。Scala可以把任何类型转为Unit，以下方法最后的String类结果会转为Unit并丢弃：
</p>

<pre class="brush: scala">
scala&gt; def f(): Unit = "This String is lost!"
f: ()Unit
</pre>

<p>
有花括号但没有等号的方法默认为Unit，有了等号但没有类型会由编译器自动推导：
</p>

<pre class="brush: scala">
scala&gt; def f() {"This String is lost!"}
f: ()Unit

scala&gt; def f() = {"This String get returned!"}
f: ()java.lang.String

scala&gt; f
res2: java.lang.String = This String get returned!
</pre>

<h2 id="toc_3.4">函数字面量（Function Literal）</h2>

<p>
函数字面量用<code>=&gt;</code>来分隔参数表与函数体：
</p>

<pre class="brush: scala">
(x:Int, y:Int) =&gt; x + y
</pre>

<p>
通过函数字面量来迭代处理参数的例子：
</p>

<pre class="brush: scala">
args.foreach( (arg: String) =&gt; println(arg) )

//这里的String类型可以自动推导出来：
args.foreach( arg =&gt; println(arg) )

//在这种字面量只有一行而且只有一个参数情况下，可以省掉参数列表
args.foreach( println )
</pre>


<h2 id="toc_3.5">for循环</h2>

<pre class="brush: scala">
scala&gt; for (i &lt;- 0 to 10) print(i)
012345678910

</pre>


<h2 id="toc_3.6">方法与操作符</h2>

<p>
下面的语句产一个从0到5的集合：
</p>

<pre class="brush: scala">
scala&gt; 0 to 5
res9: scala.collection.immutable.Range.Inclusive = Range(0, 1, 2, 3, 4, 5)
</pre>

<p>
其实这个<code>to</code>是一个方法的调用。Scala中对于方法调用时，如果方法只有一个参数的话可以省略括号，原本的样子是：
</p>

<pre class="brush: scala">
(0).to(5)
</pre>

<p>
scala中没有操作符的重载，因为操作符也是方法的名字：
</p>

<pre class="brush: scala">
1 + 2
</pre>
<p>
相当于：
</p>
<pre class="brush: scala">
(1).+(2)
</pre>

<h2 id="toc_3.7">类型参数化数组</h2>

<p>
长度为3的数组，存放的元素类型为<code>String</code>：
</p>

<pre class="brush: scala">
val gs: Array[String] = new Array[String](3)
</pre>

<pre class="brush: scala">

scala&gt; val gs = new Array[String](3)
gs: Array[String] = Array(null, null, null)

scala&gt; gs(0) = "aa"
scala&gt; gs(1) = "bb"
scala&gt; gs(2) = "cc"

scala&gt; gs.foreach(print)
aabbcc

scala&gt; val ns = Array("11","22","33")
ns: Array[java.lang.String] = Array(11, 22, 33)

scala&gt; ns.foreach(print)
112233
</pre>


<h2 id="toc_3.8">apply与update方法</h2>

<p>
对一个对象的后面加上括号的操作其实是调用了这个对象的<code>apply</code>方法。所以数组的元素索引操作其实是<code>apply</code>方法调用：
</p>

<pre class="brush: scala">
gs(0)
//相当于：
gs.apply(0)

val ns = Array("11","22","33")
//相当于：
val ns = Array.apply("11","22","33")
</pre>

<p>
对带有括号并包括一到多个参数的变量赋值时，编译器使用对象的<code>update</code>方法对括号里的参数（索引值）和等号右边的对象执行调用：
</p>
<pre class="brush: scala">
gs(0) = "aa"
//相当于：
gs.update(0, "aa")
</pre>


<h2 id="toc_3.9">列表</h2>

<p>
与<code>java.util.List</code>不同，<code>scala.List</code>是不可变的。不可变的对象更加符合函数式风格。
</p>

<pre class="brush: scala">
scala&gt; val ll = List(1,2,3)
ll: List[Int] = List(1, 2, 3)
</pre>

<p>
<code>::</code>把一个元素加到列表的头上； 用<code>:::</code>连起两个列表：
</p>

<pre class="brush: scala">
scala&gt; 0 :: ll
res12: List[Int] = List(0, 1, 2, 3)

scala&gt; val ll2 = List(4,5,6)
ll2: List[Int] = List(4, 5, 6)

scala&gt; ll ::: ll2
res11: List[Int] = List(1, 2, 3, 4, 5, 6)
</pre>

<p>
一个元素也没有的空列表用<code>Nil</code>表示，作为一个空的列表，它可以把其他的元素给串起来：
</p>

<pre class="brush: scala">
scala&gt; val nl = 1 :: 2 :: 3 :: Nil
nl: List[Int] = List(1, 2, 3)
</pre>

<p>
List只能把元素加在头上，如果要加在后面的话，一个方法是在加到头上以后再调用<code>reverse</code>方法；还有一个方案是使用ListBuffer，它有<code>append</code>方法。
</p>

<h3 id="toc_3.9.1">方法关联性</h3>

<p>
所有以<code>:</code>结尾的方法其实是后一个操作数调用前一个操作数，所以：
</p>

<pre class="brush: scala">
0 :: ll
// 其实是
ll.::(0)

ll ::: ll2
// 其实是
ll2.:::(ll)
</pre>

<p>
回到前面的串列表操作：
</p>

<pre class="brush: scala">
val nl = 1 :: 2 :: 3 :: Nil
</pre>

<p>
如果没有最后的<code>Nil</code>，就变成了<code>3.::(2)</code>。因为数字没有<code>::</code>方法，这样就会报错。
</p>

<h3 id="toc_3.9.2">List常用方法</h3>

<pre class="brush: scala">
List() 或 Nil                          // 空List
List("Cool", "tools", "rule")          // 创建带有三个值"Cool"，"tools"和"rule"的新List[String]

val thrill = "Will"::"fill"::"until"::Nil  // 创建带有三个值"Will"，"fill"和"until"的新List[String]

List("a", "b") ::: List("c", "d")      // 叠加两个列表（返回带"a"，"b"，"c"和"d"的新List[String]）
thrill(2)                              // 返回在thrill列表上索引为2（基于0）的元素（返回"until"）
thrill.count(s =&gt; s.length == 4)       // 计算长度为4的String元素个数（返回2）
thrill.drop(2)                         // 返回去掉前2个元素的thrill列表（返回List("until")）
thrill.dropRight(2)                    // 返回去掉后2个元素的thrill列表（返回List("Will")）
thrill.exists(s =&gt; s == "until")       // 判断是否有值为"until"的字串元素在thrill里（返回true）
thrill.filter(s =&gt; s.length == 4)      // 依次返回所有长度为4的元素组成的列表（返回List("Will", "fill")）
thrill.forall(s =&gt; s.endsWith("1"))    // 辨别是否thrill列表里所有元素都以"l"结尾（返回true）
thrill.foreach(s =&gt; print(s))          // 对thrill列表每个字串执行print语句（"Willfilluntil"）
thrill.foreach(print)                  // 与前相同，不过更简洁（同上）
thrill.head                            // 返回thrill列表的第一个元素（返回"Will"）
thrill.init                            // 返回thrill列表除最后一个以外其他元素组成的列表（返回List("Will", "fill")）
thrill.isEmpty                         // 说明thrill列表是否为空（返回false）
thrill.last                            // 返回thrill列表的最后一个元素（返回"until"）
thrill.length                          // 返回thrill列表的元素数量（返回3）
thrill.map(s =&gt; s + "y")               // 返回由thrill列表里每一个String元素都加了"y"构成的列表（返回List("Willy", "filly", "untily")）
thrill.mkString(", ")                  // 用列表的元素创建字串（返回"will, fill, until"）
thrill.remove(s =&gt; s.length == 4)      // 返回去除了thrill列表中长度为4的元素后依次排列的元素列表（返回List("until")）
thrill.reverse                         // 返回含有thrill列表的逆序元素的列表（返回List("until", "fill", "Will")）

thrill.sort((s, t) =&gt; s.charAt(0).toLowerCase &lt; t.charAt(0).toLowerCase)
// 返回包括thrill列表所有元素，并且第一个字符小写按照字母顺序排列的列表（返回List("fill", "until", "Will")）

thrill.tail                            // 返回除掉第一个元素的thrill列表（返回List("fill", "until")）
</pre>


<h2 id="toc_3.10">元组（Tuple）</h2>

<p>
元组像列表，但可以放不同类型的元素。这样类似于Java Bean，但写起来更加简单。元组的类型按字段个数来识别，有2个字段的就是<code>Tuple2</code>、3个就是<code>Tuple3</code>，Scala最多支持到<code>Tuple22</code>：
</p>

<pre class="brush: scala">
scala&gt; val pair = (99, "Luft")
pair: (Int, java.lang.String) = (99,Luft)
</pre>


<p>
访问字段通过<code>_序号</code>来实现。不能像数组一样用<code>()</code>的原因是：如果要用<code>apply</code>方法，那定义方法的时候就要声明返回类型，而同一个元组中元素的类型是不同的，所以写不出这个<code>apply</code>方法。
</p>

<pre class="brush: scala">
scala&gt; print(pair._1)
99
scala&gt; print(pair._2)
Luft
</pre>


<h2 id="toc_3.11">集（Set）和映射（Map）</h2>
<p>
对于Map和Set，Scala都分别提供了可变和不变的版本（放一不同的包里）。可变版本的操作会在本地修改，不可变的版本会返回一个新的对象。一般默认会使用不可变版本。
</p>

<p>
Set继承关系：
</p>


<p>
<img src="images/Selection_015.png" alt="Set继承关系" />
</p>

<pre class="brush: scala">
scala&gt; var jetSet = Set("Boeing", "Airbus")
jetSet: scala.collection.immutable.Set[java.lang.String] = Set(Boeing, Airbus)

scala&gt; jetSet += "Lear"

scala&gt; println(jetSet.contains("Cessna"))
false

scala&gt; println(jetSet)
Set(Boeing, Airbus, Lear)
</pre>

<p>
有些情况下想要指定使用可变版本的：
</p>

<pre class="brush: scala">
scala&gt; import scala.collection.mutable.Set
import scala.collection.mutable.Set

scala&gt; val movieSet = Set("Hitch", "Poltergeist")
movieSet: scala.collection.mutable.Set[java.lang.String] = Set(Poltergeist, Hitch)

scala&gt; movieSet += "Shrek"
res3: movieSet.type = Set(Shrek, Poltergeist, Hitch)

scala&gt; println(movieSet)
Set(Shrek, Poltergeist, Hitch)
</pre>

<p>
指定要使用HashSet：
</p>

<pre class="brush: scala">
scala&gt; import scala.collection.immutable.HashSet
import scala.collection.immutable.HashSet

scala&gt; val hashSet = HashSet("Tomatoes", "Chilies")
hashSet: scala.collection.immutable.HashSet[java.lang.String] = Set(Chilies, Tomatoes)

scala&gt; println(hashSet + "Coriander")
Set(Chilies, Tomatoes, Coriander)
</pre>


<p>
Map继承关系：
</p>


<p>
<img src="images/Selection_016.png" alt="Map继承关系" />
</p>


<p>
默认的Map用不可变的类型：
</p>

<pre class="brush: scala">
scala&gt; val romanNumberal = Map( 1 -&gt; "I", 2 -&gt; "II", 3 -&gt; "III",
     | 4 -&gt; "IV", 5 -&gt; "V")
romanNumberal: scala.collection.immutable.Map[Int,java.lang.String] = Map(5 -&gt; V, 1 -&gt; I, 2 -&gt; II, 3 -&gt; III, 4 -&gt; IV)

scala&gt; println(romanNumberal(4))
IV
</pre>

<p>
使用一个可变的Map
</p>

<pre class="brush: scala">
scala&gt; import scala.collection.mutable.Map
import scala.collection.mutable.Map

scala&gt; val treasureMap = Map[Int, String]()
treasureMap: scala.collection.mutable.Map[Int,String] = Map()

scala&gt; treasureMap += (1 -&gt; "Go to inland.")
res6: treasureMap.type = Map(1 -&gt; Go to inland.)

scala&gt; treasureMap += (2 -&gt; "Find big X on ground.")
res7: treasureMap.type = Map(1 -&gt; Go to inland., 2 -&gt; Find big X on ground.)

scala&gt; treasureMap += (3 -&gt; "Dig.")
res8: treasureMap.type = Map(3 -&gt; Dig., 1 -&gt; Go to inland., 2 -&gt; Find big X on ground.)

scala&gt; println(treasureMap(2))
Find big X on ground.
</pre>



<h2 id="toc_3.12">函数式风格</h2>

<p>
函数式风格极力避免使用变量（就是用到变量也尽量用val这种不可变的变量）与副作用。
</p>

<h3 id="toc_3.12.1">典型的指令式风格</h3>

<p>
先来看一个指令式的for循环：
</p>

<pre class="brush: scala">
scala&gt; val args = Array("11","22","33")
args: Array[java.lang.String] = Array(11, 22, 33)

scala&gt; def printArgs(args: Array[String]): Unit = {
     | var i = 0
     | while (i &lt; args.length) {
     | println(args(i))
     | i += 1
     | }
     | }
printArgs: (args: Array[String])Unit
</pre>

<h3 id="toc_3.12.2">去除变量的使用</h3>

<p>
通过去掉val的使用变得更加函数式风格：
</p>

<pre class="brush: scala">
scala&gt; def printArgs(args: Array[String]): Unit = {
     | for (arg &lt;- args) println(arg)
     | }
printArgs: (args: Array[String])Unit
</pre>

<p>
当然更优雅的风格是这样的：
</p>

<pre class="brush: scala">
scala&gt; def printArgs(args: Array[String]): Unit = {
     | args.foreach(println)
     | }
printArgs: (args: Array[String])Unit
</pre>

<h3 id="toc_3.12.3">去除副作用</h3>

<p>
光去掉了变量的使用还不是函数式的。因为这个例子中还有副作用：打印到输出流。
</p>

<p>
所以我们在这里把字符串的格式化与打印输出分成两个功能来做：
</p>

<pre class="brush: scala">
scala&gt; def formatArgs(args: Array[String]) = args.mkString("\n")
formatArgs: (args: Array[String])String

scala&gt; println(formatArgs(args))
11
22
33
</pre>

<p>
这样才真正算是函数式风格。鼓励程序员尽量设计出没有副作用，没有变量的代码。 
</p>



<h2 id="toc_3.13">读取文本文件</h2>

<p>
一个读取文本文件的方法，统计每个行里的字符数：
</p>

<pre class="brush: scala">
import scala.io.Source

if (args.length &gt; 0) {
	for (line &lt;- Source.fromFile(args(0)).getLines)
		println(line.length + " " + line)
} else {
	Console.err.println("Please enter filename")
}
</pre>

<p>
执行一下：
</p>

<pre class="brush: scala"  title=".scala">
--(morgan-laptop:pts/5)-(13-03-16 17:49:53)-(~/workspace/study/scala/tmp)
\-(morgan:%) &gt;&gt;&gt; scala readFile.scala readFile.scala
22 import scala.io.Source
0 
22 if (args.length &gt; 0) {
48      for (line &lt;- Source.fromFile(args(0)).getLines)
35              println(line.length + " " + line)
8 } else {
45      Console.err.println("Please enter filename")
1 }
</pre>

<p>
执行的结束不错，但是没有排版……强化一下，先遍历一次得到最长的统计参数。
</p>

<pre class="brush: scala">
import scala.io.Source

def widthOfLength(s: String) = s.length.toString.length

if (args.length &gt; 0) {
	val lines = Source.fromFile(args(0)).getLines.toList

	/* 找到最长的一行，不用for循环，
	   显得更加函数式一些 */
	val longestLine = lines.reduceLeft(
		(a, b) =&gt; if (a.length &gt; b.length) a else b
	)
	val maxWidth = widthOfLength(longestLine)

	for (line &lt;- lines) {
		val numSpaces = maxWidth - widthOfLength(line)
		val padding = " " * numSpaces
		println(padding + line.length + " | " + line)
	}
} else {
	Console.err.println("Please enter filename")
}
</pre>

<p>
输出格式为：
</p>

<pre class="brush: scala">
--(morgan-laptop:pts/8)-(13-03-17 15:14:04)-(~/workspace/study/scala/tmp)
\-(morgan:%) &gt;&gt;&gt; scala readFile.scala readFile.scala
22 | import scala.io.Source
 0 | 
55 | def widthOfLength(s: String) = s.length.toString.length
 0 | 
22 | if (args.length &gt; 0) {
53 |    val lines = Source.fromFile(args(0)).getLines.toList
 0 | 
36 |    val longestLine = lines.reduceLeft(
45 |            (a, b) =&gt; if (a.length &gt; b.length) a else b
 2 |    )
42 |    val maxWidth = widthOfLength(longestLine)
 0 | 
22 |    for (line &lt;- lines) {
48 |            val numSpaces = maxWidth - widthOfLength(line)
31 |            val padding = " " * numSpaces
47 |            println(padding + line.length + " | " + line)
 2 |    }
 8 | } else {
45 |    Console.err.println("Please enter filename")
 1 | }
</pre>



<h1 id="toc_4">基本类型</h1>

<p>
基本类型包括<code>java.lang</code>包下的<code>String</code>和<code>scala</code>包下的<code>Byte</code>、<code>Short</code>、<code>Int</code>、<code>Long</code>、<code>Float</code>、<code>Double</code>、<code>Char</code>、<code>Boolean</code>。还有在<code>scala.runtime</code>包下对应的包装器类<code>Rich...</code>，如：<code>RichInt</code>。
</p>

<h2 id="toc_4.1">字符串</h2>

<p>
除了和Java一样的字符串字面量表示方式以外，Scala还提供了原始字符串（raw string）方便照原文解读： 
</p>

<pre class="brush: scala">
println("""Welcome to Ultamix 3000.
           Type "HELP" for help.""")
</pre>

<p>
输出的内容包括所有的转义字符和空格：
</p>

<pre class="brush: scala">
Welcome to Ultamix 3000.
           Type "HELP" for help.
</pre>

<p>
有些情况下希望在源代码里也能排版提好看一点，所以字符串里提供<code>stripMargin</code>方法可以通过管道符<code>|</code>来取得想要的部分：
</p>

<pre class="brush: scala">
println("""|Welcome to Ultamix 3000.
           |Type "HELP" for help.""".stripMargin)
</pre>

<pre class="brush: scala">
Welcome to Ultamix 3000.
Type "HELP" for help.
</pre>

<h2 id="toc_4.2">符号</h2>

<p>
格式为<code>'symb</code>，这里的<code>symb</code>可以是任何字母或数字。这种字面量被直接映射为类<code>scala.Symbol</code>的实例，解释器调用工厂方法<code>Symbol("symb")</code>产生。
</p>

<p>
符号变量什么事情都做不了，只能显示自己的名字，而且符号变量是被限定（interned）的，如果同一个字面量出现两次，其实指向的是同一个<code>Symble</code>实例：
</p>

<pre class="brush: scala">
scala&gt; val s = 'aSymbol
s: Symbol = 'aSymbol

scala&gt; s.name
res3: String = aSymbol
</pre>

<p>
那符号能用来干嘛？比如说，下面的函数更新记录，<code>field</code>是字段名、<code>value</code>是值：
</p>

<pre class="brush: scala">
scala&gt; def updateRecordByName(field: Symbol, value: Any){ }
updateRecordByName: (field: Symbol, value: Any)Unit

scala&gt; updateRecordByName('pcOK, "OK Computer")
</pre>



<h2 id="toc_4.3">操作符与方法</h2>

<p>
操作符也是普通方法的另一种写法，操作符的重载也就是方法的重载。
</p>

<h3 id="toc_4.3.1">中缀操作符（infix）</h3>

<pre class="brush: scala">
scala&gt; val s = "Hello, world!"
s: java.lang.String = Hello, world!

scala&gt; s indexOf 'o'
res6: Int = 4

scala&gt; s indexOf ('o', 5)
res7: Int = 8
</pre>

<h3 id="toc_4.3.2">前缀操作符</h3>

<p>
前缀操作符以<code>unary_</code>开头，能有四种<code>+</code>、<code>-</code>、<code>!</code>、<code>~</code>：
</p>

<pre class="brush: scala">
scala&gt; - 2.0
res8: Double = -2.0

scala&gt; (2.0).unary_-
res9: Double = -2.0
</pre>

<p>
其他的符号就算定义了也不能作为前置操作符解释，如果定义了<code>p.unary_*</code>，在调用<code>*p</code>会被Scala解释为<code>*.p</code>。
</p>

<h3 id="toc_4.3.3">后缀操作符</h3>

<p>
后缀操作符其实就是没有参数的函数。一般习惯上没有副作用的话就加上括号，如：<code>println()</code>；如果没有副作用就不加括号，如：<code>String.toLowerCase</code>
</p>

<pre class="brush: scala">
scala&gt; "Hello".toLowerCase
res10: java.lang.String = hello

scala&gt; "Hello" toLowerCase
res11: java.lang.String = hello
</pre>


<h2 id="toc_4.4">对象相等性</h2>

<p>
操作符<code>==</code>与<code>!=</code>不仅比较基本类型，也可以比较对象，甚至是不同类的对象也可以比较，也可以和<code>null</code>比不会有异常抛出：
</p>

<pre class="brush: scala">
scala&gt;  1 == 2
res12: Boolean = false

scala&gt; 1 != 2
res13: Boolean = true

scala&gt; List(1, 2, 3) == List(1, 2, 3)
res14: Boolean = true

scala&gt; List(1, 2, 3) == List(4, 5, 6)
res15: Boolean = false

scala&gt; 1 == 1.0
res16: Boolean = true

scala&gt; List(1, 2, 3) == "hello"
res17: Boolean = false

scala&gt; List(1, 2, 3) == null
res18: Boolean = false

scala&gt; null == List(1, 2, 3)
res19: Boolean = false

scala&gt; ("he" + "llo") == "hello"
res20: Boolean = true
</pre>



<h1 id="toc_5">类</h1>

<p>
简单定义类与创建对象：
</p>

<pre class="brush: scala">
scala&gt; class ChecksumAccumulator { }
defined class ChecksumAccumulator

scala&gt; new ChecksumAccumulator
res0: ChecksumAccumulator = ChecksumAccumulator@91f1520

scala&gt; class ChecksumAccumulator {
     | var sum = 0
     | }
defined class ChecksumAccumulator

scala&gt; val acc = new ChecksumAccumulator
acc: ChecksumAccumulator = ChecksumAccumulator@501fdcfb

scala&gt; val csa = new ChecksumAccumulator
csa: ChecksumAccumulator = ChecksumAccumulator@58f285cd
</pre>

<h2 id="toc_5.1">访问控制</h2>

<p>
默认为public。
</p>


<h2 id="toc_5.2">成员方法</h2>

<pre class="brush: scala">
class ChecksumAccumulator {
	private var sum = 0
	
	def add(b: Byte): Unit = {
		sum += b
	}

	def checksum(): Int =  {
		return ~(sum &amp; 0xFF) + 1
	}
}
</pre>

<p>
Scala中参数都是val，不可变。
</p>

<pre class="brush: scala">
	def add(b: Byte): Unit = {
		// b = 1   // error, because b is val
		sum += b
	}
</pre>

<p>
只有一行的方法体可以去掉花括号并放在函数头一行，方法会自动返回最后一行语句，不用加return：
</p>

<pre class="brush: scala">
class ChecksumAccumulator {
	private var sum = 0
	def add(b: Byte): Unit = sum += b
	def checksum(): Int =  ~(sum &amp; 0xFF) + 1
}
</pre>

<p>
没有返回的方法可以省略类型Unit与等号：
</p>

<pre class="brush: scala">
	def add(b: Byte): Unit = sum += b
	// 简化
	def add(b: Byte) { sum += b }
</pre>

<h1 id="toc_6">单例对象</h1>

<p>
Scala中没有像Java那样的静态成员而是用单例对象（Singleton Object）来代替。
</p>

<p>
在定义格式基本上和类一样，除了了object关键字代替class：
</p>

<pre class="brush: scala">
object ObjNam{
	// ...
}
</pre>

<h1 id="toc_7">伴生对象</h1>

<p>
如果一个单例对象的名字和类一样，并且必须在同一个文件里。那它就是这个类的伴生对象（Companion Object），类是它的伴生类（Companion Class）。它们可以相互访问私有成员。
</p>

<pre class="brush: scala" title="ChecksumAccumulator.scala">
import scala.collection.mutable.Map

class ChecksumAccumulator {
	private var sum = 0
	def add(b: Byte) { sum += b }
	def checksum(): Int =  ~(sum &amp; 0xFF) + 1
}

object ChecksumAccumulator {
	private val cache = Map[String, Int]()

	def caculate(s: String): Int = {
		if (cache.contains(s))
			cache(s)
		else {
			val acc = new ChecksumAccumulator
			for (c &lt;- s)
				acc.add(c.toByte)
			val cs = acc.checksum()
			cache += (s -&gt; cs)
			cs
		}
	}
}

</pre>

<p>
直接通过调用方法：
</p>

<pre class="brush: scala">
val res1 = ChecksumAccumulator.caculate("Every value is an object")
println(res1)

val res2 = ChecksumAccumulator.caculate("So simple!")
println(res2)
</pre>

<pre class="brush: scala">
</pre>

<pre class="brush: scala">
</pre>


<pre class="brush: scala">
</pre>

<pre class="brush: scala">
</pre>


<pre class="brush: scala">
</pre>

<pre class="brush: scala">
</pre>


<pre class="brush: scala">
</pre>

<pre class="brush: scala">
</pre>


<pre class="brush: scala">
</pre>

<pre class="brush: scala">
</pre>


<pre class="brush: scala">
</pre>

<pre class="brush: scala">
</pre>


<pre class="brush: scala">
</pre>

<pre class="brush: scala">
</pre>


<pre class="brush: scala">
</pre>

<pre class="brush: scala">
</pre>


<pre class="brush: scala">
</pre>

<pre class="brush: scala">
</pre>

<pre class="brush: scala">
</pre>

<pre class="brush: scala">
</pre>


</body>
</html>
