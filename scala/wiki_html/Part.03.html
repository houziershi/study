<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">

<script type="text/javascript" src="theme/scripts/jquery-1.4.2.min.js"></script>

<link type="text/css" rel="stylesheet" href="hl-code/styles/shCore.css"/>
<link type="text/css" rel="stylesheet" href="hl-code/styles/shCoreRDark.css"/>
<link type="text/css" rel="stylesheet" href="hl-code/styles/shThemeRDark.css"/>
<script type="text/javascript" src="hl-code/scripts/shCore.js"></script>
<script type="text/javascript" src="hl-code/scripts/shAutoloader.js"></script>

<link type="text/css" rel="stylesheet" href="theme/styles/style.css" />

<script type="text/javascript" src="theme/scripts/script.js"></script>


<title>Part III</title>
</head>
<body>



<h1>Part III</h1>
<div class="toc">
<ul>
<li><a href="#toc_1">实现列表</a>
<ul>
<li><a href="#toc_1.1">List类实现原理</a>
<ul>
<li><a href="#toc_1.1.1">Nil对象</a>
<li><a href="#toc_1.1.2">::类</a>
<li><a href="#toc_1.1.3">其他的类方法</a>
</ul>
</ul>
</ul>
</div>

<h1 id="toc_1">实现列表</h1>

<p>
列表不是Scala语言的内建结构，而是定义在<code>Scala</code>包中的<code>List</code>抽象类。它有一个子类<code>::</code>和一个子对象<code>Nil</code>。
</p>

<h2 id="toc_1.1">List类实现原理</h2>

<p>
本节的目的是实现一个简化的List实现：
</p>

<pre class="brush: scala">
  package scala
  abstract class List[+T] { ... }
</pre>

<p>
作为一个抽象类<code>List</code>不能用像<code>new List</code>这样的空构造器构建。
</p>

<p>
再来看类型参数<code>[+T]</code>表明列表是协变的：
</p>

<pre class="brush: scala">
  scala&gt; val xs = List(1, 2, 3)
  xs: List[Int] = List(1, 2, 3)

  scala&gt; var ys: List[Any] = xs
  ys: List[Any] = List(1, 2, 3)
</pre>

<p>
实现的目标要有以下三个功能：
</p>

<pre class="brush: scala">
    def isEmpty: Boolean
    def head: T
    def tail: List[T]
</pre>

<p>
这三个方法在<code>List</code>类中是抽象的，被定义在<code>Nil</code>和<code>::</code>中。
</p>

<h3 id="toc_1.1.1">Nil对象</h3>

<p>
<code>Nil</code>对象继承自<code>List[Nothing]</code>，它定义了空列表。因为协变的作为它可以兼容任何类型的<code>List</code>实例：
</p>

<pre class="brush: scala">
  case object Nil extends List[Nothing] {
    override def isEmpty = true
    def head: Nothing =
      throw new NoSuchElementException("head of empty list")
    def tail: List[Nothing] =
      throw new NoSuchElementException("tail of empty list")
  }
</pre>

<p>
成员方法<code>head</code>的实现方法是抛出异常，因为对于成员类型<code>Nothing</code>来说，返回结果必须是<code>Nothing</code>，而<code>Nothing</code>是个根本不存在的类型，所以它无法正常返回结果，只能抛出异常。
</p>

<h3 id="toc_1.1.2">::类</h3>

<dl>
<dt><code>::</code>类读作“cons”，意思是“构造”，它实现了非空列表。冒号对应中缀模式，会被当作构造器使用：`x </dt>
<dd>xs<code>是对类</code>::<code>的构造器调用</code>::(x, xs)`。</dd>
</dl>

<pre class="brush: scala">
  final case class ::[T](hd: T, tl: List[T]) extends List[T] {
    def head = hd
    def tail = tl
    override def isEmpty: Boolean = false
  }
</pre>

<p>
上面的代码可以简化，直接由参数实现超类<code>List</code>的<code>head</code>和<code>tail</code>方法：
</p>

<pre class="brush: scala">
  final case class ::[T](head: T, tail: List[T])
      extends List[T] {

    override def isEmpty: Boolean = false
  }
</pre>

<h3 id="toc_1.1.3">其他的类方法</h3>

<pre class="brush: scala">
  def length: Int = 
    if (isEmpty) 0 else 1 + tail.length

  def drop(n: Int): List[T] = 
    if (isEmpty) Nil
    else if (n &lt;= 0) this
    else tail.drop(n - 1)

  def map[U](f: T =&gt; U): List[U] =
    if (isEmpty) Nil
    else f(head) :: tail.map(f)
</pre>


</body>
</html>
