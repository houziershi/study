<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">

<script type="text/javascript" src="theme/scripts/jquery-1.4.2.min.js"></script>

<link type="text/css" rel="stylesheet" href="hl-code/styles/shCore.css"/>
<link type="text/css" rel="stylesheet" href="hl-code/styles/shCoreRDark.css"/>
<link type="text/css" rel="stylesheet" href="hl-code/styles/shThemeRDark.css"/>
<script type="text/javascript" src="hl-code/scripts/shCore.js"></script>
<script type="text/javascript" src="hl-code/scripts/shAutoloader.js"></script>

<link type="text/css" rel="stylesheet" href="theme/styles/style.css" />

<script type="text/javascript" src="theme/scripts/script.js"></script>


<title>Part.04</title>
</head>
<body>


<h1 id="toc_1">抽象成员</h1>

<p>
Scala中不仅可以指定方法为抽象，还可以声明字段甚至抽象类型为类和特质的成员。
</p>

<h2 id="toc_1.1">抽象成员的快速浏览</h2>

<p>
在特质中分别对类型（T）、方法（transform）、val（initial）、var（current）的抽象声明：
</p>

<pre class="brush: scala">
  trait Abstract {
    type T
    def transform(x: T): T
    val initial: T
    var current: T
  }
</pre>

<p>
实现：
</p>

<pre class="brush: scala">
  class Concrete extends Abstract {
    type T = String
    def transform(x: String) = x + x
    val initial = "hi"
    var current = initial
  }
</pre>

<h2 id="toc_1.2">类型成员</h2>

<p>
（略）
</p>

<h2 id="toc_1.3">抽象val</h2>

<p>
val是不可变的，抽象的val指定了类型与变量名，不指定值：
</p>

<pre class="brush: scala">
  val initial: String
</pre>

<p>
实现时指定值：
</p>

<pre class="brush: scala">
  val initial = "hi"
</pre>

<p>
如果不知道类中定义的确切内容，但是确定对于每个实例来说值都是不可变的。在这样的情况下可以使用抽象的val声明，格式类似于无参数方法声明：
</p>

<pre class="brush: scala">
  def initial: String
</pre>

<p>
客户代码将使用统一的<code>obj.initial</code>方法引用val及方法。如果<code>initial</code>是抽象val，那么客户就可以保证每次引用都将得到同样的值。如果<code>initial</code>是抽象方法那就无法保证，因为在不同的实现中<code>initial</code>可以被实现为每次调用都返回不同的值。
</p>

<p>
换名话说抽象的val限制了合法实现的方式：任何实现都必须是<code>val</code>类型的定义不可以是<code>var</code>。另一方面，抽象方法声明可以被实现为具体的方法定义或具体的<code>val</code>定义。
</p>

<p>
所以在下面的代码中，<code>Apple</code>是合法的子类面<code>BadApple</code>不是：
</p>

<pre class="brush: scala">
  abstract class Fruit {
    val v: String // `v' for value
    def m: String // `m' for method
  }

  abstract class Apple extends Fruit {
    val v: String
    val m: String // OK to override a `def' with a `val'
  }

  abstract class BadApple extends Fruit {
    def v: String // ERROR: cannot override a `val' with a `def'
    def m: String
  }
</pre>

<h2 id="toc_1.4">抽象var</h2>

<p>
在特质里使用，只声明类型与名称，没有初始值：
</p>

<pre class="brush: scala">
  trait AbstractTime {
    var hour: Int
    var minute: Int
  }
</pre>

<p>
也会有自动扩展的<code>getter</code>与<code>setter</code>方法，相当于：
</p>

<pre class="brush: scala">
  trait AbstractTime {
    def hour: Int          // getter for `hour'
    def hour_=(x: Int)     // setter for `hour'
    def minute: Int        // getter for `minute'
    def minute_=(x: Int)   // setter for `minute'
  }
</pre>

<h2 id="toc_1.5">初始化抽象val</h2>

<p>
结合特质来使用，抽象val可以让子类扩展提供父类没有的参数与细节。因为特质缺省能用来传递参数的构造器。
</p>

<p>
拿前面的实数类来作例子，以下特质：
</p>

<pre class="brush: scala">
  trait RationalTrait { 
    val numerArg: Int 
    val denomArg: Int 
  } 
</pre>

<p>
为了实例化这个特质，先要实现val。在这里我们要用到新的<code>new</code>语法结构：
</p>

<pre class="brush: scala">
  new RationalTrait {
    val numerArg = 1
    val denomArg = 2
  }
</pre>

<p>
上面的代码会产混入了物质的匿名类实例，类似于<code>new Rational(1, 2)</code>。当然区别还是有的：
</p>

<pre class="brush: scala">
  new Rational(expr1, expr2)
</pre>

<p>
上面的两个表达式会在类初始化前计算，而相反的：
</p>

<pre class="brush: scala">
  new RationalTrait {
    val numerArg = expr1
    val denomArg = expr2
  }
</pre>

<p>
上面的两个表达式会作为匿名类初始化的一部分计算。而匿名类初始化在<code>RationalTrait</code>之后执行，所以<code>numerArg</code>和<code>denomArg</code>的值在<code>RationalTrait</code>初始化期间还没有准备好，都是<code>Int</code>类型的默认值<code>0</code>。
</p>

<p>
所以对下面的代码来说，这会成为一个问题，因为其中定义了经过约分后的分子与分母：
</p>

<pre class="brush: scala">
  trait RationalTrait { 
    val numerArg: Int 
    val denomArg: Int 
    require(denomArg != 0)
    private val g = gcd(numerArg, denomArg)
    val numer = numerArg / g
    val denom = denomArg / g
    private def gcd(a: Int, b: Int): Int = 
      if (b == 0) a else gcd(b, a % b)
    override def toString = numer +"/"+ denom
  }
</pre>

<p>
如果尝试使用某种分子和分母的表达式面不是简单的字面量实例化这个特质，会引起以下错误：
</p>

<pre class="brush: scala">
  scala&gt; val x = 2
  x: Int = 2

  scala&gt; new RationalTrait {
       |   val numerArg = 1 * x
       |   val denomArg = 2 * x
       | }
  java.lang.IllegalArgumentException: requirement failed
          at scala.Predef$.require(Predef.scala:107)
          at RationalTrait$class.$init$(&lt;console&gt;:7)
          at $anon$1.&lt;init&gt;(&lt;console&gt;:7)
          ....
</pre>

<p>
解决方案有两个，分别是预初始化字段和懒加载val。
</p>

<h3 id="toc_1.5.1">fields预初始化字段</h3>

<p>
给字段定义加上花括号，放在超类的构造器之前：
</p>

<pre class="brush: scala">
  scala&gt; new { 
       |   val numerArg = 1 * x
       |   val denomArg = 2 * x 
       | } with RationalTrait
  res15: java.lang.Object with RationalTrait = 1/2
</pre>

<p>
不仅匿名类，对象或是有名称的类也可以用。预初始化段落在下面每个定义的<code>extends</code>关键字之后：
</p>

<pre class="brush: scala">
  object twoThirds extends {
    val numerArg = 2
    val denomArg = 3
  } with RationalTrait
</pre>


<pre class="brush: scala">
</pre>

<pre class="brush: scala">
</pre>

<pre class="brush: scala">
</pre>

<pre class="brush: scala">
</pre>

<pre class="brush: scala">
</pre>

<pre class="brush: scala">
</pre>

<pre class="brush: scala">
</pre>

<pre class="brush: scala">
</pre>

<pre class="brush: scala">
</pre>

<pre class="brush: scala">
</pre>

<pre class="brush: scala">
</pre>

<pre class="brush: scala">
</pre>

<pre class="brush: scala">
</pre>

<pre class="brush: scala">
</pre>

<pre class="brush: scala">
</pre>

<pre class="brush: scala">
</pre>

<pre class="brush: scala">
</pre>

<pre class="brush: scala">
</pre>

<pre class="brush: scala">
</pre>

<pre class="brush: scala">
</pre>

<pre class="brush: scala">
</pre>

<pre class="brush: scala">
</pre>

<pre class="brush: scala">
</pre>

<pre class="brush: scala">
</pre>

<pre class="brush: scala">
</pre>

<pre class="brush: scala">
</pre>

<pre class="brush: scala">
</pre>

<pre class="brush: scala">
</pre>

<pre class="brush: scala">
</pre>

<pre class="brush: scala">
</pre>

<pre class="brush: scala">
</pre>

<pre class="brush: scala">
</pre>

<pre class="brush: scala">
</pre>

<pre class="brush: scala">
</pre>

<pre class="brush: scala">
</pre>

<pre class="brush: scala">
</pre>

<pre class="brush: scala">
</pre>

<pre class="brush: scala">
</pre>

<pre class="brush: scala">
</pre>

<pre class="brush: scala">
</pre>

<pre class="brush: scala">
</pre>

<pre class="brush: scala">
</pre>

<pre class="brush: scala">
</pre>

<pre class="brush: scala">
</pre>

<pre class="brush: scala">
</pre>

<pre class="brush: scala">
</pre>

<pre class="brush: scala">
</pre>

<pre class="brush: scala">
</pre>

<pre class="brush: scala">
</pre>

<pre class="brush: scala">
</pre>

<pre class="brush: scala">
</pre>

<pre class="brush: scala">
</pre>

<pre class="brush: scala">
</pre>

<pre class="brush: scala">
</pre>


</body>
</html>
