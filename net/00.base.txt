
IP地址与MAC地址

我们的主机上网路卡可以透过 ifconfig来查询到MAC，如第一个以太网为一般叫作eth0：

$ ifconfig eth0

eth0      Link encap:Ethernet  HWaddr 00:25:b3:69:16:59  
          inet addr:192.168.1.104  Bcast:192.168.1.255  Mask:255.255.255.0
          inet6 addr: fe80::225:b3ff:fe69:1659/64 Scope:Link
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:87822 errors:0 dropped:0 overruns:0 frame:0
          TX packets:65169 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000 
          RX bytes:95827160 （95.8 MB）  TX bytes:9333772 （9.3 MB）
          Interrupt:17 

但数据在网卡之间的传输要通过ARP （Address Resolution Protocol）解析IP与MAC的对照关系得到网卡的MAC。当我们的主机想要找出目标IP时，就会对整个区域网路进行广播封包（broadcast）的传送， 这个广播封包可以对所有区域网路内的电脑要求回报他的IP与MAC， 当目标IP看到这个广播封包时，就会回应您主机相关的 MAC 资讯，如果非目标主机接到这个封包， 就会主动的忽略。这样就可以取得标主机的MAC，而这个目
标主机的MAC就会被记录到你的主机内存中的ARP table（不过还是要再次的提醒，MAC是不能跨路由的）。

如果想要查看ARP记录，可以通过arp命令：

参数-n 加主机名可以将主机名称以 IP 的型态显示：

[root@linux ~]# arp -n
Address       HWtype HWaddress         Flags Mask Iface
192.168.1.100 ether  00:01:03:01:02:03 C          eth0
192.168.1.240 ether  00:01:03:01:DE:0A C          eth0
192.168.1.254 ether  00:01:03:55:74:AB C          eth0

从上面的结果中可以看到由于有记录MAC与IP的对应，因此当下回资料又传送到同一部主机时会主动的传送到同一个MAC去，而不需要再次透过broadcast来查询MAC，所以省去了很多网路延迟的时间。ARP table是动态的资讯，会随时随着网域里面电脑的IP更动而变化，所以，即使常常更动的电脑IP，ARP table也会自动的重新。

如果有特殊需求也可以利用参数“-s hostname（IP） Hardware_address”来定义静态的 ARP 对应:

[root@linux ~]# arp -s 192.168.1.100 01:00:2D:23:A1:0E

还可以通过参数 -d 将 hostname 的 hardware_address 由 ARP table 当中删除掉。


IP地址格式

IP地址一共有32位二进制：

00000000.00000000.00000000.00000000 ==> 0.0.0.0
11111111.11111111.11111111.11111111 ==> 255.255.255.255

这32位被分为两部分：“网络号”与“主机号”。如果多个IP地址拥有相同的网格号与各自不同的主机号，那么这些机器就是处于同一个“物理网段”内。如下面这个典型的C类网段，前24位是网络号，后8位是主机号：

|----------Net_ID---------|--host-|
11000000.10101000.00000000.00000000 ==> 192.168.0.0 
11000000.10101000.00000000.11111111 ==> 192.168.0.255


在同一个网段内，Net_ID 是不变的，Host_ID则是不可重复。而此外， Host_ID在二进位的表示法当中，不可同时为0也不可同时为1，例如上面的例子当中，192.168.0.0 （Host_ID全部为0）以及 192.168.0.255（Host_ID全部为1）不可用来作为网段内主机的IP。

在同一个物理网段之内，如果两部主机设定成不同的IP网段，则两部主机无法直接以MAC讯框格式进行资料的传递，因为广播封包无法查询到MAC 与IP的对应。

IP的分级
目前 Internet将IP简单的分类成为A， B， C三种常见的等级:
以二进位说明 Network 第一个数字的定义:

A Class : 0xxxxxxx.xxxxxxxx.xxxxxxxx.xxxxxxxx ==> NetI_D 的开头是 0
          |--net--|---------host------------|  0.xx.xx.xx ~ 126.xx.xx.xx
B Class : 10xxxxxx.xxxxxxxx.xxxxxxxx.xxxxxxxx ==> NetI_D 的开头是 10
          |------net-------|------host------| 128.xx.xx.xx ~ 191.xx.xx.xx
C Class : 110xxxxx.xxxxxxxx.xxxxxxxx.xxxxxxxx ==> NetI_D 的开头是 110
          |-----------net-----------|-host--| 192.xx.xx.xx ~ 223.xx.xx.xx

A类网中还有一个127.xxx.xxx.xxx被操作系统占用作为圆环调用（lookback）。

子网掩码：把网络号全1，把主机号全0。

IP地址中主机地址全0表示是这个网络的网络号；主机号全1表示是广播地址（Broadcast）。

           |----------Net_ID---------|--host-|
  Net Mask: 11111111.11111111.11111111.00000000 ==> 255.255.255.0
    Net ID: 11000000.10101000.00000000.00000000 ==> 192.168.0.0
First Addr: 11000000.10101000.00000000.00000001 ==> 192.168.0.1
 Last Addr: 11000000.10101000.00000000.11111110 ==> 192.168.0.254
 Broadcast: 11000000.10101000.00000000.11111111 ==> 192.168.0.255

表示网络号与掩码直接表示某网络前24位都是掩码：192.168.0.0/24



拆分子网：

再拿出主机号中的n位来表示网络，这样就成了2的n次方个子网：

例如原本的C网：

           |----------Net_ID---------|--host-|
  Net Mask: 11111111.11111111.11111111.00000000 ==> 255.255.255.0
    Net ID: 11000000.10101000.00000000.00000000 ==> 192.168.0.0
First Addr: 11000000.10101000.00000000.00000001 ==> 192.168.0.1
 Last Addr: 11000000.10101000.00000000.11111110 ==> 192.168.0.254
 Broadcast: 11000000.10101000.00000000.11111111 ==> 192.168.0.255

切成两个子网路之后的Net_ID与Host_ID为

           |----------Net_ID-----------|--host-|
  Net Mask: 11111111.11111111.11111111.10000000 ==> 255.255.255.128
  Net ID 1: 11000000.10101000.00000000.00000000 ==> 192.168.0.0
Broadcast1: 11000000.10101000.00000000.01111111 ==> 192.168.0.127
  Net ID 2: 11000000.10101000.00000000.10000000 ==> 192.168.0.128
Broadcast2: 11000000.10101000.00000000.11111111 ==> 192.168.0.255

第一个子网络为：
192.168.0.0/25 或 192.168.0.0/255.255.255.128 

第二个子网路为：
192.168.0.128/25 或 192.168.0.128/255.255.255.128



IP地址的类型

在IPv4里面就只有两种IP的类别，分别是：
Public IP：公共IP，经由INTERNIC所统一规划的IP，只有这种IP才可以连上Internet；
Private IP：有IP或保留IP，不能直接连上Internet的IP，主要用于区域网路内的主机连线规划。

早在 IPv4 规划的时候就担心 IP 会有不足的情况，而且为了应付某些私有网路的网路设定，于是就有了私有 IP （ Private IP ） 的产生了。 私有IP也分别在A，B，C三个Class当中各保留一段作为私有IP网段，那就是：

A Class:10.0.0.0 - 10.255.255.255
B Class:172.16.0.0 - 172.31.255.255
C Class:192.168.0.0 - 192.168.255.255

由于这三个Class的IP是预留使用的，所以并不能直接作为Internet上面的连接之用有底下的几个限制:
私有位址的路由资讯不能对外散播；
使用私有位址作为来源或目的地址的封包，不能透过Internet来转送：
关于私有位址的参考纪录（如 DNS），只能限于内部网路使用；

如果要将这些私有IP送上Internet可以设定一个简单的防火墙加上NAT（Network Address Transfer）主机设定，你就可以透过IP伪装来使你的私有 IP 的电脑也可以连上 Internet。

回环地址（lo）被放在127.0.0.0/8这个A Class，而且预设的主机（localhost）的IP是127.0.0.1。不用装网卡都可以访问到。



路由

当目标机器与自己是同一网络中，可以通过查自己的ARP记录直接利用MAC通讯。不在同一网段（网络号不同）不能直接通讯，要通过路由。

首先发送机会查看自己的路由表，如果没有相关的设置就往默认网关（default gateway）上发。默认网关一般都是路由器，它根据收到包的IP来判断把包发到对应网络的目标机。

每个机器都有路由表，可以通过route命令查看。参数-n表示以ip地址形式查看：

# route
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
default         192.168.1.1     0.0.0.0         UG    0      0        0 wlan0
link-local      *               255.255.0.0     U     1000   0        0 wlan0
192.168.1.0     *               255.255.255.0   U     2      0        0 wlan0


# route -n
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
0.0.0.0         192.168.1.1     0.0.0.0         UG    0      0        0 wlan0
169.254.0.0     0.0.0.0         255.255.0.0     U     1000   0        0 wlan0
192.168.1.0     0.0.0.0         255.255.255.0   U     2      0        0 wlan0

上面输出的资料共有八个栏位,您需要注意的有几个地方：
Destination其实就是 Network 的意思
Gateway就是该介面的 Gateway 那个 IP 啦!若为 0.0.0.0 表示不需要额外的 IP
Genmask就是Netmask。与 Destination 组合成为一部主或网域
Flags共有多个旗标可以来表示该网域或主机代表的意义：
     U代表该路由可用
     G代表该网域需要经由Gateway 来帮忙转递
     H代表该行路由为一部主机,而非一整个网域
     Iface就是Interface的意思




TCP协议

三次握手建立连线

在封包连接模式当中，在建立连线之前都必须要通过三个确认的动作，所以这种连线方式也就被称为三向交握（Three-way handshake）。们将整个流程分成ABCD四个阶段来说明一下:

A：封包发起（SYN=1,Seq=10001）。

当用户端想要对伺服器端连线时，就必须要送出一个要求连线的封包，此时用户端必须随机取用一个大于1024以上的端口。然后在TCP的表头当中，必须要带有SYN的主动连线（SYN=1）,并且记下发送出连线封包给伺服器端的序号（Sequence number = 10001）。

B：认封包传送（ACK=1,ack=10002;SYN=1,seq=20001）。

当伺服器接到这个封包，并且确定要接收这个封包后，就会开始制作一个同时带有SYN=1，ACK=1的封包。其中那个acknowledge的号码是要给client端确认用的，所以该数字会比（A步骤）里面的Sequence号码多一号（ack = 10001+1 = 10002）。

伺服器也必须要确认用户端确实可以接收我们的封包才行，所以也会发送出一个Sequence(seq=20001) 给用户端,并且开始等待用户端回应。

C：回送确认封包（ACK=1,ack=20002）

当用户端收到来自伺服器端的ACK数字(10002)后就能够确认之前那个要求封包被正确的收受了，接下来如果用户端也同意与伺服器端建立连线时,就会再次的发送一个确认封包 (ACK=1) 给伺服器,亦即是 acknowledge = 20001+1 = 20002。

D：取得最后确认
若一切都顺利。在伺服器端收到带有ACK=1且ack=20002序号的封包后,就能够建立起这次的连线了。

在建立了连线之后该次连线通道就可以在用户端与伺服器端建立起一对socket pair，然后通过该socket pair进行TCP封包的PSH、FIN等传输与连线中断等动作。


UDP协议

UDP协议中不用进行三次握手验证所以速度快，但可靠性也低。



ICMP协议

ICMP的全称是Internet Control Message Protocol，网际网路讯息控制协定。基本上ICMP是一个错误侦测与回报的机制，最大的功能就是可以确保我们网路的连线状态与连线的正确性。最简单的指令就是ping与traceroute。这两个指令可以透过ICMP封包的辅助来确认与回报网路主机的状态。
