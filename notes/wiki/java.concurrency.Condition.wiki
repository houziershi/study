

= 条件队列的缺陷 =

例子：现在有一个队列被多个线程访问。

出队方法检查如果没有元素就等待其他线程放入元素以后再唤醒它。成功放入元素以后，
它也会唤醒一下其他线程，因为可能有别的取出线程看到队列空了以后等待有元素的：

{{{class="brush: java"
public void put(Object obj) {
	while(this.isFull())
		wait();

	doPut(obj);
	notifyAll();
}
}}}

以上设计有些问题：

* 被唤醒的原因不一定是因为队列不满了。
* 就算是因为队列空了，也有可能在异步过程中其他线程又放满了。

对于以上的忙等待模式，可以改进为下面的套路：用一个对象作为锁来同步防止又被改掉
了：

{{{class="brush: java"
void func() throws InterruptException {
	synchronized (lock) {
		while(!isReady)
			lock.wait();

		// do something
	}
}
}}}

这样解决了出错问题，但还有性能问题：`notify()`选一个唤醒，而`notifyAll()`会唤醒
多个线程。很多被唤醒的线程不是真的满足了条件，它们会又一次竞争锁。然后只有一个
得到锁其他的又进入等待。这样很浪费。


= Condition =

`Condition`提供了更加细致的条件，比条件队列要好。接口的主要方法：

{{{class="brush: java"
public interface Condition {
	void await() throws InterruptedException;
	boolean await(long time, TimeUnit unit) throws InterruptedException;
	long awaitNanos(long nanosTimeout) throws InterruptedException;
	void awaitUninterruptibly();
	boolean awaitUntil(Date deadline) throws InterruptedException;
	void signal();
	void signalAll();
}
}}}

`Condition`通过外部锁创建：

{{{class="brush: java"
@ThreadSafe
public class ConditionBoundedBuffer<T> {

	protected final Lock lock = new ReentrantLock();
	
	// CONDITION PREDICATE: notFull (count < items.length)
	private final Condition notFull = lock.newCondition();
	// CONDITION PREDICATE: notEmpty (count > 0)
	private final Condition notEmpty = lock.newCondition();
	
	@GuardedBy("lock")
	private final T[] items = (T[]) new Object[BUFFER_SIZE];
	@GuardedBy("lock")
	private int tail, head, count;

	// BLOCKS-UNTIL: notFull
	public void put(T x) throws InterruptedException {
		lock.lock();
		try {
			while (count == items.length)
				notFull.await();
			items[tail] = x;
			if (++tail == items.length)
				tail = 0;
			++count;
			notEmpty.signal();
		} finally {
			lock.unlock();
		}
	}

	// BLOCKS-UNTIL: notEmpty
	public T take() throws InterruptedException {
		lock.lock();
		try {
			while (count == 0)
				notEmpty.await();
			T x = items[head];
			items[head] = null;
			if (++head == items.length)
				head = 0;
			--count;
			notFull.signal();
			return x;
		} finally {
			lock.unlock();
		}
	}

}
}}}


{{{class="brush: java"
}}}
