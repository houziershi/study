%title Part VI

%toc Part VI

= 泛型与类型转换高级应用 =

== 多重界定 ==

=== 多重泛型界定 ===

泛型变量可以同时有上界与下界：

{{{class="brush: scala"
T >: Lower <: Upper
}}}

虽然同时有多个上界或下界是不可以的，但可以要求一个类型实现多个特质：

{{{class="brush: scala"
T <: Comparable[T] with Serializable with Coneable
}}}

=== 多重视图界定 ===

{{{class="brush: scala"
T <% Comparable[T] <% String
}}}

=== 多重上下文界定 ===

{{{class="brush: scala"
T : Ordering : Manifest
}}}

== 类型约束 ==

可用的约束有三种：

* `T =:= U`：`T`是否等于`U`。
* `T <:< U`：`T`是`U`的子类型。
* `T <%< U`：`T`是否能被隐式转换为`U`。

=== 定义只在特定条件下使用的方法 ===

类型约束让程序员定义只有在特定条件下使用的方法。例：

{{{class="brush: scala"
scala> class Pair[T](val first: T, val second: T) {
     |   def smaller(implicit ev: T <:< Ordered[T]) =
     |     if (first < second) first else second
     | }
defined class Pair
}}}


可以虽然`File`没有混入`Ordered[T]`，但因为`smaller`声明了隐式参数，所以还是可以
构造出`Pair[File]`：

{{{class="brush: scala"
scala> import java.io.File
import java.io.File

scala> val p = new Pair(new File("."), new File(".."))
p: Pair[java.io.File] = Pair@be1fcc
}}}

但是如果调用`smaller()`方法，那就出错了：

{{{class="brush: scala"
scala> p.smaller // Error
<console>:11: error: Cannot prove that java.io.File <:< Ordered[java.io.File].
              p.smaller // Error
                ^
}}}

另一个例子：

`Option`有一个`orNull`方法：

{{{class="brush: scala"
scala> val friends = Map("Fred" -> "Barney")
friends: scala.collection.immutable.Map[String,String] = Map(Fred -> Barney)

scala> val friendOpt = friends.get("Wilma") // An Option[String]
friendOpt: Option[String] = None

scala> val friendOrNull = friendOpt.orNull // A String or null
friendOrNull: String = null
}}}

Java类对象如果为`null`表示没有值，但基本类型没有办法用`null`表示。

因为`orNull`的实现带有约束`Null <:< A`，所以可能实例化`Option[Int]`，只要别对
这些实例使用`orNull`就可以了：

{{{class="brush: scala"
scala> val scores = Map("Fred" -> 42)
scores: scala.collection.immutable.Map[String,Int] = Map(Fred -> 42)

scala> val scoreOpt = scores.get("Fred") // An Option[Int]
scoreOpt: Option[Int] = Some(42)

scala> val scoreOrNull = scoreOpt.orNull // Error
<console>:9: error: Cannot prove that Null <:< Int.
       val scoreOrNull = scoreOpt.orNull // Error
}}}


=== 改进类型推断 ===


`<:<`能增加类型推断，比如对于参数的下界声明：

{{{class="brush: scala"
scala> def firstLast[A, C <: Iterable[A]](it: C) = (it.head, it.last)
firstLast: [A, C <: Iterable[A]](it: C)(A, A)
}}}

调用时不能直接传入整数列表，因为实参类型`[Nothing, List[Int]]`不符合形参类型
`[A, C <: Iterable[A]]`：

{{{class="brush: scala"
scala> firstLast(List(1, 2, 3)) // Error
<console>:9: error: inferred type arguments [Nothing,List[Int]] do not conform 
							to method firstLast's type parameter bounds [A,C <: Iterable[A]]
              firstLast(List(1, 2, 3)) // Error
              ^
<console>:9: error: type mismatch;
 found   : List[Int]
 required: C
              firstLast(List(1, 2, 3)) // Error
}}}

因为要在同一步中匹配类型`A`与类型`C`，仅根据`List(1,2,3)`无法判断出`A`的类型。
解决方案可以通过柯里化的方式先匹配`C`再匹配`A`：

{{{class="brush: scala"
scala> def firstLast[A, C](it: C)(implicit ev: C <:< Iterable[A]) =
     |   (it.head, it.last)
firstLast: [A, C](it: C)(implicit ev: <:<[C,Iterable[A]])(A, A)

scala> firstLast(List(1, 2, 3)) // OK
res3: (Int, Int) = (1,3)
}}}

再看一个类似的例子，`corresponds`方法检查两个序列的成员是否一一对应：

{{{class="brush: scala"
scala> val a = Array("Hello", "Fred")
a: Array[String] = Array(Hello, Fred)

scala> val b = Array(5, 4)
b: Array[Int] = Array(5, 4)

scala> a.corresponds(b)(_.length == _)
res7: Boolean = true
}}}

`corresponds`方法的声明其实是这样：

{{{class="brush: scala"
def corresponds[B](that: Seq[B])(p: (A, B) => Boolean): Boolean
}}}

对于柯里化后的两个参数列表，要推断类型`B`：

{{{class="brush: scala"
scala> a.corresponds(b)(_.length == _)
}}}

就相当于是：

{{{class="brush: scala"
Array("Hello", "Fred").corresponds(Array(5, 4))(_.length == _)
}}}

* `Array[A]`对应前实例`Array("Hello","Fred")`，那类型`A`就是`String`。
* 形参`Seq[B]`得到的实参是`Array(5, 4)`，那类型`B`就是`Int`。
* 确认了`A`与`B`，那`(A, B) => Boolean`就是`(String, Int) => Boolean`。


=== 类型证明 ===

如果`firstLast()`方法要返回一个对象的头和尾，最直接的逻辑是：

{{{class="brush: scala"
def firstLast[C](it: C) = (it.head, it.last)
}}}

但这样是错误的，因为不知道`it`的类型`C`是什么类型，很有可能它没有`head`与`last`
方法。

如果用`T`表示有`head`与`last`方法的类型（比如`Iterable`特质）。需要确保`C`类型
必须继承或是可以隐式转换为`T`：

{{{class="brush: scala"
def firstLast[A, C](it: C)(implicit ev: C <:< Iterable[A]) = (it.head, it.last)
}}}

`en`就是类型证明对象，它的类型是`C <:< Iterable[A]`，保证`C`是`Iterable[A]`的
类型（或是子类）或可以转换为`Iterable[A]`。这里不知道`Iterable`成员的类型是啥，
就用`Iterable[A]`来表示。

但`=:=`、`<:<`、`<%<`其实是库中的类而不是语法特性，而且是带有隐式值的类。比如在
`Predef`对象中`<:<`的定义：

{{{class="brush: scala"
abstract class <:<[-From, +To] extends Function1[From,To]

object <:< {
	implicit def conforms[A] = new (A <:< A) { def apply(x: A) = x }
}
}}}

类型`<:<[-From, +To]`继承自函数，参数`-From`逆变而返回值`+To`协变。这个函数的
功能可以理解为把`From`类型从转为`To`类型对象。

伴生对象中的方法`conforms[A]`是一个隐式的对象。提供了一个把类型`From`转为类型`To`
的默认实现：在这里，它假设`To`类型就是`From`类型或是它的子类。它直接用`apply()`
方法返回一个`<:<[A,A]`的实例，因为同一个类型即是自己的超类又是自己的子类，所以
返回的`<:<[A,A]`符合`<:<[-From, +To]`。

现在回到之前取列表头尾的函数，我们用整数列表为参数：

{{{class="brush: scala"
scala> def firstLast[A, C](it: C)(implicit ev: C <:< Iterable[A]) =
     |   (it.head, it.last)
firstLast: [A, C](it: C)(implicit ev: <:<[C,Iterable[A]])(A, A)

scala> firstLast(List(1, 7, 2, 9))
res0: (Int, Int) = (1,9)
}}}

在这里编译器要验证的是`implicit ev: List[Int] <:< Iterable[Int]`，会先查看在
伴生对象中是否有可以应用到`List[Int] <:< Iterable[Int]`的隐式对象。当找到：

{{{class="brush: scala"
implicit def conforms[A] = new (A <:< A) { def apply(x: A) = x }
}}}

用`List`代入类型`A`：

{{{class="brush: scala"
def conforms[List] = new (List <:< List) { def apply(x: List) = x }
}}}

的返回类型`List <:< List`可以匹配到`List <:< Iterable`。因为`<:<[-From, +To]`中
参数`-From`逆变而返回值`+To`协变。


=== 检查泛型隐式对象是否存在 ===

在REPL环境中可以用`implicitly`函数检查泛型隐式对象是否存在：

{{{class="brush: scala"
scala> implicitly[String <:< AnyRef]
res1: <:<[String,AnyRef] = <function1>

scala> implicitly[AnyRef <:< String]
<console>:8: error: Cannot prove that AnyRef <:< String.
              implicitly[AnyRef <:< String]
                        ^
}}}

存在会返回函数，不存在就返回错误：

{{{class="brush: scala"
scala> implicitly[List[Int] <:< Iterable[Int]]
res4: <:<[List[Int],Iterable[Int]] = <function1>

scala> implicitly[List <:< Iterable]
<console>:8: error: type List takes type parameters
              implicitly[List <:< Iterable]
                         ^
<console>:8: error: type Iterable takes type parameters
              implicitly[List <:< Iterable]
                                  ^
}}}

== implicitNotFount注解 ==

作为是为了让报错时的信息更加有可读性：

{{{class="brush: scala"
@implicitNotFound(msg = "I am baffled why you give me ${From} when I want ${To}.")
abstract class <:<[-From, +To] extends Function1[From, To]

object <:< {
  implicit def conforms[A] = new (A <:< A) { def apply(x: A) = x }
}

def firstLast[A, C](it: C)(implicit ev: C <:< Iterable[A]) =
  (it.head, it.last)
}}}

这样当出错时：

{{{class="brush: scala"
scala> firstLast("Fred")
<console>:23: error: I am baffled why you give me String when I want Iterable[A].
              firstLast("Fred")
                       ^
}}}

== CanBuildFrom解读 ==

=== 定义 ===

模拟`Iterable`特质中的`map`方法。先定义`Iterator`特质：

{{{class="brush: scala"
trait Iterator[E] {
  def next(): E
  def hasNext: Boolean
}
}}}

集合的构造器是`Builder`，把`E`类型的元素添加到缓存中去。返回的结果是一个集合，
类型用`To`表示：

{{{class="brush: scala"
trait Builder[-E, +To] {
  def +=(e: E): Unit
  def result(): To
}
}}}

`CanBuildFrom[From, E, To]`特质提供类型证明。它的`apply()`方法把`From`类型的实例
转为`Builder`：

{{{class="brush: scala"
trait CanBuildFrom[-From, -E, +To] {
  def apply(): Builder[E, To]
}
}}}

这样就实现的`From`与`To`的类型兼容。

然后是`Iterable`特质，有`iterator()`方法返回`Iterator`类型的迭代器，`map()`方法
执行映射操作：

{{{class="brush: scala"
trait Iterable[A, Repr] {
  def iterator(): Iterator[A]

  def map[B, That](f : (A) => B)
    (implicit bf: CanBuildFrom[Repr, B, That]): That = 
  {
    val builder = bf()
    val iter = iterator()
    while (iter.hasNext) builder += f(iter.next())
    builder.result
  }
}
}}}

`map()`方法的和第一个参数列表是映射的方法`F`，很好理解。

第二个参数列表中的类型参数`Repr`是展现类型，它可以选择合适的构造器工厂来创建如
`range`可`String`之类的非常规集合。

在Scala类库中的`Iterable`的`map()`方法是被定义在`TraversableLike[A, Repr]`特质
中的。这样更加常用的`Iterable`就不用再带上`Repr`这个类型参数了。

=== 归纳 ===

* `map()`方法的主要任务是创造一个目标类型`That`的构造器`Builder`。
* 迭代源集合，把每个元素传递给映射方法`f`，把`f`的返回值放到`Builder`。
* `builder.result()`方法返回目标类型的集合。

=== 使用 ===

每个集合实现都在伴生对象中提供一个隐式的`CanBuildFrom`对象。比如下面的
简单版的`ArrayBuffer`实现，注意数组类型要有上下文界定`[E : Manifest]`：

{{{class="brush: scala; highlight: [9,15,32]"
class Buffer[E : Manifest] extends Iterable[E, Buffer[E]] 
    with Builder[E, Buffer[E]] {

  private var capacity = 10
  private var length = 0

  private var elems = new Array[E](capacity) 

  def iterator() = new Iterator[E] {
    private var i = 0
    def hasNext = i < length
    def next() = { i += 1; elems(i - 1) }
  }

  def +=(e: E) {
    if (length == capacity) {
      capacity = 2 * capacity
      val nelems = new Array[E](capacity) 
      for (i <- 0 until length) nelems(i) = elems(i)
      elems = nelems
    }
    elems(length) = e
    length += 1
  }

  def result() = this

}

object Buffer {

  implicit def canBuildFrom[E : Manifest] = 
		new CanBuildFrom[Buffer[_], E, Buffer[E]] {
    def apply() = new Buffer[E]
  }

}
}}}

`Iterator()`方法返回迭代器；`+=()`方法实现添加元素；`canBuildFrom()`方法把源类型
`Buffer[_]`集合转为成员类型为`E`的构造器`Buffer[Manifest]`。


{{{class="brush: scala"
scala>   val names = new Buffer[String]
names: Buffer[String] = Buffer@114069b

scala>   names += "Fred"

scala>   names += "Linda"

scala>   val lengths = names.map(_.length)
lengths: Buffer[Int] = Buffer@4c27d525

scala>   lengths.map(println(_))
4
5
res2: Buffer[Unit] = Buffer@1b8f2e35
}}}

注意这里的`Buffer`类已经有一个`+=()`方法了，而且返回类型就是自己。所以可以用它
自己来混入`Builder`接口。

相对来说如果我们需要的是一个简化版的`Range`类型，那就要注意`Range`类的构造函数
并不会返回一个`Range`类型实例（当然也不应该这样返回）如：

{{{class="brush: scala"
scala> (1 to 10).map(x => x * x)
res0: scala.collection.immutable.IndexedSeq[Int] = Vector(1, 4, 9, 16, 25, 36, 4
9, 64, 81, 100)
}}}

返回的类型应该是一个序列而不是一个`Range`。在Scala的类库中`Range`是扩展自
`IndexedSeq[Int]`，而`IndexedSeq`的伴生对象定义一个构造`Vector`的构造器。对于
我们的简化版`Range`来说，要提供一个`Buffer`作为其构造器：

{{{class="brush: scala; highlight: [14]"
class Range(val low: Int, val high: Int) extends Iterable[Int, Range] {

  def iterator() = new Iterator[Int] {
    private var i = low
    def hasNext = i <= high
    def next() = { i += 1; i - 1 }
  }  

}

object Range {

  implicit def canBuildFrom[E : Manifest] = 
		new CanBuildFrom[Range, E, Buffer[E]] {
			def apply() = new Buffer[E]
  }

}
}}}

注意构造器的类型为`Buffer[E]`。

对于`map`方法中的`CanBuildFrom`隐式参数的定义：

{{{class="brush: scala"
implicit bf: CanBuildFrom[Repr, E, That]
}}}

来说`Repr`就是`Range`，这样隐式参数就可以看作：

{{{class="brush: scala"
implicit bf: CanBuildFrom[Range, E, That]
}}}

`Range`伴生对象的`canBuildFrom[E]`被调用产生的是：

{{{class="brush: scala"
CanBuildFrom[Range, E, Buffer[E]]
}}}

上面这个就是`bf`的类型，其`apply`方法将产出`Buffer[E]`，用于构造结果。

总之，隐式参数`CanBuildFrom[Repr, E, That]`会定位到一个可以产出目标集合构造器的
工厂对象。这个工厂是定义在`Repr`伴生对象中的一个隐式值。

调用时：

{{{class="brush: scala"
scala> import scala.math._
import scala.math._

scala>   val res = new Range(1, 10).map(sqrt(_))
res: Buffer[Double] = Buffer@79111260

scala>   res.map(println(_))
}}}




== 依赖于其他类型的类型的类型 ==

与上面的`CanBuildFrom`类似的，还有一个通过依赖其他类型的实现方案.

`List[T]`依赖于类型`T`生成一个特定类型的实例，如`List[Int]`。有时称这样的泛型
类型为类型构造器（type constructor）。不仅如此，Scala中还可以定义出依赖于其他
类型的类型的类型。

为了明白这样做的意义，我们用一个简化版的`Iterable`特质来说明：

{{{class="brush: scala"
trait Iterable[E] {
	def iterator(): Iterator[E]
	def map[F](f: (E) => F): Iterable[F]
}
}}}

如果有一个类实现该特质：

{{{class="brush: scala"
class Buffer[E] extends Iterable[E] {
	def iterator(): Iterator[E] = ....
	def map[F](f: (E) => f): Buffer[F] = ...
}
}}}

因为需要在`Buffer`类的`map()`方法中返回的是`Buffer`类型自己而不是`Iterable`，
所以为了`Iterable`特质中实现这个`map()`方法，我们必须用一个东西来代表`Buffer[E]`
或是其他的子类：

{{{class="brush: scala"
trait Iterable[E, C[_]] {
	def iterator(): Iterator[E]
	def build[F](): C[F]
	def map[F](f: (E) => F): Iterable[F]
}
}}}

这里的参数类型`C[_]`自己也是一个参数类型，所以像高阶函数一样`Iterable`成为了一个
高阶类型。

对于`map()`方法返回的类型并不一定和实例原来的类型一样，比如：`Buffer`类的`map()`
方法的返回类型也是`Buffer`；但是`Range`执行`map()`方法的结果通常不会也是一个
`Range`（比如可能是一个`Buffer[F]`）。所以对于`Range`类型声明的可能是这样的：

{{{class="brush: scala"
class Range extends Iterable[Int, Buffer]
}}}

这里的`Int, Buffer`对应`Iterable`声明中的`E, C[_]`，显然`C[_]`对应的是`Buffer`。

现在因为`map()`方法返回的类可以是存放任何`F`类型的容器，所以我们需要一个类来表示
存放任何`F`类型的容器的类`Container`：

{{{class="brush: scala"
trait Container[E] {
  def +=(e: E): Unit
}
}}}

它正好适合作为`Iterable`的`build()`方法的返回类型：

{{{class="brush: scala"
trait Iterable[E, C[X] <: Container[X]] {
	def build[F](): C[F]
	...
}
}}}

这里限制的容器`C`和`Container`的内容必须是相同类型的。

这样就可以在`Iterable`中实现`map()`方法了：

{{{class="brush: scala"
trait Iterable[E, C[X] <: Container[X]] {
  def iterator(): Iterator[E]
  def build[F : Manifest](): C[F]
  
  def map[F : Manifest](f: (E) => F): C[F] = {
    val res = build[F]()
    val iter = iterator()
    while (iter.hasNext) res += f(iter.next())
    res
  }
}
}}}

这样子类中就不用实现`map()`方法了。

下面是`Range`类的定义：

{{{class="brush: scala"
// An iterable, but not a container
class Range(val low: Int, val high: Int) extends Iterable[Int, Buffer] {
  def iterator() = new Iterator[Int] {
    private var i = low
    def hasNext = i <= high
    def next() = { i += 1; i - 1 }
  }  
  def build[F : Manifest]() = new Buffer[F]
    // Produced collection need not be the same type
}
}}}

它只混入了`Iterable`接口：可以遍历内容，但不能添加内容。

`Buffer`则混入了`Iterable`与`Container`：

{{{class="brush: scala"
class Buffer[E : Manifest] extends Iterable[E, Buffer] with Container[E] {
  private var capacity = 10
  private var length = 0
  private var elems = new Array[E](capacity) // See note
  def iterator() = new Iterator[E] {
    private var i = 0
    def hasNext = i < length
    def next() = { i += 1; elems(i - 1) }
  }
  def build[F : Manifest]() = new Buffer[F]
  def +=(e: E) {
    if (length == capacity) {
      capacity = 2 * capacity
      val nelems = new Array[E](capacity) // See note
      for (i <- 0 until length) nelems(i) = elems(i)
      elems = nelems
    }
    elems(length) = e
    length += 1
  }
}
}}}

`Manifest`上下文界定是为了构造`Array[E]`所必须的，这和高等类型没有什么关系。

=== 小结 ===

这是一个典型的例子：`Iterator`依赖`Container`。但`Container`不是一个普通的类型，
而是一个制件类型的机制。

在实际应用中，Scala的`Iterable`并不是高级类型来实现的，而是用隐式转换实现的一个
对象用于构造目标集合。


== 存在类型 ==

所有Java类型在Scala中都有对等的概念。一般的类型可以用同名的类型表示，如：

* Java中的`Pattern`对应Scala里的`Pattern`
* Java中的`Iterator<Component>`对应Scala里的`Iterator[Component]`

但是像是Java里的`Iterator<?>`或`Iterator<? extends Component>`这样的通配符类型
或是`Iterator`这样没有参数的原始类型要用到一种额外的叫作“存在类型”的类型来表示。

存在类型是Scala语言所支持的特性，但实际上它的作用是用于从Scala访问Java类型。主要
用途是当Scala访问Java时能够理解编译器报错的信息。存在类型的通用形式如下：

{{{class="brush: scala"
  type forSome { declarations }
}}}

`type`是任意的Scala类型，`declarations`是一个抽象的`val`和`type`列表。这个定义
可以解读为：声明的变量和类型是存在但未知的，正如类中的抽象成员那样。这个类型进而
被允许引用这些声明的变量和类型，虽然编译器不知道具体是什么类。

看一个具体的例子，Java中的`Iterator<?>`可以在Scala中写为：

{{{class="brush: scala"
Iterator[T] forSome { type T }
}}}

相当于前面的类型通配符：

{{{class="brush: scala"
Iterator[_]
}}}

其实类型通配符就是存在类型的一个语法糖。

Java中的：

{{{class="brush: java"
Iterator<? extends Component>
}}}

在Scala中写为存在类型结合指定上界和下界的方式：

{{{class="brush: scala"
Iterator[T] forSome { type T <: Component }
}}}

相当于前面的类型通配符：

{{{class="brush: scala"
Iterator[_ <: Component]
}}}

还可以有更加复杂的表示法，如：

{{{class="brush: scala"
map[T, U] forSome { type T; type U <: T }
}}}

还可以在`forSome`块中使用`val`声明因为`val`是可以有内部类的。以类型：

{{{class="brush: scala"
import scala.collection.mutable.ArrayBuffer

class Network {

  class Member(val name: String) {
    // ...
  }
  
  // ...
  
}
}}}

为例，可以用这样的形式：

{{{class="brush: scala"
m.Member forSome { val n: Network }
}}}

这里就完全等同于类型投影：

{{{class="brush: scala"
Network#member
}}}

但也会有更复杂的情况：

{{{class="brush: scala"
def process[M <: n.Member forSome { val n: Network }](m1: M, m2: M) = (m1, m2)
}}}

这个方法只接收同一实例子类的成员：

{{{class="brush: scala"
val chatter = new Network
val myFace = new Network
val fred = chatter.join("Fred")
val wilma = chatter.join("Wilma")
val barney = myFace.join("Barney")
process(fred, wilma) // Ok
process(fred, barney) // Error
}}}

存在类型对于对于简单的用例来说，可以当`forSome`不存在。虽然`forSome`语句中的类型
和值是未知的，Scala还是会检查程序是否完备。举例来说，对于以下的Java类：

{{{class="brush: java"
  // This is a Java class with wildcards
  public class Wild {
    Collection<?> contents() {
      Collection<String> stuff = new Vector<String>();
      stuff.add("a");
      stuff.add("b");
      stuff.add("see");
      return stuff;
    }
  }
}}}

如果在Scala中访问这个类，会看到它有一个存在类型：

{{{class="brush: scala"
  scala> val contents = (new Wild).contents
  contents: java.util.Collection[?0] forSome { type ?0 } =
     [a, b, see]
}}}

要看这个集合里有多少元素，可以简单忽略存在定义部分，像平常一样调用`size`方法：

{{{class="brush: scala"
  scala> contents.size()
  res0: Int = 3
}}}

对于复杂的类型的情况，存在类型会显得笨拙一些。因为没有办法给存在类型命名。以创建
一个可变Scala类型为例，需要用`contents`的元素初始化它：

{{{class="brush: scala"
  import scala.collection.mutable.Set
  val iter = (new Wild).contents.iterator
  val set = Set.empty[???]     // what type goes here? 这里要用什么类型？
  while (iter.hasMore)
    set += iter.next()
}}}

第三行里没有办法给出Java集合里的元素类型名称，所以不能给出`set`方法的满足类型。
为了绕过此问题，应该考试如下两种技巧：

# 将存在的类型传入方法时，把类型参数从`forSome`语句移到方法的类型参数中。
  在方法体内，可以用这个类型参数来指定本来在`forSome`语句中的类型。
# 不要从方法返回存在的类型，而是返回一个带有`forSome`语句中的每个类型的抽象成员
  的对象（参见抽象对象一章）。

使用这两个技巧，之前的代码写成这个样子：

{{{class="brush: scala"
  import scala.collection.mutable.Set
  import java.util.Collection

  abstract class SetAndType {
    type Elem
    val set: Set[Elem]
  }

  def javaSet2ScalaSet[T](jset: Collection[T]): SetAndType = {
    val sset = Set.empty[T]  // now T can be named!

    val iter = jset.iterator
    while (iter.hasNext)
      sset += iter.next()

    return new SetAndType {
      type Elem = T
      val set = sset
    }
  }
}}}


综上所棕，对于Scala来说，用存在类型实现不如抽象成员实现更加方便。所以Scala中几乎
不用存在类型。

== Scala类型小结 ==


| 类型         | 语法                                    |                |
| ------------ | --------------------------------------- | -------------- |
| 类 或 特质   | `class C ...` , `trait C ...`           |                |
| 元组         | `(T1, ... , Tn)`                        |                |
| 函数类型     | `(T1, ... , Tn) => T`                   |                |
| 方法类型     | `(T1, ... , Tn)T`                       | 编译器内部使用 |
| 注解         | `T @A`                                  |                |
| 参数化类型   | `A[T1, ... , Tn]`                       |                |
| 单例类型     | `value.type`                            |                |
| 类型投影     | `O#I`                                   |                |
| 复合类型     | `T1 with T2 with ... with Tn { ... }`   |                |
| 中置类型     | `T1 A T2`                               |                |
| 存在类型     | `T forSome { type and val }`            |                |

方法类型`(T1, ... , Tn)T`（与函数类型相比少了`=>`）一般只在编译器内部使用。
在REPL中输入函数类型：

{{{class="brush: scala"
scala> val triple = (x: Int) => 3 * x
triple: Int => Int = <function1>
}}}

而方法类型是这样的：

{{{class="brush: scala"
scala> def square(x: Int) = x * x
square: (x: Int)Int
}}}

可以在方法后面加上`_`可以转为函数类型：

{{{class="brush: scala"
scala> square _
res0: Int => Int = <function1>
}}}



== 家族多态 ==

就是许多个相关的类，又要共用代码、又要保护类型安全，这个比较难搞。Java的事件处理
是一个典型的例子：

* 有多个不同的事件（如：`ActionEvent`、`ChangeEvent`等……）
* 每个事件有单独的监听器接口（如：`ActionListener`、`ChangeListener`等……）

为了设计一套管理监听器的通用机制，我们先用泛型类型，然后再切换到抽象类型。

Java中每个监听器接口有不同的方法对应事件：`actionPerformed`、`stateChanged`、
`itemStateChanged`等。先把这些方法统一起来：

{{{class="brush: scala"
// Version 1: The event source is an Object

import scala.collection.mutable.ArrayBuffer
import java.awt.event.ActionEvent

trait Listener[E] {
  def occurred(e: E): Unit
}
}}}

事件源要有一个监听器的集合，和一个触发这些监听器的方法：

{{{class="brush: scala"
trait Source[E, L <: Listener[E]] {
  private val listeners = new ArrayBuffer[L]
  def add(l: L) { listeners += l }
  def remove(l: L) { listeners -= l }
  def fire(e: E) { for (l <- listeners) l.occurred(e) }
}
}}}

在这个基础上，以按钮事件`ActionEvent`为例，生成对应的监听器：

{{{class="brush: scala"
trait ActionListener extends Listener[ActionEvent]
}}}

`Button`类可以混入`Source`特质：

{{{class="brush: scala"
class Button extends Source[ActionEvent, ActionListener] {
  def click() {
    fire(new ActionEvent(this, ActionEvent.ACTION_PERFORMED, "click"))
  }
}
}}}

现在`Button`类不需要重复监听器管理代码，并且监听器的类型是安全的：只能给按钮加上
`ActionEvent`，`ChangeListener`。

调用：

{{{class="brush: scala"
scala> val b = new Button
b: Button = Button@b11fcc2

scala> b.add(new ActionListener {
     |   def occurred(e: ActionEvent) {
     |     println(e)
     |   }
     | })

scala> b.click()
java.awt.event.ActionEvent[ACTION_PERFORMED,cmd=click,when=0,modifiers=] on 
$line14.$read$$iw$$iw$$iw$Button@b11fcc2
}}}

根据Java中`ActionEvent`类的定义，它把事件源设置为`this`，但事件源的类型为
`Object`。这里可以用自身类型让它也是类型安全的：

{{{class="brush: scala; highlight: [10]"
trait Event[S] {
  var source: S = _
}

trait Listener[S, E <: Event[S]] {
  def occurred(e: E): Unit
}

trait Source[S, E <: Event[S], L <: Listener[S, E]] {
  this: S =>
  private val listeners = new ArrayBuffer[L]
  def add(l: L) { listeners += l }
  def remove(l: L) { listeners -= l }
  def fire(e: E) {
    e.source = this // Self-type needed here
    for (l <- listeners) l.occurred(e)
  }
}
}}}

自身类型`this: S =>`把事件源都设为`this`，不然`this`只能是某种`Source`，而不一定
是`Event[S]`所要求的类型。

定义按钮的例子：

{{{class="brush: scala"
class ButtonEvent extends Event[Button]

trait ButtonListener extends Listener[Button, ButtonEvent]

class Button extends Source[Button, ButtonEvent, ButtonListener] {
  def click() { fire(new ButtonEvent) }
}
}}}

调用：

{{{class="brush: scala"
val b = new Button
b.add(new ButtonListener {
  def occurred(e: ButtonEvent) {
    println(e + " from " + e.source)
  }
})
b.click()
}}}

这里的参数类型太多了，看起来不是很简洁。而且类型`Button`是循环依赖的。

如果用抽象类型的话，会好很多：

{{{class="brush: scala"
import scala.collection.mutable.ArrayBuffer
import java.awt.event.ActionEvent

trait ListenerSupport {
  type S <: Source
  type E <: Event
  type L <: Listener

  trait Event {
    var source: S = _
  }

  trait Listener {
    def occurred(e: E): Unit
  }

  trait Source {
    this: S =>

    private val listeners = new ArrayBuffer[L]
    def add(l: L) { listeners += l }
    def remove(l: L) { listeners -= l }
    def fire(e: E) {
      e.source = this
      for (l <- listeners) l.occurred(e)
    }
  }
}
}}}

这样也有限制：不能声明顶级类型。所以这里把所有的类型都放在一个`ListenerSupport`
类型里面。

然后定义按钮事件与按钮监听器时，就可以把定义包含在一个扩展该特质的模块当中：

{{{class="brush: scala"
object ButtonModule extends ListenerSupport {
  type S = Button
  type E = ButtonEvent
  type L = ButtonListener

  class ButtonEvent extends Event

  trait ButtonListener extends Listener

  class Button extends Source {
    def click() { fire(new ButtonEvent) }
  }
}
}}}

调用的例子，注意要使用时必须引入这个模块：

{{{class="brush: scala"
scala> import ButtonModule._
import ButtonModule._

scala> val b = new Button
b: ButtonModule.Button = ButtonModule$Button@48250355

scala>   b.add(new ButtonListener {
     |     def occurred(e: ButtonEvent) {
     |       println(e + " from " + e.source)
     |     }
     |   })

scala> b.click()
$line6.$read$$iw$$iw$ButtonModule$ButtonEvent@65d0e7e9 from 
$line6.$read$$iw$$iw$ButtonModule$Button@48250355
}}}

注意：虽然这里类型名只用了一个字母：

{{{class="brush: scala"
  type S = Button
  type E = ButtonEvent
  type L = ButtonListener
}}}

但实际上标识符都可以用，而且应该是具有可读性的：

{{{class="brush: scala"
  type SourceType = Button
  type EventType = ButtonEvent
  type ListenerType = ButtonListener
}}}



{{{class="brush: scala"
}}}


{{{class="brush: scala"
}}}




= 有状态的对象 =

类似于JavaBean的getter和setter方法，Scala对象的非私有`var x`有自动生成的访问方法
`x`和设值方法`x_=`。

对于类中的字段：

{{{class="brush: scala"
var hour = 12
}}}

会有额外的getter方法`hour`和setter方法`hour_=`。方法的访问性与字段一致。

拿这个例子来说：

{{{class="brush: scala"
  class Time {
    var hour = 12
    var minute = 0
  }
}}}

和下面的代码是一样的：

{{{class="brush: scala"
  class Time {

    private[this] var h = 12
    private[this] var m = 0

    def hour: Int = h
    def hour_=(x: Int) { h = x }

    def minute: Int = m
    def minute_=(x: Int) { m = x }
  }
}}}

所以可以直接定义getter和setter。

下面的代码在setter前进行检查：

{{{class="brush: scala"
  class Time {

    private[this] var h = 12
    private[this] var m = 12

    def hour: Int = h
    def hour_= (x: Int) {
      require(0 <= x && x < 24)
      h = x
    }

    def minute = m
    def minute_= (x: Int) {
      require(0 <= x && x < 60)
      m = x
    }
  }
}}}

再看一个温度的例子：

{{{class="brush: scala"
  class Thermometer {

    var celsius: Float = _

    def fahrenheit = celsius * 9 / 5 + 32
    def fahrenheit_= (f: Float) {
      celsius = (f - 32) * 5 / 9
    }
    override def toString = fahrenheit +"F/"+ celsius +"C"
  }
}}}

注意：变量`celsius`的值为`_`，表示初始化值。对于数值代表`0`，对于布尔类型代表
`false`，引用类型则代表`null`。

Scala中的初始化器`=_`，如果写成：

{{{class="brush: scala"
var celsius
}}}

这样就成了抽象变量（以后到了“抽象成员”这一章介绍），而不是一个没有初始化的变量。
这个和Java的习惯很不一样。

使用的例子：

{{{class="brush: scala"
  scala> val t = new Thermometer
  t: Thermometer = 32.0F/0.0C

  scala> t.celsius = 100

  scala> t
  res3: Thermometer = 212.0F/100.0C

  scala> t.fahrenheit = -40

  scala> t
  res4: Thermometer = -40.0F/-40.0C
}}}

== 案例：离散事件模拟 ==

来个SICP（Structure and Interpretation of Computer Programs，计算机程序的构造与
解释）里的例子。

== 为数字电路定制语言 ==

<img src="images/scala/18.01.png" />

为了实现这三种基本的门，我们建立一个`Wire`类代表线路。可以这样构造线路：

{{{class="brush: scala"
val a = new Wire
val b = new Wire
val c = new Wire
}}}

或简洁地写成：

{{{class="brush: scala"
val a, b, c = new Wire
}}}

三个基本的门电路由以下三个过程模拟：

{{{class="brush: scala"
  def inverter(input: Wire, output: Wire)
  def andGate(a1: Wire, a2: Wire, output: Wire)
  def orGate(o1: Wire, o2: Wire, output: Wire)
}}}

注意这里的过程都没有返回值。按照函数式的思想，应该是返回构造好的门对象。但是在
这里我们选择了没有返回值，而是通过副作用来模拟门电路。副作用让一步步渐进地构造
复杂的电路更加容易，如`inverter(a,b)`在`a`与`b`之间放置反转电路。

还有这里的方法名没有用动词而是用了名词，这是为了方便说明制造的是哪个门电路。这
反映了DSL说明的本质：应该描述电路，而不是如何制造它。

下面是一个半加法器（half-adder）。它根据两个输入`a`和`b`产生累加和`s`。

累加的定义为：`s= (a+b)%2`及进位`c`，其中的`c = (a+b)/2`。

半加法器电路图：

<img src="images/scala/18.02.png" />

用我们的代码描述：

{{{class="brush: scala"
  def halfAdder(a: Wire, b: Wire, s: Wire, c: Wire) {
    val d, e = new Wire
    orGate(a, b, d)
    andGate(a, b, c)
    inverter(c, e)
    andGate(d, e, s)
  }
}}}

接下来是一个全加法器，定义为根据参数`a`和`b`还有进位`cin`得到两个输出。一个是和
`sum = (a+b+cin)%2`，另一个是进位输出`count = (a+b+cin)/2`：

<img src="images/scala/18.03.png" />

代码为：

{{{class="brush: scala"
  def fullAdder(a: Wire, b: Wire, cin: Wire,
      sum: Wire, cout: Wire) {

    val s, c1, c2 = new Wire
    halfAdder(a, cin, s, c1)
    halfAdder(b, s, sum, c2)
    orGate(c1, c2, cout)
  }
}}}

这是内部DSL很好的例子：通过宿主语言将特定的语言定义为库面不是完全实现这种语言。


== Simulation API ==

完成了对电路的模拟以后，再来分析对时间的模拟。模拟时间包括在指定时间执行指定的
动作。

私有变量保存时间，但提供对时间的公开访问：

{{{class="brush: scala"
  private var curtime: Int = 0

  def currentTime: Int = curtime
}}}

定义动作：在我们的例子中，把参数列表和返回都为空的过程`() => Unit`作为基本的动作
。给这样类型的过程起个别名叫`Action`：

{{{class="brush: scala"
type Action = () => Unit
}}}

在特定时间执行的的操作定义为工作项目（work item）：

{{{class="brush: scala"
  case class WorkItem(time: Int, action: Action)
}}}

注意这里用的是样本类，所以用工厂方法创建实例就可以自动获得访问构造器参数`time`和
`action`的方法。

还有一个类来保存末执行工作条目的排程表（agenda），注意它是按时间排序的：

{{{class="brush: scala"
  private var agenda: List[WorkItem] = List()
}}}

提供在一定 时延后加入新的工作条目的方法，注意加入操作也要排序：

{{{class="brush: scala"
  def afterDelay(delay: Int)(block: => Unit) {
    val item = WorkItem(currentTime + delay, () => block)
    agenda = insert(agenda, item)
  }

  private def insert(ag: List[WorkItem],
      item: WorkItem): List[WorkItem] = {
    if (ag.isEmpty || item.time < ag.head.time) item :: ag
    else ag.head :: insert(ag.tail, item)
  }
}}}

核心是`run`方法：

{{{class="brush: scala"
  def run() {
    afterDelay(0) {
      println("*** simulation started, time = "+
          currentTime +" ***")
    }
    while (!agenda.isEmpty) next()
  }
  
  private def next() {
    (agenda: @unchecked) match {
      case item :: rest =>
        agenda = rest
        curtime = item.time
        item.action()
    }
  }
}}}

注意这里为了方便去掉了空列表的情况。为了防止编译器警告我们在模式匹配里故意漏掉了
列表为空的情况，在这里使用了`(agenda: @unchecked) match`而不是`agenda match`。

完整的代码在包`org.stairwaybook.simulation`里：

{{{class="brush: scala"
  abstract class Simulation {

    type Action = () => Unit

    case class WorkItem(time: Int, action: Action)

    private var curtime = 0
    def currentTime: Int = curtime

    private var agenda: List[WorkItem] = List()

    private def insert(ag: List[WorkItem],
        item: WorkItem): List[WorkItem] = {

      if (ag.isEmpty || item.time < ag.head.time) item :: ag
      else ag.head :: insert(ag.tail, item)
    }

    def afterDelay(delay: Int)(block: => Unit) {
      val item = WorkItem(currentTime + delay, () => block)
      agenda = insert(agenda, item)
    }

    private def next() {
      (agenda: @unchecked) match {
        case item :: rest =>
          agenda = rest
          curtime = item.time
          item.action()
      }
    }

    def run() {
      afterDelay(0) {
        println("*** simulation started, time = "+
            currentTime +" ***")
      }
      while (!agenda.isEmpty) next()
    }
  }
}}}



== 电路模拟 ==

这里创建了`BasicCircuitSiomulation`来模拟电路。

为了模拟电路和延迟声明了三个方法：`InverterDelay`、`AndGateDelay`、`OrGateDelay`。由于
不同模拟电路的技术参数不同，所以这三个方法是抽象方法。

=== Wire类 ===

需要支持的三种基本动作：

`getSignal: Boolean`：返回当前线路上的信号。

`setSignal(sig: Boolean)`：设置线路信号。

`addAction(p: Action)`：添加动作到线路上。基本思想是所有附加在某线路上的动作过程
在每次信号改变时被执行。通过连接组件可以为线路添加该组件的功能。加上的动作会在被
加到线路时以及每次线路信号改变时被执行。

实现代码`sigVal`代表当前信号，`actions`是附加的动作过程。需要注意的是`setSignal`
方法，当信号改变时，新的信号首先被保存在变量`sigVal`中，然后执行所有线路附加
动作：

{{{class="brush: scala"
  class Wire {
    private var sigVal = false
    private var actions: List[Action] = List()

    def getSignal = sigVal

    def setSignal(s: Boolean) =
      if (s != sigVal) {
        sigVal = s
        actions foreach (_ ())
      }

    def addAction(a: Action) = {
      actions = a :: actions
      a()
    }
  }
}}}

注意上面的缩写格式：`actions forearch(_())`代表对每个元素执行`_()`。在“函数和装饰”这一章的
“占位符”部分说明过，函数`_()`是`f => f()`的缩写，代表空参数函数。

=== 反转操作 ===

`inverter`方法会在安装之后以及每次线路信号变化时被调用。它通过`setSignal`把输出设为输入的反值。

另外，由于还要模拟电路的响应时间，所以输入值改变以后，还要等`InverterDelay`单位的模拟时间后，
才发生改变：

{{{class="brush: scala"
  def inverter(input: Wire, output: Wire) = {
    def invertAction() {
      val inputSig = input.getSignal
      afterDelay(InverterDelay) {
        output setSignal !inputSig
      }
    }
    input addAction invertAction
  }
}}}

注意这里的`afterDelay`方法是把这个操作加到队列的最后面。

=== 与门和或门操作 ===

大致思想和上面类似：

{{{class="brush: scala"
  def andGate(a1: Wire, a2: Wire, output: Wire) = {
    def andAction() = {
      val a1Sig = a1.getSignal
      val a2Sig = a2.getSignal
      afterDelay(AndGateDelay) {
        output setSignal (a1Sig & a2Sig)
      }
    }
    a1 addAction andAction
    a2 addAction andAction
  }

  def orGate(o1: Wire, o2: Wire, output: Wire) {
    def orAction() {
      val o1Sig = o1.getSignal
      val o2Sig = o2.getSignal
      afterDelay(OrGateDelay) {
        output setSignal (o1Sig | o2Sig)
      }
    }
    o1 addAction orAction
    o2 addAction orAction
  }
}}}

=== 模拟输出 ===

通过探针（probe）观察线路上信号的改变。

还是在信号改变时被调用，显示输出线路的名称、模拟时间、信号值：

{{{class="brush: scala"
  def probe(name: String, wire: Wire) {
    def probeAction() {
      println(name +" "+ currentTime +
          " new-value = "+ wire.getSignal)
    }
    wire addAction probeAction
  }
}}}

=== 运行模拟器 ===

`BasicCircuitSimulation`继承了`CircuitSimulation`

{{{class="brush: scala"
  package org.stairwaybook.simulation

  abstract class CircuitSimulation
    extends BasicCircuitSimulation {

    def halfAdder(a: Wire, b: Wire, s: Wire, c: Wire) {
      val d, e = new Wire
      orGate(a, b, d)
      andGate(a, b, c)
      inverter(c, e)
      andGate(d, e, s)
    }

    def fullAdder(a: Wire, b: Wire, cin: Wire,
        sum: Wire, cout: Wire) {

      val s, c1, c2 = new Wire
      halfAdder(a, cin, s, c1)
      halfAdder(b, s, sum, c2)
      orGate(c1, c2, cout)
    }
  }
}}}

剩下的电路延迟时间和定义被模拟的电路都留在Scala交互Shell中实现：

{{{class="brush: scala"
  scala> import org.stairwaybook.simulation._
  import org.stairwaybook.simulation._
}}}

定义延迟时间：

{{{class="brush: scala"
  scala> object MySimulation extends CircuitSimulation {
       | def InverterDelay = 1
       | def AndGateDelay = 3
       | def OrGateDelay = 5
       | }
  defined module MySimulation
}}}

定义一下简化以后对`MySimulation`的引用：

{{{class="brush: scala"
  scala> import MySimulation._
  import MySimulation._
}}}

定义线路的部分。先定义四根线路，再把探针放在其中的两根上。探针会立即输出结果：

{{{class="brush: scala"
  scala> val input1, input2, sum, carry = new Wire
  input1: MySimulation.Wire =
      simulator.BasicCircuitSimulation$Wire@111089b
  input2: MySimulation.Wire =
      simulator.BasicCircuitSimulation$Wire@14c352e
  sum: MySimulation.Wire =
      simulator.BasicCircuitSimulation$Wire@37a04c
  carry: MySimulation.Wire =
      simulator.BasicCircuitSimulation$Wire@1fd10fa

  scala> probe("sum", sum)
  sum 0 new-value = false

  scala> probe("carry", carry)
  carry 0 new-value = false
}}}

加上半加法器：

{{{class="brush: scala"
  scala> halfAdder(input1, input2, sum, carry)
}}}

逐次把两根输入线信号设为`true`，并执行模拟过程：

{{{class="brush: scala"
  scala> input1 setSignal true

  scala> run()
  *** simulation started, time = 0 ***
  sum 8 new-value = true

  scala> input2 setSignal true

  scala> run()
  *** simulation started, time = 8 ***
  carry 11 new-value = true
  sum 15 new-value = false
}}}

全部代码如下：

{{{class="brush: scala"
package org.stairwaybook.simulation

abstract class BasicCircuitSimulation extends Simulation {

  def InverterDelay: Int
  def AndGateDelay: Int
  def OrGateDelay: Int

  class Wire {

    private var sigVal = false
    private var actions: List[Action] = List()

    def getSignal = sigVal

    def setSignal(s: Boolean) =
      if (s != sigVal) {
        sigVal = s
        actions foreach (_ ())
      }

    def addAction(a: Action) = {
      actions = a :: actions
      a()
    }
  }

  def inverter(input: Wire, output: Wire) = {
    def invertAction() {
      val inputSig = input.getSignal
      afterDelay(InverterDelay) {
        output setSignal !inputSig
      }
    }
    input addAction invertAction
  }

  // continued in Listing 18.10...
  // ...continued from Listing 18.9
  def andGate(a1: Wire, a2: Wire, output: Wire) = {
    def andAction() = {
      val a1Sig = a1.getSignal
      val a2Sig = a2.getSignal
      afterDelay(AndGateDelay) {
        output setSignal (a1Sig & a2Sig)
      }
    }
    a1 addAction andAction
    a2 addAction andAction
  }

  def orGate(o1: Wire, o2: Wire, output: Wire) {
    def orAction() {
      val o1Sig = o1.getSignal
      val o2Sig = o2.getSignal
      afterDelay(OrGateDelay) {
        output setSignal (o1Sig | o2Sig)
      }
    }
    o1 addAction orAction
    o2 addAction orAction
  }

  def probe(name: String, wire: Wire) {
    def probeAction() {
      println(name +" "+ currentTime +
          " new-value = "+ wire.getSignal)
    }
    wire addAction probeAction
  }
}

abstract class Simulation {

  type Action = () => Unit

  case class WorkItem(time: Int, action: Action)

  private var curtime = 0
  def currentTime: Int = curtime

  private var agenda: List[WorkItem] = List()

  private def insert(ag: List[WorkItem],
      item: WorkItem): List[WorkItem] = {

    if (ag.isEmpty || item.time < ag.head.time) item :: ag
    else ag.head :: insert(ag.tail, item)
  }

  def afterDelay(delay: Int)(block: => Unit) {
    val item = WorkItem(currentTime + delay, () => block)
    agenda = insert(agenda, item)
  }

  private def next() {
    (agenda: @unchecked) match {
      case item :: rest =>
        agenda = rest
        curtime = item.time
        item.action()
    }
  }

  def run() {
    afterDelay(0) {
      println("*** simulation started, time = "+
          currentTime +" ***")
    }
    while (!agenda.isEmpty) next()
  }
}


abstract class CircuitSimulation
  extends BasicCircuitSimulation {

  def halfAdder(a: Wire, b: Wire, s: Wire, c: Wire) {
    val d, e = new Wire
    orGate(a, b, d)
    andGate(a, b, c)
    inverter(c, e)
    andGate(d, e, s)
  }

  def fullAdder(a: Wire, b: Wire, cin: Wire,
      sum: Wire, cout: Wire) {

    val s, c1, c2 = new Wire
    halfAdder(a, cin, s, c1)
    halfAdder(b, s, sum, c2)
    orGate(c1, c2, cout)
  }
}

 object MySimulation extends CircuitSimulation {
           def InverterDelay = 1
           def AndGateDelay = 3
           def OrGateDelay = 5

  def main(args: Array[String]) {
    val input1, input2, sum, carry = new Wire

    probe("sum", sum)
    probe("carry", carry)
    halfAdder(input1, input2, sum, carry)

    input1 setSignal true
    run()

    input2 setSignal true
    run()
  }
}
}}}




= 实现列表 =

列表不是Scala语言的内建结构，而是定义在`Scala`包中的`List`抽象类。它有一个子类
`::`和一个子对象`Nil`。



== List类实现原理 ==

本节的目的是实现一个简化的List实现：

{{{class="brush: scala"
  package scala
  abstract class List[+T] { ... }
}}}

作为一个抽象类`List`不能用像`new List`这样的空构造器构建，由类型参数`[+T]`表明
列表是协变的。


{{{class="brush: scala"
  scala> val xs = List(1, 2, 3)
  xs: List[Int] = List(1, 2, 3)

  scala> var ys: List[Any] = xs
  ys: List[Any] = List(1, 2, 3)
}}}

实现的目标要有以下三个功能：

{{{class="brush: scala"
    def isEmpty: Boolean
    def head: T
    def tail: List[T]
}}}

这三个方法在`List`类中是抽象的，被定义在`Nil`和`::`中。

=== Nil对象 ===

`Nil`对象继承自`List[Nothing]`，它定义了空列表。因为协变的作为它可以兼容任何类型
的`List`实例：

{{{class="brush: scala"
  case object Nil extends List[Nothing] {
    override def isEmpty = true
    def head: Nothing =
      throw new NoSuchElementException("head of empty list")
    def tail: List[Nothing] =
      throw new NoSuchElementException("tail of empty list")
  }
}}}

成员方法`head`的实现方法是抛出异常，因为对于成员类型`Nothing`来说，返回结果必须
是`Nothing`，而`Nothing`是个根本不存在的类型，所以它无法正常返回结果，只能抛出
异常。

=== Cons类 ===

`::`类读作“cons”，意思是“构造”，它实现了非空列表。“使用列表”这一章中“列表模式”里
说过模式中的每个中缀调用被作为构造器调用。

就是说：`x :: xs`是对类`::`的构造器调用`::(x, xs)`。

{{{class="brush: scala"
  final case class ::[T](hd: T, tl: List[T]) extends List[T] {
    def head = hd
    def tail = tl
    override def isEmpty: Boolean = false
  }
}}}

`hd`是头一个元素，`tl`是其他的所有元素。上面的代码可以简化，直接由参数实现超类
`List`的`head`和`tail`方法：

{{{class="brush: scala"
  final case class ::[T](head: T, tail: List[T])
      extends List[T] {

    override def isEmpty: Boolean = false
  }
}}}

=== 其他的类方法 ===

{{{class="brush: scala"
  def length: Int = 
    if (isEmpty) 0 else 1 + tail.length

  def drop(n: Int): List[T] = 
    if (isEmpty) Nil
    else if (n <= 0) this
    else tail.drop(n - 1)

  def map[U](f: T => U): List[U] =
    if (isEmpty) Nil
    else f(head) :: tail.map(f)
}}}


=== 列表构建 ===

对于冒号结束的操作符`::`和`:::`，它们的操作都是绑定在右操作数上的。即：

{{{class="brush: scala"
x :: xs
}}}

被看作是：

{{{class="brush: scala"
xs.::(x)
}}}

因为`x`是列表元素可以是任意类型，所以不能假设它正好是具有`::`方法的
类型。也由于这个原因`::`方法应该生成一个新的列表。


还有值得讨论的地方是新加入元素的类型。思维惯性上会认为和列表元素是同一类型，但
实际上可用的范围更大。以下面的层级关系为例：

{{{class="brush: scala"
  abstract class Fruit 
  class Apple extends Fruit
  class Orange extends Fruit


  scala> val apples = new Apple :: Nil
  apples: List[Apple] = List(Apple@585fa9)

  scala> val fruits = new Orange :: apples
  fruits: List[Fruit] = List(Orange@cd6798, Apple@585fa9)
}}}

上面的例子说明新加入的元素可以产生超类类型的列表。实现这样弹性的`::`方法：

{{{class="brush: scala"
  def ::[U >: T](x: U): List[U] = new scala.::(x, this)
}}}

注意方法本身是多态的，类型参数是`U`，添加的元素类型必须是`U`，返回结果类型是
`List[U]`。而`[U >: T]`限定列表元素T的超类。

结合前面的例子，`U`被实例化为`Fruit`。因为`List[Apple]`中的`Apple`是`Fruit`的
子类，于是`U`的下界被满足。

<img src="images/scala/22.02.png" />

实际上对带有下界的`T`定义不只是为了方便，更加是为类型正确。因为`List`是协变的，
如果用下面的形式：

{{{class="brush: scala"
  // Error
  def ::(x: T): List[T] = new scala.::(x, this)
}}}

因为方法参数被认为是逆变位置，所以上面的列表元素类型`T`处于逆变位置。这样`List`
就不能被声明为`T`保持协变了。所以使用下界`[U >: T]`，即加强了类型检查，又让使用
更加有弹性。


=== 连接列表方法 ===

连接列表的实现方法差不多：

{{{class="brush: scala"
    def :::[U >: T](prefix: List[U]): List[U] = 
      if (prefix.isEmpty) this
      else prefix.head :: prefix.tail ::: this
}}}

因为`::`与`:::`是右关联的，所以下面四个语句其实相等：

{{{class="brush: scala"
  prefix.head :: prefix.tail ::: this
  prefix.head :: (prefix.tail ::: this)
  (prefix.tail ::: this).::(prefix.head)
  this.:::(prefix.tail).::(prefix.head)
}}}


== ListBuffer类 ==

列表的典型访问模式是递归，比如有一个让列表所有元素自加1的方法：

{{{class="brush: scala"
  def incAll(xs: List[Int]): List[Int] = xs match {
    case List() => List()
    case x :: xs1 => x + 1 :: incAll(xs1)
  }
}}}

这个方法有个问题：`incAll`是在`::`运算里面的，不是尾递归，堆栈的爆掉的危险。所以
要换个用循环的方案：

{{{class="brush: scala"
  for (x <- xs) // ??
}}}

那循环体内怎么写？前面的`incAll`递归方案可以通过加前缀操作；循环只能通过加后缀，
但`:::`操作时间与第一个列表长度成正比，效率很差：

{{{class="brush: scala"
  var result = List[Int]()    // a very inefficient approach
  for (x <- xs) result = result ::: List(x + 1)
  result
}}}

较好的办法是使用列表缓冲（list buffer）收集元素，最后用`toList`方法一次转换为
列表。

类`ListBuffer`位于`scala.collection.mutable`包中，而且它经过优化的增减操作与
`toList`操作都只要很短的常量时间就可以完成：

{{{class="brush: scala"
  import scala.collection.mutable.ListBuffer

  val buf = new ListBuffer[Int]
  for (x <- xs) buf += x + 1
  buf.toList
}}}


== 实际的List类实现 ==

虽然我们自己实现的`List`类很简洁，但实际上在遍历列表时为了避免递归一般都使用列表
缓冲与循环结合的方式。比如真正的`List`类是这样实现`map`方法的：

{{{class="brush: scala"
  final override def map[U](f: T => U): List[U] = {
    val b = new ListBuffer[U]
    var these = this
    while (!these.isEmpty) {
      b += f(these.head)
      these = these.tail
    }
    b.toList
  }
}}}

看了以上的代码后，大家可能会对最后`b.toList`的效率感兴趣。实际上它的效率与列表的
长度无关。关于原因可以看一下`::`类的实现：

{{{class="brush: scala"
  final case class ::[U](hd: U, 
      private[scala] var tl: List[U]) extends List[U] {

    def head = hd
    def tail = tl
    override def isEmpty: Boolean = false
  }
}}}

可以看到参数`tl`的类型是`var`，所以列表除了头一个元素以下的部分还是可以改变的。
而且修饰符`private[scala]`限定只有`scala`包中可以访问它。而修改它的是
`scala.collection.mutable`中的`ListBuffer`。

ListBuffer的元素被表示为列表，而添加新元素操作只对列表中最后一个`::`单元的`t1`
字段修改：

{{{class="brush: scala"
  package scala.collection.immutable
  final class ListBuffer[T] extends Buffer[T] {
    private var start: List[T] = Nil       // 所有元素的列表
    private var last0: ::[T] = _           // 最后一个 '::' 成员
    private var exported: Boolean = false  // 是否执行过toList操作
}}}

`toList`方法的实现也很简单。它返回由`start`指向的列表，如果列表非空，就设置
`exported`为`true`：

{{{class="brush: scala"
  override def toList: List[T] = {
    exported = !start.isEmpty
    start
  }
}}}

`toList`返回的列表应该是不可变的实例。那如果在这以后又被添加了元素的话，就不得不
改变`start`指向的列表。所以为了维护正确性，由`+=`方法转向对一个新列表进行操作：

{{{class="brush: scala"
  override def += (x: T) {
    if (exported) copy()
    if (start.isEmpty) {
      last0 = new scala.::(x, Nil)
      start = last0
    } else {
      val last1 = last0
      last0 = new scala.::(x, Nil)
      last1.tl = last0
    }
  }
}}}

上面的逻辑中可以看出，如果没有被`toList`过，还可以在原来的列表上修改。如果已经
生成过列表了，那复制操作就不可避免。


== 外在的函数式风格 ==

回顾本章的内容可以感受到：指使式方案可以避免重复复制以提高效率；函数式风格以不可
改变与不共享数据让程序变得更加可靠。

Scala官方的实现方式让程序在外部看来是函数式，而内部实现在不得已的情况下使用
指令式实现。这样的实现可以被称作“外在函数式风格”。




= 重温for表达式 =

先讨论一个例子，`Person`类有名字，性别，孩子三个成员：

{{{class="brush: scala"
  case class Person(name: String, isMale: Boolean, children: Person*)
}}}

根据这个类建立一些实例：

{{{class="brush: scala"
  val lara = Person("Lara", false)
  val bob = Person("Bob", true)
  val julie = Person("Julie", false, lara, bob)
  val persons = List(lara, bob, julie)
}}}

如果要找出所有母亲与孩子的结对，方案一是使用`map`、`flatMap`和`filter`这样的高阶
函数组成这样的查询操作：

{{{class="brush: scala"
  scala> persons filter (p => !p.isMale) flatMap (p =>
       |     (p.children map (c => (p.name, c.name))))
  res5: List[(String, String)] = List((Julie,Lara),
      (Julie,Bob))
}}}

上面的代码很看起来挺难理解的，用for表达式来实现另一个版本：

{{{class="brush: scala"
  scala> for (p <- persons; if !p.isMale; c <- p.children) 
       | yield (p.name, c.name)
  res6: List[(String, String)] = List((Julie,Lara),
      (Julie,Bob))
}}}

for循环比高阶函数可读性更加好一些。但实际上Scala编译器把循环版本转为高阶函数版本
：

* 所有有`yield`结果的for表达式会被转为`map`、`flatMap`与`filter`组合的调用。
* 所有无`yield`结果的for表达式被转为`filter`与`foreach`的调用。


== For表达式 ==

for表达式的一般形式：

{{{class="brush: scala"
  for ( seq ) yield expr
}}}

其中的`seq`部分由生成器、定义、过滤器组成，以分号分隔：

{{{class="brush: scala"
  for (p <- persons; n = p.name; if (n startsWith "To")) 
  yield n
}}}

小括号可以由大括号代替，并且在用大括号的情况下还能省略分号：

{{{class="brush: scala"
  for {
    p <- persons              // 生成器
    n = p.name                // 定义
    if (n startsWith "To")    // 过滤器
  } yield n
}}}

如果有多个生成器，后面的生成器在内层的循环：

{{{class="brush: scala"
  scala> for (x <- List(1, 2); y <- List("one", "two")) 
       | yield (x, y)
  res0: List[(Int, java.lang.String)] = 
    List((1,one), (1,two), (2,one), (2,two))
}}}

== 8皇后问题 ==

8皇后问题：标准棋盘上放8个皇后，相互之间不能处理叫吃的位置上（同行、同列、
同对角线）。

对于这个问题，把它扩展为任意尺寸的棋盘：在N*N的棋盘上放N个皇后，反而更加简单。设
左上角的坐标是(1,1)，右下角是(N,N)。

定义好了问题以后再看解决方案：

同一行的会被叫吃，所以每行只能放一个。那就一行一行地放皇后并检查会不会被叫吃。在
处理过程中还会遇到第K行的皇后把从`1`到`k-1`行的皇后全都叫吃的局面，这时就要放弃
这部分操作继续另外一种从1到k-1行皇后的配置方案。

另外一个方案更加具有函数式风格：

穷举出所有在`N*N`棋盘上放`k`个皇后的方案`0<k<N`。那么每个方案都可以用长度的`k`的
列表表示，为了处理方便顺序要按堆栈的方式把第k行在最顶层，`k-1`到`k`行依次向下。
所有的堆栈在一起组成了所有解决方案的列表。

现在我们把在第`k+1`行放皇后的操作变为对前一个方案多加一个皇后的所有可能的扩展。
这会产一个长度为`k+1`的列表。

下面的`placeQueens`函数实现了这一算法：

{{{class="brush: scala"
  def queens(n: Int): List[List[(Int, Int)]] = {
    def placeQueens(k: Int): List[List[(Int, Int)]] =
      if (k == 0) 
        List(List())
      else 
        for {
          queens <- placeQueens(k - 1)
          column <- 1 to n
          queen = (k, column)
          if isSafe(queen, queens) 
        } yield queen :: queens

    placeQueens(n)
  }
}}}

两个生成器：

* `queens <- placeQueens(k - 1)`遍历所有行（递归调用）。
* `column <- 1 to n`遍历所有列。

过滤器来检查有没有叫吃情况发生：

{{{class="brush: scala"
  def isSafe(queen: (Int, Int), queens: List[(Int, Int)]) = 
    queens forall (q => !inCheck(queen, q))

  def inCheck(q1: (Int, Int), q2: (Int, Int)) = 
    q1._1 == q2._1 ||                          // 同一行
    q1._2 == q2._2 ||                          // 同一列
    (q1._1 - q2._1).abs == (q1._2 - q2._2).abs // 对角线
}}}


== 使用for表达式进行查询 ==

模拟一个查找图书的应用：

{{{class="brush: scala"
  case class Book(title: String, authors: String*)

  val books: List[Book] =
    List(
      Book(
        "Structure and Interpretation of Computer Programs",
        "Abelson, Harold", "Sussman, Gerald J."
      ),
      Book(
        "Principles of Compiler Design",
        "Aho, Alfred", "Ullman, Jeffrey"
      ),
      Book(
        "Programming in Modula-2",
        "Wirth, Niklaus"
      ),
      Book(
        "Elements of ML Programming",
        "Ullman, Jeffrey"
      ),
      Book(
        "The Java Language Specification", "Gosling, James",
        "Joy, Bill", "Steele, Guy", "Bracha, Gilad"
      )
    )
}}}

查找作者姓“Gosling”的书名：

{{{class="brush: scala"
  scala> for (b <- books; a <- b.authors
       |      if a startsWith "Gosling")
       | yield b.title
  res0: List[String] = List(The Java Language Specification)
}}}

查找书名含“Program”：

{{{class="brush: scala"
  scala> for (b <- books if (b.title indexOf "Program") >= 0)
       | yield b.title
  res4: List[String] = List(Structure and Interpretation of
    Computer Programs, Programming in Modula-2, Elements
      of ML Programming)
}}}

查找编写了两本书以上的作者：

{{{class="brush: scala"
  scala> for (b1 <- books; b2 <- books if b1 != b2;
       |     a1 <- b1.authors; a2 <- b2.authors if a1 == a2)
       | yield a1
  res5: List[String] = List(Ullman, Jeffrey, Ullman, Jeffrey)
}}}

上面的代码有缺陷，同一个作者会出现多次。下面的代码完成去重：

{{{class="brush: scala"
  scala> def removeDuplicates[A](xs: List[A]): List[A] = {
       |   if (xs.isEmpty) xs
       |   else
       |     xs.head :: removeDuplicates(
       |       xs.tail filter (x => x != xs.head)
       |     )
       | }
  removeDuplicates: [A](List[A])List[A]

  scala> removeDuplicates(res5)
  res6: List[java.lang.String] = List(Ullman, Jeffrey)
}}}

最后一个表达式可以使用for表达式表现为：

{{{class="brush: scala"
   xs.head :: removeDuplicates(
     for (x <- xs.tail if x != xs.head) yield x
   )
}}}

== for表达式的转译 ==

每个for表达式都可以换成`map`、`flatMap`、`filter`这三个高阶的形式表达。

=== 简单变量生成器 ===

`x <- exp1`这种生成器生成到简单变量的情况下，大概有三种情况。

==== 一个生成器 ====

{{{class="brush: scala"
for (x <- exp1) yield exp2
}}}

相当于：

{{{class="brush: scala"
exp1 .map(x => exp2)
}}}

==== 以一个生成器和过滤器载开头 ====

{{{class="brush: scala"
for (x <- exp1 if exp2) yield exp3
}}}

相当于：

{{{class="brush: scala"
for (x <- exp1 filter(x => exp2)) yield exp3
}}}

相当于：

{{{class="brush: scala"
exp1 filter (x => exp2) map (x => exp3)
}}}

如果过滤器后有更多的元素同理。设`seq`为任意序列生成器、定义或过滤器，则：

{{{class="brush: scala"
for (x <- exp1 if exp2 ; seq) yield exp3
}}}

相当于：

{{{class="brush: scala"
for (x <- exp1 filter exp2 ; seq) yield exp3
}}}

==== 以两个生成器开始 ====

{{{class="brush: scala"
for (x <- exp1 ; y <- exp2 ; seq) yield exp3
}}}

设`seq`为任意序列生成器、定义或过滤器。则相当于`flatMap`的应用：

{{{class="brush: scala"
exp1 .flatMap(x => for (y <- exp2 ; seq) yield exp3)
}}}

==== 组合应用生成变量的例子 ====

组合上面三种情况来处理“找出所有出版过至少两本书的作者”：

{{{class="brush: scala"
for (b1 <- books; b2 <- books if b1 != b2;
     a1 <- b1.authors; a2 <- b2.authors if a1 == a2)
yield a1
}}}

相当于：

{{{class="brush: scala"
books flatMap (b1 =>
  books filter (b2 => b1 != b2) flatMap (b2 =>
    b1.authors flatMap (a1 =>
      b2.authors filter (a2 => a1 == a2) map (a2 =>
        a1))))
}}}

=== 生成器转译中的模式 ===

如果生成器不是`x <- expq`这样生成到简单变量`x`的情况。转译起来就麻烦了。

==== 变量元组 ====

这种情况还简单，看起来像变量差不多。

{{{class="brush: scala"
for ((x1, ..., xn) <- exp1) yield exp2
}}}

相当于：

{{{class="brush: scala"
exp1 .map { case(x1, ..., xn) => exp2 }
}}}

==== 单个模式匹配的情况 ====

单个模式匹配的情况下：

{{{class="brush: scala"
for (pat <- exp1) yield exp2
}}}

相当于：

{{{class="brush: scala"
exp1 filter {
	case pat => true
	case _   => false
} map {
	case pat => exp2
}
}}}

基本思路是只有匹配于`pat`的情况才会被映射，所以也保证了模式匹配不会抛出
`MatchError`。

注意这只在单个模式匹配的情况下讨论。其他的情况参考Scala语言规格书“Ode08”。


=== 多层内嵌定义 ===

{{{class="brush: scala"
for (x <- exp1; y = exp2; seq) yield exp3
}}}

设`seq`为任意序列生成器、定义或过滤器。上面相当于：

{{{class="brush: scala"
for((x,y) <- for (x <- exp1) yield (x, exp2); seq) yield exp3
}}}

因为`exp2`用到了`x`所以每次产`x`的时候`exp2`要重新计算。这样浪费了性能，所以：


{{{class="brush: scala"
  for (x <- 1 to 1000; y = expensiveComputationNotInvolvingX)
  yield x * y
}}}

更好的写法是：

{{{class="brush: scala"
  val y = expensiveComputationNotInvolvingX
  for (x <- 1 to 1000) yield x * y
}}}

=== 没有返回值的情况 ===

前面描述了通过`yield`生成值的情况。在不产值的情况下一般更简单，只要`foreach`：

{{{class="brush: scala"
for (x <- exp1) body
}}}

相当于：

{{{class="brush: scala"
exp1 foreach (x => body)
}}}

更加复杂的情况：

{{{class="brush: scala"
for (x <- exp1 ; if exp2 ; y <- exp3) body
}}}

相当于：

{{{class="brush: scala"
exp1 filter (x => exp2) foreach (
	x => exp3 foreach (y => body)
)
}}}

例子，把列表形式的矩阵所有元素累加在一起：

{{{class="brush: scala"
  var sum = 0
  for (xs <- xss; x <- xs) sum += x
}}}

相当于：

{{{class="brush: scala"
  var sum = 0
  xss foreach (xs => 
    xs foreach (x =>
      sum += x))
}}}

== 把高阶函数转为for循环 ==

下面的三个函数是用for循环分别实现`map`、`flatMap`、`filter`的演示：

{{{class="brush: scala"
  object Demo {
    def map[A, B](xs: List[A], f: A => B): List[B] =
      for (x <- xs) yield f(x)

    def flatMap[A, B](xs: List[A], f: A => List[B]): List[B] =
      for (x <- xs; y <- f(x)) yield y

    def filter[A](xs: List[A], p: A => Boolean): List[A] =
      for (x <- xs if p(x)) yield x
  }
}}}

== for的应用 ==

for表达式的实现是基于`map`、`flatMap`、`filter`这些高阶函数。所以可以把for用在
大批量数据上。for可以应用在数组和列表上也是因为这些这两个数组结构实现了这三个
高阶函数，其实可用的还有范围（Range）、迭代器（Iterator）、流（Stream）还有集
（Set）。

如果没有实现那三个方法的话要实现以后才能使用for，具体规则为：

* 有`map`可以用单一生成器。
* 有`flatMap`和`map`可以有多个生成器。
* 有`foreach`可以有单一或多个生成器。
* 有`filter`可以有过滤器。

设一个集合类`C`，典型的方法签名：

{{{class="brush: scala"
  abstract class C[A] {
    def map[B](f: A => B): C[B]
    def flatMap[B](f: A => C[B]): C[B]
    def filter(p: A => Boolean): C[A]
    def foreach(b: A => Unit): Unit
  }
}}}

注意：对于参数类型`A`，方法返回的结果类型为有可能是`A`、`B`或`Unit`。

函数式编程里个概念叫单体（monad）有很广泛地应用，包括从集合、IO操作、状态操作、
回溯计算及交易等。`map`、`flatMap`、`filter`这三个方法可以用来定制单体功能。



