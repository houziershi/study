
%title 线程安全问题

%toc 线程安全问题


= 恢复中断 =

处理异常以后如果应该中断当前线程，应该中断：

{{{class="brush: java"
public class TaskRunnable implements Runnable {
	BlockingQueue<Task> queue;

	//...

	public void run() {
		try {
			processTask(queue.take());
		} catch (InterruptedException e) {
			// 中断当前线程
			Thread.currentThread().interrupt();
		}
	}
}
}}}


= 访问原子性 =

= 封闭 =

限制资源只能在一个线程中被访问。

== 竞争条件 ==

竞争条件（Race Condition）：多个线程以不正确的顺序访问同一资源。

`final`保证字段访问的原子性。

== 监视器模式 ==

* 用一个或多个对象来控制对不同操作锁。
* 对于包含多个变量的不变性每件，要有同一个锁来保护。
* 对于每个会被多个线程访问的对象，注释写明它是由哪个锁来保护的。

=== 锁错对象 ===

同一个原子操作没有锁住同一个对象：

{{{class="brush: java; highlight: [4, 8]"
@NotThreadSafe
public class ListHelper<E> {

	public List<E> list = Collections.synchronizedList(new ArrayList<E>());
		
	// ...
	
	public synchronized boolean putIfAbsent(E x) {
		boolean absent = !list.contains(x);
		if (absent) list.add(x);
		return absent;
	}
}
}}}

虽然是并发安全列表，但列表锁的是列表自己；而方法锁的是对象。

下面这样就对了，应该锁住的是同一个对象：

{{{class="brush: java; highlight: [4,9]"
@ThreadSafe
public class ListHelper<E> {

	public List<E> list = Collections.synchronizedList(new ArrayList<E>());
		
	// ...
	
	public synchronized boolean putIfAbsent(E x) {
		synchronized (list) {
			boolean absent = !list.contains(x);
			if (absent) list.add(x);
			return absent;
		}
	}
}
}}}




= 多线程共享对象 =


== 可见性 ==

对一个目标的操作并不一定通过了内存栅栏。其他的线程看不到这个变化。

用`synchronized`修饰的`getter setter`，用`volatile`声明变量。


== 发布未完成对象 ==

构造函数中使用到的内部类会得到当前对象的引用，等于已经发布出去了。所以不要在
`public`构造函数中使用内部类，如新建线程并启动之类的。

推荐用静态的工厂方法应用到这样的场景。


== 实现单例 ==

提前初始化：

{{{class="brush: java"
Class ConnectionFactory {
	private static Connection conn = new Connection();

	public static Connection getInstance() {
		return conn;
	}
}	
}}}

嫌提前消耗了资源，那用私有内部类实现延迟初始化：

{{{class="brush: java"
Class ConnectionFactory {
	private static class Holder {
		public static Connection conn = new Connection();
	}

	public static Connection getInstance() {
		return Holder.conn;
	}
}	
}}}



== 迭代集合 ==

迭代过程中可能已经被修改。注意`toString`也是基于迭代的。


== 阻塞队列 ==

不能用循环忙等待，标志位退出的方式。可以在队列里放一个特殊成员，读到它就表示
应该退出。

== Copy-on-Write ==

每次修改其实都是做了一个新的副本。



{{{class="brush: java"
}}}



{{{class="brush: java"
}}}



{{{class="brush: java"
}}}



{{{class="brush: java"
}}}



{{{class="brush: java"
}}}



{{{class="brush: java"
}}}



{{{class="brush: java"
}}}



{{{class="brush: java"
}}}



{{{class="brush: java"
}}}



{{{class="brush: java"
}}}



{{{class="brush: java"
}}}



{{{class="brush: java"
}}}



{{{class="brush: java"
}}}



{{{class="brush: java"
}}}


{{{class="brush: java"
}}}



{{{class="brush: java"
}}}



{{{class="brush: java"
}}}



{{{class="brush: java"
}}}



{{{class="brush: java"
}}}



{{{class="brush: java"
}}}



{{{class="brush: java"
}}}



{{{class="brush: java"
}}}



{{{class="brush: java"
}}}



{{{class="brush: java"
}}}



{{{class="brush: java"
}}}



{{{class="brush: java"
}}}



{{{class="brush: java"
}}}


{{{class="brush: java"
}}}






