
%title 线程安全问题

%toc 线程安全问题

= 可见性 =

== 内存栅栏 ==

对一个目标的操作并不一定通过了内存栅栏（比如只是缓存在寄存器中），其他的线程
看不到这个变化。

编译器与处理器会对内存操作的执行顺序进行调整，所以没有办法对内存操作的执行顺序
进行判断。

<img src='images/java.jvm/02.jpg' />


= 访问原子性 =

== 64位非原子性操作 ==

虽然由于可见性原因，可能会读到过期的值。但是最底安全性保证对于大多数变量读写操作
自身是原子性的。但是对于64位的非`volatile`变量如`long`或`double`的读写操作却允许
分解成两个对32位的读写操作。

所以对于被多线程访问的64位变量一定要加`volatile`修饰符。

== 保证可见性与操作原子性 ==

* 用`synchronized`修饰的`getter setter`，保证可见性与操作原子性。
* 用`volatile`声明变量，保证可见性。没有锁速度快，但可见性与安全都不如锁。

`volatile`可以保证自己的修改对其他线程可见，但是不具备原子性，如：`count++`
操作不是原子性的，这种情况下要用并发包下的原子访问类。



= 竞争条件 =

竞争条件（Race Condition）：多个线程以不正确的顺序访问同一资源。

`final`保证字段访问的原子性。

== 锁错对象 ==

同一个原子操作没有锁住同一个对象：

{{{class="brush: java; highlight: [4, 8]"
@NotThreadSafe
public class ListHelper<E> {

	public List<E> list = Collections.synchronizedList(new ArrayList<E>());
		
	// ...
	
	public synchronized boolean putIfAbsent(E x) {
		boolean absent = !list.contains(x);
		if (absent) list.add(x);
		return absent;
	}
}
}}}

虽然是并发安全列表，但列表锁的是列表自己；而方法锁的是对象。

下面这样就对了，应该锁住的是同一个对象：

{{{class="brush: java; highlight: [4,9]"
@ThreadSafe
public class ListHelper<E> {

	public List<E> list = Collections.synchronizedList(new ArrayList<E>());
		
	// ...
	
	public synchronized boolean putIfAbsent(E x) {
		synchronized (list) {
			boolean absent = !list.contains(x);
			if (absent) list.add(x);
			return absent;
		}
	}
}
}}}



= 把对象封闭在线程内 =

线程封闭 :: 限制资源只能在一个线程中被访问。

为了避免同步与锁，尽量把对象封闭在当前线程里不共享出去。常用方法有“栈封闭”和
本地线程变量。

== 栈封闭 ==

把操作的对象封闭在一个栈里（如方法），作为一个局部变量。这样其他线程就访问不到：

{{{class="brush: java"
public int doCount(Collection<Employee> company) {
	int count = 0;
	SortedSet<Employee> empSet = new TreeSet<Employee> (
			new MyComparator()
	);
	empSet.addAll(company);

	for(Employee e : empSet) {
		count += e.getSalary();
	}
}
}}}

上面通过内部引用`empSet`来操作。`empSet`复制了`company`的内容，而且它是局部变量
不会被外部线程访问到。


== 本地线程变量（ThreadLocal） ==

`ThreadLocal`类把内部成员封闭为仅本线程可见。静态的`ThreadLocal`对象可以作为
一种在当前线程里共享对象的方式。例如把数据缓存起来，让本线程里的其他模块可以
共享。





= 把对象共享给其他线程 =


== 不可变对象 ==

不可变对象一定是线程安全的。

=== Final字段 ===

`final`修饰符不仅表示字段不可变，类不可被继承，还表示字段的初始化过程的安全性。
所以`final`字段可以不受限制访问，无需要同步。

=== volatile字段组合不可变类 ===

我们的`User`类是不可变的，因为它的字段都是`final`的，通过构造函数初始化：

{{{class="brush: java"
class User {
	private final String id;
	private final String name;
	
	public User(String name, String id) {
		this.id = id;
		this.name = name;
	}
}
}}}

在因为本身是不可变的，在使用它的地方再用`volatile`修饰了以后就很安全，不用加锁：

{{{class="brush: java"
public class Company {

	private volatile User boss = new User('A001', 'Big Boss');
	
	// ...

}
}}}


== 发布未完成对象 ==

构造函数中使用到的内部类会得到当前对象的引用，等于已经发布出去了。所以不要在
`public`构造函数中使用内部类，如：新建线程并启动、创建监听器之类的。

推荐用静态的工厂方法应用到这样的场景。如：

{{{class="brush: java"
public class SafeListener {
	private final EventListener listener;

	private SafeListener() {
		listener = new EventListener() {
			public void onEvent(Event e) {
				// ...
			}
		};
	}
	
	public static SafeListener newInstance(EventSource source) {
		SaftListener safe = new SafeListener();
		source.registerListener(safe.listener);
		return safe;
	}

}
}}}


== 实现单例 ==

=== 提前初始化 ===

Eager Initialization：

{{{class="brush: java"
Class ConnectionFactory {
	private static Connection conn = new Connection();

	public static Connection getInstance() {
		return conn;
	}
}	
}}}

=== 延迟初始化 ===

嫌提前消耗了资源，那用延迟初始化（lazy initialization）：

{{{class="brush: java"
public class Singleton {
	private static final Singleton instance;

	private Singleton() {
	}

	public static synchronized Singleton getInstance() {
		if (instance ==null) {
			instance = new Singleton();
		}
		return instance;
	}
}
}}}

==== 错误的方式 ====

功能上OK了，但是同步代码性能开销大。有些优化方案是有线程安全隐患的：

{{{class="brush: java; highlight:[11]"
public class Singleton {
	private static final Singleton instance;

	private Singleton() {
	}

	public static Singleton getInstance() {
		if (instance == null) {           // 第一次检查
			synchronized(Singleton.class) { // 加锁
				if (instance ==null) {        // 第二次检查
					instance = new Singleton(); // 问题的根源在这里
				}
			}
		}
		return instance;
	}
}
}}}

问题在于在线程执行到读取到`instance`不为`null`时，`instance`有可能还没有完成
初始化。`instance = new Singleton();`创建一个单例对象。这一行代码可以分解为如下
的三行伪代码：

{{{class="brush: java"
memory = allocate();     // 分配单例对象的内存空间
ctorSingleton(instance); // 初始化单例对象
instance = memory;       // 设置instance指向刚放分配的内存地址
}}}

java语言规范允2和3重排序，而且在一些JIT编译器上，这种重排序是真实发生的。重排序
之后的伪代码如下：

{{{class="brush: java"
memory = allocate();     // 分配单例对象的内存空间
instance = memory;       // 设置instance指向刚放分配的内存地址
ctorSingleton(instance); // 初始化单例对象
}}}

在计算机中，编译器和处理器都要遵守as-if-serial语义。as-if-serial语义的本质是保证
重排序不能改变单线程/单处理器内的程序执行结果。假设一个线程A在构造单例对象后，
立即访问这个单例对象。下面是对应的示意图：

<img src="images/java.currency/singleton/01.png" />

如上图所示，只要保证4排在2的前面，即使2和3之间重排序了，也不会改变单线程内的执行
语义。这里2和3的重排序即没有改变程序的执行结果，又可以提高程序的执行性能。

下面，让我们看看多线程并发执行的时候的情况。请看下面的示意图：

<img src="images/java.currency/singleton/02.png" />

虽然因为编译器和处理器都要遵守as-if-serial语义，从而能保证A线程的执行语义不会被
改变。但是当线程A和B按上图的时序执行时，B线程将看到一个还没有被初始化的对象。

回到本文的主题`instance = new Singleton();`如果发生重排序，另一个并发执行的
线程B就有可能在判断中返回`false`。线程B接下来将访问单例对象，但此时这个对象还
没有被A线程初始化！

在知晓了问题发生的根源之后，我们可以发现解决这个问题的办法由两个：

* 不允许2和3重排序；
* 允许2和3重排序，但不允许其他线程“看到”这个重排序。

两个解决方案分别对应于上面两点。

==== 基于volatile修正方案 ====

{{{class="brush: java"
public class Singleton {
	private volatile static final Singleton instance;

	private Singleton() {
	}

	public static Singleton getInstance() {
		if (instance == null) {           // 第一次检查
			synchronized(Singleton.class) { // 加锁
				if (instance ==null) {        // 第二次检查
					instance = new Singleton(); // 现在没问题了
				}
			}
		}
		return instance;
	}
}
}}}

如上面示例代码所示，我们只需要把单例对象的引用设置为`volatile`，就可以解决问题。
从JDK5开始的JSR-133内存模型规范增强了`volatile`的语义：JDK5之前，允许`volatile`
变量与普通变量重排序；从JDK5开始，不允许`volatile`变量与普通变量重排序。

当声明单例对象的引用为`volatile`后，三行伪代码中的2和3之间的重排序，在多线程环境
中将会被禁止。上面示例代码将按如下时序执行：

<img src="images/java.currency/singleton/03.png" />

事实上，这里线程A初始化单例对象，和线程B初次访问这个单例对象，这两个操作之间存在
happens-before关系。

这个解决方案本质上是通过禁止2和3中的重排序，来保证多线程正确并发执行。

==== 基于静态初始化 ====

JVM在类的初始化阶段（即在Class被加载后，被线程使用之前），会执行静态初始化。在
执行静态初始化期间，JVM会去获取一个锁。这个锁可以同步多个线程同时对一个类的
初始化。

基于这个特性，可以实现另一种延迟初始化单例对象的方案：

{{{class="brush: java"
public class Singleton {
private static class LazyHolder{
    public static Singleton instance = new Singleton ();
}

private Singleton() {
}

public static synchronized Singleton getInstance() {
    return LazyHolder. Instance;
}
}}}

假设两个线程并发执行`getInstance()`，下面是示意图：

<img src="images/java.currency/singleton/04.png" />

这个方案的本质是：允许2和3重排序，但不允许非构造线程（这里指线程B）看到这个
重排序。

==== 基于私有内部类静态初始化 ====

同理也可以用私有内部类实现延迟初始化

{{{class="brush: java"
Class ConnectionFactory {
	private static class Holder {
		public static Connection conn = new Connection();
	}

	public static Connection getInstance() {
		return Holder.conn;
	}
}	
}}}


== 安全地把对象发布给其他的线程 ==

=== 线程安全容器 ===

存入线程安全的容器（`HashTable`、`SynchronizedMap`、`ConcurrentMap`、`Vector`、
`CopyOnWriteArrayList`、`CopyOnWriteArraySet`、`SynchronizedList`、
`SynchronizedSet`、`BlockingQueue`、`ConcurrentLinkedQueue`）中，其他线程再通过
这些容器取得对象。这样的过程是安全的。




= 设计出线程安全的类 =

== 收集同步需求 ==

不可变条件 :: 判断状态是否有效。

如：性别可取的值只用“男”、“女”、“未知”，计数器的值必须是正整数。

后验证条件 :: 根据前一个状态判断后一个状态是否有效。

计数器当前值是17，更新操作以后的值一定是18。相反温度计当前是18度，更新以后的值
和当前温度就没有太大关系。

所以为了确保线程安全性就一定要了解对象的不可变条件与后验证条件，为了实现这种种
约束就要借助于原子性与封装性。

== 封闭非线程安全的字段 ==

如果对象的成员不是线程安全类的，那就把它封闭在内里不要让外部能够访问到它。也
不要反它传递到类外部去。


== 监视器模式 ==

把多个非线程安全的类作为字段组成一个类时，监视器模式很有用。

* 用一个或多个对象来控制对不同操作锁。
* 对于包含多个变量的不变性每件，要有同一个锁来保护。
* 对于每个会被多个线程访问的对象，注释写明它是由哪个锁来保护的。


== 线程安全的委托 ==

多个线程安全的类作为字段组成一个类，新的类不一定是线程安全的。

=== 单个线程安全成员 ===

如果计数器`Conter`类只有一个成员，是`AtomicLong`类的`currNum`。那么计数器是线程
安全的，相当于把增加计数操作的线程安全性“委托”给了这个线程安全成员。


{{{class="brush: java"
public class Counter {
    private final AtomicInteger currNum = new AtomicInteger(0);

    public void increase() {
			this.currNum.getAndIncrement();
    }
}
}}}


=== 多个独立状态的线程安全成员 ===

如果多个线程安全成员的状态是相互独立的话，并不会给新合成的类增加任何不变性条件。
所以线程安全性还是安全委托给了这多个独立的成员。


=== 多个相关状态的线程安全成员 ===

如果多个线程安全成员的状态是相互关联的话，就不是线程安全的。

如下面的代码两个字段分别代表“上限”与“下限”。所以有了新的不变性条件就是下限一定
要大于上限：

{{{class="brush: java"
public class NumberRange {
    // INVARIANT: lower <= upper
    private final AtomicInteger lower = new AtomicInteger(0);
    private final AtomicInteger upper = new AtomicInteger(0);

    public void setLower(int i) {
        // Warning -- unsafe check-then-act
        if (i > upper.get())
            throw new IllegalArgumentException("can't set lower to " 
								+ i + " > upper");
        lower.set(i);
    }

    public void setUpper(int i) {
        // Warning -- unsafe check-then-act
        if (i < lower.get())
            throw new IllegalArgumentException("can't set upper to " + i 
								+ " < lower");
        upper.set(i);
    }

    public boolean isInRange(int i) {
        return (i >= lower.get() && i <= upper.get());
    }
}
}}}

所以就要有锁来控制不变性条件。

=== 发布线程安全的成员变量 ===

如果成员变量是线程安全的，那是否可以把这个成员共享给其他线程？这还是决定于
不变性条件。

还是以前面的计数器为例子：

{{{class="brush: java"
public class Counter {
    private final AtomicInteger currNum = new AtomicInteger(0);

    public void increase() {
			this.currNum.getAndIncrement();
    }
}
}}}

`currNum`每次必须加一，这是不变性条件。如果发布到了外面其他线程可能乱改。


== 扩展现有的类 ==

=== 继承 ===

继承一个已经是线程安全的类：

如：给`Vector`添加“没有则添加”方法：

{{{class="brush: java"
@ThreadSafe
public class BetterVecotr<E> extends Vector<E> {

	public synchronized boolean putIfAbsent(E x) {
		boolean absent = !this.contains(x);
		if (absent)
			this.add(x);
		return absent;
	}
}
}}}

这样线程安全上没有问题，但代码风格上有问题：把实现分开放到了两个类里。

=== 包上工具类 ===

有的时候类是`final`的，不可以被继承。所以只能包上工具类：

{{{class="brush: java"
@ThreadSafe
public class ListHelper<E> {
	public List<E> list = Collections.synchronizedList(new ArrayList<E>());

	public synchronized boolean putIfAbsent(E x) {
		synchronized (list) {
			boolean absent = !list.contains(x);
			if (absent)
				list.add(x);
			return absent;
		}
	}

}
}}}

这样线程安全上没有问题，但代码风格上有问题：把实现分开放到了两个类里。


=== 组合新类 ===

不依赖其他类是否是线程安全的，全部都自己来维护线程安全性。

下面的版本接收一个非线程安全的`List`，虽然外部其他对这个`List`的操作是非线程
安全的，但通过我们这里提供了一个原子性的“没有则添加”接口。

{{{class="brush: java"
@ThreadSafe
public class ImprovedList<T> implements List<T> {
	public final List<E> list;
	
	public ImprovedList(List<t> list) {
		this.list = list;
	}

	public synchronized boolean putIfAbsent(T x) {
		boolean absent = !list.contains(x);
		if (absent)
			list.add(x);
		return absent;
	}

}
}}}


= 同步容器类 =


迭代非线程安全集合会抛出`ConcurrentModifyException`。


== 迭代集合 ==

即使是同步的容器，在迭代过程中也可能已经被修改。注意`toString`也是基于迭代的。

{{{class="brush: java"
}}}

== Copy-on-Write ==

每次修改其实都是做了一个新的副本。


{{{class="brush: java"
}}}



{{{class="brush: java"
}}}



{{{class="brush: java"
}}}



{{{class="brush: java"
}}}



{{{class="brush: java"
}}}



{{{class="brush: java"
}}}



{{{class="brush: java"
}}}



{{{class="brush: java"
}}}


{{{class="brush: java"
}}}



{{{class="brush: java"
}}}



{{{class="brush: java"
}}}



{{{class="brush: java"
}}}



{{{class="brush: java"
}}}



{{{class="brush: java"
}}}



{{{class="brush: java"
}}}



{{{class="brush: java"
}}}



{{{class="brush: java"
}}}



{{{class="brush: java"
}}}



{{{class="brush: java"
}}}



{{{class="brush: java"
}}}



{{{class="brush: java"
}}}


{{{class="brush: java"
}}}




























