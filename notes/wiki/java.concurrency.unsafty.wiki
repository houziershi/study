
%title 线程安全问题

%toc 线程安全问题

= 可见性 =

== 内存栅栏 ==

对一个目标的操作并不一定通过了内存栅栏（比如只是缓存在寄存器中），其他的线程
看不到这个变化。

编译器与处理器会对内存操作的执行顺序进行调整，所以没有办法对内存操作的执行顺序
进行判断。




= 访问原子性 =

== 64位非原子性操作 ==

虽然由于可见性原因，可能会读到过期的值。但是最底安全性保证对于大多数变量读写操作
自身是原子性的。但是对于64位的非`volatile`变量如`long`或`double`的读写操作却允许
分解成两个对32位的读写操作。

所以对于被多线程访问的64位变量一定要加`volatile`修饰符。

== 保证可见性与操作原子性 ==

* 用`synchronized`修饰的`getter setter`，保证可见性与操作原子性。
* 用`volatile`声明变量，保证可见性。没有锁速度快，但可见性与安全都不如锁。

`volatile`可以保证自己的修改对其他线程可见，但是不具备原子性，如：`count++`
操作不是原子性的，这种情况下要用并发包下的原子访问类。



= 竞争条件 =

竞争条件（Race Condition）：多个线程以不正确的顺序访问同一资源。

`final`保证字段访问的原子性。

== 锁错对象 ==

同一个原子操作没有锁住同一个对象：

{{{class="brush: java; highlight: [4, 8]"
@NotThreadSafe
public class ListHelper<E> {

	public List<E> list = Collections.synchronizedList(new ArrayList<E>());
		
	// ...
	
	public synchronized boolean putIfAbsent(E x) {
		boolean absent = !list.contains(x);
		if (absent) list.add(x);
		return absent;
	}
}
}}}

虽然是并发安全列表，但列表锁的是列表自己；而方法锁的是对象。

下面这样就对了，应该锁住的是同一个对象：

{{{class="brush: java; highlight: [4,9]"
@ThreadSafe
public class ListHelper<E> {

	public List<E> list = Collections.synchronizedList(new ArrayList<E>());
		
	// ...
	
	public synchronized boolean putIfAbsent(E x) {
		synchronized (list) {
			boolean absent = !list.contains(x);
			if (absent) list.add(x);
			return absent;
		}
	}
}
}}}



= 把对象封闭在线程内 =

线程封闭 :: 限制资源只能在一个线程中被访问。

为了避免同步与锁，尽量把对象封闭在当前线程里不共享出去。常用方法有“栈封闭”和
本地线程变量。

=== 栈封闭 ===

把操作的对象封闭在一个栈里（如方法），作为一个局部变量。这样其他线程就访问不到：

{{{class="brush: java"
public int doCount(Collection<Employee> company) {
	int count = 0;
	SortedSet<Employee> empSet = new TreeSet<Employee> (
			new MyComparator()
	);
	empSet.addAll(company);

	for(Employee e : empSet) {
		count += e.getSalary();
	}
}
}}}

上面通过内部引用`empSet`来操作。`empSet`复制了`company`的内容，而且它是局部变量
不会被外部线程访问到。


=== 本地线程变量（ThreadLocal） ===

`ThreadLocal`类把内部成员封闭为仅本线程可见。静态的`ThreadLocal`对象可以作为
一种在当前线程里共享对象的方式。例如把数据缓存起来，让本线程里的其他模块可以
共享。





= 把对象共享给其他线程 =


== 不可变对象 ==

不可变对象一定是线程安全的。

=== Final字段 ===

`final`修饰符不仅表示字段不可变，类不可被继承，还表示字段的初始化过程的安全性。
所以`final`字段可以不受限制访问，无需要同步。

=== volatile字段组合不可变类 ===

我们的`User`类是不可变的，因为它的字段都是`final`的，通过构造函数初始化：

{{{class="brush: java"
class User {
	private final String id;
	private final String name;
	
	public User(String name, String id) {
		this.id = id;
		this.name = name;
	}
}
}}}

在因为本身是不可变的，在使用它的地方再用`volatile`修饰了以后就很安全，不用加锁：

{{{class="brush: java"
public class Company {

	private volatile User boss = new User('A001', 'Big Boss');
	
	// ...

}
}}}


== 发布未完成对象 ==

构造函数中使用到的内部类会得到当前对象的引用，等于已经发布出去了。所以不要在
`public`构造函数中使用内部类，如：新建线程并启动、创建监听器之类的。

推荐用静态的工厂方法应用到这样的场景。如：

{{{class="brush: java"
public class SafeListener {
	private final EventListener listener;

	private SafeListener() {
		listener = new EventListener() {
			public void onEvent(Event e) {
				// ...
			}
		};
	}
	
	public static SafeListener newInstance(EventSource source) {
		SaftListener safe = new SafeListener();
		source.registerListener(safe.listener);
		return safe;
	}

}
}}}


== 实现单例 ==

提前初始化：

{{{class="brush: java"
Class ConnectionFactory {
	private static Connection conn = new Connection();

	public static Connection getInstance() {
		return conn;
	}
}	
}}}

嫌提前消耗了资源，那用私有内部类实现延迟初始化：

{{{class="brush: java"
Class ConnectionFactory {
	private static class Holder {
		public static Connection conn = new Connection();
	}

	public static Connection getInstance() {
		return Holder.conn;
	}
}	
}}}


== 安全地把对象发布给其他的线程 ==

=== 线程安全容器 ===

存入线程安全的容器（`HashTable`、`SynchronizedMap`、`ConcurrentMap`、`Vector`、
`CopyOnWriteArrayList`、`CopyOnWriteArraySet`、`SynchronizedList`、
`SynchronizedSet`、`BlockingQueue`、`ConcurrentLinkedQueue`）中，其他线程再通过
这些容器取得对象。这样的过程是安全的。




= 设计出线程安全的类 =

== 收集同步需求 ==

不可变条件 :: 判断状态是否有效。

如：性别可取的值只用“男”、“女”、“未知”，计数器的值必须是正整数。

后验证条件 :: 根据前一个状态判断后一个状态是否有效。

计数器当前值是17，更新操作以后的值一定是18。相反温度计当前是18度，更新以后的值
和当前温度就没有太大关系。

所以为了确保线程安全性就一定要了解对象的不可变条件与后验证条件，为了实现这种种
约束就要借助于原子性与封装性。

== 封闭非线程安全的字段 ==

如果对象的成员不是线程安全类的，那就把它封闭在内里不要让外部能够访问到它。也
不要反它传递到类外部去。


== 监视器模式 ==

把多个非线程安全的类作为字段组成一个类时，监视器模式很有用。

* 用一个或多个对象来控制对不同操作锁。
* 对于包含多个变量的不变性每件，要有同一个锁来保护。
* 对于每个会被多个线程访问的对象，注释写明它是由哪个锁来保护的。


== 线程安全的委托 ==

多个线程安全的类作为字段组成一个类，新的类不一定是线程安全的。

=== 单个线程安全成员 ===

如果计数器`Conter`类只有一个成员，是`AtomicLong`类的`currNum`。那么计数器是线程
安全的，相当于把增加计数操作的线程安全性“委托”给了这个线程安全成员。


{{{class="brush: java"
public class Counter {
    private final AtomicInteger currNum = new AtomicInteger(0);

    public void increase() {
			this.currNum.getAndIncrement();
    }
}
}}}


=== 多个独立状态的线程安全成员 ===

如果多个线程安全成员的状态是相互独立的话，并不会给新合成的类增加任何不变性条件。
所以线程安全性还是安全委托给了这多个独立的成员。


=== 多个相关状态的线程安全成员 ===

如果多个线程安全成员的状态是相互关联的话，就不是线程安全的。

如下面的代码两个字段分别代表“上限”与“下限”。所以有了新的不变性条件就是下限一定
要大于上限：

{{{class="brush: java"
public class NumberRange {
    // INVARIANT: lower <= upper
    private final AtomicInteger lower = new AtomicInteger(0);
    private final AtomicInteger upper = new AtomicInteger(0);

    public void setLower(int i) {
        // Warning -- unsafe check-then-act
        if (i > upper.get())
            throw new IllegalArgumentException("can't set lower to " 
								+ i + " > upper");
        lower.set(i);
    }

    public void setUpper(int i) {
        // Warning -- unsafe check-then-act
        if (i < lower.get())
            throw new IllegalArgumentException("can't set upper to " + i 
								+ " < lower");
        upper.set(i);
    }

    public boolean isInRange(int i) {
        return (i >= lower.get() && i <= upper.get());
    }
}
}}}

所以就要有锁来控制不变性条件。

=== 发布线程安全的成员变量 ===

如果成员变量是线程安全的，那是否可以把这个成员共享给其他线程？这还是决定于
不变性条件。

还是以前面的计数器为例子：

{{{class="brush: java"
public class Counter {
    private final AtomicInteger currNum = new AtomicInteger(0);

    public void increase() {
			this.currNum.getAndIncrement();
    }
}
}}}

`currNum`每次必须加一，这是不变性条件。如果发布到了外面其他线程可能乱改。


== 扩展现有的类 ==

=== 继承 ===

继承一个已经是线程安全的类：

如：给`Vector`添加“没有则添加”方法：

{{{class="brush: java"
@ThreadSafe
public class BetterVecotr<E> extends Vector<E> {

	public synchronized boolean putIfAbsent(E x) {
		boolean absent = !this.contains(x);
		if (absent)
			this.add(x);
		return absent;
	}
}
}}}

这样线程安全上没有问题，但代码风格上有问题：把实现分开放到了两个类里。

=== 包上工具类 ===

有的时候类是`final`的，不可以被继承。所以只能包上工具类：

{{{class="brush: java"
@ThreadSafe
public class ListHelper<E> {
	public List<E> list = Collections.synchronizedList(new ArrayList<E>());

	public synchronized boolean putIfAbsent(E x) {
		synchronized (list) {
			boolean absent = !list.contains(x);
			if (absent)
				list.add(x);
			return absent;
		}
	}

}
}}}

这样线程安全上没有问题，但代码风格上有问题：把实现分开放到了两个类里。


=== 组合新类 ===

不依赖其他类是否是线程安全的，全部都自己来维护线程安全性。

下面的版本接收一个非线程安全的`List`，虽然外部其他对这个`List`的操作是非线程
安全的，但通过我们这里提供了一个原子性的“没有则添加”接口。

{{{class="brush: java"
@ThreadSafe
public class ImprovedList<T> implements List<T> {
	public final List<E> list;
	
	public ImprovedList(List<t> list) {
		this.list = list;
	}

	public synchronized boolean putIfAbsent(T x) {
		boolean absent = !list.contains(x);
		if (absent)
			list.add(x);
		return absent;
	}

}
}}}


= 同步容器类 =


迭代非线程安全集合会抛出`ConcurrentModifyException`。


== 迭代集合 ==

即使是同步的容器，在迭代过程中也可能已经被修改。注意`toString`也是基于迭代的。

{{{class="brush: java"
}}}

== Copy-on-Write ==

每次修改其实都是做了一个新的副本。


{{{class="brush: java"
}}}



{{{class="brush: java"
}}}



{{{class="brush: java"
}}}



{{{class="brush: java"
}}}



{{{class="brush: java"
}}}



{{{class="brush: java"
}}}



{{{class="brush: java"
}}}



{{{class="brush: java"
}}}


{{{class="brush: java"
}}}



{{{class="brush: java"
}}}



{{{class="brush: java"
}}}



{{{class="brush: java"
}}}



{{{class="brush: java"
}}}



{{{class="brush: java"
}}}



{{{class="brush: java"
}}}



{{{class="brush: java"
}}}



{{{class="brush: java"
}}}



{{{class="brush: java"
}}}



{{{class="brush: java"
}}}



{{{class="brush: java"
}}}



{{{class="brush: java"
}}}


{{{class="brush: java"
}}}




























