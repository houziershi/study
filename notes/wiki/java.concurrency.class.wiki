
%title 并发方案

%toc 并发方案


= 原子操作 =

== 原子操作类 ==

`java.utils.concurrent.atomic`包装器把对象包装成原子操作。

`AtomicLong`类的原子方法`incrementAndGet()`和`decresmentAndGet()`。

== 原子包装器 ==

包装集合为不可变版本：`Collections.unmodifiableLists(list)`

包装同步版：`SynchronizedMap m = Collection.SynchronizedMap(new HashMap())`

把一个引用包装成原子访问：

{{{class="brush: java"
private final AtomicReferency<BigInteger> lastNumber = 
	new AtomicReferency<BigInteger>()
	
private final AtomicReferency<BigInteger> firstNumber = 
	new AtomicReferency<BigInteger>()
}}}

但注意上面的例子，虽然每个数字的访问是原子性的，但一起操作两个数字的方法不是
线程安全的。



= 并发容器 =

Java 5中新加入的并发类为并发环境进行了优化。`Queue`和`BlockingQueue`实现了队列，

`CuncurrentHashMap`实现并发Map。

Java 6引入了`ConcurrentSkipListMap`和`ConcurrentSkipListSet`对应`Sortedmap`和
`SortedSet`。

并发容器的迭代器不会抛出`ConcurrentModificationExcetpion`，可以不加锁就进行迭代
。这样的迭代器具有弱一致性（Weakly Consistent），而不是“及时失败”。弱一致性可以
容忍并发的修改，当创建迭代器时会遍历已有的元素，并可以（但不保证）在迭代器被构造
后将修改操作反映给容器。

对于并发容器来说`size`或`isEmpty`这样的方法返回的结果可能是已经过期的结果。但
在并发环境下这样的状态总是在不断变化的，所以这样的方法意义不大。

== 并发队列 ==

常用队列：

* `Queue`不阻塞，空时取返回空；满时放抛异常。
* `SynchrousQueue`会同步插入与删除操作。
* `BlockingQueue`存取操作会阻塞。
* `PriorityBlockingQueue`带优先级的队列。


=== 阻塞队列 ===

简单的阻塞队列可以用`LinkedblockingQueue`或`ArrayBlockingQueue`。

对于队列空取或满存的情况有四种策略：

* 抛出异常。
* 特殊值。空取时为`null`；满存时为`false`。
* 阻塞。
* 超时。只会阻塞指定的时间。

|      | 抛出异常  | 特殊值   | 阻塞   | 超时                 |
| 插入 | add(e)    | offer(e) | put(e) | offer(e, time, unit) |
| 移除 | remove()  | poll()   | take() | poll(time, unit)     |
| 检查 | element() | peek()   | 不可用 | 不可用               |

=== 饱和策略 ===

* `Abort`：抛异常，调用者处理异常。
* `Discard`：丢掉任务。
* `DiscardOlds`：丢掉最老的任务。
* `DiscardPolicy`：丢掉优先级最低的。
* `Caller_Runs`：不抛异常，退回给调用者。用一个`execute()`执行它。

=== 队列工作的问题 ===

请求来太快了把等待队列也占满了。太长或是无限的队列，用`SynchronizeQueue`避免
队列任务。它不是真的队列而是一个移交机制（相当于只有一个容量的队列），前一个
请求没有处理完后一个请求会被拒绝。

阻塞队列不能用循环忙等待，标志位退出的方式。可以在队列里放一个特殊成员，读到它
就表示应该退出。



== ConcurrentHashMap ==

`ConcurrentHashMap`等为并发环境设计。为了优化性能不只用了一个锁，而是采用分段锁
（Lock Striping），所以增加了并发性能。

`ConcurrentHashMap`是为了强化并发环境下使用，所以没有办法对它的`Map`加锁以独占
访问。这是弱化独占访问而加强了`get`、`put`、`containsKey`、`remove`等方法的
并发性的取舍。


=== 额外的原子操作 ===

虽然不能加锁独占方问，但为一些复合操作为提供了原子操作。如：“没有则添加”、“相等
则替换”。

{{{class="brush: java"
public interface ConcurrentMap<K,V> extends Map<K,V> {

	// Insert into map only if no value is mapped from K
	V putIfAbsent(K key, V value);

	// Remove only if K is mapped to V
	boolean remove(K key, V value);

	// Replace value only if K is mapped to oldValue
	boolean replace(K key, V oldValue, V newValue);

	// Replace value only if K is mapped to some value
	V replace(K key, V newValue);

}
}}}



= 应用：生产者－消费者模式 =

利用队列实现生产者－消费者模式。

== 双端队列与工作密取 ==

工作密取模式：生产者生成任务加到任务队列中，消费者在处理过程中会产生新的任务。
所以消费都也可以把任务加到工作队列中。

例如：对于网络爬虫来说，一个链接就是一个任务。爬虫把链接加入到队列中，解析器在
解析网页时会发现网页上有的链接，这又是新的任务。解析器要把新的链接再加到队列中
去。

Java 6增加了两种容器类型`Deque`（发音为deck）与`BlockingDeque`，分别对应`Queue`
和`BlockingQueue`扩展为双端队列，可以实现工作密取模式。

== 恢复中断 ==

必须处理`InterruptedException`，不然其他的线程就没有办法中断当前线程了：

{{{class="brush: java"
public class TaskRunnable implements Runnable {
	BlockingQueue<Task> queue;

	//...

	public void run() {
		try {
			processTask(queue.take());
		} catch (InterruptedException e) {
			// 中断当前线程
			Thread.currentThread().interrupt();
		}
	}
}
}}}



= 信号量（Semaphore） =

信号量控制访问的总数。它的操作提原子的：

* 指定资源的总量：`Semaphore sem = new Semaphore(num);`
* 新访问记录占用资源：`sem.acquire();`
* 结束后记录放开资源：`sem.release();`



= 闭锁（Latch） =

Latch让多个线程等待把准备工作完成，再一起向下执行。

`CountDownLatch`是一个实现，通过计数器来控制：

* 子线程调用`countDown`方法把计数器减1。
* 主线程调用`await`方法等待，等计数器到0了启动。

在任务没有返回值的情况下，`CountDownLatch`比用`Future`更合适。

例：在计时测试中使用`CountDownLatch`来启动与停止线程：

{{{class="brush: java; highlight: [11, 13, 25, 26]"
public class TestHarness {
	public long timeTasks(int nThreads, final Runnable task)
			throws InterruptedException {
		final CountDownLatch startGate = new CountDownLatch(1);
		final CountDownLatch endGate = new CountDownLatch(nThreads);

		for (int i = 0; i < nThreads; i++) {
			Thread t = new Thread() {
				public void run() {
					try {
						startGate.await();
						try {
							task.run();
						} finally {
							endGate.countDown();
						}
					} catch (InterruptedException ignored) {
					}
				}
			};
			t.start();
		}

		long start = System.nanoTime();
		startGate.countDown();
		endGate.await();
		long end = System.nanoTime();
		return end - start;
	}
}
}}}





= 栅栏（Barrier） =

栅栏和闭锁一样也是控制一组线程，闭锁到一终止状态不能再重新复位了。闭锁用于等待
事件，而栅栏用于等待其他线程。

栅栏的实现类`CyclicBarrier`可以重复使用，在迭代算法中非常有用。把一个问题分成
多个子问题。

当线程到了栅栏位置以后调用`await`方法阻塞，等待所有线程都到了栅栏后放开栅栏一起
继续执行。栅栏也被复位以备下次使用；

如果`await`阻塞超时或是线程被中断，那么就认为栅栏被破坏了。所有阻塞的`await`会
抛出`BrokenBarrierException`。

如果成功通过栅栏，那么`await`会给每个线程发一个唯一的索引号，可以在索引中选一个
领导线程，由它在下一轮中执行一些特殊的工作。

`CyclicBarrier`的构造函数还可以接收一个`Runnable`，并在成功通过栅栏时在一个
子任务执行它。但是在线程被释放之前是不能执行的。

以一个细胞游戏为例子，在一个N*N的棋盘上，把整个棋盘分成多个小棋盘并行执行。：

{{{class="brush: java; highlight: [4, 10, 30]"
public class CellularAutomata {

	private final Board mainBoard;
	private final CyclicBarrier barrier;
	private final Worker[] workers;

	public CellularAutomata(Board board) {
		this.mainBoard = board;
		int count = Runtime.getRuntime().availableProcessors();
		this.barrier = new CyclicBarrier(count,
				new Runnable() {
					public void run() {
						mainBoard.commitNewValues();
					}});
		this.workers = new Worker[count];
		for (int i = 0; i < count; i++)
			workers[i] = new Worker(mainBoard.getSubBoard(count, i));
	}

	private class Worker implements Runnable {
		private final Board board;

		public Worker(Board board) { this.board = board; }
		public void run() {
			while (!board.hasConverged()) {
				for (int x = 0; x < board.getMaxX(); x++)
					for (int y = 0; y < board.getMaxY(); y++)
						board.setNewValue(x, y, computeValue(x, y));
				try {
					barrier.await();
				} catch (InterruptedException ex) {
					return;
				} catch (BrokenBarrierException ex) {
					return;
				}
			}
		}

		private int computeValue(int x, int y) {
			// Compute the new value that goes in (x,y)
			return 0;
		}
	}

	public void start() {
		for (int i = 0; i < workers.length; i++)
			new Thread(workers[i]).start();
		mainBoard.waitForConvergence();
	}

	interface Board {
		int getMaxX();
		int getMaxY();
		int getValue(int x, int y);
		int setNewValue(int x, int y, int value);
		void commitNewValues();
		boolean hasConverged();
		void waitForConvergence();
		Board getSubBoard(int numPartitions, int index);
	}

}
}}}



= Callable =

`Runnable`不能有返回值、也不能抛出异常，所以`Callable`更加好。`Callable`相当于
可以有返回结果的`Runnable`。例如一个返回`void`的`Callable`就是`Callable<void>`
。而且`Runnable`只能抛出非受检查异常，而`Callable`可以抛出受检查或非受检查异常。

`Callable`的接口方法是`call()`。如果想要一个在运行后有返回值是`void`类型的话
可以这样：`Callable<Void>`。



= Future =

`FutureTask`实现了`Future`语义，表示一个会有结果的计算。计算过程是通过`Callable`
接口实现的。`FutureTask`可以三种状态：

* 等待运行。
* 正在运行。
* 已经完成。

当任务处于完成状态以后就一直停在这个状态了。

`Future`通过`get`方法取得计算结果。取结果的行为取决于状态：

* 如果任务已经完成`get`会立即返回结果。
* 如果还没有完成就阻塞等待。然后成功返回结果或是抛异常。

`FutureTask`确保安全地计算结果从执行计算的线程传递到需要结果的线程。

如下面用`Future`来处理会花费大量时间的数据库访问任务：

{{{class="brush: java; highlight: [6, 19, 20]"
public class Preloader {
	ProductInfo loadProductInfo() throws DataLoadException {
		return null;
	}

	private final FutureTask<ProductInfo> future =
		new FutureTask<ProductInfo>(new Callable<ProductInfo>() {
			public ProductInfo call() throws DataLoadException {
				return loadProductInfo();
			}
		});
	private final Thread thread = new Thread(future);

	public void start() { thread.start(); }

	public ProductInfo get()
			throws DataLoadException, InterruptedException {
		try {
			return future.get();
		} catch (ExecutionException e) {
			Throwable cause = e.getCause();
			if (cause instanceof DataLoadException)
				throw (DataLoadException) cause;
			else
				throw LaunderThrowable.launderThrowable(cause);
		}
	}

	interface ProductInfo { }
}

class DataLoadException extends Exception { }
}}}

`Callable`会抛出异常，并且任何代码都会抛出`Error`。无论抛出了什么在`Future.get`
里都会被封装成`ExecutionException`以及`CancellationException`。由于这里抛出的
类型都是被作为`Throwable`返回的，所以处理起来有些复杂：

因为要判断抛出的类型是`CheckedException`？`RuntimeException`？还是`Error`？

如果是我们预想中的`DataLoadException`，走我们预计的处理方式。其他的可能性用
下面的工具类`LaunderThrowable`来处理异常。它会把强制把未检查的异常转为
`RuntimeException`：

{{{class="brush: java"
public class LaunderThrowable {
	/**
	 * Coerce an unchecked Throwable to a RuntimeException
	 * <p/>
	 * If the Throwable is an Error, throw it; if it is a
	 * RuntimeException return it, otherwise throw IllegalStateException
	 */
	public static RuntimeException launderThrowable(Throwable t) {
		if (t instanceof RuntimeException)
			return (RuntimeException) t;
		else if (t instanceof Error)
			throw (Error) t;
		else
			throw new IllegalStateException("Not unchecked", t);
	}
}
}}}

== 结合Future与CurrentMap实现缓存 ==

先定义一个接口`Computable`，`A`为输入类型，`V`为输出类型。接口方法`compute`是
计算主逻辑：

{{{class="brush: java"
public interface Computable<A, V> {
	V compute(A arg) throws InterruptedException;
}
}}}

带缓存的计算功能可以实现这个接口。通过`CurrentMap`的`putIfAbsent`实现原子性的
“没有则添加”；用`Future`表示计算正在执行，避免重计算同一个值：

{{{class="brush: java; highlight: [2, 12, 14, 19, 20, 23, 27]"
public class Memoizer <A, V> implements Computable<A, V> {
	private final ConcurrentMap<A, Future<V>> cache
			= new ConcurrentHashMap<A, Future<V>>();
	private final Computable<A, V> c;

	public Memoizer(Computable<A, V> c) {
		this.c = c;
	}

	public V compute(final A arg) throws InterruptedException {
		while (true) {
			Future<V> f = cache.get(arg);
			if (f == null) {
				Callable<V> eval = new Callable<V>() {
					public V call() throws InterruptedException {
						return c.compute(arg);
					}
				};
				FutureTask<V> ft = new FutureTask<V>(eval);
				f = cache.putIfAbsent(arg, ft);
				if (f == null) {
					f = ft;
					ft.run();
				}
			}
			try {
				return f.get();
			} catch (CancellationException e) {
				cache.remove(arg, f);
			} catch (ExecutionException e) {
				throw LaunderThrowable.launderThrowable(e.getCause());
			}
		}
	}
}
}}}

这样实现的带缓存的计算类可以用在`Servlet`里：

{{{class="brush: java; highlight: [3, 9]"
@ThreadSafe
public class Factorizer extends GenericServlet implements Servlet {
	private final Computable<BigInteger, BigInteger[]> c =
			new Computable<BigInteger, BigInteger[]>() {
				public BigInteger[] compute(BigInteger arg) {
					return factor(arg);
				}
			};
	private final Computable<BigInteger, BigInteger[]> cache
			= new Memoizer<BigInteger, BigInteger[]>(c);

	public void service(ServletRequest req, ServletResponse resp) {
		try {
			BigInteger i = extractFromRequest(req);
			encodeIntoResponse(resp, cache.compute(i));
		} catch (InterruptedException e) {
			encodeError(resp, "factorization interrupted");
		}
	}

	void encodeIntoResponse(ServletResponse resp, BigInteger[] factors) {
	}

	void encodeError(ServletResponse resp, String errorString) {
	}

	BigInteger extractFromRequest(ServletRequest req) {
		return new BigInteger("7");
	}

	BigInteger[] factor(BigInteger i) {
		// Doesn't really factor
		return new BigInteger[]{i};
	}
}
}}}



= Executor框架 =

== 传统任务管理的缺陷 ==

在同一线程中处理所有任务，性能差：

{{{class="brush: java"
public class SingleThreadWebServer {
	public static void main(String[] args) throws IOException {
		ServerSocket socket = new ServerSocket(80);
		while (true) {
			Socket connection = socket.accept();
			handleRequest(connection);
		}
	}

	private static void handleRequest(Socket connection) {
		// request-handling logic here
	}
}
}}}

为每个任务创建一个线程，太浪费资源：

{{{class="brush: java"
public class ThreadPerTaskWebServer {
	public static void main(String[] args) throws IOException {
		ServerSocket socket = new ServerSocket(80);
		while (true) {
			final Socket connection = socket.accept();
			Runnable task = new Runnable() {
				public void run() {
					handleRequest(connection);
				}
			};
			new Thread(task).start();
		}
	}

	private static void handleRequest(Socket connection) {
		// request-handling logic here
	}
}
}}}

== 用Executor框架 ==

在Java类库中，任务执行的主要抽象是`Executor`而不是`Thread`。所以每当看到：

{{{class="brush: java"
	new Thread(runnable).start();
}}}

这样的模式时，要考虑用`Executor`来代替`Thread`。

`Executor`接口代表一个任务，要实现的方法`execute`里是对`Runnable`对象的调用：

{{{class="brush: java"
public interface Executor {
	void execute(Runnable command);
}
}}}

`Executor`相当于一个基于生产者－消费者模式的任务队列，分开了任务提交与任务执行
的解耦。用它来实现一个基于线程池的Web服务器：

{{{class="brush: java; highlight: [3, 15]"
public class TaskExecutionWebServer {
	private static final int NTHREADS = 100;
	private static final Executor exec
			= Executors.newFixedThreadPool(NTHREADS);

	public static void main(String[] args) throws IOException {
		ServerSocket socket = new ServerSocket(80);
		while (true) {
			final Socket connection = socket.accept();
			Runnable task = new Runnable() {
				public void run() {
					handleRequest(connection);
				}
			};
			exec.execute(task);
		}
	}

	private static void handleRequest(Socket connection) {
		// request-handling logic here
	}
}
}}}

== 重写不同的线程策略 ==

前面说到`Executor`的接口方法`execute`：

{{{class="brush: java"
public interface Executor {
	void execute(Runnable command);
}
}}}

可以重写它来实现不同的策略，如：

为每个请求都创建一个线程：

{{{class="brush: java"
public class ThreadPerTaskExecutor implements Executor {
	void execute(Runnable r) {
		new Thread(r).start();
	}
}
}}}

或用同步的方法在当前线程中执行任务：

{{{class="brush: java"
public class WithinThreadExecutor implements Executor {
	void execute(Runnable r) {
		r.run();
	}
}
}}}

== 不同类型的线程池 ==

前面服务器例子中创建线程池的方法：

{{{class="brush: java"
Executor pool = Executors.newFixedThreadPool(num);
}}}

`Executors`可以调用不同的工厂方法返回不同的线程池：

`newFixedThreadPool`：固定长度。如果有线程因异常结束会补充一个新的。

`newCachedThreadPool`：可缓存。按需要回收空闲线程或添加新线程，并且不限制线程池
规模。

`newSingleThreadExecutor`：单线程的`Executor`。一个线程因为异常结束再建一个来
替换它。能保证依照任务顺序执行。还保证前一个任务的内存操作对下一个任务是
可见的。

`newScheduledThreadPool`：固定长度，并像`Timer`可以执行计划任务。


== Executor生命周期 ==

因为是异步的，所以提供了管理生命周期的工具`ExecutorService`，它继承了`Executor`
，并添加了控制生命周期的方法。

当`ExecutorService`关闭后，再提交任务会被抛弃，或使`execute`方法抛出未检查异常
`RejectedExecutionException`。

{{{class="brush: java"
public interface ExecutorService Extends Executor {

	/* 平缓关闭，不接新任务，等待已经加入的任务完成 *;
	void shutdown();
	
	/* 强关，停止所有正在运行的任务 */
	List<Runnable> shutdownNow();
	
	/* 可用来轮询是否终止 */
	boolean isShutdown();
	
	boolean isInited();
	

	boolean awaitTermination(long timeout, TimeUnit unit) 
		throws InterruptedException;
	// ... 其他方法
}
}}}

支持关闭操作的web服务器例子。不断地处理请求，有一个特殊的请求是关机，读到它就
关掉：

{{{class="brush: java; highlight: [2, 22, 31, 32]"
public class LifecycleWebServer {
	private final ExecutorService exec = Executors.newCachedThreadPool();

	public void start() throws IOException {
		ServerSocket socket = new ServerSocket(80);
		while (!exec.isShutdown()) {
			try {
				final Socket conn = socket.accept();
				exec.execute(new Runnable() {
					public void run() {
						handleRequest(conn);
					}
				});
			} catch (RejectedExecutionException e) {
				if (!exec.isShutdown())
					log("task submission rejected", e);
			}
		}
	}

	public void stop() {
		exec.shutdown();
	}

	private void log(String msg, Exception e) {
		Logger.getAnonymousLogger().log(Level.WARNING, msg, e);
	}

	void handleRequest(Socket connection) {
		Request req = readRequest(connection);
		if (isShutdownRequest(req))
			stop();
		else
			dispatchRequest(req);
	}

	interface Request {
	}

	private Request readRequest(Socket s) {
		return null;
	}

	private void dispatchRequest(Request r) {
	}

	private boolean isShutdownRequest(Request r) {
		return false;
	}
}
}}}


= 延时任务与周期任务 =

== 传统方案的不足 ==

=== Timer方案的不足 ===

`Timer`方案有缺点，因为执行的时候只创建一个线程。前一个任务时间长了会影响后面
任务的时间精确性。而且如果`TimerTask`抛出未检查异常中断了任务`Timer`也不会恢复
执行。

可以使用阻塞队列`DelayQueue`，它为`ScheduledThreadPoolExecutor`提供了调度功能。
`DelayQueue`里管理一组`Delayed`对象，每个都对应一个时间延迟。在`DelayQueue`里
只有某个元素逾期后才能从`DelayQueue`中执行`take`操作。`DelayQueue`中的对象按
延迟时间排序。

=== 忙等待方案 ===

{{{class="brush: java"
public void loopTask() {
	while (flag) {
		doSomething();
		sleep(100);
	}
}
}}}

* 这样的任务，每启动一个实例，就会有一个线程。操作系统最大线程数是有限的。
* 注意`sleep(100)`，占用了一个线程，大部分时间不害休眠状态。

== 周期性任务线程池 ==

`ScheduledThreadPoolExecutor`适合执行周期性任务。注意要用`static final`修饰才能
由多个线程共享：

{{{class="brush: java"
private static final ScheduledExecutorService timer = 
	Executors.newScheduledThreadPool(10);
}}}

成员方法`scheduleAtFixedRate(runnable)`接收任务，执行间隔等设置：

{{{class="brush: java"
private void init() {
	replenishTask = timer.scheduleAtFixedRate(
		new Runnable() {
			public void run() {
				// do something...
			}
		}, 0, 1, TimeUnit.SECONDS);
}
}}}

注意任务要处理掉异常，因为如果有异常抛出的话会中断周期任务。

`ScheduledExecutorService.shutdown()`关闭线程池。但是要注意已经启动的线程停不
下来。所以在创建线程池时指定线程的构造器让创建出来的线程都是守护线程：

{{{class="brush: java"
import java.util.concurrent.ThreadFactory;

private static final ScheduledExecutorService Timer =
	Executors.newScheduledThreadPool(10, ThreadFactory() {
		public Thread newThread(Runnable runnable) {
			Thread thread = new Thread(runnable);
			thread.setDaemon(true);
			return thread;
		}
	});
}}}



= 设计并行程序 =

之前已经说过`Callable`比`Runnable`好：可以有返回值还可以抛出受检查异常。

{{{class="brush: java"
public interface Callable<V> {
	V call() throws Exception;
}
}}}

`Runnable`和`Callable`都是对任务的抽象。在`Executor`框架中执行任务有四个阶段：
创建、提交、开始、完成。`Executor`框架中可以取消一个已经提交但是还没有开始执行
的任务；对于已经在执行的任务只能让它响应中断时才能取消。

`Future`表示一个任务的使命周期，并提供方法来判断是否已经完成或取消，以及取得
执行结果和取消任务。当一个`Future`执行完成以后，它就永远停在完成状态上。

{{{class="brush: java"
public interface Future<V> {
	boolean cancel(boolean mayInterruptIfRunning);
	boolean isCancelled();
	boolean isDone();
	
	V get() throws InterruptedException, ExecutionException, 
		CancellationException;
		
	V get(long timeout, TimeUnit unit) throws InterruptedException, 
		ExecutionException, CancellationException, TimeoutException;
}
}}}

有多个方法来创建`Future`：

`ExecutorService`中的`submit`方法以`Runnable`或`Callable`对象提交给`Executor`，
从而创建一个`Future`。可以用这个`Future`来执行任务或取消任务。

还可以显式地为某个`Runnalbe`或`Callable`实例化一个`FutureTask`。由于`FutureTask`
实现了`Runnable`，所以可以拿它提交给`Executor`来执行，或是直接调用它的`run`方法
。

从Java 6开始`ExecutorService`实现可以改写`AbstractExecutorService`中的
`newTaskFor` 方法从而根据已经提交的`Runnable`或`Callable`来控制`Future`的实例化
过程。在现有的默认的实现中，仅仅是创建了一个新的`FutureTask`：

{{{class="brush: java"
protected <T> RunnableFuture<T> newTaskFor(Callable<T> task) {
	return new FutureTask<T>(task);
}
}}}

在`Runnable`或`Callable`提交到`Executor`过程中是安全传递的，不会有等到构造了一半
的情况发生；把`Future`传递给其他线程也是安全的，所以在其他线程中可以放心使用
`get`方法取结果。


== 拆分任务并行执行 ==

以一个渲染网页程序为例子：渲染页面文字与下载页面上的图片这两种工作可以并行执行，
而且因为一个是CPU密集一个是IO密集，即使在单核CPU上性能提升也很明显：

把下载任务做成`Callable`传递给`ExecutorService`。当主任务要图片时会等
`Future.get`返回结果。当收到中断异常时，中断当前线程并退出。

{{{class="brush: java; highlight: [2,6,16,20,23]"
public abstract class FutureRenderer {
	private final ExecutorService executor = Executors.newCachedThreadPool();

	void renderPage(CharSequence source) {
		final List<ImageInfo> imageInfos = scanForImageInfo(source);
		Callable<List<ImageData>> task =
				new Callable<List<ImageData>>() {
					public List<ImageData> call() {
						List<ImageData> result = new ArrayList<ImageData>();
						for (ImageInfo imageInfo : imageInfos)
							result.add(imageInfo.downloadImage());
						return result;
					}
				};

		Future<List<ImageData>> future = executor.submit(task);
		renderText(source);

		try {
			List<ImageData> imageData = future.get();
			for (ImageData data : imageData)
				renderImage(data);
		} catch (InterruptedException e) {
			// Re-assert the thread's interrupted status
			Thread.currentThread().interrupt();
			// We don't need the result, so cancel the task too
			future.cancel(true);
		} catch (ExecutionException e) {
			throw launderThrowable(e.getCause());
		}
	}

	interface ImageData {
	}

	interface ImageInfo {
		ImageData downloadImage();
	}

	abstract void renderText(CharSequence s);

	abstract List<ImageInfo> scanForImageInfo(CharSequence s);

	abstract void renderImage(ImageData i);
}
}}}

上面的任务虽然很好地把CPU密集任务和IO密集任务分开了，这属于异构任务并行化。这样
的是很难确定这两边的任务负载是一样的。可能有一边很轻，马上就完成了，另一边还在
执行。所以很难保证效率提高了多少。

只有相互独立的同构任务可以并发处理时，才能体现出明显的提升。


== CompletionService与BlockingQueue ==

在身`Executor`提交了一组任务，可以用保留与每个任务相关的`Future`，反复调用`get`
方法，同时设参数`timeout`为`0`。这种轮询的方式虽然有用，但可以用更好的方法：
完成服务`CompletionServise`。

`CompletionServise`相当组合了`Executor`与`BlockingQueue`。可以把`Callable`任务
交给它执行，然后用类似于队列操作的`take`和`pall`等方法取结果。已经完成的结果被
封装为`Future`。

`CompletionServise`有一个实现类`ExecutorCompletionService`，可以把计算部分委托
给`Executor`。它的实现非常简单。在构造函数中创建一个`BlockingQueue`来保存计算
结果。当计算完成后，调用`FutureTask`中的`done`方法。当提交某个任务时，该任务
首先被包装为一个`QueueingFuture`，这是`FutureTask`的子类，然后改写`dome`方法，
并将结果存入`BlockingQueue`中。如下面代码，`take`和`poll`方法委托给了
`BlockingQueue`，这些方法会在得出结果前阻塞。

{{{class="brush: java"
private class QueueingFuture<V> extends FutureTask<V> {
	QueueingFuture(Callable<V> c) { super(c); }
	QueueingFuture(Runnable t, V r) { super(t, r); }
	
	protected void done() {
		completionQueue.add(this);
	}
}
}}}

使用`CompletionService`的例子。主要强化在两个地方：

* 为每张图片建立一个独立的任务，并在线程池中启动它们。这样下载变成并行任务。
* 从`CompletionService`中取得的结果是下载完立即显示出来。


{{{class="brush: java; highlight: [3, 12, 16, 26]"
public abstract class Renderer {

	private final ExecutorService executor;

	Renderer(ExecutorService executor) {
		this.executor = executor;
	}

	void renderPage(CharSequence source) {
		final List<ImageInfo> info = scanForImageInfo(source);
		
		CompletionService<ImageData> completionService =
				new ExecutorCompletionService<ImageData>(executor);
				
		for (final ImageInfo imageInfo : info)
			completionService.submit(new Callable<ImageData>() {
				public ImageData call() {
					return imageInfo.downloadImage();
				}
			});

		renderText(source);

		try {
			for (int t = 0, n = info.size(); t < n; t++) {
				Future<ImageData> f = completionService.take();
				ImageData imageData = f.get();
				renderImage(imageData);
			}
		} catch (InterruptedException e) {
			Thread.currentThread().interrupt();
		} catch (ExecutionException e) {
			throw launderThrowable(e.getCause());
		}
	}

	interface ImageData {
	}

	interface ImageInfo {
		ImageData downloadImage();
	}

	abstract void renderText(CharSequence s);

	abstract List<ImageInfo> scanForImageInfo(CharSequence s);

	abstract void renderImage(ImageData i);

}
}}}

多个`ExecutorCompletionService`可以共享一个`Executor`，所以可以创建一个特定的
`Executor`来计算私有任务，还可以能共享一个公共`Executor`的
`ExecutorCompletionService`。所以`CompletionService`的作为就相当于一组计算的句柄
，这与`Future`作为单个计算的够本是类似的。通过记录提交给`CompletionService`任务
的数量，并计算出已经获得的已经完成结果数量，即使使用一个共享的`Executor`也可以
知道已经获得了所有任务结果的时间。


== 设置任务的执行时限 ==

`Future.get`中可以设定超时限制，超时后抛出`TimeoutException`。一般在任务超时后
应该立即`Future.cancel(true)`停止，从而避免继续计算一个不能再用的结果而浪费计算
资源。如果编写的任务是可以取消的，可以提前中止它，防止消耗资源。

例子：从广告服务器上取广告。把广告任务交给`Executor`。如果超时就取消任务：

{{{class="brush: java; highlight: [3,10,15]"
Page renderPageWithAd() throws InterruptedException {
	long endNanos = System.nanoTime() + TIME_BUDGET;
	Future<Ad> f = exec.submit(new FetchAdTask());
	// Render the page while waiting for the ad
	Page page = renderPageBody();
	Ad ad;
	try {
		// Only wait for the remaining time budget
		long timeLeft = endNanos - System.nanoTime();
		ad = f.get(timeLeft, NANOSECONDS);
	} catch (ExecutionException e) {
		ad = DEFAULT_AD;
	} catch (TimeoutException e) {
		ad = DEFAULT_AD;
		f.cancel(true);
	}
	page.setAd(ad);
	return page;
}
}}}

超时任务还可以扩展到多个任务的情况。创建n个任务，提交到一个线程池，保留n个
`Future`。除了用`Future.get`方法一个一个取结果，还可以用一组任务为参数直接调用
`invokeAll`方法，按任务集合中迭代器顺序把所有的`Future`添加到返回集合中。这样
每个`Future`与对应的`Callable`关联起来了。所有任务都完毕或是超时以后`invokeAll`
方法将返回。可以用`get`方法或`isCancelled`方法来判断每个任务是否完成。

{{{class="brush: java; highlight: [17,19,24,28,30]"
private class QuoteTask implements Callable<TravelQuote> {
	private final TravelCompany company;
	private final TravelInfo travelInfo;
	...
	public TravelQuote call() throws Exception {
		return company.solicitQuote(travelInfo);
	}
}

public List<TravelQuote> getRankedTravelQuotes( TravelInfo travelInfo, 
		Set<TravelCompany> companies, Comparator<TravelQuote> ranking, 
		long time, TimeUnit unit) throws InterruptedException 
{
	List<QuoteTask> tasks = new ArrayList<QuoteTask>();

	for (TravelCompany company : companies)
		tasks.add(new QuoteTask(company, travelInfo));

	List<Future<TravelQuote>> futures = exec.invokeAll(tasks, time, unit);
	List<TravelQuote> quotes = new ArrayList<TravelQuote>(tasks.size());
	Iterator<QuoteTask> taskIter = tasks.iterator();

	for (Future<TravelQuote> f : futures) {
		QuoteTask task = taskIter.next();
		try {
			quotes.add(f.get());
		} catch (ExecutionException e) {
			quotes.add(task.getFailureQuote(e.getCause()));
		} catch (CancellationException e) {
			quotes.add(task.getTimeoutQuote(e));
		}
	}
	Collections.sort(quotes, ranking);

	return quotes;
}
}}}



= 取消、关闭任务与线程 =

Java没有提供安全终止线程的机制，`Thread`的`stop`与`suspend`等方法会有一些缺陷，
应该避免使用。推荐让一个线程调用中断来停止另一个线程。

取消或中断任务

=== 取消任务 ===

使用`volatile`的标记是否继续执行，公开方法`cancel`来修改标志位：

{{{class="brush: java; highlight: [8, 12, 21]"
@ThreadSafe
public class PrimeGenerator implements Runnable {
	private static ExecutorService exec = Executors.newCachedThreadPool();

	@GuardedBy("this")
	private final List<BigInteger> primes = new ArrayList<BigInteger>();

	private volatile boolean cancelled;

	public void run() {
		BigInteger p = BigInteger.ONE;
		while (!cancelled) {
			p = p.nextProbablePrime();
			synchronized (this) {
				primes.add(p);
			}
		}
	}

	public void cancel() {
		cancelled = true;
	}

	public synchronized List<BigInteger> get() {
		return new ArrayList<BigInteger>(primes);
	}
}
}}}

这是一种等等取消的策略，如果计算操作被阻塞的话，可能永远也不会检查到标志位。


=== 中断任务 ===

`Thread`类中的相关方法：

{{{class="brush: java"
public class Thread {
	
	/* 中断线程 */
	public void interrupt() { ... }

	/* 查看线程的中断状态 */
	public boolean isInterrupted() { ... }

	/* 静态方法，清除本线程的中断状态。注意不是目标线程
	   而是本线程 */
	public static boolean interrupted() { ... }
	
	...
}
}}}

在阻塞情况下被中断：

阻塞库方法，如`Thread.sleep`和`Object.wait`都会检查线程中断，在中断时返回。中断
时执行的操作有：清除中断状态，抛出`InterruptedException`表示任务提前结束。JVM
不保证阻塞方法检查到中断的速度，但其实还是挺快的。

在非阻塞情况下被中断：

非阻塞情况下被中断，它的中断状态会被设置，然后根据被取消的操作来检查中断状态以
判断发生了中断。这样如果不触发`InterruptedException`中断状态会一直保持，赶到明确
清除了中断状态。

调用`interrupt`方法只是发出一个请示。所以目标线程一定要处理中断异常，不然线程就
中断不了。

在调用静态的`interrupted`方法时一定要小心，因为它在返回了当前线程的中断状态同时
还会清除，所以如果返回了`true`就一定要处理，不然就丢失了一次中断请求。如下面的
代码地检查到有请求中断时马上中断当前任务：

{{{class="brush: java; highlight: [11, 18]"
class PrimeProducer extends Thread {
	private final BlockingQueue<BigInteger> queue;

	PrimeProducer(BlockingQueue<BigInteger> queue) {
		this.queue = queue;
	}

	public void run() {
		try {
			BigInteger p = BigInteger.ONE;
			while (!Thread.currentThread().isInterrupted())
			queue.put(p = p.nextProbablePrime());
		} catch (InterruptedException consumed) {
			/* Allow thread to exit */
		}
	}

	public void cancel() { interrupt(); }
}
}}}


=== 中断策略 ===

收到中断请求并不是说一定要马上处理，可以完成当前任务或是再加些善后，在合适的时候
再向上抛出中断异常、或其他方式表达已经收到中断请示。

当前任务并不一定是在一个独立的线程里运行，有可以和其他任务一起是一个串型的单线程
，也有可能是一个线程池里。所以一般业务逻辑代码收到了中断请求以后只向外抛中断异常
。让调用都或外部容器来进一步的操作。

执行的任务应该保存执行线程的中断状态，如果除了把`InterruptedException`传递给调用
者外还要有其他的操作，那么应该在捕获`InterruptedException`后恢复中断状态，即用
`interrupt`方法中断当前的线程：

{{{class="brush: java"
Thread.currentThread().interrupt();
}}}

=== 响应中断 ===

在阻塞函数调用时，处理中断的两种基本策略：

* 传递异常（可以在完成任务或善后），这样本方法也成了可中断的方法。
* 恢复中断状态，从而使调用栈中的上层代码可以对其进行处理。

继续抛出异常，可以只是简单地抛出：

{{{class="brush: java"
BlockingQueue<Task> queue;
...

public Task getNextTask() throws InterruptedException {
	return queue.take();
}
}}}

对于不支持取消但仍可以调用中断阻塞方法的操作，在忙等待检查中应该在本地保存中断
状态。因为大多数阻塞方法在入口处检查中断状态，在遇到中断时抛出
`InterruptedException`。

下面的代码用`interrupted`标记是正常完成还是被中断，如果是被中断的要恢复中断状态：

{{{class="brush: java; highlight: [2,8,14]"
public Task getNextTask(BlockingQueue<Taskgt; queue) {
	boolean interrupted = false;
	try {
		while (true) {
			try {
				return queue.take();
			} catch (InterruptedException e) {
				interrupted = true;
				// 继续循环，但记录下被中断过
			}
		}
	} finally {
		if (interrupted)
			Thread.currentThread().interrupt(); // 恢复线程的状态是中断的
	}
}
}}}

如果代码不会调用可中断的阻塞方法，那么还是可以通过任务代码中轮询当前线程中断状态
的方式来响应中断。

=== 通过Future来实现取消 ===

`Future.cancel(boolean)`设置任务是否可以检测到中断请求。下面的代码在超时后取消
那些不再需要结果的任务：

{{{class="brush: java"
public static void timedRun(Runnable r, long timeout, TimeUnit unit) 
	throws InterruptedException 
{
	Future<?> task = taskExec.submit(r);
	try {
		task.get(timeout, unit);
	} catch (TimeoutException e) {
		// 如果是因为超时，接下来的任务都被取消
	} catch (ExecutionException e) {
		//  如果是任务逻辑中的异常，继续抛出
		throw launderThrowable(e.getCause());
	} finally {
		// 已经结束，执行取消也不会有坏处
		task.cancel(true); // 如果任务正在运行，就会被中断
	}
}
}}}

当`Future.get`抛出中断异常或超时异常后，如果确定不再需要结果，那可以用
`Future.cancel`取消任务。


=== 处理不可中断的阻塞 ===

像是IO这样的阻塞操作提前返回或抛出中断异常来响应中断请求。如Socket IO的或内部锁
阻塞时被调用`interrupte`方法只设置线程中断状态，没有其他效果。所以对于不同的情况
要有不同的方法：

`java.io`包中的Socket IO。可以通过关闭Socket，让`read`或`write`等阻塞方法抛出
`SocketException`。

`java.io`包中的同步IO。`InterruptibleChannel`上阻塞的线程可以被中断并抛出
`ClosedByInterruptException`并关闭链路，还会引起同一链路上阻塞的其他线程同样抛出
`ClosedByInterruptException`。当关闭一个`InterruptibleChannel`时，阻塞在同一链路
上的所有阻塞线程抛出`AsynchronousClosedException`。

`Selector`的异步IO。因为`Selector.select`方法阻塞了，调用`close`或`wakeup`方法
会抛出`ClosedSelectorException`并提前返回。

内置锁。内置锁无法中断，推荐改用显式锁。

一个中断Socket连接的例子，重写了`interrupt`方法。在方法里关闭了连接并调用超类的
`interrupt`方法：

{{{class="brush: java; highlight: [13,16]"
public class ReaderThread extends Thread {

	private final Socket socket;
	
	// ...

	public ReaderThread(Socket socket) throws IOException {
		this.socket = socket;
		this.in = socket.getInputStream();
	}
	
	// ...

}
}}}


=== newTaskFor封装非标准的取消 ===

Java 6在`ThreadPoolExecutor`中增加了`newTaskFor`工厂方法，创建的代表任务的
`Future`对象。`newTaskFor`方法还能返回扩展`Future`和`Runnable`接口，并由
`FutureTask`实现的`RunnableFuture`接口。

下面的例子里我们定义了一个`CancellableTask`接口继承自`Callable`，它有`cancel`
方法和`newTask`工厂方法来创造`RunnableFuture`。`CancellingExecutor`继承自
`ThreadPoolExecutor`，并通过重写`newTaskFor`让`CancellableTask`可以创建自己的
`Future`：

{{{class="brush: java; highlight: [3,4,13,15,39]"

/*  任务 */
public interface CancellableTask<T> extends Callable<T> {
	void cancel();
	RunnableFuture<T> newTask();
}

/* 线程池 */
@ThreadSafe
public class CancellingExecutor extends ThreadPoolExecutor {
	...
	protected<T> RunnableFuture<T> newTaskFor(Callable<T> callable) {
		if (callable instanceof CancellableTask)
			return ((CancellableTask<T>) callable).newTask();
		else
			return super.newTaskFor(callable);
	}
}

public abstract class SocketUsingTask<T> implements CancellableTask<T> {
	@GuardedBy("this") 
	private Socket socket;
	
	protected synchronized void setSocket(Socket s) {
		socket = s;
	}
	
	public synchronized void cancel() {
		try {
			if (socket != null)
			socket.close();
		} catch (IOException ignored) {
		}
	}
	
	public RunnableFuture<T> newTask() {
		return new FutureTask<T>(this) {
			public boolean cancel(boolean mayInterruptIfRunning) {
				try {
					SocketUsingTask.this.cancel();
				} finally {
					return super.cancel(mayInterruptIfRunning);
				}
			}
		};
	}
	
}
}}}


== 停止基于线程的服务 ==

除了任务需要停止以外，还有很多为支持线程与任务提供的服务也需要停止，如线程池、
任务队列等……

由于线程的所有权是不可传递的，所以对于这些服务来说，应该通过它们自身生命周期方法
来停止它们。

对于设计服务的开发人员来说，如果这个服务存在的时间长于线程的方法存在的时间，就要
为这个服务提供生命周期方法。

=== 注意事项 ===

关闭一个服务不能仅仅中断服务的线程，还要考虑到服务中下执行到一半的任务等事项，
还有任务的阻塞状态。

=== 关闭ExecutorService ===

成员方法`shutdown`与`shutdownNow`。

=== 毒丸项目 ===

队列中一个特殊的成员，读到就表示应该停止了。


=== 只执行一次的服务 ===

服务要处理一批任务，当所有任务都处理完成后结束。这时可以用一个私有的`Executor`来
简化服务的生命周期管理，因为这个`Executor`的生命周期被限制于这个方法的调用。

下面的例子在多台主机上并行检查邮件。它创建一个私有的`Executor`，给每个主机提交
任务，任务全完成以后关闭`Executor`并等待结束。

注意这里`hasNewMail`标记的类型是`final AtomicBoolean`而不是`volatile boolean`
是因为必须是`final`的，不然内部类访问不到。

{{{class="brush: java; highlight: [6,8,18,19]"
public class CheckForMail {

	public boolean checkMail(Set<String> hosts, long timeout, TimeUnit unit)
			throws InterruptedException 
	{
		ExecutorService exec = Executors.newCachedThreadPool();

		final AtomicBoolean hasNewMail = new AtomicBoolean(false);
		try {
			for (final String host : hosts)
				exec.execute(new Runnable() {
					public void run() {
						if (checkMail(host))
							hasNewMail.set(true);
					}
				});
		} finally {
			exec.shutdown();
			exec.awaitTermination(timeout, unit);
		}
		return hasNewMail.get();
	}

	private boolean checkMail(String host) {
		// Check for mail
		return false;
	}
}
}}}



=== 记录关闭时的状态 ===

`ExecutorService`的`shutdownNow`把强制关掉正执行中的任务。下面实现的强化类
`TrackingExecutor`记录那些任务是已经开始但学没有正常完成的，在`Executor`结束后
可以通过`getCanceledTasks`方法取得还没有执行的任务。注意为了生效返回时一定要维持
线程的中断状态：

{{{class="brush: java; highlight: [9,20]"
public class TrackingExecutor extends AbstractExecutorService {
	private final ExecutorService exec;
	private final Set<Runnable> tasksCancelledAtShutdown =
			Collections.synchronizedSet(new HashSet<Runnable>());

	public List<Runnable> getCancelledTasks() {
		if (!exec.isTerminated())
			throw new IllegalStateException(/*...*/);
		return new ArrayList<Runnable>(tasksCancelledAtShutdown);
	}

	public void execute(final Runnable runnable) {
		exec.execute(new Runnable() {
			public void run() {
				try {
					runnable.run();
				} finally {
					if (isShutdown()
							&& Thread.currentThread().isInterrupted())
						tasksCancelledAtShutdown.add(runnable);
				}
			}
		});
	}

	public TrackingExecutor(ExecutorService exec) {
		this.exec = exec;
	}

	public void shutdown() {
		exec.shutdown();
	}

	public List<Runnable> shutdownNow() {
		return exec.shutdownNow();
	}

	public boolean isShutdown() {
		return exec.isShutdown();
	}

	public boolean isTerminated() {
		return exec.isTerminated();
	}

	public boolean awaitTermination(long timeout, TimeUnit unit)
			throws InterruptedException {
		return exec.awaitTermination(timeout, unit);
	}


}
}}}

在一个爬虫程序上应用上面`TrackingExecutor`的例子：

{{{class="brush: java; highlight: [12, 55]"
public abstract class WebCrawler {

	private class CrawlTask implements Runnable {
		private final URL url;

		CrawlTask(URL url) {
			this.url = url;
		}

		public void run() {
			for (URL link : processPage(url)) {
				if (Thread.currentThread().isInterrupted())
					return;
				submitCrawlTask(link);
			}
		}

		private int count = 1;

		boolean alreadyCrawled() {
			return seen.putIfAbsent(url, true) != null;
		}

		void markUncrawled() {
			seen.remove(url);
			System.out.printf("marking %s uncrawled%n", url);
		}


		public URL getPage() {
			return url;
		}
	}

	private volatile TrackingExecutor exec;
	@GuardedBy("this")
	private final Set<URL> urlsToCrawl = new HashSet<URL>();

	private final ConcurrentMap<URL, Boolean> seen = 
		new ConcurrentHashMap<URL, Boolean>();

	private static final long TIMEOUT = 500;
	private static final TimeUnit UNIT = MILLISECONDS;

	protected abstract List<URL> processPage(URL url);

	public WebCrawler(URL startUrl) {
		urlsToCrawl.add(startUrl);
	}

	public synchronized void stop() throws InterruptedException {
		try {
			saveUncrawled(exec.shutdownNow());
			if (exec.awaitTermination(TIMEOUT, UNIT))
				saveUncrawled(exec.getCancelledTasks());
		} finally {
			exec = null;
		}
	}

	public synchronized void start() {
		exec = new TrackingExecutor(Executors.newCachedThreadPool());
		for (URL url : urlsToCrawl) submitCrawlTask(url);
		urlsToCrawl.clear();
	}

	private void saveUncrawled(List<Runnable> uncrawled) {
		for (Runnable task : uncrawled)
			urlsToCrawl.add(((CrawlTask) task).getPage());
	}

	private void submitCrawlTask(URL u) {
		exec.execute(new CrawlTask(u));
	}

}
}}}

`TrackingExecutor`中存在一个不可避免的竞争条件：在线程池关闭时可能会有已经完成的
任务还是处于中断列表里没有更新。对于幂等操作这问题不大，但对于不可重复执行操作
会引发问题。

=== 程序异常终止 ===

线程API中`UncaughExceptionHandler`处理抛出的异常。防止任务中抛出了未捕获的异常，
而会影响到整个线程。这个接口很简单：

{{{class="brush: java"
public interface UncaughtExceptionHandler {
	void uncaughtException(Thread t, Throwable e);
}
}}}

可以实现接口来处理没有被捕获的异常，最简单的方式就是写日志：

{{{class="brush: java"
public class UEHLogger implements Thread.UncaughtExceptionHandler {
	public void uncaughtException(Thread t, Throwable e) {
		Logger logger = Logger.getAnonymousLogger();
		logger.log(Level.SEVERE,
			"Thread terminated with exception: " + t.getName(), e);
	}
}
}}}

要为线程池中所有线程设置一个`UncaughExceptionHandler`，需要为
`ThreadPoolExecutor` 的构造函数提供一个`ThreadFactory`（和所有的线程一样，只有
线程的所有都能改变线程的`UncaughExceptionHandler`）。

注意只有`execute`方法提交的任务才能把它抛出的异常交给处理器；`submit`提交的任务
无论是抛出的未检查异常还是受检查异常都被认为是任务返回状态的一部分由`Future.get`
封装在`ExecutionException`中重新抛出。


== JVM关闭 ==

正常关闭：

* 最后一个非守护进程结束。
* 调用System.exit()`方法。
* 被操作系统`SIGINT`信号或`Control-C`

非正常关闭：

* `Runtime.halt`
* 被操作系统`SIGINT`（被KILL掉）

=== 关闭钩子 ===

正常关闭时会调用关闭钩子，即通过`Runtime.addShutdownHook`方法注册的但还没有开始
的线程。钩子会并发挂靠，所以JVM不能保证钩子调用的顺序。所有钩子都执行完后如果
`funFinalizersOnExit`为`true`则JVM将运行终结器（垃圾回收器调用类的`finalize`
方法）。

钩子不应该对当前程序的状态做任何假设，如假设线程池是否已经关闭等。应该尽快做收尾
工作。

例：一个停止日志服务的钩子程序：

{{{class="brush: java"
public void start() {
	Runtime.getRuntime().addShutdownHook(new Thread() {
		public void run() {
			try { LogService.this.stop(); }
			catch (InterruptedException ignored) {}
		}
	});
}
}}}

=== 守护进程 ===

普通进程如果还没有执行完JVM是关不掉的；守护进程会随JVM关闭而关掉，是连`finilly`
块都不执行、连回卷栈操作也不执行，直接就关掉了。所以当心不是什么服务都可以作为
守护进程的。

=== 终结器（finallyze方法） ===

它的目的是清理资源，但是由于它的任何状态都可以被多个线程访问，而且不能保证什么
时候被调用或是会不会被调用。所以清理工作还是及时放在`finally`块中早点做掉保险。




= 线程池的使用 =

== 任务与执行策略之间的隐性耦合 ==

`Executor`框架可以分开提交任务与处理任务的耦合。但任务之间的耦合还是要注意。

== ThreadPoolExecutor ==

一般由`Executors`的工厂方法`newCachedThreadPool`、`newFixedThreadPool`、
`newScheduledThreadExecutor`产生。一般用`newCachedThreadPool`有比较泛用的配置。

如果产生的默认配置不能满足需求，还可以用它的构造函数定制一个出来： 

{{{class="brush: java"
public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize,
	long keepAliveTime, TimeUnit unit,
	BlockingQueue<Runnable> workQueue, ThreadFactory threadFactory,
	RejectedExecutionHandler handler) 
{
	// ...
}
}}}

=== 设置线程池大小 ===

核心大小与最大大小设置了一开始的大小和最大小，存在时间表示一定时间内没有任务就
代表这个线程可以被回收掉，如果在当前线程池的大小已经超过核心大小那么这些标记的
线程就会被回收。

`newfixedThreadPool`方法创建的线程池不会超时；`newCachedThreadPood`创建的线程池
最大是`Integer.MAX_VALUE`，而基本大小是0，超时是1分钟。

=== 配置任务队列 ===

单线程的`Executor`不会有并发任务，它通过线程封闭来实现线程安全性。但在并发线程池
中会有多个并发任务。请求速度超过处理速度时即使把任务放在队列里，没有运行不占用
线程资源，也可能因为队列太大而耗尽资源。

`ThreadPoolExecutor`的构造函数可能接收一个`BlockingQueue`来作为任务队列。基本有
三种方案：

* 无限队列。
* 有限队列。
* 同步移交（Synchronous Handoff）。

无限队列是`newFixedThreadPool`和`newSingleThreadExecutor`默认的。一般用一个不
限制长度的`LinkedBlockingQueue`来实现。

有限的队列可以用`ArrayBlockingQueue`、限制长度的`LinkedBlockingQueue`或
`PriorityBlockingQueue`配合相应的满策略。

同步移交应用于非常大的或者无限的线程池，可以通过`SynchronousQueue`来实现。它并不
是真的队列，仅仅是一个从生产者转到消费者的移交机制。相当于一个没有长度的队列，
要把一个元素放入它，就一定要有一个空闲的线程在等待。如果没有线程等待，而且线程池
已经满任务会被拒绝。只有在线程池是有界的并且可以拒绝任务时，同步移交才有价值。

`PriorityBlockingQueue`对于任务的优先级有排序，要实现`Comparable`接口。

* 任务独立性

只有任务是相互独立的才能用有限制的队列，不然所依赖的任务进不了队列执行不了就
锁死了。这时应该用无界的线程池，如`newCachedThreadPool`。


=== 饱和策略 ===

`ThreadPoolExecutor`的饱合策略可以通过`setRejectedExecutionHandler`来修改。

* `Abort`：抛未检查异常，调用者处理异常。
* `Discard`：丢掉任务。
* `DiscardOlds`：丢掉最老的任务。
* `DiscardPolicy`：丢掉优先级最低的。
* `Caller_Runs`：不抛异常，退回给调用者。用一个`execute()`执行它。

`Caller_Runs`不抛弃任务也不抛异常，而是在一个`execute()`执行它。相当于让调用者
执行，这样调用都就花时间执行任务而暂缓提交新任务了。

下面是一个例子，线程池用`CallerRuns`策略，调用者中用信号量来限制任务产生量：

{{{class="brush: java"
ThreadPoolExecutor executor = new ThreadPoolExecutor(N_THREADS, N_THREADS,
			0L, TimeUnit.MILLISECONDS, 
			new LinkedBlockingQueue<Runnable>(CAPACITY));
			
executor.setRejectedExecutionHandler(
		new ThreadPoolExecutor.CallerRunsPolicy() );
}}}

调用者中：

{{{class="brush: java; highlight: [4,8,14,21,26]"
@ThreadSafe
public class BoundedExecutor {
	private final Executor exec;
	private final Semaphore semaphore;

	public BoundedExecutor(Executor exec, int bound) {
		this.exec = exec;
		this.semaphore = new Semaphore(bound);
	}

	public void submitTask(final Runnable command) 
		throws InterruptedException 
	{
		semaphore.acquire();
		try {
			exec.execute(new Runnable() {
					public void run() {
					try {
						command.run();
					} finally {
						semaphore.release();
					}
				}
			});
		} catch (RejectedExecutionException e) {
			semaphore.release();
		}
	}

}
}}}

=== 线程工厂 ===

还可以指定线程池创建线程的工厂方法。比如想要让创建的线程是守护线程、给每个创建
的线程指定`UncaughtExceptionHandler`等需求。工厂方法的接口如下：

{{{class="brush: java"
public interface ThreadFactory {
	Thread newThread(Runnable r);
}
}}}

自定义一个工厂方法的例子，这个工厂和产生的线程有名字，可以用来日志跟踪：

{{{class="brush: java"
public class MyThreadFactory implements ThreadFactory {
	private final String poolName;

	public MyThreadFactory(String poolName) {
		this.poolName = poolName;
	}

	public Thread newThread(Runnable runnable) {
		return new MyAppThread(runnable, poolName);
	}
}
}}}

注意创建的线程也是自定义的，带有名字：

{{{class="brush: java"
public class MyAppThread extends Thread {
	public static final String DEFAULT_NAME = "MyAppThread";
	private static volatile boolean debugLifecycle = false;
	private static final AtomicInteger created = new AtomicInteger();
	private static final AtomicInteger alive = new AtomicInteger();
	private static final Logger log = Logger.getAnonymousLogger();

	public MyAppThread(Runnable r) {
		this(r, DEFAULT_NAME);
	}

	public MyAppThread(Runnable runnable, String name) {
		super(runnable, name + "-" + created.incrementAndGet());
		setUncaughtExceptionHandler(
			new Thread.UncaughtExceptionHandler() {
				public void uncaughtException(Thread t, Throwable e) {
					log.log(Level.SEVERE, "UNCAUGHT in thread " + t.getName(), e);
				}
		});
	}

	public void run() {
		// Copy debug flag to ensure consistent value throughout.
		boolean debug = debugLifecycle;
		if (debug) log.log(Level.FINE, "Created " + getName());
		try {
			alive.incrementAndGet();
			super.run();
		} finally {
			alive.decrementAndGet();
			if (debug) log.log(Level.FINE, "Exiting " + getName());
		}
	}

	public static int getThreadsCreated() {
		return created.get();
	}

	public static int getThreadsAlive() {
		return alive.get();
	}

	public static boolean getDebug() {
		return debugLifecycle;
	}

	public static void setDebug(boolean b) {
		debugLifecycle = b;
	}
}
}}}

如果要在程序中利用安全策略来控制对某些特殊代码库的访问权限。可以通过`Executor`
中的`privilegedThreadFactory`工厂来定制自己的线程工厂。所创建的线程与创建这个
`privilegedThreadFactory`的线程有同样的访问权限、`AccessControlContext`和
`conextClassLoader`。如果不用`privilegedThreadFactory`线程池创建的线程将从在需要
新线程时调用`execute`或`submit`的客户程序中继承访问权限。

{{{class="brush: java"
}}}

=== 设置现有的ThreadPoolExecutor ===

现有的线程池不能随便改：

{{{class="brush: java"
ExecutorService exec = Executors.newCachedThreadPool();
if (exec instanceof ThreadPoolExecutor)
	((ThreadPoolExecutor) exec).setCorePoolSize(10);
else
	throw new AssertionError("Oops, bad assumption");
}}}

Executors中有一个`unconfigurableExecutorService`工厂方法，它把现有的
`ExecutorService`包装成了别的东西，只暴露出了`ExecutorService`方法。

`newSingleThreadExecutor`创建的结果就是这样封装过的，因为要的就是单线程的，不能
让别人改成多线程的。

你也可以在自己的`Executor`中使用这种策略来不让别人改。


== 扩展ThreadPoolExecutor ==

它提供了几个方法是可以在子类中重写的：

`afterExecute`在`run`方法正常执行完或是抛出异常时会执行。但如是如果完成后带一个
`Error`就不会被执行。

`beforeExecute`在任务执行前运行，但如果它抛出了`RuntimeException`那么任务就不会
执行。

`terminated`在线程池关闭时调用。

例子：给线程池添加统计信息

{{{class="brush: java"
public class TimingThreadPool extends ThreadPoolExecutor {
	private final ThreadLocal<Long> startTime = new ThreadLocal<Long>();
	private final Logger log = Logger.getLogger("TimingThreadPool");
	private final AtomicLong numTasks = new AtomicLong();
	private final AtomicLong totalTime = new AtomicLong();

	protected void beforeExecute(Thread t, Runnable r) {
		super.beforeExecute(t, r);
		log.fine(String.format("Thread %s: start %s", t, r));
		startTime.set(System.nanoTime());
	}

	protected void afterExecute(Runnable r, Throwable t) {
		try {
			long endTime = System.nanoTime();
			long taskTime = endTime - startTime.get();
			numTasks.incrementAndGet();
			totalTime.addAndGet(taskTime);
			log.fine(String.format("Thread %s: end %s, time=%dns",
					t, r, taskTime));
		} finally {
			super.afterExecute(r, t);
		}
	}

	protected void terminated() {
		try {
			log.info(String.format("Terminated: avg time=%dns",
			totalTime.get() / numTasks.get()));
		} finally {
			super.terminated();
		}
	}

}
}}}



= 外部锁（显示锁） =

JDK5还提供了外部锁：`java.util.concurrent.locks.Lock`。补充`synchronized`对应
的内置锁。

* 内置锁在`synchronized`代码结束后自动释放。无论是正常离开还是异常跳转。
* 内置锁无法实现非阻塞结构的加锁规则。
* 外部锁必须手动释放，所以一定要在`finally`块中释放。

== 创建外部锁 ==

`Lock`的实现类`ReentrantLock`可能对已经获得锁的线程重新请示锁。

{{{class="brush: java"
Lock lock = new ReentrantLock();

lock.lock();
try {
	/* do something */ 
} finally {
	lock.unlock();
}
}}}


== 避免死锁 ==

内置锁容易死锁，外部锁`tryLock()`方法尽量避免死锁。因为这个方法会在取不到锁时
退回，下次再试。

如下面的在两个账户之间的转账程序，通过轮询的方式反常尝试取得锁：

{{{class="brush: java; highlight:[4,5,7,14,19]"
public void transferMoney(Account fromAccount, Account toAccount, 
		BigDecimal amt) 
{
	while (true) {
		if (fromAccount.lock.tryLock()) {
			try {
				if (toAccount.lock.tryLock()) {
					try {
						if (fromAccount.getBalance().Compareto(amount) < 0) {
							throw new InsufficientFundsException(); // 余额不足
						} else {
							fromAccount.debit(amount);
							toAccount.credit(amount);
					} finally {
						toAccount.lock.unlock();
					}
				}
			} finally {
				fromAccount.lock.unlock();
			}
		}
	}
}
}}}

还可以指定时限：

{{{class="brush: java"
if (!lock.tryLock(time, NANOSECONDS))
	return false;
try {
	/* do something */
} finally {
	lock.unlock();
}
}}}

还可以指定取锁过程中可以响应中断。这样还要多加一个`try-catch`再处理中断异常的：

{{{class="brush: java"
try {
	lock.lockInterruptibly(); // 可中断
	try {
		// do something 
	} finally {
		lock.unlock();
	}
} catch (InterruptedException) {
	// do something
}
}}}



== 分开读写锁 ==

`ReentrantReadWriteLock`分开读写锁以取得更加细的控制：

{{{class="brush: java"
private final ReadWriteLock monitor = new ReentrantReadWriteLock();

monitor.readLock.lock()
monitor.readLock.unlock()

monitor.writeLock.lock()
monitor.writeLock.unlock()
}}}

例：成员变量有`a`、`b`两个，操作有三个：

* 读`a`
* 读`b`
* 同时修改`a`与`b`

可以用读锁控制前两个操作，写锁控制后一个。这样两个读操作就看不到第三个操作执行
了一半，只改了`a`还没有修改`b`这样的情况。

对于大量读而少量改的情况下，读写锁可以明显提升性能：

{{{class="brush: java; highlight: [4,5,12,16,22,26]"
public class ReadWriteMap<K,V> {
	private final Map<K,V> map;
	private final ReadWriteLock lock = new ReentrantReadWriteLock();
	private final Lock r = lock.readLock();
	private final Lock w = lock.writeLock();

	public ReadWriteMap(Map<K,V> map) {
	this.map = map;
	}

	public V put(K key, V value) {
		w.lock();
		try {
			return map.put(key, value);
		} finally {
			w.unlock();
		}
	}

	// Do the same for remove(), putAll(), clear()
	public V get(Object key) {
		r.lock();
		try {
			return map.get(key);
		} finally {
			r.unlock();
		}
	}

	// Do the same for other read-only Map methods
}
}}}

当然`ConcurrentHashMap`性能已经不错了。这里演示了一下怎么提高其他的Map的并发
性能。




= Condition =

== 条件队列的缺陷 ==

例子：现在有一个队列被多个线程访问。

出队方法检查如果没有元素就等待其他线程放入元素以后再唤醒它。成功放入元素以后，
它也会唤醒一下其他线程，因为可能有别的取出线程看到队列空了以后等待有元素的：

{{{class="brush: java"
public void put(Object obj) {
	while(this.isFull())
		wait();

	doPut(obj);
	notifyAll();
}
}}}

以上设计有些问题：

* 被唤醒的原因不一定是因为队列不满了。
* 就算是因为队列空了，也有可能在异步过程中其他线程又放满了。

对于以上的忙等待模式，可以改进为下面的套路：用一个对象作为锁来同步防止又被改掉
了：

{{{class="brush: java"
void func() throws InterruptException {
	synchronized (lock) {
		while(!isReady)
			lock.wait();

		// do something
	}
}
}}}

这样解决了出错问题，但还有性能问题：`notify()`选一个唤醒，而`notifyAll()`会唤醒
多个线程。很多被唤醒的线程不是真的满足了条件，它们会又一次竞争锁。然后只有一个
得到锁其他的又进入等待。这样很浪费。

另外，推荐调用`notifyAll`，虽然性能比`notify`低，但是更容易确保类的行为是正确的
。

== 使用Condition ==

`Condition`提供了更加细致的条件，比条件队列要好。接口的主要方法：

{{{class="brush: java"
public interface Condition {
	void await() throws InterruptedException;
	boolean await(long time, TimeUnit unit) throws InterruptedException;
	long awaitNanos(long nanosTimeout) throws InterruptedException;
	void awaitUninterruptibly();
	boolean awaitUntil(Date deadline) throws InterruptedException;
	void signal();
	void signalAll();
}
}}}

`Condition`通过外部锁`Lock.newCondition`方法创建。对于同一个`Lock`可以有多个
`Condition`。`Condition`继承了相差`Lock`对象的公平性，对于公平的锁，线程会按FIFO
顺序从`Condtion.await`中释放。

通过`Lock`对象的`newCondition`方法来取得`Condition`对象。它的`await`方法会释放锁
并挂起当前线程，等待其他线程调用这个对象的`signal`或`signalAll`访求表示条件已经
满足。这些方法的调用推荐用`try-finally`包起来。


例子：

{{{class="brush: java; highlight: [4,6,7,9,18,21,26,28,34,37,43,46]"
@ThreadSafe
public class ConditionBoundedBuffer<T> {

	protected final Lock lock = new ReentrantLock();
	
	// CONDITION PREDICATE: notFull (count < items.length)
	private final Condition notFull = lock.newCondition();
	// CONDITION PREDICATE: notEmpty (count > 0)
	private final Condition notEmpty = lock.newCondition();
	
	@GuardedBy("lock")
	private final T[] items = (T[]) new Object[BUFFER_SIZE];
	@GuardedBy("lock")
	private int tail, head, count;

	// BLOCKS-UNTIL: notFull
	public void put(T x) throws InterruptedException {
		lock.lock();
		try {
			while (count == items.length)
				notFull.await();
			items[tail] = x;
			if (++tail == items.length)
				tail = 0;
			++count;
			notEmpty.signal();
		} finally {
			lock.unlock();
		}
	}

	// BLOCKS-UNTIL: notEmpty
	public T take() throws InterruptedException {
		lock.lock();
		try {
			while (count == 0)
				notEmpty.await();
			T x = items[head];
			items[head] = null;
			if (++head == items.length)
				head = 0;
			--count;
			notFull.signal();
			return x;
		} finally {
			lock.unlock();
		}
	}

}
}}}

例子： 时间监听器接口在时间增长时执行操作：

{{{class="brush: java"
package thread;
 
import java.util.Date;
 
public interface ClockListener {
 
    public void update(Date date);
 
}
}}}

时钟类记录时间增长：

{{{class="brush: java"
package thread;
 
import java.util.Date;
 
public class Clock implements Runnable {
    private ClockListener listener;
    private boolean run = true;
 
    public Clock(ClockListener listener) {
        this.listener = listener;
        new Thread(this).start();
    }
 
    @Override
    public void run() {
        long lastTime = System.currentTimeMillis();
        while (this.run) {
            try {
                Thread.sleep(10);
            } catch (InterruptedException e) {
                // do nothing
            }
            long now = System.currentTimeMillis();
            if ((now / 1000) - (lastTime / 1000) >= 1) {
                listener.update(new Date(now));
                lastTime = now;
            }
        }
    }
 
    public void stop() {
        this.run = false;
    }
 
}
}}}

测试，检查记录的时间列表是不是每个时间项目都比前一个增加一秒钟：

{{{class="brush: java"
package thread;
 
import java.util.Date;
 
public class Clock implements Runnable {
    private ClockListener listener;
    private boolean run = true;
 
    public Clock(ClockListener listener) {
        this.listener = listener;
        new Thread(this).start();
    }
 
    @Override
    public void run() {
        long lastTime = System.currentTimeMillis();
        while (this.run) {
            try {
                Thread.sleep(10);
            } catch (InterruptedException e) {
                // do nothing
            }
            long now = System.currentTimeMillis();
            if ((now / 1000) - (lastTime / 1000) >= 1) {
                listener.update(new Date(now));
                lastTime = now;
            }
        }
    }
 
    public void stop() {
        this.run = false;
    }
 
}
}}}






= Synchronizer =

== AQS ==

`ReentrantLock`与`Semaphore`这两个接口的功能很相像，甚至可以通过`ReentrantLock`
来实现`Semaphore`或反过来。下面是一个用`Lock`械实现信号量的例子：

{{{class="brush: java"
@ThreadSafe
public class SemaphoreOnLock {
	private final Lock lock = new ReentrantLock();
	// CONDITION PREDICATE: permitsAvailable (permits > 0)
	private final Condition permitsAvailable = lock.newCondition();
	@GuardedBy("lock") private int permits;

	SemaphoreOnLock(int initialPermits) {
		lock.lock();
		try {
			permits = initialPermits;
		} finally {
			lock.unlock();
		}
	}

	// BLOCKS-UNTIL: permitsAvailable
	public void acquire() throws InterruptedException {
		lock.lock();
		try {
			while (permits <= 0)
			permitsAvailable.await();
			--permits;
		} finally {
			lock.unlock();
		}
	}

	public void release() {
		lock.lock();
		try {
			++permits;
			permitsAvailable.signal();
		} finally {
			lock.unlock();
		}
	}
}
}}}

实际上外部锁和信号量都是用了同一个基类`AbstractQueuedSynchronizer`即AQS，它是
很多其他同步类的基类。AQS是一个用于构造锁和同步的框架，`CountDownLatch`、
`SynchronousQueue`、`FutureTask`等都是通过它实现的。

通过实现AQS构建同步器不心处理在多个位置上的竞争问题，它只会在一个时刻发生阻塞，
降低了上下文开销。

== 实现AQS ==

一般现有的工具已经够用了。但是有必要了解一下通过AQS实现同步器的原理。最基本的
两个操作是“获取（acquire）”和“释放（release）”。

一般获取操作要依赖状态，并通常会阻塞。比如取得锁或信号量、`CountDownLatch`中等待
闭锁到结束状态、`FutureTask`中等待任务完成。

释放操作是不可阻塞的，所以请求时被阻塞的线程都开始执行。

AQS中的状态是一个整数信息，可心通过`getState`、`setState`、`compareSetState`等
`protected`方法来操作。例如在`ReentrantLock`中用它来表示所有者线程已经重复取得
该锁的次数、信号量中用来表示剩下的许可数量，`FutureTask`用来表示任务的状态。
实现类中还可以加上新的信息，如`ReentrantLock`中保存了锁的所有者信息，这样就可以
区别这是重入不审锁竞争。

下面的伪代码显示了AQS中获取操作与释放操作的形式：

{{{class="brush: java"
boolean acquire() throws InterruptedException {
	while (当前状态不允许获取操作) {
		if (需要阻塞获取请求) {
			如果当前线程不在队列中，把它放入队列
			阻塞当前线程
		}
		else
			return failure
	}
	可能更新同步器的状态
	如果线程在队列中，反它移出队列
	return success
}

void release() {
	更新同步器状态
	if (新状态允许某个被阻塞的线程成功获取)
		解除队列中一个或多个线程的阻塞状态
}
}}}

根据同步器的不同，获取操作可以是独占操作（如`ReentrantLock`），也可以是非独占的
（如信号量和`CountDownLatch`）。

一个获取操作分成两步。先是判断是否能获取，可以就允许线程执行，不可以就阻塞或失败
。比如锁是否被其他线程持有，闭锁是否处于结束状态。然后再更新同步器的状态，这可能
会对其他线程是否能取得这个同步器造成影响。如果是个锁的话，被一个线程获取了就不能
被其他线程获取了。

如果某同步器支持独占操作，那么要再实现一些保护方法：`tryAcquire`、`tryRelease`、
`isHeldExclusively`等。如果是可以共享取得同步器的，应该实现：`tryAcquireShared`
、`tryReleaseShared`等方法。


=== 实现一个简单的闭锁 ===

一个简单的二元闭锁。两个公有方法`await`和`signal`分别对应获取和释放。我们定义
`state`为1时表示打开，为0时表示锁住：

{{{class="brush: java; highlight: [13,15,17,20,21]"
@ThreadSafe
public class OneShotLatch {
	private final Sync sync = new Sync();

	public void signal() {
		sync.releaseShared(0);
	}

	public void await() throws InterruptedException {
		sync.acquireSharedInterruptibly(0);
	}

	private class Sync extends AbstractQueuedSynchronizer {

		protected int tryAcquireShared(int ignored) {
			// Succeed if latch is open (state == 1), else fail
			return (getState() == 1) ? 1 : -1;
		}

		protected boolean tryReleaseShared(int ignored) {
			setState(1); // Latch is now open
			return true; // Other threads may now be able to acquire

		}
	}
}
}}}

注意这里没有直接继承AQS而是在外面包了一层，但这样会暴露出太多AQS的方法给用户，
所以`java.util.concurrent`包中很多同步器也没有用继承的方式。


== Java并发包中的AQS ==

介绍一下Java提供的同步器中是如何使用AQS的。

=== ReentrantLock ===

只支持独占获取操作，所以实现了`tryAcquire`、`tryRelease`、`isHeldExclusively`。
同步状态保存获取锁操作的次数，还有一个`owner`变量记录当前所有的线程。在
`tryRelease`中检查`owner`以保证当前线程执行`unlock`时已经获取了锁。`tryAcquire`
中使用`owner`来判断操作是重入还是竞争：

{{{class="brush: java"
protected boolean tryAcquire(int ignored) {
	final Thread current = Thread.currentThread();
	int c = getState();
	if (c == 0) {
		if (compareAndSetState(0, 1)) {
			owner = current;
			return true;
		}
	} else if (current == owner) {
		setState(c+1);
		return true;
	}
	return false;
}
}}}

=== Semaphore与CountDownLatch ===

信号量的AQS状态用于保存可用的许可数量。`tryAcquireShared`方法来操作许可数量。
在检查到还有可用的情况下用`compareAndSetState`以原子操作方式减少许可。

{{{class="brush: java"

protected int tryAcquireShared(int acquires) {
	while (true) {
		int available = getState();
		int remaining = available - acquires;
		if (remaining < 0 || compareAndSetState(available, remaining))
			return remaining;
	}
}

protected boolean tryReleaseShared(int releases) {
	while (true) {
		int p = getState();
		if (compareAndSetState(p, p + releases))
			return true;
	}
}
}}}

`CountDownLatch`也类似，`countDown`方法调用`release`；`await`调用`acquire`，当
计数器为0时`acquire`方法立即返回，不然就阻塞。


=== FutureTask ===

虽然看起来不像是同步器，但`Future.get`语言非常像闭锁。这里用AQS状态来保证任务
执行状态，还有其他的状态来保存异常与计算结果。

还特别维护了一个引用指向执行计算任务的线程，因为任务如果取消，这个线程就会中断
。


=== ReentrantReadWriteLock ===

虽然有读和写两个锁，实现中是用单个AQS子类同时管理两个锁。状态值是32位整数。它
用了16位的状态来表示写入锁计数，并用另一个16位状态来表示读取锁读数。在读锁上的
操作将使用共享的获取方法与释放方法，在写锁上的操作使用独占的获取方法与释放方法。

AQS在内部维护一个等待线程队列，其中记录了某个线程请求是独占的还是共享。在读写锁
中，锁可用时如果位于队头部的线程执行的是写入，那会取得这个锁。如果是读操作，那第
队列中在第一个写入线程之前的所有线程都将获取这个锁。



= Fork-Join =

Java 7新提供了“Fork-Join”机制。在多个线程并行的情况下，如果有些进程处于等待
状态会自动转而处理其他可以进行的任务以提高性能。

适合Fork-Join的情况：

* 任务开销不要太大；希望没有副作用；希望没有同步操作。
* 适合分解成小的任务。

== 实现方式 ==

实现`RecursiveTask`接口，并重写`compute`方法。里面可以执行多个`ForkJoinTask`。
`invokeAll`启动所以的任务，先完成或阻塞的子任务会自动转而完成还没有完成的任务。
如：

{{{class="brush: java; highlight: [1,6,10]"
private static class FileSizeFinder extends RecursiveTask<Long> {
	@Override
	public Long compute() {
		long size = 0;
		
		List<ForkJoinTask<Long>> tasks = new ArrayList<ForkJoinTask<Long>>();
		// add task to list
		// ...
		
		for(final ForkJoinTask<Long> task : invokeAll(tasks)) {
			size += task.join();
		}
		return size;
	}
}
}}}

调用时用`ForkJoinPool`：

{{{class="brush: java"
private final static ForkJoinPool forkJoinPool = new ForkJoinPool();
final long total = forkJoinPool.invoke(new FileSizeFinder(new File(args[0])));
}}}

注意`forkJoinPool`必须是静态成员才可以在整个应用中共享。

统计目录下所有文件大小的完整代码如下：

{{{class="brush: java"
package com.agiledeveloper.pcj;

import java.util.concurrent.ForkJoinPool;
import java.util.concurrent.ForkJoinTask;
import java.util.concurrent.RecursiveTask;
import java.util.List;
import java.util.ArrayList;
import java.io.File;

public class FileSize {

	private final static ForkJoinPool forkJoinPool = new ForkJoinPool();

	private static class FileSizeFinder extends RecursiveTask<Long>
	{
		final File file;

		public FileSizeFinder(final File theFile) {
			file = theFile;
		}

		@Override
		public Long compute() {
			long size = 0;
			if (file.isFile()) {
				size = file.length();
			} else {
				final File[] children = file.listFiles();
				if (children != null) {
					List<ForkJoinTask<Long>> tasks = 
						new ArrayList<ForkJoinTask<Long>>();
					for(final File child : children) {
						if (child.isFile()) {
							size += child.length();
						} else {
							tasks.add(new FileSizeFinder(child));
						}
					}

					for(final ForkJoinTask<Long> task : invokeAll(tasks)) {
						size += task.join();
					}
				}
			}

			return size;
		}
	}

	public static void main(final String[] args) {
		final long start = System.nanoTime();
		final long total = forkJoinPool.invoke(
				new FileSizeFinder(new File(args[0])));
		final long end = System.nanoTime();
		System.out.println("Total Size: " + total);
		System.out.println("Time taken: " + (end - start)/1.0e9);		
	}
}
}}}
