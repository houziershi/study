
%title 并发方案

%toc 并发方案


= 原子操作 =

== 原子操作类 ==

`java.utils.concurrent.atomic`包装器把对象包装成原子操作。

`AtomicLong`类的原子方法`incrementAndGet()`和`decresmentAndGet()`。

== 原子包装器 ==

包装集合为不可变版本：`Collections.unmodifiableLists(list)`

包装同步版：`SynchronizedMap m = Collection.SynchronizedMap(new HashMap())`

把一个引用包装成原子访问：

{{{class="brush: java"
private final AtomicReferency<BigInteger> lastNumber = 
	new AtomicReferency<BigInteger>()
	
private final AtomicReferency<BigInteger> firstNumber = 
	new AtomicReferency<BigInteger>()
}}}

但注意上面的例子，虽然每个数字的访问是原子性的，但一起操作两个数字的方法不是
线程安全的。



= 并发容器 =

Java 5中新加入的并发类为并发环境进行了优化。`Queue`和`BlockingQueue`实现了队列，

`CuncurrentHashMap`实现并发Map。

Java 6引入了`ConcurrentSkipListMap`和`ConcurrentSkipListSet`对应`Sortedmap`和
`SortedSet`。

并发容器的迭代器不会抛出`ConcurrentModificationExcetpion`，可以不加锁就进行迭代
。这样的迭代器具有弱一致性（Weakly Consistent），而不是“及时失败”。弱一致性可以
容忍并发的修改，当创建迭代器时会遍历已有的元素，并可以（但不保证）在迭代器被构造
后将修改操作反映给容器。

对于并发容器来说`size`或`isEmpty`这样的方法返回的结果可能是已经过期的结果。但
在并发环境下这样的状态总是在不断变化的，所以这样的方法意义不大。

== 并发队列 ==

常用队列：

* `Queue`不阻塞，空时取返回空；满时放抛异常。
* `SynchrousQueue`会同步插入与删除操作。
* `BlockingQueue`存取操作会阻塞。
* `PriorityBlockingQueue`带优先级的队列。


=== 阻塞队列 ===

简单的阻塞队列可以用`LinkedblockingQueue`或`ArrayBlockingQueue`。

对于队列空取或满存的情况有四种策略：

* 抛出异常。
* 特殊值。空取时为`null`；满存时为`false`。
* 阻塞。
* 超时。只会阻塞指定的时间。

|      | 抛出异常  | 特殊值   | 阻塞   | 超时                 |
| 插入 | add(e)    | offer(e) | put(e) | offer(e, time, unit) |
| 移除 | remove()  | poll()   | take() | poll(time, unit)     |
| 检查 | element() | peek()   | 不可用 | 不可用               |

=== 饱和策略 ===

* `Abort`：抛异常，调用者处理异常。
* `Discard`：丢掉任务。
* `DiscardOlds`：丢掉最老的任务。
* `DiscardPolicy`：丢掉优先级最低的。
* `Caller_Runs`：不抛异常，退回给调用者。用一个`execute()`执行它。

=== 队列工作的问题 ===

请求来太快了把等待队列也占满了。太长或是无限的队列，用`SynchronizeQueue`避免
队列任务。它不是真的队列而是一个移交机制（相当于只有一个容量的队列），前一个
请求没有处理完后一个请求会被拒绝。

阻塞队列不能用循环忙等待，标志位退出的方式。可以在队列里放一个特殊成员，读到它
就表示应该退出。



== ConcurrentHashMap ==

`ConcurrentHashMap`等为并发环境设计。为了优化性能不只用了一个锁，而是采用分段锁
（Lock Striping），所以增加了并发性能。

`ConcurrentHashMap`是为了强化并发环境下使用，所以没有办法对它的`Map`加锁以独占
访问。这是弱化独占访问而加强了`get`、`put`、`containsKey`、`remove`等方法的
并发性的取舍。


=== 额外的原子操作 ===

虽然不能加锁独占方问，但为一些复合操作为提供了原子操作。如：“没有则添加”、“相等
则替换”。

{{{class="brush: java"
public interface ConcurrentMap<K,V> extends Map<K,V> {

	// Insert into map only if no value is mapped from K
	V putIfAbsent(K key, V value);

	// Remove only if K is mapped to V
	boolean remove(K key, V value);

	// Replace value only if K is mapped to oldValue
	boolean replace(K key, V oldValue, V newValue);

	// Replace value only if K is mapped to some value
	V replace(K key, V newValue);

}
}}}



= 应用：生产者－消费者模式 =

利用队列实现生产者－消费者模式。

== 双端队列与工作密取 ==

工作密取模式：生产者生成任务加到任务队列中，消费者在处理过程中会产生新的任务。
所以消费都也可以把任务加到工作队列中。

例如：对于网络爬虫来说，一个链接就是一个任务。爬虫把链接加入到队列中，解析器在
解析网页时会发现网页上有的链接，这又是新的任务。解析器要把新的链接再加到队列中
去。

Java 6增加了两种容器类型`Deque`（发音为deck）与`BlockingDeque`，分别对应`Queue`
和`BlockingQueue`扩展为双端队列，可以实现工作密取模式。

== 恢复中断 ==

必须处理`InterruptedException`，不然其他的线程就没有办法中断当前线程了：

{{{class="brush: java"
public class TaskRunnable implements Runnable {
	BlockingQueue<Task> queue;

	//...

	public void run() {
		try {
			processTask(queue.take());
		} catch (InterruptedException e) {
			// 中断当前线程
			Thread.currentThread().interrupt();
		}
	}
}
}}}



= 信号量（Semaphore） =

信号量控制访问的总数。它的操作提原子的：

* 指定资源的总量：`Semaphore sem = new Semaphore(num);`
* 新访问记录占用资源：`sem.acquire();`
* 结束后记录放开资源：`sem.release();`



= 闭锁（Latch） =

Latch让多个线程等待把准备工作完成，再一起向下执行。

`CountDownLatch`是一个实现，通过计数器来控制：

* 子线程调用`countDown`方法把计数器减1。
* 主线程调用`await`方法等待，等计数器到0了启动。

在任务没有返回值的情况下，`CountDownLatch`比用`Future`更合适。

例：在计时测试中使用`CountDownLatch`来启动与停止线程：

{{{class="brush: java; highlight: [11, 13, 25, 26]"
public class TestHarness {
	public long timeTasks(int nThreads, final Runnable task)
			throws InterruptedException {
		final CountDownLatch startGate = new CountDownLatch(1);
		final CountDownLatch endGate = new CountDownLatch(nThreads);

		for (int i = 0; i < nThreads; i++) {
			Thread t = new Thread() {
				public void run() {
					try {
						startGate.await();
						try {
							task.run();
						} finally {
							endGate.countDown();
						}
					} catch (InterruptedException ignored) {
					}
				}
			};
			t.start();
		}

		long start = System.nanoTime();
		startGate.countDown();
		endGate.await();
		long end = System.nanoTime();
		return end - start;
	}
}
}}}





= 栅栏（Barrier） =

栅栏和闭锁一样也是控制一组线程，闭锁到一终止状态不能再重新复位了。闭锁用于等待
事件，而栅栏用于等待其他线程。

栅栏的实现类`CyclicBarrier`可以重复使用，在迭代算法中非常有用。把一个问题分成
多个子问题。

当线程到了栅栏位置以后调用`await`方法阻塞，等待所有线程都到了栅栏后放开栅栏一起
继续执行。栅栏也被复位以备下次使用；

如果`await`阻塞超时或是线程被中断，那么就认为栅栏被破坏了。所有阻塞的`await`会
抛出`BrokenBarrierException`。

如果成功通过栅栏，那么`await`会给每个线程发一个唯一的索引号，可以在索引中选一个
领导线程，由它在下一轮中执行一些特殊的工作。

`CyclicBarrier`的构造函数还可以接收一个`Runnable`，并在成功通过栅栏时在一个
子任务执行它。但是在线程被释放之前是不能执行的。

以一个细胞游戏为例子，在一个N*N的棋盘上，把整个棋盘分成多个小棋盘并行执行。：

{{{class="brush: java; highlight: [4, 10, 30]"
public class CellularAutomata {

	private final Board mainBoard;
	private final CyclicBarrier barrier;
	private final Worker[] workers;

	public CellularAutomata(Board board) {
		this.mainBoard = board;
		int count = Runtime.getRuntime().availableProcessors();
		this.barrier = new CyclicBarrier(count,
				new Runnable() {
					public void run() {
						mainBoard.commitNewValues();
					}});
		this.workers = new Worker[count];
		for (int i = 0; i < count; i++)
			workers[i] = new Worker(mainBoard.getSubBoard(count, i));
	}

	private class Worker implements Runnable {
		private final Board board;

		public Worker(Board board) { this.board = board; }
		public void run() {
			while (!board.hasConverged()) {
				for (int x = 0; x < board.getMaxX(); x++)
					for (int y = 0; y < board.getMaxY(); y++)
						board.setNewValue(x, y, computeValue(x, y));
				try {
					barrier.await();
				} catch (InterruptedException ex) {
					return;
				} catch (BrokenBarrierException ex) {
					return;
				}
			}
		}

		private int computeValue(int x, int y) {
			// Compute the new value that goes in (x,y)
			return 0;
		}
	}

	public void start() {
		for (int i = 0; i < workers.length; i++)
			new Thread(workers[i]).start();
		mainBoard.waitForConvergence();
	}

	interface Board {
		int getMaxX();
		int getMaxY();
		int getValue(int x, int y);
		int setNewValue(int x, int y, int value);
		void commitNewValues();
		boolean hasConverged();
		void waitForConvergence();
		Board getSubBoard(int numPartitions, int index);
	}

}
}}}



= Callable =

`Runnable`不能有返回值、也不能抛出异常，所以`Callable`更加好。`Callable`相当于
可以有返回结果的`Runnable`。例如一个返回`void`的`Callable`就是`Callable<void>`
。而且`Runnable`只能抛出非受检查异常，而`Callable`可以抛出受检查或非受检查异常。

`Callable`的接口方法是`call()`。如果想要一个在运行后有返回值是`void`类型的话
可以这样：`Callable<Void>`。



= Future =

`FutureTask`实现了`Future`语义，表示一个会有结果的计算。计算过程是通过`Callable`
接口实现的。`FutureTask`可以三种状态：

* 等待运行。
* 正在运行。
* 已经完成。

当任务处于完成状态以后就一直停在这个状态了。

`Future`通过`get`方法取得计算结果。取结果的行为取决于状态：

* 如果任务已经完成`get`会立即返回结果。
* 如果还没有完成就阻塞等待。然后成功返回结果或是抛异常。

`FutureTask`确保安全地计算结果从执行计算的线程传递到需要结果的线程。

如下面用`Future`来处理会花费大量时间的数据库访问任务：

{{{class="brush: java; highlight: [6, 19, 20]"
public class Preloader {
	ProductInfo loadProductInfo() throws DataLoadException {
		return null;
	}

	private final FutureTask<ProductInfo> future =
		new FutureTask<ProductInfo>(new Callable<ProductInfo>() {
			public ProductInfo call() throws DataLoadException {
				return loadProductInfo();
			}
		});
	private final Thread thread = new Thread(future);

	public void start() { thread.start(); }

	public ProductInfo get()
			throws DataLoadException, InterruptedException {
		try {
			return future.get();
		} catch (ExecutionException e) {
			Throwable cause = e.getCause();
			if (cause instanceof DataLoadException)
				throw (DataLoadException) cause;
			else
				throw LaunderThrowable.launderThrowable(cause);
		}
	}

	interface ProductInfo { }
}

class DataLoadException extends Exception { }
}}}

`Callable`会抛出异常，并且任何代码都会抛出`Error`。无论抛出了什么在`Future.get`
里都会被封装成`ExecutionException`以及`CancellationException`。由于这里抛出的
类型都是被作为`Throwable`返回的，所以处理起来有些复杂：

因为要判断抛出的类型是`CheckedException`？`RuntimeException`？还是`Error`？

如果是我们预想中的`DataLoadException`，走我们预计的处理方式。其他的可能性用
下面的工具类`LaunderThrowable`来处理异常。它会把强制把未检查的异常转为
`RuntimeException`：

{{{class="brush: java"
public class LaunderThrowable {
	/**
	 * Coerce an unchecked Throwable to a RuntimeException
	 * <p/>
	 * If the Throwable is an Error, throw it; if it is a
	 * RuntimeException return it, otherwise throw IllegalStateException
	 */
	public static RuntimeException launderThrowable(Throwable t) {
		if (t instanceof RuntimeException)
			return (RuntimeException) t;
		else if (t instanceof Error)
			throw (Error) t;
		else
			throw new IllegalStateException("Not unchecked", t);
	}
}
}}}

== 结合Future与CurrentMap实现缓存 ==

先定义一个接口`Computable`，`A`为输入类型，`V`为输出类型。接口方法`compute`是
计算主逻辑：

{{{class="brush: java"
public interface Computable<A, V> {
	V compute(A arg) throws InterruptedException;
}
}}}

带缓存的计算功能可以实现这个接口。通过`CurrentMap`的`putIfAbsent`实现原子性的
“没有则添加”；用`Future`表示计算正在执行，避免重计算同一个值：

{{{class="brush: java; highlight: [2, 12, 14, 19, 20, 23, 27]"
public class Memoizer <A, V> implements Computable<A, V> {
	private final ConcurrentMap<A, Future<V>> cache
			= new ConcurrentHashMap<A, Future<V>>();
	private final Computable<A, V> c;

	public Memoizer(Computable<A, V> c) {
		this.c = c;
	}

	public V compute(final A arg) throws InterruptedException {
		while (true) {
			Future<V> f = cache.get(arg);
			if (f == null) {
				Callable<V> eval = new Callable<V>() {
					public V call() throws InterruptedException {
						return c.compute(arg);
					}
				};
				FutureTask<V> ft = new FutureTask<V>(eval);
				f = cache.putIfAbsent(arg, ft);
				if (f == null) {
					f = ft;
					ft.run();
				}
			}
			try {
				return f.get();
			} catch (CancellationException e) {
				cache.remove(arg, f);
			} catch (ExecutionException e) {
				throw LaunderThrowable.launderThrowable(e.getCause());
			}
		}
	}
}
}}}

这样实现的带缓存的计算类可以用在`Servlet`里：

{{{class="brush: java; highlight: [3, 9]"
@ThreadSafe
public class Factorizer extends GenericServlet implements Servlet {
	private final Computable<BigInteger, BigInteger[]> c =
			new Computable<BigInteger, BigInteger[]>() {
				public BigInteger[] compute(BigInteger arg) {
					return factor(arg);
				}
			};
	private final Computable<BigInteger, BigInteger[]> cache
			= new Memoizer<BigInteger, BigInteger[]>(c);

	public void service(ServletRequest req, ServletResponse resp) {
		try {
			BigInteger i = extractFromRequest(req);
			encodeIntoResponse(resp, cache.compute(i));
		} catch (InterruptedException e) {
			encodeError(resp, "factorization interrupted");
		}
	}

	void encodeIntoResponse(ServletResponse resp, BigInteger[] factors) {
	}

	void encodeError(ServletResponse resp, String errorString) {
	}

	BigInteger extractFromRequest(ServletRequest req) {
		return new BigInteger("7");
	}

	BigInteger[] factor(BigInteger i) {
		// Doesn't really factor
		return new BigInteger[]{i};
	}
}
}}}



= Executor框架 =

== 传统任务管理的缺陷 ==

在同一线程中处理所有任务，性能差：

{{{class="brush: java"
public class SingleThreadWebServer {
	public static void main(String[] args) throws IOException {
		ServerSocket socket = new ServerSocket(80);
		while (true) {
			Socket connection = socket.accept();
			handleRequest(connection);
		}
	}

	private static void handleRequest(Socket connection) {
		// request-handling logic here
	}
}
}}}

为每个任务创建一个线程，太浪费资源：

{{{class="brush: java"
public class ThreadPerTaskWebServer {
	public static void main(String[] args) throws IOException {
		ServerSocket socket = new ServerSocket(80);
		while (true) {
			final Socket connection = socket.accept();
			Runnable task = new Runnable() {
				public void run() {
					handleRequest(connection);
				}
			};
			new Thread(task).start();
		}
	}

	private static void handleRequest(Socket connection) {
		// request-handling logic here
	}
}
}}}

== 用Executor框架 ==

在Java类库中，任务执行的主要抽象是`Executor`而不是`Thread`。所以每当看到：

{{{class="brush: java"
	new Thread(runnable).start();
}}}

这样的模式时，要考虑用`Executor`来代替`Thread`。

`Executor`接口代表一个任务，要实现的方法`execute`里是对`Runnable`对象的调用：

{{{class="brush: java"
public interface Executor {
	void execute(Runnable command);
}
}}}

`Executor`相当于一个基于生产者－消费者模式的任务队列，分开了任务提交与任务执行
的解耦。用它来实现一个基于线程池的Web服务器：

{{{class="brush: java; highlight: [3, 15]"
public class TaskExecutionWebServer {
	private static final int NTHREADS = 100;
	private static final Executor exec
			= Executors.newFixedThreadPool(NTHREADS);

	public static void main(String[] args) throws IOException {
		ServerSocket socket = new ServerSocket(80);
		while (true) {
			final Socket connection = socket.accept();
			Runnable task = new Runnable() {
				public void run() {
					handleRequest(connection);
				}
			};
			exec.execute(task);
		}
	}

	private static void handleRequest(Socket connection) {
		// request-handling logic here
	}
}
}}}

== 重写不同的线程策略 ==

前面说到`Executor`的接口方法`execute`：

{{{class="brush: java"
public interface Executor {
	void execute(Runnable command);
}
}}}

可以重写它来实现不同的策略，如：

为每个请求都创建一个线程：

{{{class="brush: java"
public class ThreadPerTaskExecutor implements Executor {
	void execute(Runnable r) {
		new Thread(r).start();
	}
}
}}}

或用同步的方法在当前线程中执行任务：

{{{class="brush: java"
public class WithinThreadExecutor implements Executor {
	void execute(Runnable r) {
		r.run();
	}
}
}}}

== 不同类型的线程池 ==

前面服务器例子中创建线程池的方法：

{{{class="brush: java"
Executor pool = Executors.newFixedThreadPool(num);
}}}

`Executors`可以调用不同的工厂方法返回不同的线程池：

`newFixedThreadPool`：固定长度。如果有线程因异常结束会补充一个新的。

`newCachedThreadPool`：可缓存。按需要回收空闲线程或添加新线程，并且不限制线程池
规模。

`newSingleThreadExecutor`：单线程的`Executor`。一个线程因为异常结束再建一个来
替换它。能保证依照任务顺序执行。还保证前一个任务的内存操作对下一个任务是
可见的。

`newScheduledThreadPool`：固定长度，并像`Timer`可以执行计划任务。


== Executor生命周期 ==

因为是异步的，所以提供了管理生命周期的工具`ExecutorService`，它继承了`Executor`
，并添加了控制生命周期的方法。

当`ExecutorService`关闭后，再提交任务会被抛弃，或使`execute`方法抛出未检查异常
`RejectedExecutionException`。

{{{class="brush: java"
public interface ExecutorService Extends Executor {

	/* 平缓关闭，不接新任务，等待已经加入的任务完成 *;
	void shutdown();
	
	/* 强关，停止所有正在运行的任务 */
	List<Runnable> shutdownNow();
	
	/* 可用来轮询是否终止 */
	boolean isShutdown();
	
	boolean isInited();
	

	boolean awaitTermination(long timeout, TimeUnit unit) 
		throws InterruptedException;
	// ... 其他方法
}
}}}

支持关闭操作的web服务器例子。不断地处理请求，有一个特殊的请求是关机，读到它就
关掉：

{{{class="brush: java; highlight: [2, 22, 31, 32]"
public class LifecycleWebServer {
	private final ExecutorService exec = Executors.newCachedThreadPool();

	public void start() throws IOException {
		ServerSocket socket = new ServerSocket(80);
		while (!exec.isShutdown()) {
			try {
				final Socket conn = socket.accept();
				exec.execute(new Runnable() {
					public void run() {
						handleRequest(conn);
					}
				});
			} catch (RejectedExecutionException e) {
				if (!exec.isShutdown())
					log("task submission rejected", e);
			}
		}
	}

	public void stop() {
		exec.shutdown();
	}

	private void log(String msg, Exception e) {
		Logger.getAnonymousLogger().log(Level.WARNING, msg, e);
	}

	void handleRequest(Socket connection) {
		Request req = readRequest(connection);
		if (isShutdownRequest(req))
			stop();
		else
			dispatchRequest(req);
	}

	interface Request {
	}

	private Request readRequest(Socket s) {
		return null;
	}

	private void dispatchRequest(Request r) {
	}

	private boolean isShutdownRequest(Request r) {
		return false;
	}
}
}}}


= 延时任务与周期任务 =

== 传统方案的不足 ==

=== Timer方案的不足 ===

`Timer`方案有缺点，因为执行的时候只创建一个线程。前一个任务时间长了会影响后面
任务的时间精确性。而且如果`TimerTask`抛出未检查异常中断了任务`Timer`也不会恢复
执行。

可以使用阻塞队列`DelayQueue`，它为`ScheduledThreadPoolExecutor`提供了调度功能。
`DelayQueue`里管理一组`Delayed`对象，每个都对应一个时间延迟。在`DelayQueue`里
只有某个元素逾期后才能从`DelayQueue`中执行`take`操作。`DelayQueue`中的对象按
延迟时间排序。

=== 忙等待方案 ===

{{{class="brush: java"
public void loopTask() {
	while (flag) {
		doSomething();
		sleep(100);
	}
}
}}}

* 这样的任务，每启动一个实例，就会有一个线程。操作系统最大线程数是有限的。
* 注意`sleep(100)`，占用了一个线程，大部分时间不害休眠状态。

== 周期性任务线程池 ==

`ScheduledThreadPoolExecutor`适合执行周期性任务。注意要用`static final`修饰才能
由多个线程共享：

{{{class="brush: java"
private static final ScheduledExecutorService timer = 
	Executors.newScheduledThreadPool(10);
}}}

成员方法`scheduleAtFixedRate(runnable)`接收任务，执行间隔等设置：

{{{class="brush: java"
private void init() {
	replenishTask = timer.scheduleAtFixedRate(
		new Runnable() {
			public void run() {
				// do something...
			}
		}, 0, 1, TimeUnit.SECONDS);
}
}}}

注意任务要处理掉异常，因为如果有异常抛出的话会中断周期任务。

`ScheduledExecutorService.shutdown()`关闭线程池。但是要注意已经启动的线程停不
下来。所以在创建线程池时指定线程的构造器让创建出来的线程都是守护线程：

{{{class="brush: java"
import java.util.concurrent.ThreadFactory;

private static final ScheduledExecutorService Timer =
	Executors.newScheduledThreadPool(10, ThreadFactory() {
		public Thread newThread(Runnable runnable) {
			Thread thread = new Thread(runnable);
			thread.setDaemon(true);
			return thread;
		}
	});
}}}



= 设计并行程序 =

之前已经说过`Callable`比`Runnable`好：可以有返回值还可以抛出受检查异常。

{{{class="brush: java"
public interface Callable<V> {
	V call() throws Exception;
}
}}}

`Runnable`和`Callable`都是对任务的抽象。在`Executor`框架中执行任务有四个阶段：
创建、提交、开始、完成。`Executor`框架中可以取消一个已经提交但是还没有开始执行
的任务；对于已经在执行的任务只能让它响应中断时才能取消。

`Future`表示一个任务的使命周期，并提供方法来判断是否已经完成或取消，以及取得
执行结果和取消任务。当一个`Future`执行完成以后，它就永远停在完成状态上。

{{{class="brush: java"
public interface Future<V> {
	boolean cancel(boolean mayInterruptIfRunning);
	boolean isCancelled();
	boolean isDone();
	
	V get() throws InterruptedException, ExecutionException, 
		CancellationException;
		
	V get(long timeout, TimeUnit unit) throws InterruptedException, 
		ExecutionException, CancellationException, TimeoutException;
}
}}}

有多个方法来创建`Future`：

`ExecutorService`中的`submit`方法以`Runnable`或`Callable`对象提交给`Executor`，
从而创建一个`Future`。可以用这个`Future`来执行任务或取消任务。

还可以显式地为某个`Runnalbe`或`Callable`实例化一个`FutureTask`。由于`FutureTask`
实现了`Runnable`，所以可以拿它提交给`Executor`来执行，或是直接调用它的`run`方法
。

从Java 6开始`ExecutorService`实现可以改写`AbstractExecutorService`中的
`newTaskFor` 方法从而根据已经提交的`Runnable`或`Callable`来控制`Future`的实例化
过程。在现有的默认的实现中，仅仅是创建了一个新的`FutureTask`：

{{{class="brush: java"
protected <T> RunnableFuture<T> newTaskFor(Callable<T> task) {
	return new FutureTask<T>(task);
}
}}}

在`Runnable`或`Callable`提交到`Executor`过程中是安全传递的，不会有等到构造了一半
的情况发生；把`Future`传递给其他线程也是安全的，所以在其他线程中可以放心使用
`get`方法取结果。


== 拆分任务并行执行 ==

以一个渲染网页程序为例子：渲染页面文字与下载页面上的图片这两种工作可以并行执行，
而且因为一个是CPU密集一个是IO密集，即使在单核CPU上性能提升也很明显：

把下载任务做成`Callable`传递给`ExecutorService`。当主任务要图片时会等
`Future.get`返回结果。当收到中断异常时，中断当前线程并退出。

{{{class="brush: java; highlight: [2,6,16,20,23]"
public abstract class FutureRenderer {
	private final ExecutorService executor = Executors.newCachedThreadPool();

	void renderPage(CharSequence source) {
		final List<ImageInfo> imageInfos = scanForImageInfo(source);
		Callable<List<ImageData>> task =
				new Callable<List<ImageData>>() {
					public List<ImageData> call() {
						List<ImageData> result = new ArrayList<ImageData>();
						for (ImageInfo imageInfo : imageInfos)
							result.add(imageInfo.downloadImage());
						return result;
					}
				};

		Future<List<ImageData>> future = executor.submit(task);
		renderText(source);

		try {
			List<ImageData> imageData = future.get();
			for (ImageData data : imageData)
				renderImage(data);
		} catch (InterruptedException e) {
			// Re-assert the thread's interrupted status
			Thread.currentThread().interrupt();
			// We don't need the result, so cancel the task too
			future.cancel(true);
		} catch (ExecutionException e) {
			throw launderThrowable(e.getCause());
		}
	}

	interface ImageData {
	}

	interface ImageInfo {
		ImageData downloadImage();
	}

	abstract void renderText(CharSequence s);

	abstract List<ImageInfo> scanForImageInfo(CharSequence s);

	abstract void renderImage(ImageData i);
}
}}}

上面的任务虽然很好地把CPU密集任务和IO密集任务分开了，这属于异构任务并行化。这样
的是很难确定这两边的任务负载是一样的。可能有一边很轻，马上就完成了，另一边还在
执行。所以很难保证效率提高了多少。

只有相互独立的同构任务可以并发处理时，才能体现出明显的提升。


== CompletionService与BlockingQueue ==

在身`Executor`提交了一组任务，可以用保留与每个任务相关的`Future`，反复调用`get`
方法，同时设参数`timeout`为`0`。这种轮询的方式虽然有用，但可以用更好的方法：
完成服务`CompletionServise`。

`CompletionServise`相当组合了`Executor`与`BlockingQueue`。可以把`Callable`任务
交给它执行，然后用类似于队列操作的`take`和`pall`等方法取结果。已经完成的结果被
封装为`Future`。

`CompletionServise`有一个实现类`ExecutorCompletionService`，可以把计算部分委托
给`Executor`。它的实现非常简单。在构造函数中创建一个`BlockingQueue`来保存计算
结果。当计算完成后，调用`FutureTask`中的`done`方法。当提交某个任务时，该任务
首先被包装为一个`QueueingFuture`，这是`FutureTask`的子类，然后改写`dome`方法，
并将结果存入`BlockingQueue`中。如下面代码，`take`和`poll`方法委托给了
`BlockingQueue`，这些方法会在得出结果前阻塞。

{{{class="brush: java"
private class QueueingFuture<V> extends FutureTask<V> {
	QueueingFuture(Callable<V> c) { super(c); }
	QueueingFuture(Runnable t, V r) { super(t, r); }
	
	protected void done() {
		completionQueue.add(this);
	}
}
}}}

使用`CompletionService`的例子。主要强化在两个地方：

* 为每张图片建立一个独立的任务，并在线程池中启动它们。这样下载变成并行任务。
* 从`CompletionService`中取得的结果是下载完立即显示出来。


{{{class="brush: java; highlight: [3, 12, 16, 26]"
public abstract class Renderer {

	private final ExecutorService executor;

	Renderer(ExecutorService executor) {
		this.executor = executor;
	}

	void renderPage(CharSequence source) {
		final List<ImageInfo> info = scanForImageInfo(source);
		
		CompletionService<ImageData> completionService =
				new ExecutorCompletionService<ImageData>(executor);
				
		for (final ImageInfo imageInfo : info)
			completionService.submit(new Callable<ImageData>() {
				public ImageData call() {
					return imageInfo.downloadImage();
				}
			});

		renderText(source);

		try {
			for (int t = 0, n = info.size(); t < n; t++) {
				Future<ImageData> f = completionService.take();
				ImageData imageData = f.get();
				renderImage(imageData);
			}
		} catch (InterruptedException e) {
			Thread.currentThread().interrupt();
		} catch (ExecutionException e) {
			throw launderThrowable(e.getCause());
		}
	}

	interface ImageData {
	}

	interface ImageInfo {
		ImageData downloadImage();
	}

	abstract void renderText(CharSequence s);

	abstract List<ImageInfo> scanForImageInfo(CharSequence s);

	abstract void renderImage(ImageData i);

}
}}}

多个`ExecutorCompletionService`可以共享一个`Executor`，所以可以创建一个特定的
`Executor`来计算私有任务，还可以能共享一个公共`Executor`的
`ExecutorCompletionService`。所以`CompletionService`的作为就相当于一组计算的句柄
，这与`Future`作为单个计算的够本是类似的。通过记录提交给`CompletionService`任务
的数量，并计算出已经获得的已经完成结果数量，即使使用一个共享的`Executor`也可以
知道已经获得了所有任务结果的时间。


== 设置任务的执行时限 ==

`Future.get`中可以设定超时限制，超时后抛出`TimeoutException`。一般在任务超时后
应该立即`Future.cancel(true)`停止，从而避免继续计算一个不能再用的结果而浪费计算
资源。如果编写的任务是可以取消的，可以提前中止它，防止消耗资源。

例子：从广告服务器上取广告。把广告任务交给`Executor`。如果超时就取消任务：

{{{class="brush: java; highlight: [3,10,15]"
Page renderPageWithAd() throws InterruptedException {
	long endNanos = System.nanoTime() + TIME_BUDGET;
	Future<Ad> f = exec.submit(new FetchAdTask());
	// Render the page while waiting for the ad
	Page page = renderPageBody();
	Ad ad;
	try {
		// Only wait for the remaining time budget
		long timeLeft = endNanos - System.nanoTime();
		ad = f.get(timeLeft, NANOSECONDS);
	} catch (ExecutionException e) {
		ad = DEFAULT_AD;
	} catch (TimeoutException e) {
		ad = DEFAULT_AD;
		f.cancel(true);
	}
	page.setAd(ad);
	return page;
}
}}}

超时任务还可以扩展到多个任务的情况。创建n个任务，提交到一个线程池，保留n个
`Future`。除了用`Future.get`方法一个一个取结果，还可以用一组任务为参数直接调用
`invokeAll`方法，按任务集合中迭代器顺序把所有的`Future`添加到返回集合中。这样
每个`Future`与对应的`Callable`关联起来了。所有任务都完毕或是超时以后`invokeAll`
方法将返回。可以用`get`方法或`isCancelled`方法来判断每个任务是否完成。

{{{class="brush: java; highlight: [17,19,24,28,30]"
private class QuoteTask implements Callable<TravelQuote> {
	private final TravelCompany company;
	private final TravelInfo travelInfo;
	...
	public TravelQuote call() throws Exception {
		return company.solicitQuote(travelInfo);
	}
}

public List<TravelQuote> getRankedTravelQuotes( TravelInfo travelInfo, 
		Set<TravelCompany> companies, Comparator<TravelQuote> ranking, 
		long time, TimeUnit unit) throws InterruptedException 
{
	List<QuoteTask> tasks = new ArrayList<QuoteTask>();

	for (TravelCompany company : companies)
		tasks.add(new QuoteTask(company, travelInfo));

	List<Future<TravelQuote>> futures = exec.invokeAll(tasks, time, unit);
	List<TravelQuote> quotes = new ArrayList<TravelQuote>(tasks.size());
	Iterator<QuoteTask> taskIter = tasks.iterator();

	for (Future<TravelQuote> f : futures) {
		QuoteTask task = taskIter.next();
		try {
			quotes.add(f.get());
		} catch (ExecutionException e) {
			quotes.add(task.getFailureQuote(e.getCause()));
		} catch (CancellationException e) {
			quotes.add(task.getTimeoutQuote(e));
		}
	}
	Collections.sort(quotes, ranking);

	return quotes;
}
}}}



= 取消、关闭任务与线程 =

Java没有提供安全终止线程的机制，`Thread`的`stop`与`suspend`等方法会有一些缺陷，
应该避免使用。推荐让一个线程调用中断来停止另一个线程。

取消或中断任务

=== 取消任务 ===

使用`volatile`的标记是否继续执行，公开方法`cancel`来修改标志位：

{{{class="brush: java; highlight: [8, 12, 21]"
@ThreadSafe
public class PrimeGenerator implements Runnable {
	private static ExecutorService exec = Executors.newCachedThreadPool();

	@GuardedBy("this")
	private final List<BigInteger> primes = new ArrayList<BigInteger>();

	private volatile boolean cancelled;

	public void run() {
		BigInteger p = BigInteger.ONE;
		while (!cancelled) {
			p = p.nextProbablePrime();
			synchronized (this) {
				primes.add(p);
			}
		}
	}

	public void cancel() {
		cancelled = true;
	}

	public synchronized List<BigInteger> get() {
		return new ArrayList<BigInteger>(primes);
	}
}
}}}

这是一种等等取消的策略，如果计算操作被阻塞的话，可能永远也不会检查到标志位。


=== 中断任务 ===

`Thread`类中的相关方法：

{{{class="brush: java"
public class Thread {
	
	/* 中断线程 */
	public void interrupt() { ... }

	/* 查看线程的中断状态 */
	public boolean isInterrupted() { ... }

	/* 静态方法，清除本线程的中断状态。注意不是目标线程
	   而是本线程 */
	public static boolean interrupted() { ... }
	
	...
}
}}}

在阻塞情况下被中断：

阻塞库方法，如`Thread.sleep`和`Object.wait`都会检查线程中断，在中断时返回。中断
时执行的操作有：清除中断状态，抛出`InterruptedException`表示任务提前结束。JVM
不保证阻塞方法检查到中断的速度，但其实还是挺快的。

在非阻塞情况下被中断：

非阻塞情况下被中断，它的中断状态会被设置，然后根据被取消的操作来检查中断状态以
判断发生了中断。这样如果不触发`InterruptedException`中断状态会一直保持，赶到明确
清除了中断状态。

调用`interrupt`方法只是发出一个请示。所以目标线程一定要处理中断异常，不然线程就
中断不了。

在调用静态的`interrupted`方法时一定要小心，因为它在返回了当前线程的中断状态同时
还会清除，所以如果返回了`true`就一定要处理，不然就丢失了一次中断请求。如下面的
代码地检查到有请求中断时马上中断当前任务：

{{{class="brush: java; highlight: [11, 18]"
class PrimeProducer extends Thread {
	private final BlockingQueue<BigInteger> queue;

	PrimeProducer(BlockingQueue<BigInteger> queue) {
		this.queue = queue;
	}

	public void run() {
		try {
			BigInteger p = BigInteger.ONE;
			while (!Thread.currentThread().isInterrupted())
			queue.put(p = p.nextProbablePrime());
		} catch (InterruptedException consumed) {
			/* Allow thread to exit */
		}
	}

	public void cancel() { interrupt(); }
}
}}}


=== 中断策略 ===

收到中断请求并不是说一定要马上处理，可以完成当前任务或是再加些善后，在合适的时候
再向上抛出中断异常、或其他方式表达已经收到中断请示。

当前任务并不一定是在一个独立的线程里运行，有可以和其他任务一起是一个串型的单线程
，也有可能是一个线程池里。所以一般业务逻辑代码收到了中断请求以后只向外抛中断异常
。让调用都或外部容器来进一步的操作。

执行的任务应该保存执行线程的中断状态，如果除了把`InterruptedException`传递给调用
者外还要有其他的操作，那么应该在捕获`InterruptedException`后恢复中断状态，即用
`interrupt`方法中断当前的线程：

{{{class="brush: java"
Thread.currentThread().interrupt();
}}}

=== 响应中断 ===

在阻塞函数调用时，处理中断的两种基本策略：

* 传递异常（可以在完成任务或善后），这样本方法也成了可中断的方法。
* 恢复中断状态，从而使调用栈中的上层代码可以对其进行处理。

继续抛出异常，可以只是简单地抛出：

{{{class="brush: java"
BlockingQueue<Task> queue;
...

public Task getNextTask() throws InterruptedException {
	return queue.take();
}
}}}

对于不支持取消但仍可以调用中断阻塞方法的操作，在忙等待检查中应该在本地保存中断
状态。因为大多数阻塞方法在入口处检查中断状态，在遇到中断时抛出
`InterruptedException`。

下面的代码用`interrupted`标记是正常完成还是被中断，如果是被中断的要恢复中断状态：

{{{class="brush: java; highlight: [2,8,14]"
public Task getNextTask(BlockingQueue<Taskgt; queue) {
	boolean interrupted = false;
	try {
		while (true) {
			try {
				return queue.take();
			} catch (InterruptedException e) {
				interrupted = true;
				// 继续循环，但记录下被中断过
			}
		}
	} finally {
		if (interrupted)
			Thread.currentThread().interrupt(); // 恢复线程的状态是中断的
	}
}
}}}

如果代码不会调用可中断的阻塞方法，那么还是可以通过任务代码中轮询当前线程中断状态
的方式来响应中断。

=== 通过Future来实现取消 ===

`Future.cancel(boolean)`设置任务是否可以检测到中断请求。下面的代码在超时后取消
那些不再需要结果的任务：

{{{class="brush: java"
public static void timedRun(Runnable r, long timeout, TimeUnit unit) 
	throws InterruptedException 
{
	Future<?> task = taskExec.submit(r);
	try {
		task.get(timeout, unit);
	} catch (TimeoutException e) {
		// 如果是因为超时，接下来的任务都被取消
	} catch (ExecutionException e) {
		//  如果是任务逻辑中的异常，继续抛出
		throw launderThrowable(e.getCause());
	} finally {
		// 已经结束，执行取消也不会有坏处
		task.cancel(true); // 如果任务正在运行，就会被中断
	}
}
}}}

当`Future.get`抛出中断异常或超时异常后，如果确定不再需要结果，那可以用
`Future.cancel`取消任务。


=== 处理不可中断的阻塞 ===

像是IO这样的阻塞操作提前返回或抛出中断异常来响应中断请求。如Socket IO的或内部锁
阻塞时被调用`interrupte`方法只设置线程中断状态，没有其他效果。所以对于不同的情况
要有不同的方法：

`java.io`包中的Socket IO。可以通过关闭Socket，让`read`或`write`等阻塞方法抛出
`SocketException`。

`java.io`包中的同步IO。`InterruptibleChannel`上阻塞的线程可以被中断并抛出
`ClosedByInterruptException`并关闭链路，还会引起同一链路上阻塞的其他线程同样抛出
`ClosedByInterruptException`。当关闭一个`InterruptibleChannel`时，阻塞在同一链路
上的所有阻塞线程抛出`AsynchronousClosedException`。

`Selector`的异步IO。因为`Selector.select`方法阻塞了，调用`close`或`wakeup`方法
会抛出`ClosedSelectorException`并提前返回。

内置锁。内置锁无法中断，推荐改用显式锁。

一个中断Socket连接的例子，重写了`interrupt`方法。在方法里关闭了连接并调用超类的
`interrupt`方法：

{{{class="brush: java; highlight: [13,16]"
public class ReaderThread extends Thread {

	private final Socket socket;
	
	// ...

	public ReaderThread(Socket socket) throws IOException {
		this.socket = socket;
		this.in = socket.getInputStream();
	}
	
	// ...

}
}}}


=== newTaskFor封装非标准的取消 ===

Java 6在`ThreadPoolExecutor`中增加了`newTaskFor`工厂方法，创建的代表任务的
`Future`对象。`newTaskFor`方法还能返回扩展`Future`和`Runnable`接口，并由
`FutureTask`实现的`RunnableFuture`接口。

下面的例子里我们定义了一个`CancellableTask`接口继承自`Callable`，它有`cancel`
方法和`newTask`工厂方法来创造`RunnableFuture`。`CancellingExecutor`继承自
`ThreadPoolExecutor`，并通过重写`newTaskFor`让`CancellableTask`可以创建自己的
`Future`：

{{{class="brush: java; highlight: [3,4,13,15,39]"

/*  任务 */
public interface CancellableTask<T> extends Callable<T> {
	void cancel();
	RunnableFuture<T> newTask();
}

/* 线程池 */
@ThreadSafe
public class CancellingExecutor extends ThreadPoolExecutor {
	...
	protected<T> RunnableFuture<T> newTaskFor(Callable<T> callable) {
		if (callable instanceof CancellableTask)
			return ((CancellableTask<T>) callable).newTask();
		else
			return super.newTaskFor(callable);
	}
}

public abstract class SocketUsingTask<T> implements CancellableTask<T> {
	@GuardedBy("this") 
	private Socket socket;
	
	protected synchronized void setSocket(Socket s) {
		socket = s;
	}
	
	public synchronized void cancel() {
		try {
			if (socket != null)
			socket.close();
		} catch (IOException ignored) {
		}
	}
	
	public RunnableFuture<T> newTask() {
		return new FutureTask<T>(this) {
			public boolean cancel(boolean mayInterruptIfRunning) {
				try {
					SocketUsingTask.this.cancel();
				} finally {
					return super.cancel(mayInterruptIfRunning);
				}
			}
		};
	}
	
}
}}}


== 停止基于线程的服务 ==

除了任务需要停止以外，还有很多为支持线程与任务提供的服务也需要停止，如线程池、
任务队列等……

由于线程的所有权是不可传递的，所以对于这些服务来说，应该通过它们自身生命周期方法
来停止它们。

对于设计服务的开发人员来说，如果这个服务存在的时间长于线程的方法存在的时间，就要
为这个服务提供生命周期方法。

=== 注意事项 ===

关闭一个服务不能仅仅中断服务的线程，还要考虑到服务中下执行到一半的任务等事项，
还有任务的阻塞状态。

=== 关闭ExecutorService ===

成员方法`shutdown`与`shutdownNow`。

=== 毒丸项目 ===

队列中一个特殊的成员，读到就表示应该停止了。


=== 只执行一次的服务 ===

服务要处理一批任务，当所有任务都处理完成后结束。这时可以用一个私有的`Executor`来
简化服务的生命周期管理，因为这个`Executor`的生命周期被限制于这个方法的调用。

下面的例子在多台主机上并行检查邮件。它创建一个私有的`Executor`，给每个主机提交
任务，任务全完成以后关闭`Executor`并等待结束。

注意这里`hasNewMail`标记的类型是`final AtomicBoolean`而不是`volatile boolean`
是因为必须是`final`的，不然内部类访问不到。

{{{class="brush: java; highlight: [6,8,18,19]"
public class CheckForMail {

	public boolean checkMail(Set<String> hosts, long timeout, TimeUnit unit)
			throws InterruptedException 
	{
		ExecutorService exec = Executors.newCachedThreadPool();

		final AtomicBoolean hasNewMail = new AtomicBoolean(false);
		try {
			for (final String host : hosts)
				exec.execute(new Runnable() {
					public void run() {
						if (checkMail(host))
							hasNewMail.set(true);
					}
				});
		} finally {
			exec.shutdown();
			exec.awaitTermination(timeout, unit);
		}
		return hasNewMail.get();
	}

	private boolean checkMail(String host) {
		// Check for mail
		return false;
	}
}
}}}



=== 记录关闭时的状态 ===

`ExecutorService`的`shutdownNow`把强制关掉正执行中的任务。下面实现的强化类
`TrackingExecutor`记录那些任务是已经开始但学没有正常完成的，在`Executor`结束后
可以通过`getCanceledTasks`方法取得还没有执行的任务。注意为了生效返回时一定要维持
线程的中断状态：

{{{class="brush: java; highlight: [9,20]"
public class TrackingExecutor extends AbstractExecutorService {
	private final ExecutorService exec;
	private final Set<Runnable> tasksCancelledAtShutdown =
			Collections.synchronizedSet(new HashSet<Runnable>());

	public List<Runnable> getCancelledTasks() {
		if (!exec.isTerminated())
			throw new IllegalStateException(/*...*/);
		return new ArrayList<Runnable>(tasksCancelledAtShutdown);
	}

	public void execute(final Runnable runnable) {
		exec.execute(new Runnable() {
			public void run() {
				try {
					runnable.run();
				} finally {
					if (isShutdown()
							&& Thread.currentThread().isInterrupted())
						tasksCancelledAtShutdown.add(runnable);
				}
			}
		});
	}

	public TrackingExecutor(ExecutorService exec) {
		this.exec = exec;
	}

	public void shutdown() {
		exec.shutdown();
	}

	public List<Runnable> shutdownNow() {
		return exec.shutdownNow();
	}

	public boolean isShutdown() {
		return exec.isShutdown();
	}

	public boolean isTerminated() {
		return exec.isTerminated();
	}

	public boolean awaitTermination(long timeout, TimeUnit unit)
			throws InterruptedException {
		return exec.awaitTermination(timeout, unit);
	}


}
}}}

在一个爬虫程序上应用上面`TrackingExecutor`的例子：

{{{class="brush: java; highlight: [12, 55]"
public abstract class WebCrawler {

	private class CrawlTask implements Runnable {
		private final URL url;

		CrawlTask(URL url) {
			this.url = url;
		}

		public void run() {
			for (URL link : processPage(url)) {
				if (Thread.currentThread().isInterrupted())
					return;
				submitCrawlTask(link);
			}
		}

		private int count = 1;

		boolean alreadyCrawled() {
			return seen.putIfAbsent(url, true) != null;
		}

		void markUncrawled() {
			seen.remove(url);
			System.out.printf("marking %s uncrawled%n", url);
		}


		public URL getPage() {
			return url;
		}
	}

	private volatile TrackingExecutor exec;
	@GuardedBy("this")
	private final Set<URL> urlsToCrawl = new HashSet<URL>();

	private final ConcurrentMap<URL, Boolean> seen = 
		new ConcurrentHashMap<URL, Boolean>();

	private static final long TIMEOUT = 500;
	private static final TimeUnit UNIT = MILLISECONDS;

	protected abstract List<URL> processPage(URL url);

	public WebCrawler(URL startUrl) {
		urlsToCrawl.add(startUrl);
	}

	public synchronized void stop() throws InterruptedException {
		try {
			saveUncrawled(exec.shutdownNow());
			if (exec.awaitTermination(TIMEOUT, UNIT))
				saveUncrawled(exec.getCancelledTasks());
		} finally {
			exec = null;
		}
	}

	public synchronized void start() {
		exec = new TrackingExecutor(Executors.newCachedThreadPool());
		for (URL url : urlsToCrawl) submitCrawlTask(url);
		urlsToCrawl.clear();
	}

	private void saveUncrawled(List<Runnable> uncrawled) {
		for (Runnable task : uncrawled)
			urlsToCrawl.add(((CrawlTask) task).getPage());
	}

	private void submitCrawlTask(URL u) {
		exec.execute(new CrawlTask(u));
	}

}
}}}

`TrackingExecutor`中存在一个不可避免的竞争条件：在线程池关闭时可能会有已经完成的
任务还是处于中断列表里没有更新。对于幂等操作这问题不大，但对于不可重复执行操作
会引发问题。

=== 程序异常终止 ===

线程API中`UncaughExceptionHandler`处理抛出的异常。防止任务中抛出了未捕获的异常，
而会影响到整个线程。这个接口很简单：

{{{class="brush: java"
public interface UncaughtExceptionHandler {
	void uncaughtException(Thread t, Throwable e);
}
}}}

可以实现接口来处理没有被捕获的异常，最简单的方式就是写日志：

{{{class="brush: java"
public class UEHLogger implements Thread.UncaughtExceptionHandler {
	public void uncaughtException(Thread t, Throwable e) {
		Logger logger = Logger.getAnonymousLogger();
		logger.log(Level.SEVERE,
			"Thread terminated with exception: " + t.getName(), e);
	}
}
}}}

要为线程池中所有线程设置一个`UncaughExceptionHandler`，需要为
`ThreadPoolExecutor` 的构造函数提供一个`ThreadFactory`（和所有的线程一样，只有
线程的所有都能改变线程的`UncaughExceptionHandler`）。

注意只有`execute`方法提交的任务才能把它抛出的异常交给处理器；`submit`提交的任务
无论是抛出的未检查异常还是受检查异常都被认为是任务返回状态的一部分由`Future.get`
封装在`ExecutionException`中重新抛出。


== JVM关闭 ==

正常关闭：

* 最后一个非守护进程结束。
* 调用System.exit()`方法。
* 被操作系统`SIGINT`信号或`Control-C`

非正常关闭：

* `Runtime.halt`
* 被操作系统`SIGINT`（被KILL掉）

=== 关闭钩子 ===

正常关闭时会调用关闭钩子，即通过`Runtime.addShutdownHook`方法注册的但还没有开始
的线程。钩子会并发挂靠，所以JVM不能保证钩子调用的顺序。所有钩子都执行完后如果
`funFinalizersOnExit`为`true`则JVM将运行终结器（垃圾回收器调用类的`finalize`
方法）。

钩子不应该对当前程序的状态做任何假设，如假设线程池是否已经关闭等。应该尽快做收尾
工作。

例：一个停止日志服务的钩子程序：

{{{class="brush: java"
public void start() {
	Runtime.getRuntime().addShutdownHook(new Thread() {
		public void run() {
			try { LogService.this.stop(); }
			catch (InterruptedException ignored) {}
		}
	});
}
}}}

=== 守护进程 ===

普通进程如果还没有执行完JVM是关不掉的；守护进程会随JVM关闭而关掉，是连`finilly`
块都不执行、连回卷栈操作也不执行，直接就关掉了。所以当心不是什么服务都可以作为
守护进程的。

=== 终结器（finallyze方法） ===

它的目的是清理资源，但是由于它的任何状态都可以被多个线程访问，而且不能保证什么
时候被调用或是会不会被调用。所以清理工作还是及时放在`finally`块中早点做掉保险。

{{{class="brush: java"
}}}



{{{class="brush: java"
}}}



{{{class="brush: java"
}}}



{{{class="brush: java"
}}}



{{{class="brush: java"
}}}



{{{class="brush: java"
}}}



{{{class="brush: java"
}}}



{{{class="brush: java"
}}}



{{{class="brush: java"
}}}



{{{class="brush: java"
}}}



{{{class="brush: java"
}}}



{{{class="brush: java"
}}}






