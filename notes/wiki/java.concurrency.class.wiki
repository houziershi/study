
%title 并发方案

%toc 并发方案


= 原子操作 =

== 原子操作类 ==

`java.utils.concurrent.atomic`包装器把对象包装成原子操作。

`AtomicLong`类的原子方法`incrementAndGet()`和`decresmentAndGet()`。

== 原子包装器 ==

包装集合为不可变版本：`Collections.unmodifiableLists(list)`

包装同步版：`SynchronizedMap m = Collection.SynchronizedMap(new HashMap())`

把一个引用包装成原子访问：

{{{class="brush: java"
private final AtomicReferency<BigInteger> lastNumber = 
	new AtomicReferency<BigInteger>()
	
private final AtomicReferency<BigInteger> firstNumber = 
	new AtomicReferency<BigInteger>()
}}}

但注意上面的例子，虽然每个数字的访问是原子性的，但一起操作两个数字的方法不是
线程安全的。



= 并发容器 =

Java 5中新加入的并发类为并发环境进行了优化。`Queue`和`BlockingQueue`实现了队列，

`CuncurrentHashMap`实现并发Map。

Java 6引入了`ConcurrentSkipListMap`和`ConcurrentSkipListSet`对应`Sortedmap`和
`SortedSet`。

并发容器的迭代器不会抛出`ConcurrentModificationExcetpion`，可以不加锁就进行迭代
。这样的迭代器具有弱一致性（Weakly Consistent），而不是“及时失败”。弱一致性可以
容忍并发的修改，当创建迭代器时会遍历已有的元素，并可以（但不保证）在迭代器被构造
后将修改操作反映给容器。

对于并发容器来说`size`或`isEmpty`这样的方法返回的结果可能是已经过期的结果。但
在并发环境下这样的状态总是在不断变化的，所以这样的方法意义不大。

== 并发队列 ==

常用队列：

* `Queue`不阻塞，空时取返回空；满时放抛异常。
* `SynchrousQueue`会同步插入与删除操作。
* `BlockingQueue`存取操作会阻塞。
* `PriorityBlockingQueue`带优先级的队列。


=== 阻塞队列 ===

简单的阻塞队列可以用`LinkedblockingQueue`或`ArrayBlockingQueue`。

对于队列空取或满存的情况有四种策略：

* 抛出异常。
* 特殊值。空取时为`null`；满存时为`false`。
* 阻塞。
* 超时。只会阻塞指定的时间。

|      | 抛出异常  | 特殊值   | 阻塞   | 超时                 |
| 插入 | add(e)    | offer(e) | put(e) | offer(e, time, unit) |
| 移除 | remove()  | poll()   | take() | poll(time, unit)     |
| 检查 | element() | peek()   | 不可用 | 不可用               |

=== 饱和策略 ===

* `Abort`：抛异常，调用者处理异常。
* `Discard`：丢掉任务。
* `DiscardOlds`：丢掉最老的任务。
* `DiscardPolicy`：丢掉优先级最低的。
* `Caller_Runs`：不抛异常，退回给调用者。用一个`execute()`执行它。

=== 队列工作的问题 ===

请求来太快了把等待队列也占满了。太长或是无限的队列，用`SynchronizeQueue`避免
队列任务。它不是真的队列而是一个移交机制（相当于只有一个容量的队列），前一个
请求没有处理完后一个请求会被拒绝。

阻塞队列不能用循环忙等待，标志位退出的方式。可以在队列里放一个特殊成员，读到它
就表示应该退出。



== ConcurrentHashMap ==

`ConcurrentHashMap`等为并发环境设计。为了优化性能不只用了一个锁，而是采用分段锁
（Lock Striping），所以增加了并发性能。

`ConcurrentHashMap`是为了强化并发环境下使用，所以没有办法对它的`Map`加锁以独占
访问。这是弱化独占访问而加强了`get`、`put`、`containsKey`、`remove`等方法的
并发性的取舍。


=== 额外的原子操作 ===

虽然不能加锁独占方问，但为一些复合操作为提供了原子操作。如：“没有则添加”、“相等
则替换”。

{{{class="brush: java"
public interface ConcurrentMap<K,V> extends Map<K,V> {

	// Insert into map only if no value is mapped from K
	V putIfAbsent(K key, V value);

	// Remove only if K is mapped to V
	boolean remove(K key, V value);

	// Replace value only if K is mapped to oldValue
	boolean replace(K key, V oldValue, V newValue);

	// Replace value only if K is mapped to some value
	V replace(K key, V newValue);

}
}}}



= 应用：生产者－消费者模式 =

利用队列实现生产者－消费者模式。

== 双端队列与工作密取 ==

工作密取模式：生产者生成任务加到任务队列中，消费者在处理过程中会产生新的任务。
所以消费都也可以把任务加到工作队列中。

例如：对于网络爬虫来说，一个链接就是一个任务。爬虫把链接加入到队列中，解析器在
解析网页时会发现网页上有的链接，这又是新的任务。解析器要把新的链接再加到队列中
去。

Java 6增加了两种容器类型`Deque`（发音为deck）与`BlockingDeque`，分别对应`Queue`
和`BlockingQueue`扩展为双端队列，可以实现工作密取模式。

== 恢复中断 ==

必须处理`InterruptedException`，不然其他的线程就没有办法中断当前线程了：

{{{class="brush: java"
public class TaskRunnable implements Runnable {
	BlockingQueue<Task> queue;

	//...

	public void run() {
		try {
			processTask(queue.take());
		} catch (InterruptedException e) {
			// 中断当前线程
			Thread.currentThread().interrupt();
		}
	}
}
}}}



= 信号量（Semaphore） =

信号量控制访问的总数。它的操作提原子的：

* 指定资源的总量：`Semaphore sem = new Semaphore(num);`
* 新访问记录占用资源：`sem.acquire();`
* 结束后记录放开资源：`sem.release();`



= 闭锁（Latch） =

Latch让多个线程等待把准备工作完成，再一起向下执行。

`CountDownLatch`是一个实现，通过计数器来控制：

* 子线程调用`countDown`方法把计数器减1。
* 主线程调用`await`方法等待，等计数器到0了启动。

在任务没有返回值的情况下，`CountDownLatch`比用`Future`更合适。

例：在计时测试中使用`CountDownLatch`来启动与停止线程：

{{{class="brush: java; highlight: [11, 13, 25, 26]"
public class TestHarness {
	public long timeTasks(int nThreads, final Runnable task)
			throws InterruptedException {
		final CountDownLatch startGate = new CountDownLatch(1);
		final CountDownLatch endGate = new CountDownLatch(nThreads);

		for (int i = 0; i < nThreads; i++) {
			Thread t = new Thread() {
				public void run() {
					try {
						startGate.await();
						try {
							task.run();
						} finally {
							endGate.countDown();
						}
					} catch (InterruptedException ignored) {
					}
				}
			};
			t.start();
		}

		long start = System.nanoTime();
		startGate.countDown();
		endGate.await();
		long end = System.nanoTime();
		return end - start;
	}
}
}}}





= 栅栏（Barrier） =

栅栏和闭锁一样也是控制一组线程，闭锁到一终止状态不能再重新复位了。闭锁用于等待
事件，而栅栏用于等待其他线程。

栅栏的实现类`CyclicBarrier`可以重复使用，在迭代算法中非常有用。把一个问题分成
多个子问题。

当线程到了栅栏位置以后调用`await`方法阻塞，等待所有线程都到了栅栏后放开栅栏一起
继续执行。栅栏也被复位以备下次使用；

如果`await`阻塞超时或是线程被中断，那么就认为栅栏被破坏了。所有阻塞的`await`会
抛出`BrokenBarrierException`。

如果成功通过栅栏，那么`await`会给每个线程发一个唯一的索引号，可以在索引中选一个
领导线程，由它在下一轮中执行一些特殊的工作。

`CyclicBarrier`的构造函数还可以接收一个`Runnable`，并在成功通过栅栏时在一个
子任务执行它。但是在线程被释放之前是不能执行的。

以一个细胞游戏为例子，在一个N*N的棋盘上，把整个棋盘分成多个小棋盘并行执行。：

{{{class="brush: java; highlight: [4, 10, 30]"
public class CellularAutomata {

	private final Board mainBoard;
	private final CyclicBarrier barrier;
	private final Worker[] workers;

	public CellularAutomata(Board board) {
		this.mainBoard = board;
		int count = Runtime.getRuntime().availableProcessors();
		this.barrier = new CyclicBarrier(count,
				new Runnable() {
					public void run() {
						mainBoard.commitNewValues();
					}});
		this.workers = new Worker[count];
		for (int i = 0; i < count; i++)
			workers[i] = new Worker(mainBoard.getSubBoard(count, i));
	}

	private class Worker implements Runnable {
		private final Board board;

		public Worker(Board board) { this.board = board; }
		public void run() {
			while (!board.hasConverged()) {
				for (int x = 0; x < board.getMaxX(); x++)
					for (int y = 0; y < board.getMaxY(); y++)
						board.setNewValue(x, y, computeValue(x, y));
				try {
					barrier.await();
				} catch (InterruptedException ex) {
					return;
				} catch (BrokenBarrierException ex) {
					return;
				}
			}
		}

		private int computeValue(int x, int y) {
			// Compute the new value that goes in (x,y)
			return 0;
		}
	}

	public void start() {
		for (int i = 0; i < workers.length; i++)
			new Thread(workers[i]).start();
		mainBoard.waitForConvergence();
	}

	interface Board {
		int getMaxX();
		int getMaxY();
		int getValue(int x, int y);
		int setNewValue(int x, int y, int value);
		void commitNewValues();
		boolean hasConverged();
		void waitForConvergence();
		Board getSubBoard(int numPartitions, int index);
	}

}
}}}



= Callable =

`Runnable`不能有返回值、也不能抛出异常，所以`Callable`更加好。`Callable`相当于
可以有返回结果的`Runnable`。例如一个返回`void`的`Callable`就是`Callable<void>`
。而且`Runnable`只能抛出非受检查异常，而`Callable`可以抛出受检查或非受检查异常。

`Callable`的接口方法是`call()`。如果想要一个在运行后有返回值是`void`类型的话
可以这样：`Callable<Void>`。



= Future =

`FutureTask`实现了`Future`语义，表示一个会有结果的计算。计算过程是通过`Callable`
接口实现的。`FutureTask`可以三种状态：

* 等待运行。
* 正在运行。
* 已经完成。

当任务处于完成状态以后就一直停在这个状态了。

`Future`通过`get`方法取得计算结果。取结果的行为取决于状态：

* 如果任务已经完成`get`会立即返回结果。
* 如果还没有完成就阻塞等待。然后成功返回结果或是抛异常。

`FutureTask`确保安全地计算结果从执行计算的线程传递到需要结果的线程。

如下面用`Future`来处理会花费大量时间的数据库访问任务：

{{{class="brush: java; highlight: [6, 19, 20]"
public class Preloader {
	ProductInfo loadProductInfo() throws DataLoadException {
		return null;
	}

	private final FutureTask<ProductInfo> future =
		new FutureTask<ProductInfo>(new Callable<ProductInfo>() {
			public ProductInfo call() throws DataLoadException {
				return loadProductInfo();
			}
		});
	private final Thread thread = new Thread(future);

	public void start() { thread.start(); }

	public ProductInfo get()
			throws DataLoadException, InterruptedException {
		try {
			return future.get();
		} catch (ExecutionException e) {
			Throwable cause = e.getCause();
			if (cause instanceof DataLoadException)
				throw (DataLoadException) cause;
			else
				throw LaunderThrowable.launderThrowable(cause);
		}
	}

	interface ProductInfo { }
}

class DataLoadException extends Exception { }
}}}

`Callable`会抛出异常，并且任何代码都会抛出`Error`。无论抛出了什么在`Future.get`
里都会被封装成`ExecutionException`以及`CancellationException`。由于这里抛出的
类型都是被作为`Throwable`返回的，所以处理起来有些复杂：

因为要判断抛出的类型是`CheckedException`？`RuntimeException`？还是`Error`？

如果是我们预想中的`DataLoadException`，走我们预计的处理方式。其他的可能性用
下面的工具类`LaunderThrowable`来处理异常。它会把强制把未检查的异常转为
`RuntimeException`：

{{{class="brush: java"
public class LaunderThrowable {
	/**
	 * Coerce an unchecked Throwable to a RuntimeException
	 * <p/>
	 * If the Throwable is an Error, throw it; if it is a
	 * RuntimeException return it, otherwise throw IllegalStateException
	 */
	public static RuntimeException launderThrowable(Throwable t) {
		if (t instanceof RuntimeException)
			return (RuntimeException) t;
		else if (t instanceof Error)
			throw (Error) t;
		else
			throw new IllegalStateException("Not unchecked", t);
	}
}
}}}

== 结合Future与CurrentMap实现缓存 ==

先定义一个接口`Computable`，`A`为输入类型，`V`为输出类型。接口方法`compute`是
计算主逻辑：

{{{class="brush: java"
public interface Computable<A, V> {
	V compute(A arg) throws InterruptedException;
}
}}}

带缓存的计算功能可以实现这个接口。通过`CurrentMap`的`putIfAbsent`实现原子性的
“没有则添加”；用`Future`表示计算正在执行，避免重计算同一个值：

{{{class="brush: java; highlight: [2, 12, 14, 19, 20, 23, 27]"
public class Memoizer <A, V> implements Computable<A, V> {
	private final ConcurrentMap<A, Future<V>> cache
			= new ConcurrentHashMap<A, Future<V>>();
	private final Computable<A, V> c;

	public Memoizer(Computable<A, V> c) {
		this.c = c;
	}

	public V compute(final A arg) throws InterruptedException {
		while (true) {
			Future<V> f = cache.get(arg);
			if (f == null) {
				Callable<V> eval = new Callable<V>() {
					public V call() throws InterruptedException {
						return c.compute(arg);
					}
				};
				FutureTask<V> ft = new FutureTask<V>(eval);
				f = cache.putIfAbsent(arg, ft);
				if (f == null) {
					f = ft;
					ft.run();
				}
			}
			try {
				return f.get();
			} catch (CancellationException e) {
				cache.remove(arg, f);
			} catch (ExecutionException e) {
				throw LaunderThrowable.launderThrowable(e.getCause());
			}
		}
	}
}
}}}

这样实现的带缓存的计算类可以用在`Servlet`里：

{{{class="brush: java; highlight: [3, 9]"
@ThreadSafe
public class Factorizer extends GenericServlet implements Servlet {
	private final Computable<BigInteger, BigInteger[]> c =
			new Computable<BigInteger, BigInteger[]>() {
				public BigInteger[] compute(BigInteger arg) {
					return factor(arg);
				}
			};
	private final Computable<BigInteger, BigInteger[]> cache
			= new Memoizer<BigInteger, BigInteger[]>(c);

	public void service(ServletRequest req, ServletResponse resp) {
		try {
			BigInteger i = extractFromRequest(req);
			encodeIntoResponse(resp, cache.compute(i));
		} catch (InterruptedException e) {
			encodeError(resp, "factorization interrupted");
		}
	}

	void encodeIntoResponse(ServletResponse resp, BigInteger[] factors) {
	}

	void encodeError(ServletResponse resp, String errorString) {
	}

	BigInteger extractFromRequest(ServletRequest req) {
		return new BigInteger("7");
	}

	BigInteger[] factor(BigInteger i) {
		// Doesn't really factor
		return new BigInteger[]{i};
	}
}
}}}



= Executor框架 =

== 传统任务管理的缺陷 ==

在同一线程中处理所有任务，性能差：

{{{class="brush: java"
public class SingleThreadWebServer {
	public static void main(String[] args) throws IOException {
		ServerSocket socket = new ServerSocket(80);
		while (true) {
			Socket connection = socket.accept();
			handleRequest(connection);
		}
	}

	private static void handleRequest(Socket connection) {
		// request-handling logic here
	}
}
}}}

为每个任务创建一个线程，太浪费资源：

{{{class="brush: java"
public class ThreadPerTaskWebServer {
	public static void main(String[] args) throws IOException {
		ServerSocket socket = new ServerSocket(80);
		while (true) {
			final Socket connection = socket.accept();
			Runnable task = new Runnable() {
				public void run() {
					handleRequest(connection);
				}
			};
			new Thread(task).start();
		}
	}

	private static void handleRequest(Socket connection) {
		// request-handling logic here
	}
}
}}}

== 用Executor框架 ==

在Java类库中，任务执行的主要抽象是`Executor`而不是`Thread`。所以每当看到：

{{{class="brush: java"
	new Thread(runnable).start();
}}}

这样的模式时，要考虑用`Executor`来代替`Thread`。

`Executor`接口代表一个任务，要实现的方法`execute`里是对`Runnable`对象的调用：

{{{class="brush: java"
public interface Executor {
	void execute(Runnable command);
}
}}}

`Executor`相当于一个基于生产者－消费者模式的任务队列，分开了任务提交与任务执行
的解耦。用它来实现一个基于线程池的Web服务器：

{{{class="brush: java; highlight: [3, 15]"
public class TaskExecutionWebServer {
	private static final int NTHREADS = 100;
	private static final Executor exec
			= Executors.newFixedThreadPool(NTHREADS);

	public static void main(String[] args) throws IOException {
		ServerSocket socket = new ServerSocket(80);
		while (true) {
			final Socket connection = socket.accept();
			Runnable task = new Runnable() {
				public void run() {
					handleRequest(connection);
				}
			};
			exec.execute(task);
		}
	}

	private static void handleRequest(Socket connection) {
		// request-handling logic here
	}
}
}}}

== 重写不同的线程策略 ==

前面说到`Executor`的接口方法`execute`：

{{{class="brush: java"
public interface Executor {
	void execute(Runnable command);
}
}}}

可以重写它来实现不同的策略，如：

为每个请求都创建一个线程：

{{{class="brush: java"
public class ThreadPerTaskExecutor implements Executor {
	void execute(Runnable r) {
		new Thread(r).start();
	}
}
}}}

或用同步的方法在当前线程中执行任务：

{{{class="brush: java"
public class WithinThreadExecutor implements Executor {
	void execute(Runnable r) {
		r.run();
	}
}
}}}

== 不同类型的线程池 ==

前面服务器例子中创建线程池的方法：

{{{class="brush: java"
Executor pool = Executors.newFixedThreadPool(num);
}}}

`Executors`可以调用不同的工厂方法返回不同的线程池：

`newFixedThreadPool`：固定长度。如果有线程因异常结束会补充一个新的。

`newCachedThreadPool`：可缓存。按需要回收空闲线程或添加新线程，并且不限制线程池
规模。

`newSingleThreadExecutor`：单线程的`Executor`。一个线程因为异常结束再建一个来
替换它。能保证依照任务顺序执行。还保证前一个任务的内存操作对下一个任务是
可见的。

`newScheduledThreadPool`：固定长度，并像`Timer`可以执行计划任务。


== Executor生命周期 ==

因为是异步的，所以提供了管理生命周期的工具`ExecutorService`，它继承了`Executor`
，并添加了控制生命周期的方法。

当`ExecutorService`关闭后，再提交任务会被抛弃，或使`execute`方法抛出未检查异常
`RejectedExecutionException`。

{{{class="brush: java"
public interface ExecutorService Extends Executor {

	/* 平缓关闭，不接新任务，等待已经加入的任务完成 *;
	void shutdown();
	
	/* 强关，停止所有正在运行的任务 */
	List<Runnable> shutdownNow();
	
	/* 可用来轮询是否终止 */
	boolean isShutdown();
	
	boolean isInited();
	

	boolean awaitTermination(long timeout, TimeUnit unit) 
		throws InterruptedException;
	// ... 其他方法
}
}}}

支持关闭操作的web服务器例子。不断地处理请求，有一个特殊的请求是关机，读到它就
关掉：

{{{class="brush: java; highlight: [2, 22, 31, 32]"
public class LifecycleWebServer {
	private final ExecutorService exec = Executors.newCachedThreadPool();

	public void start() throws IOException {
		ServerSocket socket = new ServerSocket(80);
		while (!exec.isShutdown()) {
			try {
				final Socket conn = socket.accept();
				exec.execute(new Runnable() {
					public void run() {
						handleRequest(conn);
					}
				});
			} catch (RejectedExecutionException e) {
				if (!exec.isShutdown())
					log("task submission rejected", e);
			}
		}
	}

	public void stop() {
		exec.shutdown();
	}

	private void log(String msg, Exception e) {
		Logger.getAnonymousLogger().log(Level.WARNING, msg, e);
	}

	void handleRequest(Socket connection) {
		Request req = readRequest(connection);
		if (isShutdownRequest(req))
			stop();
		else
			dispatchRequest(req);
	}

	interface Request {
	}

	private Request readRequest(Socket s) {
		return null;
	}

	private void dispatchRequest(Request r) {
	}

	private boolean isShutdownRequest(Request r) {
		return false;
	}
}
}}}


= 延时任务与周期任务 =

== 传统方案的不足 ==

=== Timer方案的不足 ===

`Timer`方案有缺点，因为执行的时候只创建一个线程。前一个任务时间长了会影响后面
任务的时间精确性。而且如果`TimerTask`抛出未检查异常中断了任务`Timer`也不会恢复
执行。

可以使用阻塞队列`DelayQueue`，它为`ScheduledThreadPoolExecutor`提供了调度功能。
`DelayQueue`里管理一组`Delayed`对象，每个都对应一个时间延迟。在`DelayQueue`里
只有某个元素逾期后才能从`DelayQueue`中执行`take`操作。`DelayQueue`中的对象按
延迟时间排序。

=== 忙等待方案 ===

{{{class="brush: java"
public void loopTask() {
	while (flag) {
		doSomething();
		sleep(100);
	}
}
}}}

* 这样的任务，每启动一个实例，就会有一个线程。操作系统最大线程数是有限的。
* 注意`sleep(100)`，占用了一个线程，大部分时间不害休眠状态。

== 周期性任务线程池 ==

`ScheduledThreadPoolExecutor`适合执行周期性任务。注意要用`static final`修饰才能
由多个线程共享：

{{{class="brush: java"
private static final ScheduledExecutorService timer = 
	Executors.newScheduledThreadPool(10);
}}}

成员方法`scheduleAtFixedRate(runnable)`接收任务，执行间隔等设置：

{{{class="brush: java"
private void init() {
	replenishTask = timer.scheduleAtFixedRate(
		new Runnable() {
			public void run() {
				// do something...
			}
		}, 0, 1, TimeUnit.SECONDS);
}
}}}

注意任务要处理掉异常，因为如果有异常抛出的话会中断周期任务。

`ScheduledExecutorService.shutdown()`关闭线程池。但是要注意已经启动的线程停不
下来。所以在创建线程池时指定线程的构造器让创建出来的线程都是守护线程：

{{{class="brush: java"
import java.util.concurrent.ThreadFactory;

private static final ScheduledExecutorService Timer =
	Executors.newScheduledThreadPool(10, ThreadFactory() {
		public Thread newThread(Runnable runnable) {
			Thread thread = new Thread(runnable);
			thread.setDaemon(true);
			return thread;
		}
	});
}}}



= 设计并行程序 =

之前已经说过`Callable`比`Runnable`好：可以有返回值还可以抛出受检查异常。

{{{class="brush: java"
public interface Callable<V> {
	V call() throws Exception;
}
}}}

`Runnable`和`Callable`都是对任务的抽象。在`Executor`框架中执行任务有四个阶段：
创建、提交、开始、完成。`Executor`框架中可以取消一个已经提交但是还没有开始执行
的任务；对于已经在执行的任务只能让它响应中断时才能取消。

`Future`表示一个任务的使命周期，并提供方法来判断是否已经完成或取消，以及取得
执行结果和取消任务。当一个`Future`执行完成以后，它就永远停在完成状态上。

{{{class="brush: java"
public interface Future<V> {
	boolean cancel(boolean mayInterruptIfRunning);
	boolean isCancelled();
	boolean isDone();
	
	V get() throws InterruptedException, ExecutionException, 
		CancellationException;
		
	V get(long timeout, TimeUnit unit) throws InterruptedException, 
		ExecutionException, CancellationException, TimeoutException;
}
}}}

有多个方法来创建`Future`：

`ExecutorService`中的`submit`方法以`Runnable`或`Callable`对象提交给`Executor`，
从而创建一个`Future`。可以用这个`Future`来执行任务或取消任务。

还可以显式地为某个`Runnalbe`或`Callable`实例化一个`FutureTask`。由于`FutureTask`
实现了`Runnable`，所以可以拿它提交给`Executor`来执行，或是直接调用它的`run`方法
。

从Java 6开始`ExecutorService`实现可以改写`AbstractExecutorService`中的
`newTaskFor` 方法从而根据已经提交的`Runnable`或`Callable`来控制`Future`的实例化
过程。在现有的默认的实现中，仅仅是创建了一个新的`FutureTask`：

{{{class="brush: java"
protected <T> RunnableFuture<T> newTaskFor(Callable<T> task) {
	return new FutureTask<T>(task);
}
}}}

在`Runnable`或`Callable`提交到`Executor`过程中是安全传递的，不会有等到构造了一半
的情况发生；把`Future`传递给其他线程也是安全的，所以在其他线程中可以放心使用
`get`方法取结果。


== 拆分任务并行执行 ==

以一个渲染网页程序为例子：渲染页面文字与下载页面上的图片这两种工作可以并行执行，
而且因为一个是CPU密集一个是IO密集，即使在单核CPU上性能提升也很明显：

把下载任务做成`Callable`传递给`ExecutorService`。当主任务要图片时会等
`Future.get`返回结果。当收到中断异常时，中断当前线程并退出。

{{{class="brush: java; highlight: [2,6,16,20,23]"
public abstract class FutureRenderer {
	private final ExecutorService executor = Executors.newCachedThreadPool();

	void renderPage(CharSequence source) {
		final List<ImageInfo> imageInfos = scanForImageInfo(source);
		Callable<List<ImageData>> task =
				new Callable<List<ImageData>>() {
					public List<ImageData> call() {
						List<ImageData> result = new ArrayList<ImageData>();
						for (ImageInfo imageInfo : imageInfos)
							result.add(imageInfo.downloadImage());
						return result;
					}
				};

		Future<List<ImageData>> future = executor.submit(task);
		renderText(source);

		try {
			List<ImageData> imageData = future.get();
			for (ImageData data : imageData)
				renderImage(data);
		} catch (InterruptedException e) {
			// Re-assert the thread's interrupted status
			Thread.currentThread().interrupt();
			// We don't need the result, so cancel the task too
			future.cancel(true);
		} catch (ExecutionException e) {
			throw launderThrowable(e.getCause());
		}
	}

	interface ImageData {
	}

	interface ImageInfo {
		ImageData downloadImage();
	}

	abstract void renderText(CharSequence s);

	abstract List<ImageInfo> scanForImageInfo(CharSequence s);

	abstract void renderImage(ImageData i);
}
}}}

上面的任务虽然很好地把CPU密集任务和IO密集任务分开了，这属于异构任务并行化。这样
的是很难确定这两边的任务负载是一样的。可能有一边很轻，马上就完成了，另一边还在
执行。所以很难保证效率提高了多少。

只有相互独立的同构任务可以并发处理时，才能体现出明显的提升。


== CompletionService与BlockingQueue ==

在身`Executor`提交了一组任务，可以用保留与每个任务相关的`Future`，反复调用`get`
方法，同时设参数`timeout`为`0`。这种轮询的方式虽然有用，但可以用更好的方法：
完成服务`CompletionServise`。

`CompletionServise`相当组合了`Executor`与`BlockingQueue`。可以把`Callable`任务
交给它执行，然后用类似于队列操作的`take`和`pall`等方法取结果。已经完成的结果被
封装为`Future`。

`CompletionServise`有一个实现类`ExecutorCompletionService`，可以把计算部分委托
给`Executor`。它的实现非常简单。在构造函数中创建一个`BlockingQueue`来保存计算
结果。当计算完成后，调用`FutureTask`中的`done`方法。当提交某个任务时，该任务
首先被包装为一个`QueueingFuture`，这是`FutureTask`的子类，然后改写`dome`方法，
并将结果存入`BlockingQueue`中。如下面代码，`take`和`poll`方法委托给了
`BlockingQueue`，这些方法会在得出结果前阻塞。

{{{class="brush: java"
private class QueueingFuture<V> extends FutureTask<V> {
	QueueingFuture(Callable<V> c) { super(c); }
	QueueingFuture(Runnable t, V r) { super(t, r); }
	
	protected void done() {
		completionQueue.add(this);
	}
}
}}}

使用`CompletionService`的例子。主要强化在两个地方：

* 为每张图片建立一个独立的任务，并在线程池中启动它们。这样下载变成并行任务。
* 从`CompletionService`中取得的结果是下载完立即显示出来。


{{{class="brush: java; highlight: [3, 12, 16, 26]"
public abstract class Renderer {

	private final ExecutorService executor;

	Renderer(ExecutorService executor) {
		this.executor = executor;
	}

	void renderPage(CharSequence source) {
		final List<ImageInfo> info = scanForImageInfo(source);
		
		CompletionService<ImageData> completionService =
				new ExecutorCompletionService<ImageData>(executor);
				
		for (final ImageInfo imageInfo : info)
			completionService.submit(new Callable<ImageData>() {
				public ImageData call() {
					return imageInfo.downloadImage();
				}
			});

		renderText(source);

		try {
			for (int t = 0, n = info.size(); t < n; t++) {
				Future<ImageData> f = completionService.take();
				ImageData imageData = f.get();
				renderImage(imageData);
			}
		} catch (InterruptedException e) {
			Thread.currentThread().interrupt();
		} catch (ExecutionException e) {
			throw launderThrowable(e.getCause());
		}
	}

	interface ImageData {
	}

	interface ImageInfo {
		ImageData downloadImage();
	}

	abstract void renderText(CharSequence s);

	abstract List<ImageInfo> scanForImageInfo(CharSequence s);

	abstract void renderImage(ImageData i);

}
}}}

多个`ExecutorCompletionService`可以共享一个`Executor`，所以可以创建一个特定的
`Executor`来计算私有任务，还可以能共享一个公共`Executor`的
`ExecutorCompletionService`。所以`CompletionService`的作为就相当于一组计算的句柄
，这与`Future`作为单个计算的够本是类似的。通过记录提交给`CompletionService`任务
的数量，并计算出已经获得的已经完成结果数量，即使使用一个共享的`Executor`也可以
知道已经获得了所有任务结果的时间。


== 设置任务的执行时限 ==

`Future.get`中可以设定超时限制，超时后抛出`TimeoutException`。一般在任务超时后
应该立即`Future.cancel(true)`停止，从而避免继续计算一个不能再用的结果而浪费计算
资源。如果编写的任务是可以取消的，可以提前中止它，防止消耗资源。

例子：从广告服务器上取广告。把广告任务交给`Executor`。如果超时就取消任务：

{{{class="brush: java; highlight: [3,10,15]"
Page renderPageWithAd() throws InterruptedException {
	long endNanos = System.nanoTime() + TIME_BUDGET;
	Future<Ad> f = exec.submit(new FetchAdTask());
	// Render the page while waiting for the ad
	Page page = renderPageBody();
	Ad ad;
	try {
		// Only wait for the remaining time budget
		long timeLeft = endNanos - System.nanoTime();
		ad = f.get(timeLeft, NANOSECONDS);
	} catch (ExecutionException e) {
		ad = DEFAULT_AD;
	} catch (TimeoutException e) {
		ad = DEFAULT_AD;
		f.cancel(true);
	}
	page.setAd(ad);
	return page;
}
}}}

超时任务还可以扩展到多个任务的情况。创建n个任务，提交到一个线程池，保留n个
`Future`。除了用`Future.get`方法一个一个取结果，还可以用一组任务为参数直接调用
`invokeAll`方法，按任务集合中迭代器顺序把所有的`Future`添加到返回集合中。这样
每个`Future`与对应的`Callable`关联起来了。所有任务都完毕或是超时以后`invokeAll`
方法将返回。可以用`get`方法或`isCancelled`方法来判断每个任务是否完成。

{{{class="brush: java; highlight: [17,19,24,28,30]"
private class QuoteTask implements Callable<TravelQuote> {
	private final TravelCompany company;
	private final TravelInfo travelInfo;
	...
	public TravelQuote call() throws Exception {
		return company.solicitQuote(travelInfo);
	}
}

public List<TravelQuote> getRankedTravelQuotes( TravelInfo travelInfo, 
		Set<TravelCompany> companies, Comparator<TravelQuote> ranking, 
		long time, TimeUnit unit) throws InterruptedException 
{
	List<QuoteTask> tasks = new ArrayList<QuoteTask>();

	for (TravelCompany company : companies)
		tasks.add(new QuoteTask(company, travelInfo));

	List<Future<TravelQuote>> futures = exec.invokeAll(tasks, time, unit);
	List<TravelQuote> quotes = new ArrayList<TravelQuote>(tasks.size());
	Iterator<QuoteTask> taskIter = tasks.iterator();

	for (Future<TravelQuote> f : futures) {
		QuoteTask task = taskIter.next();
		try {
			quotes.add(f.get());
		} catch (ExecutionException e) {
			quotes.add(task.getFailureQuote(e.getCause()));
		} catch (CancellationException e) {
			quotes.add(task.getTimeoutQuote(e));
		}
	}
	Collections.sort(quotes, ranking);

	return quotes;
}
}}}



= 任务的取消与关闭 =

Java没有提供安全终止线程的机制，`Thread`的`stop`与`suspend`等方法会有一些缺陷，
应该避免使用。推荐让一个线程调用中断来停止另一个线程。


{{{class="brush: java"
}}}



{{{class="brush: java"
}}}



{{{class="brush: java"
}}}



{{{class="brush: java"
}}}



{{{class="brush: java"
}}}



{{{class="brush: java"
}}}



{{{class="brush: java"
}}}



{{{class="brush: java"
}}}



{{{class="brush: java"
}}}



{{{class="brush: java"
}}}



{{{class="brush: java"
}}}



{{{class="brush: java"
}}}



{{{class="brush: java"
}}}



{{{class="brush: java"
}}}



{{{class="brush: java"
}}}



{{{class="brush: java"
}}}



{{{class="brush: java"
}}}



{{{class="brush: java"
}}}



{{{class="brush: java"
}}}



{{{class="brush: java"
}}}



{{{class="brush: java"
}}}



{{{class="brush: java"
}}}



{{{class="brush: java"
}}}



{{{class="brush: java"
}}}



{{{class="brush: java"
}}}



{{{class="brush: java"
}}}



{{{class="brush: java"
}}}






