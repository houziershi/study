
= 非线程安全类 =

迭代非线程安全集合会抛出`ConcurrentModifyException`。


= 原子操作 =

`java.utils.concurrent.atomic`包装器把对象包装成原子操作。

`AtomicLong`类的原子方法`incrementAndGet()`和`decresmentAndGet()`。

包装集合为不可变版本：`Collections.unmodifiableLists(list)`

包装同步版：`SynchronizedMap m = Collection.SynchronizedMap(new HashMap())`

= 并发类 =

并发类如：`ConcurrentHashMap`等为并发环境设计。为了优化性能不只用了一个锁，内部
分多个块用多个锁同步。所以增加了并发性能。

= 队列 =

== 常用 ==

* `Queue`不阻塞，空时取返回空；满时放抛异常。
* `SynchrousQueue`会同步插入与删除操作。
* `BlockingQueue`存取操作会阻塞。
* `PriorityBlockingQueue`带优先级的队列。

== 阻塞队列 ==

简单的阻塞队列可以用`LinkedblockingQueue`或`ArrayBlockingQueue`。

对于队列空取或满存的情况有四种策略：

* 抛出异常。
* 特殊值。空取时为`null`；满存时为`false`。
* 阻塞。
* 超时。只会阻塞指定的时间。

|      | 抛出异常  | 特殊值   | 阻塞   | 超时                 |
| 插入 | add(e)    | offer(e) | put(e) | offer(e, time, unit) |
| 移除 | remove()  | poll()   | take() | poll(time, unit)     |
| 检查 | element() | peek()   | 不可用 | 不可用               |

== 饱和策略 ==

* `Abort`：抛异常，调用者处理异常。
* `Discard`：丢掉任务。
* `DiscardOlds`：丢掉最老的任务。
* `DiscardPolicy`：丢掉优先级最低的。
* `Caller_Runs`：不抛异常，退回给调用者。用一个`execute()`执行它。

== 队列工作的问题 ==

请求来太快了把等待队列也占满了。太长或是无限的队列，用`SynchronizeQueue`避免
队列任务。它不是真的队列而是一个移交机制（相当于只有一个容量的队列），前一个
请求没有处理完后一个请求会被拒绝。

