%title Part III

%toc Part III

= 包和引用 =

== 定义包 ==

=== package语句 ===

通过把`package`子句放在文件顶端的方式把整个文件内容放进包里：

{{{class="brush: scala"
  package bobsrockets.navigation
  class Navigator 
}}}

同一个包可以定义在不同的多个文件中。

=== 嵌套包 ===

另一种方式很像C#的命名空间。在`package`子句之后用大括号包起来一段要放到包里去的
定义。除此之外，这种语法还能把同一个文件内的不同部分放在不同的包里。

{{{class="brush: scala"
  package bobsrockets {
    package navigation {

      // In package bobsrockets.navigation
      class Navigator

      package tests {

        // In package bobsrockets.navigation.tests
        class NavigatorSuite
      }
    }
  } 
}}}

这种嵌套方式会把路径上所有的包的内容都相入进来。

类似于Java的语法实际上只是括号嵌入风格的语法糖。原理是：如果除了签入另一个包之外
对包不作任何事，你可以下面的方式省去一个缩进：

{{{class="brush: scala"
  package bobsrockets.navigation {
  
		// 这样就跳过了bobsrockets包，它的内容不会被引入

    // In package bobsrockets.navigation
    class Navigator

    package tests {

      // In package bobsrockets.navigation.tests
      class NavigatorSuite
    }
  } 
}}}

=== 包路径是相对的 ===

Java包尽管是分级的，却不是嵌套的。在Java里，在你命名一个包的时候，你必须从包层级
的根开始。

Scala为了简化，采用包风格类似于是相对路径：

{{{class="brush: scala"
  package bobsrockets {
    package navigation {
      class Navigator
    }
    package launch {
      class Booster {
        // No need to say bobsrockets.navigation.Navigator
        val nav = new navigation.Navigator
      }
    }
  } 
}}}

为了避免绝对路径与相对路径之间的歧义，可以用`_root_`表示顶层包，这样就一定是绝对
路径：

{{{class="brush: scala"
val aa = new _root_.scala.collection.mutable.ArrayBuffer[Employee] 
}}}


=== 包层级的作用域 ===

而且内部区域的包可以隐匿被定义在外部区域的同名包。还提供了`_root_`表示顶层包：

{{{class="brush: scala"
  // In file launch.scala
  package launch {
    class Booster3
  }

  // In file bobsrockets.scala
  package bobsrockets {
    package navigation {
      package launch {
        class Booster1
      }
      class MissionControl {
        val booster1 = new launch.Booster1
        val booster2 = new bobsrockets.launch.Booster2
        val booster3 = new _root_.launch.Booster3
      }
    }
    package launch {
      class Booster2
    }
  } 
}}}

上面的代码中，为了访问`Booster3`，Scala提供了所有用户可创建的包之外的名为
`_root_`的包。换句话就是，任何你写的顶层包都被当作是`_root_`包的成员。

因此，`_root_.launch`让你能访问顶层的`launch`包，`_root_.launch.Booster3`指向的
就是最外面的`booster`类。

== 包对象 ==

由于JVM的局限，包里只能放类、对象、特质，不能把变量、常量与函数放在包里。

解决方案是在上级包是定义一个与子包名称一样的包对象，包对象的成员用起来就像是在
子包中一样：

{{{class="brush: scala"
package com.horstmann.impatient

package object people {
	val defaultName = "John Q. Public"
}

package people {
	class Person {
		var name = defaultName // 从包对象取得常量
	}
}
}}}

因为在同一个包中，所以`defaultName`不需要加限制。在其他的地方访问方式可能为：

`com.horstmann.impatient.people.defaultName`

在幕后包对象被编译成带有静态方法和字段的JVM类，名为`package.class`，位于相应的
包下。以这个例子来说就是`com.horstmann.impatient.people.package`，它包含一个静态
字段`defaultName`。

== 引用包 ==

Scala里用`import`子句来引用包和其成员：

{{{class="brush: scala"
  package bobsdelights

  abstract class Fruit(
    val name: String,
    val color: String
  )

  object Fruits {
    object Apple extends Fruit("apple", "red")
    object Orange extends Fruit("orange", "orange")
    object Pear extends Fruit("pear", "yellowish")
    val menu = List(Apple, Orange, Pear)
  } 
}}}

不止是包，其他成员也可以用`import`来引用：

{{{class="brush: scala"
  // easy access to Fruit
  import bobsdelights.Fruit

  // easy access to all members of bobsdelights
  import bobsdelights._

  // easy access to all members of Fruits
  import bobsdelights.Fruits._ 
//
}}}

差别是Scala的按需引用写作尾下划线`_`而不是星号`*`（毕竟`*`是合法的Scala标识符！
）。上面的第三个引用子句与Java的静态类字段引用一致。

`cala`引用可以出现在任何地方，而不是仅仅在编译单元的开始处。同样，它们可以指向
任意值。

{{{class="brush: scala"
  def showFruit(fruit: Fruit) {
    import fruit._
    println(name +"s are "+ color)
  } 
}}}

引用语句的作用范围从引入开始到当前代码块结束。

方法`showFruit`引用了它的参数，`Fruit`类型的`fruit`，的所有成员。之后的
`println`语句就可以直接使用`name`和`color`了。这两个索引等价于`fruit.name`和
`fruit.color`。

Scala的引用很灵活的另一个方面是它们可以引用包自身，而不只是非包成员。这只有你把
内嵌包想象成包含在外围包之内才是自然的。

例如，下面的代码里包`java.util.regex`被引用。这使得`regex`可以用作简单名。要访问
`java.util.regex`包的`Pattern`单例对象，你可以只是写成`regex.Pattern`：

{{{class="brush: scala"
  import java.util.regex

  class AStarB {
    // Accesses java.util.regex.Pattern
    val pat = regex.Pattern.compile("a*b")
  } 
}}}

=== 重命名与隐藏 ===

Scala的引用同样可以重命名或隐藏成员。可以用跟在引用的成员对象之后的包含在括号里
的引用选择子句（import selector clause）做到：

* 重命名子句的格式是`<原始名> => <新命名>`。

* `<原始名> => _`格式的子句从被引用的名字中排除了`<原始名>`。

{{{class="brush: scala"
// 只引用了对象Fruits的Apple和Orange成员。 
import Fruits.{Apple, Orange} 

// Apple对象重命名为McIntosh。
import Fruits.{Apple => McIntosh, Orange}

// 以SDate的名字引用了SQL的日期类，因此你可以在同时引用普通的Java日期类Date。
import java.sql.{Date => SDate}

// 以名称S引用了java.sql包，这样你就可以写成S.Date。
import java.{sql => S}

// 引用了对象Fruits的所有成员。这与import Fruits._同义。
import Fruits.{_}

// 从Fruits对象引用所有成员，不过重命名Apple为McIntosh。
import Fuites.{Apple => McIntosh, _}

// 引用了除Pear之外的所有Fruits成员。
import Fuits.{Pear => _, _}
//
}}}

把某样东西重命名为`_`就是表示把它隐藏掉。这对避免出现混淆的局面有所帮助。比方说
你有两个包，`Fruits`和`Notebooks`，它们都定义了类`Apple`。如果你想只是得到名为
`Apple`的笔记本而不是水果，就需要引用所有的`Notebooks`和除了`Apple`之外所有的
水果：

{{{class="brush: scala"
  import Notebooks._
  import Fruits.{Apple => _, _} 
//
}}}

总而言之，引用选择可以包括下列模式：

* 简单名`x`。把`x`包含进引用名集。
* 重命名子句`x => y`。让名为`x`的成员以名称`y`出现。
* 隐藏子句`x => _`。把`x`排除在引用名集之外。
* 全包括`_`。引用除了前面子句提到的之外的全体成员。如果存在全包括，那么必须是
引用选择的最后一个。
 
本节最初展示的比较简单的引用子句可以被视为带有选择子句的简写。

例如，`import p._`等价于`import p.{_}`：并且`import p.n`等价于`import p.{n}`。


== 隐式引用 ==

Scala隐式地添加了一些引用到每个程序中。本质上，就好象下列的三个引用子句已经被
加载了：

{{{class="brush: scala"
  import java.lang._ // everything in the java.lang package
  import scala._     // everything in the scala package
  import Predef._    // everything in the Predef object 
}}}

=== java.lang ===

`java.lang`包囊括了标准Java类。它永远被隐式包含在Scala的JVM实现中。.NET实现将
代以引用system包，它是`java.lang`的.NET模拟。

=== scala ===

scala包含有标准的Scala库，包括许多通用的类和对象。因为scala被隐式引用，你可以
直接用`List`而不是`scala.List`；`import math._`等同于`import scala.math._`；
`math.sqrt(2)`等同于`scala.math.sqrt(2)`。

=== Predef ===

Predef对象包含了许多Scala程序中常用到的类型，方法和隐式转换的定义。比如，因为
`Predef`是隐式引用，你可以直接写`assert`而不是`Predef.assert`。

上面的这三个引用子句与其它的稍有不同，靠后的引用将遮盖靠前的。

例如，`StringBuilder`类被定义在`scala`包里以及Java版本1.5以后的`java.lang`包中
都有。因为`scala`引用遮盖了`java.lang`引用，所以`StringBuilder`简单名将被看作是
`scala.StringBuilder`，而不是`java.lang.StringBuilder`。





= 访问修饰符 =

Scala与Java对访问修饰符的对待方式有一些重要的差异。

== public ==

Scala中没有任何标记默认是`public`的就是公开的。与Java中默认是`protected`不同，


== private ==

* Scala的`private`只在当前的实例中可见。与Java的同一类可见不同。
* Scala里这个规则同样应用到了内部类上。这种方式更一致。这点与Java不同，
	Java会允许这两种访问因为它允许外部类访问其内部类的私有成员。

{{{class="brush: scala; highlight: [3, 5, 8]"
class Outer {
	class Inner {
		private def f() { println("f") }   // Only accessable in class "Inner"
		class InnerMost {
			f()                              // OK: Inside Class "Inner"
		}
	}
	(new Inner).f()                      // error: f is not accessible
} 
}}}

* `(new Inner).f()`访问非法，因为`f`在`Inner`中被声明为`private`所以类`Inner`
	外面不能被访问。
* 相反，类`InnerMost`里访问`f`没有问题，因为这个访问包含在`Inner`类之内。

== protected ==

Scala里`protected`只能被子类访问，和Java不一样，Java中可以被子类或同一个包中的类
访问。

{{{class="brush: scala; highlight: [4, 8, 12]"
package p {

	class Super {
		protected def f() { println("f") }  // Only accessable in sub-class
	}

	class Sub extends Super {
		f()                                 // OK, in sub-class
	}

	class Other {
		(new Super).f()                     // error:  not sub-class, same packet
	}
} 
}}}

== 保护的范围 ==

Scala里的访问修饰符可以通过使用修饰词增加。格式为`private[X]`或`protected[X]`的
修饰符表示针对`X`的私有或保护，这里`X`指代某些外围的包、类与其单例对象，也可以
用`this`表示只有当前类自己可以访问。

这样允许定义一些在你项目的若干子包中可见但对于项目外部的客户却始终不可见的东西。
同样的技巧在Java里是不可能的：

{{{class="brush: scala; highlight: [4, 5, 7, 8, 10, 18]"
package bobsrockets {
	package navigation {
	
		private[bobsrockets] class Navigator {         // acc in bobsrockets pkg
			protected[navigation] def useStarChart() {}  // like Java pprotected
			class LegOfJourney {
				private[Navigator]    val distance = 100   // like java private
				private[LegOfJourney] val days = 100       // like scala private
			}
			private[this] var speed = 200                // acc same instance
		}

	}
	package launch {
		import navigation._

		object Vehicle { 
			private[launch] val guide = new Navigator   // accessable in launch pkg
		}

	}
} 
}}}

=== 扩大范围到包：`private[包名]` ===

类`Navigator`被标记为`private[bobsrockets]`。这就是说这个类对包含在`bobsrockets`
包的所有的类和对象可见。

特别是对象`Vehicle`里对`Navigator`的访问被允许，因为`Vehicle`包含在包`launch`中
，而`launch`包在`bobsrockets`中。

另一方面，包`bobsrockets`包之外的所有代码都不能访问类`Navigator`。

`private`修饰词同样可以直接是外围包。对象`Vehicle`类的`guide`对象的访问修饰符是
这样的例子。这种访问修饰符等价于Java的包私有访问。

=== 指向外围类、对象：`private[类或对象]` ===

`private`的修饰词还能指向外围类或对象。

例如`LegOfJourney`里的`distance`变量被标记为`private[Navigator]`，
因此它在类`Navigator`的任何地方都可见。

这与Java里的内部类的私有成员具有同样的访问能力。`private[C]`里的`C`如果是最外层
的类，那么`private`的意思和Java一致。

=== 添加指定包、类、对象：`protected[包或类或对象]` ===

所有的修饰词也可以用在`protected`上，与`private`意思相同。

也就是说，类`C`的`protected[X]`修饰符允许`C`的所有子类和外围的包、类、或对象`X`
访问被标记的定义。

例如，`useStarChart`方法在`Navigator`所有子类以及包含在`navigation`包里的所有
代码能够被访问。这与Java的protected意思完全一致。

=== 只能当前实例访问：`private[this]` ===

Scala还具有一种比`private`更严格的访问修饰符。被`private[this]`标记的定义仅能在
包含了定义的同一个实例中被访问。这种定义被称为对象私有（object-private）。

例如，代码13.11中，类`Navigator`的的`speed`定义就是对象私有的。这就是说所有的
访问必须不仅是在`Navigator`类里，而且还要是同一个`Navigator`实例发生的。

因此在`Navigator`内访问`speed`和`this.speed`是合法的。然而以下的访问，将不被允许
，即使它发生在`Navigator`类之中：

{{{class="brush: scala"
  val other = new Navigator
  other.speed // this line would not compile 
}}}

把成员标记为`private[this]`是一个让它不能被同一个类中其它实例访问的保障。这在做
文档时比较有用。有时它也能让写出更通用的变体注释（参见以后会讲到的参数类型化章节
的变体注释）。

== 伴生对象的可见度性 ==

Java里，静态成员和实例成员属于同一个类，因此访问修饰符可以统一地应用在他们之上。
在Scala里没有静态成员，代之以可以拥有包含成员的仅存在一个的伴生对象。

{{{class="brush: scala"
  class Rocket {
    import Rocket.fuel
    private def canGoHomeAgain = fuel > 20
  }

  object Rocket {
    private def fuel = 10
    def chooseStrategy(rocket: Rocket) {
      if (rocket.canGoHomeAgain)
        goHome()
      else
        pickAStar()
    }
    def goHome() {}
    def pickAStar() {}
  }
 
}}}

Scala的访问规则给予了伴生对象和类一些特权。类把它所有的访问权限共享给半生对象，
反过来也是如此。特别的是，对象可以访问所有它的伴生类的私有成员，就好象类也可以
访问所有伴生对象的私有成员一样。

举个例子，上面的`Rocket`类可以访问方法`fuel`，它在`Rocket`对象中被声明为私有。
类似地，`Rocket`对象也可以访问`Rocket`类里面的私有方法`canGetHome`。

有一个例外，说到`protected static`成员时，Scala和Java的相似性被打破了。Java类`C`
的保护静态成员可以被`C`的所有子类访问。相反，伴生对象的`protected`成员没有意义，
因为单例对象没有任何子类。



= 断言 =

`assert`是预定义的方法，`assert(condition)`会在条件不成立时抛出`AssertionError`。

另一个版本`assert(condition, explanation)`，指定了抛出含有指定`explantion`作为
说明的`assertionError`。`explation`的类型为`Any`，所以任何对象都可以作为参数。
`assert`方法会对传入的参数调用`toString`的结果作为放在`AssertionError`中的文字描述。

在前面的“组合与继承”这一章中的`above`方法加上道检查，只有宽度一样的元素才可以
上下连接在一起：

{{{class="brush: scala" 
  def above(that: Element): Element = {
    val this1 = this widen that.width
    val that1 = that widen this.width
    elem(this1.contents ++ that1.contents)
  }
}}}

`assert`方法所在的`Predef`包里还有一个`ensuring`方法可以直接对表达式的返回结果
进行测试而不用先把表达式的结果先存放到变量中：

{{{class="brush: scala" 
  def widen(w: Int): Element =
    if (w <= width) this
    else {
      val left = elem(' ', (w - width) / 2, height)
      var right = elem(' ', w - width - left.width, height)
      left beside this beside right
    } ensuring (w <= _.width)
}}}

`ensuring`接收一个返回类型为Boolean的函数作为参数。注意这里`ensuring`是作用在
if-else表达式的`Element`类结果上的，而不是方法`widen`的返回值上。相当于是：

{{{class="brush: scala" 
  def widen(w: Int): Element = {
    if (w <= width) this
    else {
      val left = elem(' ', (w - width) / 2, height)
      var right = elem(' ', w - width - left.width, height)
      left beside this beside right
    } ensuring (w <= _.width)
  }
}}}

还有一点要明白的是，这里的语法看起来像是对`Element`类对象调用`ensuring`方法（把
`xxx.ensuring(...)`中的点换成了空格）。但是实际上`Emement`对象没有这个成员方法，
而是被隐式转换成了`Ensuring`对象。由于存在隐式转换，所以`ensuring`可以作用在任何
类型上。



= 测试 =

受益于和Java之间无缝操作。Java的测试库，像JUnit、TestNG，可以直接用于scala的
单元测试。

== Junit 4 ==

如果喜欢JUnit4的风格，那么可以写下面这样的单元测试。

{{{class="brush: bash" 
import java.util.ArrayList
import org.junit.Test
import org.junit.Assert._

class SampleTest {

	@Test
	def listAdd() {
		val list = new ArrayList[String]
		list add "milk"
		list add "sugar"
		assertEquals(2, list.size())
	}

}
}}}

产生的测试类可以直接在Java中使用：

{{{class="brush: bash" 
$ scalac -classpath .:junit-4.10.jar tmp.scala

$ java -classpath .:junit-4.10.jar:scala-library-2.10.2.jar \
		org.junit.runner.JUnitCore SampleTest
JUnit version 4.10
.
Time: 0.009

OK (1 test)
}}}



== ScalaTest ==

ScalaTest是专为scala设计的一个测试框架。ScalaTest提供了一些比较方便的功能。注意
ScalaTest除了自己的版本号外，对应不同的Scala版本还有不同的对应版本。拿错了是
用不了的。

先用脚本来测试一下对不对：

{{{class="brush: scala" 
class CanaryTest extends org.scalatest.Suite {

	def testOK() {
		assert(true)
	}

}

(new CanaryTest).execute()
}}}

因为使用的是脚本，所以上面最后一行调用`execute()`方法直接运行。执行：

{{{class="brush: scala" 
$ scala -classpath .:scalatest_2.10-1.9.1.jar tmp.scala
Main$$anon$1$CanaryTest:
- testOK
}}}

=== Runner ===

ScalaTest的`Runner`类来配置运行或不运行哪些套件，配置不同的`reporter`来指定报表
。可以在ScalaTest的文档中查看所有的选项。

{{{class="brush: scala" 
class CanaryTest extends org.scalatest.Suite {

	def testListEmpty() {
		val list = new java.util.ArrayList[Integer]
		assert(0 == list.size)
	}

	def testListAdd() {
		val list = new java.util.ArrayList[Integer]
		list add 1
		list add 4
		assert(2 == list.size)
	}

}
}}}

通过`Runner`打开图形界面，在`view`菜单中可以显示测试过程信息：

{{{class="brush: bash" 
$ scalac -classpath .:scalatest_2.10-1.9.1.jar tmp.scala

$ scala -classpath .:scalatest_2.10-1.9.1.jar org.scalatest.tools.Runner -p .
WARNING: -p has been deprecated and will be reused for a different (but still 
		very cool) purpose in ScalaTest 2.0. Please change all uses of -p to -R.
}}}

上面的参数`-p`指定的查找测试类的路径。

如果不想要图形界面，可以用`-o`重定向结果到标准输出：

{{{class="brush: bash" 
$ scala -classpath .:scalatest_2.10-1.9.1.jar org.scalatest.tools.Runner -p . -o
WARNING: -p has been deprecated and will be reused for a different (but still 
		very cool) purpose in ScalaTest 2.0. Please change all uses of -p to -R.
Run starting. Expected test count is: 2
DiscoverySuite:
CanaryTest:
- testListAdd
- testListEmpty
Run completed in 150 milliseconds.
Total number of tests run: 2
Suites: completed 2, aborted 0
Tests: succeeded 2, failed 0, ignored 0, pending 0
All tests passed.
}}}

还有`-f`参数可以把结果输出到文件。

=== assert()与expect()方法 ===

ScalaTest提供的`assert()`方法测试条件是否成立。还有一个两个参数版本的，第二个
参数设置失败时的提示信息。

{{{class="brush: scala" 
	assert(2 == list.size(), "Unexpected size of list")
}}}

还有一个`expect()`方法作为类似于Junit的`assertEquals()`方法。注意它的第三个参数
是一个闭包：

{{{class="brush: scala" 
	assert(2, "Unexpected size of list") { list.size() }
}}}

注意`expect()`方法已经过期，用`expectResult()`方法代替。

=== 测试异常 ===

有一个比较啰嗦的方案：

{{{class="brush: scala" 
try {
	// .....
	fail("Expected exception here")
} catch {
	case e: IndexOutOfBoundsException => // success
}
}}}

更好的方法是用ScalaTest提供的`intercept()`方法：

{{{class="brush: scala" 
intercept(classOf[IndexOutOfBoundsException], "Expected exception here") {
	// .....
}
}}}

注意上面的格式可能会在ScalaTest的新版本中改变，会是这样的：

{{{class="brush: scala" 
intercept[IndexOutOfBoundsException]("Expected exception here") {
	// .....
}
}}}

`intercept()`方法会把捕获的结果作为返回值，如果需要的话可以对它进行处理。

=== 在测试间共享代码 ===

==== BeforeAndAfter特质 ====

Scala的`BeforeAndAfter`特质提供了`beforeEach()`与`afterEach()`方法会在每个测试
开始与结束前调用；还有`beforeAll()`和`afterAll()`在所有的开始与结束时运行一次。

{{{class="brush: scala" 
class ShareCodeImperation extends org.scalatest.Suite 
	with org.scalatest.BeforeAndAfter
{
		var list: java.util.ArrayList[Integer] = _

		override def beforeEach() { list = new java.util.ArrayList[Integer] }
		override def afterEach()  { list = null }

		def testListEmptyOnCreate() {
			expect(0, "Expected size to be 0") { list.size() }
		}

		def testGetOnEmptyList() {
			intercept[IndexOutOfBoundsException] { list.get(0) }
		}
}

(new ShareCodeImperative).execute()
}}}

==== 通过闭包 ====

{{{class="brush: scala" 
import org.scalatest.Suite
import java.util.ArrayList

class ShareCodeFunctional extends Suite {

	def withList(testFunction : (ArrayList[Integer]) => Unit) {
		// init list
		val list = new ArrayList[Integer]

		try {
			testFunction(list)
		} finally {
			// clean up
		}
	}

	def testListEmptyOnCreate() {
		withList {
			list => expectResult(0, "Expected size to be 0") {
				list.size()
			}
		}
	}

	def testGetOnEmptyList() {
		withList {
			list => intercept[IndexOutOfBoundsException] {
				list.get(0)
			}
		}
	}

}

(new ShareCodeFunctional).execute()
}}}

运行：

{{{class="brush: scala" 
$ scala -deprecation -classpath .:scalatest_2.10-1.9.1.jar tmp.scala
Main$$anon$1$ShareCodeFunctional:
- testGetOnEmptyList
- testListEmptyOnCreate
}}}

=== FunSuite ===

ScalaTest提供了函数式的`FunSuite`（Function Suite）。`test`方法为测试方法，说明
字符串的内容会显示在输出信息中：

{{{class="brush: scala" 
import org.scalatest.FunSuite
import scala.collection.mutable.Stack
 
class ExampleSuite extends FunSuite {
 
  test("pop is invoked on a non-empty stack") {
    val stack = new Stack[Int]
    stack.push(1)
    stack.push(2)
    val oldSize = stack.size
    val result = stack.pop()
    assert(result === 2)
    assert(stack.size === oldSize - 1)
  }
 
  test("pop is invoked on an empty stack") {
    val emptyStack = new Stack[Int]
    intercept[NoSuchElementException] {
      emptyStack.pop()
    }
    assert(emptyStack.isEmpty)
  }
}
}}}

{{{class="brush: bash" 
\-(morgan:%) >>> scalac -cp scalatest_2.9.0-1.9.1.jar ExampleSuite.scala                      
\-(morgan:%) >>> scala -cp .:scalatest_2.9.0-1.9.1.jar org.scalatest.run ExampleSuite 
Run starting. Expected test count is: 2
ExampleSuite:
- pop is invoked on a non-empty stack
- pop is invoked on an empty stack
Run completed in 158 milliseconds.
Total number of tests run: 2
Suites: completed 1, aborted 0
Tests: succeeded 2, failed 0, ignored 0, pending 0
All tests passed.
}}}


ScalaTest中也可以写JUnit风格的测试：

{{{class="brush: scala" 
import org.scalatest.junit.AssertionsForJUnit
import scala.collection.mutable.ListBuffer
import org.junit.Assert._
import org.junit.Test
import org.junit.Before

class ExampleSuite extends AssertionsForJUnit {

  var sb: StringBuilder = _
  var lb: ListBuffer[String] = _

  @Before 
	def initialize() {
    sb = new StringBuilder("ScalaTest is ")
    lb = new ListBuffer[String]
  }

  @Test 
	def verifyEasy() { // Uses JUnit-style assertions
    sb.append("easy!")
    assertEquals("ScalaTest is easy!", sb.toString)
    assertTrue(lb.isEmpty)
    lb += "sweet"
    try {
      "verbose".charAt(-1)
      fail()
    }
    catch {
      case e: StringIndexOutOfBoundsException => // Expected
    }
  }

  @Test 
	def verifyFun() { // Uses ScalaTest assertions
    sb.append("fun!")
    assert(sb.toString === "ScalaTest is fun!")
    assert(lb.isEmpty)
    lb += "sweeter"
    intercept[StringIndexOutOfBoundsException] {
      "concise".charAt(-1)
    }
  }
}
}}}

编译运行：

{{{class="brush: bash" 
\-(morgan:%) >>> scalac -cp scalatest_2.9.0-1.9.1.jar:junit-4.8.2.jar ExampleSuite.scala                      
\-(morgan:%) >>> scala -cp .:scalatest_2.9.0-1.9.1.jar:junit-4.8.2.jar org.junit.runner.JUnitCore ExampleSuite
JUnit version 4.8.2
..
Time: 0.026

OK (2 tests)
}}}

=== 混合ScalaTest与JUnit ===

`org.scalatest.junit.JUnitSuite`已经混入了特质`AssertionsForJUnit`，可以同时被
用于JUnit与ScalaTest方法： 

{{{class="brush: scala" 
import org.scalatest.junit.JUnitSuite
import scala.collection.mutable.ListBuffer
import org.junit.Assert._
import org.junit.Test
import org.junit.Before

class ExampleSuite extends JUnitSuite {

  var sb: StringBuilder = _
  var lb: ListBuffer[String] = _

  @Before
	def initialize() {
    sb = new StringBuilder("ScalaTest is ")
    lb = new ListBuffer[String]
  }

  @Test
	def verifyEasy() { // Uses JUnit-style assertions
    sb.append("easy!")
    assertEquals("ScalaTest is easy!", sb.toString)
    assertTrue(lb.isEmpty)
    lb += "sweet"
    try {
      "verbose".charAt(-1)
      fail()
    }
    catch {
      case e: StringIndexOutOfBoundsException => // Expected
    }
  }

  @Test
	def verifyFun() { // Uses ScalaTest assertions
    sb.append("fun!")
    assert(sb.toString === "ScalaTest is fun!")
    assert(lb.isEmpty)
    lb += "sweeter"
    intercept[StringIndexOutOfBoundsException] {
      "concise".charAt(-1)
    }
  }
}
}}}

JUnit调用：

{{{class="brush: bash" 
\-(morgan:%) >>> scala -cp .:scalatest_2.9.0-1.9.1.jar:junit-4.8.2.jar org.junit.runner.JUnitCore ExampleSuite
JUnit version 4.8.2
..
Time: 0.026

OK (2 tests)
}}}

ScalaTest调用：

{{{class="brush: bash" 
\-(morgan:%) >>> scala -cp .:scalatest_2.9.0-1.9.1.jar:junit-4.8.2.jar org.scalatest.run ExampleSuite
Run starting. Expected test count is: 2
ExampleSuite:
- verifyEasy
- verifyFun
Run completed in 226 milliseconds.
Total number of tests run: 2
Suites: completed 1, aborted 0
Tests: succeeded 2, failed 0, ignored 0, pending 0
All tests passed.
}}}

ScalaTest还提供了函数式的单元测试。

{{{class="brush: scala" 
// 用函数式的方式来写单元测试
// IDE目前对ScalaTest的支持不是特别好
// 加上RunWith就可以用JUnit的方式来运行了
@RunWith(classOf[JUnitRunner])
class ElementSuite3 extends FunSuite {
    test("elem result should have passed width") {
        val ele = elem('x', 2, 3)
        assert(ele.width == 2)
    }
}
}}}

单元测试对提高软件质量很有好处。唯一的不足就是只针对程序员。其它人员要看懂还是
比较困难。ScalaTest提供了BDD（Behavior Driven Development行为驱动开发）测试方式
。下面的这段测试代码在运行时就会打印出可读的解释。
	
{{{class="brush: scala" 
class ElementSpec extends FlatSpec with ShouldMatchers {
    "A UniformElement" should
        "have a width equal to the passed value" in {
        val ele = elem('x', 2, 3)
        ele.width should be(2)
    }
    it should
        "have a height equal to the passed value" in {
        val ele = elem('x', 2, 3)
        ele.height should be(3)
    }
    it should
        "throw an IAE if passed a negative width" in {
        evaluating {
            elem('x', -2, 3)
        } should produce[IllegalArgumentException]
    }
}
}}}

上面的代码会打印出下面这样的提示。

{{{class="brush: scala" 
A UniformElement 
- should have a width equal to the passed value
- should have a height equal to the passed value
- should throw an IAE if passed a negative width
}}}

我们写单元测试时会测试一些边界值。然后再选一些典型的值。如果这些选值有库来做，
不但可以减少单元测试的工作量，而且可以将边界值选取更合理。

下面是如何将`ScalaChecker`和`ScalaTest`联合起来使用的一个例子：

{{{class="brush: scala" 
class ElementSpecChecker extends FlatSpec with ShouldMatchers with Checkers{
    "A UniformElement" should
        "have a width equal to the passed value" in {
        // 这可以用数学化的方式来读
        // 对每个整数w
        // 当w>0时
        // 都有后面的等式成立
        check((w: Int) => w > 0 ==> (elem('x', w, 3).width == w))
    }
}
}}}





= 样本类和模式匹配 =

样本类（case class）和模式匹配（pattern matching）。

假设要建立一个操作数学表达式的库，就要先定义输入的数据。为了简单，现在只关注由
变量、数字、一元及二元操作符组成的数学表达式上：


== 样本类 ==

带`case`修饰符会被编译器识别为样本类。

{{{class="brush: scala"
  abstract class Expr          // 表达式
  
  case class Var(name: String) extends Expr    // 变量
  case class Number(num: Double) extends Expr  // 常量
  
  // 一元操作符
  case class UnOp(operator: String, arg: Expr) extends Expr  

  // 二元操作符
  case class BinOp(operator: String, left: Expr, right: Expr) extends Expr 
}}}

上面为表达式定义了一个抽象的基类，四个子类分别代表四种具体的表达式。要注意的是
每个子类都有一个`case`修饰符，会被编译器识别为样本类。

=== 省略new ===

样本类有自动产生的工厂方法，创建时就用不着`new`了：

{{{class="brush: scala"
val v = Var("x")
}}}

这个特点让方法在有很多层嵌套时可以少写很多`new`，这样让代码看起来更加简洁：

{{{class="brush: scala"
val op = binOp("+", Number(1), v)
}}}

=== 类参数作为字段 ===

样本类的另一个特点是参数列表中所有的参数隐式获得了`val`前缀，被作为字段维护：

{{{class="brush: scala"
scala> v.name
res0: String = x

scala> op.left
res1: Expr = Number(1.0)
}}}

=== copy方法的带名参数 ===

`copy`方法可以得到一个副本。

{{{class="brush: scala"
case class Currency(value: Double, unit: String)

val amt = Currency(29.95, "EUR")

val price = amt.copy()
}}}

不仅仅是简单地复制，而且还可以通过传名参数指定具体属性的值：

{{{class="brush: scala"
val price = amt.copy(value = 19.95)
}}}

或：

{{{class="brush: scala"
val price = amt.copy(unit = "CHF")
}}}

=== 默认toString、hashCode、equals、copy方法 ===

编译器为样本类添加了可读性更强的`toString`方法；还有自动提供的`hashCode`和
`equals`方法会树型嵌套作用于成员变量：

{{{class="brush: scala"
  scala> println(op)
  BinOp(+,Number(1.0),Var(x))

  scala> op.right == Var("x")
  res3: Boolean = true
}}}

=== 不要继承样本类 ===

如果一个样本类是从其他样本类继承过来的，那么不会自动实现默认的`toString`、
`hashCode`、`equals`、`copy`方法。而且编译器会提示警告。在以后的Scala版本里可能
会禁止样本类扩展子类。

所以，推荐只有最末端的子类是样本类。

== 模式匹配 ==

先来看一下格式。在格式上相当于把Java的`switch`格式：

{{{class="brush: scala"
  switch (selector) { alternatives }
}}}

中括号里的选择器移到了`match`关键字的前面：

{{{class="brush: scala"
  selector match { alternatives }
}}}


有一些数学运算的值是固定的，所以可以直接写死，算都不用算。比如以下的三个：

{{{class="brush: scala"
  UnOp("-", UnOp("-", e)) => e // 负负得正
  BinOp("+", e, Number(0)) => e // 加0
  BinOp("*", e, Number(1)) => e // 乘1
}}}

定义一个`simplifyTop`来简化运算：

{{{class="brush: scala"
  def simplifyTop(expr: Expr): Expr = expr match {
    case UnOp("-", UnOp("-", e)) => e // Double negation
    case BinOp("+", e, Number(0)) => e // Adding zero
    case BinOp("*", e, Number(1)) => e // Multiplying by one
    case _ => expr
  }
}}}

方法`simplifyTop`接收一个`Expr`类型的参数。这里参数`expr`作为选择器匹配各个
备选项，`_`为通配模式能匹配所有的值，相当于Java中的default。箭头`=>`分开的模式
与表达式。

* 其中`"-"`、`"*"`、`"*"`等这样的是常量模式（constant pattern）作相等判断。
* 其中的`e`这样的变量模式（variable pattern）匹配所有的值，在`=>`右边可以操作匹配的部分内容。
* 其中`Unop("-",e)`这样的形式为构造器模式，这样匹配的条件就是类为`Unop`第一个参数是`"-"`，第二个参数被作为`e`捕获。

调用：

{{{class="brush: scala"
  scala> simplifyTop(UnOp("-", UnOp("-", Var("x"))))
  res4: Expr = Var(x)
}}}

注意：

在作为参数时，即使是在构造函数没有参数的情况下，样本类后面带的括号不能省略。不然
传递过去的就不是样本类实例，而是伴生对象。

=== match与switch的比较 ===

* `match`是一种表达式，所以有返回结果。
* 一个case不会走到下一个case。
* 如果一项也没有匹配成功，会抛出`MatchError`异常。如果不想要异常：
	- 要么把所有可能性都写上；
	- 要么加一个`_`的默认情况。

{{{class="brush: scala"
  expr match {
    case BinOp(op, left, right) =>
      println(expr +" is a binary operation")
    case _ =>
  }
}}}

这个表达式在两种情况下都会返回`Unit`值`()`，所以这个表达式的类型就是`Unit`。


== 模式的种类 ==

=== 通配模式 ===

通配模式“`_`”匹配所有的结果：

{{{class="brush: scala"
  expr match {
    case BinOp(op, left, right) =>
      println(expr +"is a binary operation")
    case _ =>
  }
}}}

通配符还可以省略省略不用关注的内容。比如只要是`BinOp`类型就行，里面的参数是什么
值不关心：

{{{class="brush: scala"
  expr match {
    case BinOp(_, _, _) => println(expr +"is a binary operation")
    case _ => println("It's something else")
  }
}}}

=== 常量模式 ===

任何字面量都可以用作常量，还有`val`与单例对象也可以。如`Nil`，`5`，`true`和`"hello"`：

{{{class="brush: scala"
  def describe(x: Any) = x match {
    case 5 => "five"
    case true => "truth"
    case "hello" => "hi!"
    case Nil => "the empty list"
    case _ => "something else"
  }
}}}

效果：

{{{class="brush: scala"
  scala> describe(5)
  res5: java.lang.String = five

  scala> describe(true)
  res6: java.lang.String = truth

  scala> describe("hello")
  res7: java.lang.String = hi!

  scala> describe(Nil)
  res8: java.lang.String = the empty list

  scala> describe(List(1,2,3))
  res9: java.lang.String = something else
}}}

=== 变量模式 ===

变量类似通配模式，只不过有个变量名所以可以在后面的表达式中操作这个变量：

{{{class="brush: scala"
  expr match {
    case 0 => "zero"
    case somethingElse => "not zero: "+ somethingElse
  }
}}}

=== 变量模式与常量模式的区别 ===

常量不止有字面形式，还有用符号名的（比如`Nil`）。这样看起来就很容易与变量模式
搞混：

{{{class="brush: scala"
  scala> import Math.{E, Pi}
  import Math.{E, Pi}

  scala> E match {
       | case Pi => "strange math? Pi = "+ Pi
       | case _ => "OK"
       | }
  res10: java.lang.String = OK
}}}

上面的`E`与`Pi`都是常量。对Scala编译器来说小写字母开头都作为变量，其他引用被认为
是常量。下面的例子中想建立一个小写的`pi`就匹配到常量`Pi`了：


{{{class="brush: scala"
  scala> val pi = Math.Pi
  pi: Double = 3.141592653589793

  scala> E match {
       | case pi => "strange math? Pi = "+ pi
       | }
  res11: java.lang.String = strange math? Pi = 2.7182818...
}}}

==== 变量模式不能用通配符 ====

在这个变量模式情况下，不能使用通配模式。因为变量模式已经可以匹配所有情况了：

{{{class="brush: scala"
  scala> E match {
       | case pi => "strange math? Pi = "+ pi
       | case _ => "OK"
       | }
  <console>:9: error: unreachable code
           case _ => "OK"
                     ^
}}}

==== 默认常量用大写开头 ====

在区别常量与变量时Scala一般默认常量是以大写开头命名的，所以下面的代码编译不过：

{{{class="brush: scala; highlight:[7]"
class Sample {
	val max = 100
	val MIN = 0

	def process(input: Int) {
		input match {
			case max => println("Don't try this at home") // Compile error
			case MIN => println("min")
			_ => println("Unreachable!!")
		}
	}
}
}}}

==== 小写常量名加`this`限定 ====

强制使用小写常量名要加上限定，如：`this.pi`或`obj.pi`的形式表示是常量模式；如果
这样还没有用，可以用反引号包起来，如：

{{{class="brush: scala"
  scala> E match {
       | case `pi` => "strange math? Pi = "+ pi
       | case _ => "OK"
       | }
  res13: java.lang.String = OK
}}}

==== 反引号转义 ====

反引号也可以用来处理其他的编码问题，如对于标识符来说，因为`yield`是Scala的保留字
所以不能写`Thread.yield()`，但可以写成：

{{{class="brush: scala"
Thread.`yield`()
}}}

这样这里的`yield`就被当作标识符而不是关键字了。

=== 构造器模式 ===

这个模式是真正牛X的模式，不仅检查对象是否是样本类的成员，还检查对象的构造器参数
是否符合指定模式。

Scala的模式支持深度匹配（deep match）。不止检查对象是否一致而且还检查对象的内容
是否匹配内层模式。由于额外的模式自身可以形成构造器模式，因此可以检查到对象内部的
任意深度。

如下面的代码不仅检查了顶层的对象是`BinOp`，而且第三个构造参数是`Number`，而且它
的值为`0`：

{{{class="brush: scala"
  expr match {
    case BinOp("+", e, Number(0)) => println("a deep match")
    case _ =>
  }
}}}

=== 序列模式 ===

==== 数组 ====

用`Array`表达式：

{{{class="brush: scala"
arr match {
	case Array(0)     => "0"
	case Array(x, y)  => x + " " + y
	case Array(x, _*) => "0 ..."
	case _            => "Something else"
}
}}}

==== 列表匹配 ====

指定匹配序列中任意元素，如指定开始为0：

{{{class="brush: scala"
  expr match {
    case List(0, _, _) => println("found it")
    case _ =>
  }
}}}

不固定长度用`_*`：

{{{class="brush: scala"
  expr match {
    case List(0, _*) => println("found it")
    case _ =>
  }
}}}

==== 列表连接匹配 ====

{{{class="brush: scala"
let match {
	case 0 :: Nil      => "0"
	case x :: y :: Nil => x + " " + y
	case 0 :: tail     => "0 ..."
	case _             => "Something else"
}
}}}


=== 元组模式 ===

检查参数是不是三元组：

{{{class="brush: scala"
  def tupleDemo(expr: Any) =
    expr match {
      case (a, b, c) => println("matched "+ a + b + c)
      case _ =>
    }
}}}

调用：

{{{class="brush: scala"
  scala> tupleDemo(("a ", 3, "-tuple"))
  matched a 3-tuple
}}}

=== 类型模式 ===

这个模式可以被用来当成类型测试和类型转换的简易替代：

{{{class="brush: scala"
  def generalSize(x: Any) = x match {
    case s: String => s.length
    case m: Map[_, _] => m.size
    case _ => -1
  }
}}}

注意方法中`s`和`x`虽然都指向同一个对象，但一个类型是`String`一个类型是`Any`。
所以可以写成`s.length`不可以写成`x.length`。


调用的例子：

{{{class="brush: scala"
  scala> generalSize("abc")
  res14: Int = 3

  scala> generalSize(Map(1 -> 'a', 2 -> 'b'))
  res15: Int = 2

  scala> generalSize(Math.Pi)
  res16: Int = -1
}}}


==== 类型推断与类型转换 ====

`isInstanceOf`测试类型的方法：

{{{class="brush: scala"
expr.isInstanceOf[String]
}}}

`asInstanceOf`转换类型的方法：

{{{class="brush: scala"
expr.asInstanceOf[String]
}}}

使用类型转换的例子：

{{{class="brush: scala"
  if (x.isInstanceOf[String]) {
    val s = x.asInstanceOf[String]
    s.length
  } else ...
}}}

推荐方案还是类型模式匹配，不要用`isInstanceOf`类型判断，并`asInstanceOf`
转换。

模式匹配的匹配操作直接就可以作为类型判断，匹配成功操作直接就已经作为匹配的类型
了

==== 类型擦除 ====

和Java一样，对于除了数组以外其他集合都采用了泛型擦除（erasure）。就是在运行时
不知道集合泛型类型。

如对于`Map[Int,Int]`，到了运行时就不知道两个类型是什么类型了。所以对于泛型的模式
匹配，编译器会有警告信息：

{{{class="brush: scala"
  scala> def isIntIntMap(x: Any) = x match {
       | case m: Map[Int, Int] => true
       | case _ => false
       | }
  warning: there were unchecked warnings; re-run with
     -unchecked for details
  isIntIntMap: (Any)Boolean
}}}

在启动编译器时加上检查开关`-unchecked`可以看到更多详细信息：

{{{class="brush: scala"
  scala> :quit
  $ scala -unchecked
  Welcome to Scala version 2.7.2
  (Java HotSpot(TM) Client VM, Java 1.5.0_13).
  Type in expressions to have them evaluated.
  Type :help for more information.

scala> def isIntIntMap(x: Any) = x match {
     | case m: Map[Int, Int] => true
     | case _ => false
     | }
  <console>:5: warning: non variable type-argument Int in
  type pattern is unchecked since it is eliminated by erasure
           case m: Map[Int, Int] => true
                   ^
}}}

所以对于不同的类型，上面函数结果都是`true`：

{{{class="brush: scala"
  scala> isIntIntMap(Map(1 -> 1))
  res17: Boolean = true

  scala> isIntIntMap(Map("abc" -> "abc"))
  res18: Boolean = true
}}}

相反，Scals中的数组和Java一样，是没有类型擦除的：

{{{class="brush: scala"
  scala> def isStringArray(x: Any) = x match {
       | case a: Array[String] => "yes"
       | case _ => "no"
       | }
  isStringArray: (Any)java.lang.String

  scala> val as = Array("abc")
  as: Array[java.lang.String] = Array(abc)

  scala> isStringArray(as)
  res19: java.lang.String = yes

  scala> val ai = Array(1, 2, 3)
  ai: Array[Int] = Array(1, 2, 3)

  scala> isStringArray(ai)
  res20: java.lang.String = no
}}}

== 变量绑定 ==

在变量模式里可以用变量操作匹配的部分，那么其他的模式里有没有办法也这样做呢？

其实除了变量模式外，也可以对任何其他模式添加变量。 作用时在匹配成功后，变量就是
匹配成功的对象了。格式为写上变量名、一个`@`符号和模式。

比如要匹配`abs`出现了两次的地方（做了两次绝对值计算等于没有算）：

{{{class="brush: scala"
  expr match {
    case UnOp("abs", e @ UnOp("abs", _)) => e
    case _ =>
  }
}}}

这里的`e`代表的就是`UnOp("abs",_)`部分。

== 守卫模式 ==

如，想要把`e+e`这个重复加法替换成乘法`e*2`：

{{{class="brush: scala"
  BinOp("+", Var("x"), Var("x"))
}}}

等于：

{{{class="brush: scala"
  BinOp("*", Var("x"), Number(2))
}}}

Scala要求模式是线性的，即模式变量只能在模式中出现一次。下面的表达式中`x`重复
出现了，所以有问题：

{{{class="brush: scala"
  scala> def simplifyAdd(e: Expr) = e match {
       | case BinOp("+", x, x) => BinOp("*", x, Number(2))
       | case _ => e
       | }
  <console>:10: error: x is already defined as value x
           case BinOp("+", x, x) => BinOp("*", x, Number(2))
                              ^
}}}

守卫模式（pattern guard）很像`for`循环中的`if`过滤条件。接在匹配模式后面的、用
`if`开始的、使用模式中变量的表达式。

如下面例子中的`if x == y`部分：

{{{class="brush: scala"
  scala> def simplifyAdd(e: Expr) = e match {
       | case BinOp("+", x, y) if x == y =>
       | BinOp("*", x, Number(2))
       | case _ => e
       | }
  simplifyAdd: (Expr)Expr
}}}

其他的例子，如只匹配正整数和只匹配以`a`开始的字符串：

{{{class="brush: scala"
  // match only positive integers
  case n: Int if 0 < n => ...

  // match only strings starting with the letter `a'
  case s: String if s(0) == 'a' => ...
}}}

== 模式重叠 ==

{{{class="brush: scala; highlight:[8,10]"
  def simplifyAll(expr: Expr): Expr = expr match {
    case UnOp("-", UnOp("-", e)) =>
      simplifyAll(e) // `-' is its own inverse
    case BinOp("+", e, Number(0)) =>
      simplifyAll(e) // `0' is a neutral element for `+'
    case BinOp("*", e, Number(1)) =>
      simplifyAll(e) // `1' is a neutral element for `*'
    case UnOp(op, e) =>
      UnOp(op, simplifyAll(e))
    case BinOp(op, l, r) =>
      BinOp(op, simplifyAll(l), simplifyAll(r))
    case _ => expr
  }
}}}

注意这个方法的第四个和第五个匹配样本的参数都是变量，而且对应的操作采用递归。因为
四和五的匹配范围比前三个更加广，所以建立放在后面。如果放在前面的话会有警告。

如下面的第一个样本能匹配任何第二个样本能匹配的情况：

{{{class="brush: scala"
  scala> def simplifyBad(expr: Expr): Expr = expr match {
       | case UnOp(op, e) => UnOp(op, simplifyBad(e))
       | case UnOp("-", UnOp("-", e)) => e
       | }
  <console>:17: error: unreachable code
           case UnOp("-", UnOp("-", e)) => e
                                           ^
}}}

== 封闭类 ==

前面说过Scala里如果所有的样本都没有匹配，那是会抛异常的。为了全都匹配，程序员会
给匹配加上一个默认匹配项处理默认情况。

实际上Scala编译器已经可以检测match表达式中遗漏的情况，但新的样本类可以定义在任何
地方。

比如我们的`Expr`有四个样本类，对应的模式匹配准备了四种情况。很好，四对四一个也
没有漏。但是，如果有人在其他的文件里又实现了第五个类……就变成漏掉一个匹配情况了。

所以有一个方案：让样本类的超类被封闭（sealed），这样就不能在别的文件中添加新的
子类。格式只要加一个`sealed`关键字：

{{{class="brush: scala"
  sealed abstract class Expr
  case class Var(name: String) extends Expr
  case class Number(num: Double) extends Expr
  case class UnOp(operator: String, arg: Expr) extends Expr
  case class BinOp(operator: String,
      left: Expr, right: Expr) extends Expr
}}}

如果代码里漏掉可能的模式：

{{{class="brush: scala"
  def describe(e: Expr): String = e match {
    case Number(_) => "a number"
    case Var(_) => "a variable"
  }
}}}

编译器会警告`UnOp`和`BinOp`没有处理：

{{{class="brush: scala"
  warning: match is not exhaustive!
  missing combination UnOp
  missing combination BinOp
}}}

如果程序员确实知道这两种情况不可能发生，就是要在这两种情况下抛异常。可以手动加上
让编译器闭嘴：

{{{class="brush: scala"
  def describe(e: Expr): String = e match {
    case Number(_) => "a number"
    case Var(_) => "a variable"
    case _ => throw new RuntimeException // Should not happen
  }
}}}

像这样加上一个永远也不会执行到的语句虽然在语法上OK，但不是一个好的代码风格。另
一个方法是对变量`e`添加注释`@unchecked`：

{{{class="brush: scala"
  def describe(e: Expr): String = (e: @unchecked) match {
    case Number(_) => "a number"
    case Var(_) => "a variable"
  }
}}}

注解会在后面的“注解”一章中介绍，这里的`@unchecked`会阻止`match`表达式检查是不是
有漏掉的可能性。

== 可选（Option）类型 ==

可选类型的格式为`Option[类型]`，它的值有两种形式：

* 在有值的情况下，返回的值形式为`Some(value)`，`value`就是值。
* 在无值的情况下，返回的是一个`None`对象。

=== `getOrElse`方法 ===

`Option`类型的`getOrElse`方法可以定义在没有值返回时的默认行为：

{{{class="brush: scala"
scala> def commentOnPractice(input: String) = {
     |     if(input == "test") Some("good") else None
     | }
commentOnPractice: (input: String)Option[String]

scala> val comment  = commentOnPractice("test")
comment: Option[String] = Some(good)

scala> println(comment.getOrElse("No comments"))
good

scala> val comment  = commentOnPractice("hack")
comment: Option[String] = None

scala> println(comment.getOrElse("No comments"))
No comments
}}}

=== `Map`返回`Option` ===

比如Scala的`Map`类型的`get`方法就是`Option`类型。在`key`有值的情况下返回
`Some（value）`；没有这个键的情况下返回`None`对象：

{{{class="brush: scala"
  scala> val capitals =
       | Map("France" -> "Paris", "Japan" -> "Tokyo")
  capitals:
    scala.collection.immutable.Map[java.lang.String,
    java.lang.String] = Map(France -> Paris, Japan -> Tokyo)

  scala> capitals get "France"
  res21: Option[java.lang.String] = Some(Paris)

  scala> capitals get "North Pole"
  res22: Option[java.lang.String] = None
}}}

=== 模式匹配处理`Option` ===

应用模式匹配处理有值和没有值的情况：

{{{class="brush: scala"
  scala> def show(x: Option[String]) = x match {
       | case Some(s) => s
       | case None => "?"
       | }
  show: (Option[String])String

  scala> show(capitals get "Japan")
  res23: String = Tokyo

  scala> show(capitals get "France")
  res24: String = Paris

  scala> show(capitals get "North Pole")
  res25: String = ?
}}}

=== `isEmpty`检查是否为空 ===

{{{class="brush: scala"
if (res.isEmpty)
	println("No result")
else
	println(res.get)
}}}

=== `for`会跳过空 ===

{{{class="brush: scala"
for (result <- resultList.get("Alice"))
	println(result)
}}}

=== 防止空指针 ===

在Java里Map没有值时返回的是`null`，如果忘记检查会引起空指针异常。而在Scala里对于
一个`Map[Int,Int]`是不可能返回`null`的。

使用`Option`类型的优点在于：

* `Option[String]`从字面上看就已经提醒了程序员内容可能为`None`；
* 在Java中如果变量为空要到运行时才抛出空指针异常，而Scala中Option类型让编译器就已经提供了检查：编译器会在把`Option[String]`当作`String`使用时报错，相当于加上了空指针的检查。

== case语句的中置表示法 ==

对于匹配两个部分的case，可以用中置表示法：

{{{class="brush: scala"
case class Currency(value: Double, unit: String)
val amt = Currency(100.00, "EUR")
}}} 

下面的匹配语句：

{{{class="brush: scala"
amt match { case Currency(a, u) => println(u + " " + a) }
}}}

可用中置表达格式：

{{{class="brush: scala"
amt match { case a Currency u => println(u + " " + a) }
}}} 

=== 中置模式匹配序列 ===

中置模式原来是要匹配序列的。以`List`为例，可以理解为每个实例要么是`Nil`，要么是
样本类`::`。例如，对于以下的定义：

{{{class="brush: scala"
	case class ::[E](head: E, tail: List[E]) extends List[E]
}}} 

可以这样匹配：

{{{class="brush: scala"
lst match { case h :: t => doSth() }
}}} 

相当于`case ::(h, t)`，会调用`::.unapply(lst)`。

中置表达式还可以嵌套。假设有一个模式`~`：

{{{class="brush: scala"
match { case ~(~(a,b),c) => doSth() }
}}} 

这个看起来太不自然了，可以用中置连接代替嵌套：

{{{class="brush: scala"
match { case a ~ b ~ c => doSth() }
}}} 

另一个例子是列表的连接操作`::`，当然要注意它是从右向左结合的：

{{{class="brush: scala"
match { case ::(first, ::(second, rest)) => doSth() }
}}} 

用中置表示为：

{{{class="brush: scala"
match { case first :: second :: rest => doSth() }
}}} 


== 模式无处不在 ==

=== 变量定义 ===

通过类型定义变量：

{{{class="brush: scala"
  scala> val myTuple = (123, "abc")
  myTuple: (Int, java.lang.String) = (123,abc)
}}}

用模式匹配代替类型声明：

{{{class="brush: scala"
  scala> val (number, string) = myTuple
  number: Int = 123
  string: java.lang.String = abc
}}}

上面的代码中按元组成员的类型，通过模式匹配自动判断出了变量`number`和`string`的类型。

这种方式用在指定精确类型的样本类时用得比较多：

{{{class="brush: scala"
  scala> val exp = new BinOp("*", Number(5), Number(1))
  exp: BinOp = BinOp(*,Number(5.0),Number(1.0))

  scala> val BinOp(op, left, right) = exp
  op: String = *
  left: Expr = Number(5.0)
  right: Expr = Number(1.0)
}}}

上面的代码正好在赋值时把参数一一对应地传了过去。

=== 偏函数的样本序列 ===

被包在花括号内的一组case选项其实是一个偏函数，偏函数并不是对所有输入的参数都有
定义。偏函数是类型`PartialFunction[A, B]`的一个实例，其中`A`是参数类型，`B`是
返回类型。

花括号case选项本来就是函数字面量，可以用在任何用函数字面量的地方。而且还是有相当
多个可选的函数字面量。如：

{{{class="brush: scala"
  val withDefault: Option[Int] => Int = {
    case Some(x) => x
    case None => 0
  }
}}}

调用：

{{{class="brush: scala"
  scala> withDefault(Some(10))
  res25: Int = 10

  scala> withDefault(None)
  res26: Int = 0
}}}

这样的方式很适合Actor应用：

{{{class="brush: scala"
  react {
    case (name: String, actor: Actor) => {
      actor ! getip(name)
      act()
    }
    case msg => {
      println("Unhandled message: "+ msg)
      act()
    }
  }
}}}

偏（partial）函数上如果值不支持会产生一个运行时异常。如下面的偏函数能返回整数
列表的第二个元素：

{{{class="brush: scala"
  val second: List[Int] => Int = {
    case x :: y :: _ => y
  }
}}}

编译器会提示匹配不全：

{{{class="brush: scala"
  <console>:17: warning: match is not exhaustive!
  missing combination Nil
}}}

产生上面这个错误的原因是：如果传递给它有三个的列表它的执行没有问题。但是少于2个
元素列表就匹配不上了：

{{{class="brush: scala"
  scala> second(List(5,6,7))
  res24: Int = 6

  scala> second(List())
  scala.MatchError: List()
   at $anonfun$1.apply(<console>:17)
   at $anonfun$1.apply(<console>:17)
   ....
}}}

=== 偏函数定义 ===

如果要检查一个偏函数是否有定义，一定要告诉编译器正在使用的函数是偏函数。类型
`Lint[Int] => Int`包含了不管是否是偏函数的，从整数列表到整数的所有函数。仅包含
整数列表到的偏函数的，应该写成`Partialfunction[List[Int],Int]`。

下面是偏函数的定义例子：

{{{class="brush: scala"
  val second: PartialFunction[List[Int],Int] = {
    case x :: y :: _ => y
  }
}}}

偏函数有一个`isDefineAt`方法来测试函数对某个值是否有定义。以这个例子来说，对于
至少两个元素的列表是有定义的：

{{{class="brush: scala"
  scala> second.isDefinedAt(List(5,6,7))
  res27: Boolean = true

  scala> second.isDefinedAt(List())
  res28: Boolean = false
}}}

Scala在编译器在把这样的表达式转为偏函数时会对模式进行两次翻译：一次是真实函数的
实现；另一次是测试函数是否对参数有定义的实现。例如上面的函数 

{{{class="brush: scala"
{case x :: y :: _ => y}
// trans to
}}}

会被翻译成：

{{{class="brush: scala"
  new PartialFunction[List[Int], Int] {
    def apply(xs: List[Int]) = xs match {
      case x :: y :: _ => y
    }
    def isDefinedAt(xs: List[Int]) = xs match {
      case x :: y :: _ => true
      case _ => false
    }
  }
}}}

这只有在声明类型为`PartialFunction`时才会发生。如果只是`Function1`或没有声明，
函数字面量会编译为完整的函数。

偏函数可能会引起运行时的异常，所以在调用前用`isDefineAt`检查一下。

=== for表达式 ===

来看一个典型的例子：每个元素都是`(country,city)`：

{{{class="brush: scala"
  scala> for ((country, city) <- capitals)
       | println("The capital of "+ country +" is "+ city)
  The capital of France is Paris
  The capital of Japan is Tokyo
}}}

当然也有元素不匹配模式的情况，下面例子中不匹配的会被丢弃。所以不用担心不能匹配的
元素：

{{{class="brush: scala"
  scala> val results = List(Some("apple"), None,
       | Some("orange"))
  results: List[Option[java.lang.String]] = List(Some(apple),
      None, Some(orange))

  scala> for (Some(fruit) <- results) println(fruit)
  apple
  orange
}}}

== 大型的例子 ==

目标是生成公式`((a / (b * c) + 1 / n) / 3)`显示形式为：

{{{class="brush: scala"
  a     1
----- + -
b * c   n
---------
    3
}}}

先来看：

{{{class="brush: scala"
  BinOp("+",
        BinOp("*",
              BinOp("+", Var("x"), Var("y")),
              Var("z")),
        Number(1))
}}}

应该输出`(x+y)*z+1`，`(x+y)`是有括号的，但是最外层不要括号。所以要先解决优先级问题：

{{{class="brush: scala"
  Map(
    "|" -> 0, "||" -> 0,
    "&" -> 1, "&&" -> 1, ...
  )
}}}

当然还有改进的空间，更好的方法是只定义递减的优先级操作符。然后根据它来计算：

{{{class="brush: scala"
    // Contains operators in groups of increasing precedence
    private val opGroups =
      Array(
        Set("|", "||"),
        Set("&", "&&"),
        Set("^"),
        Set("==", "!="),
        Set("<", "<=", ">", ">="),
        Set("+", "-"),
        Set("*", "%")
      )
}}}

再定义一个操作符与优先级映射的变量`precedence`，映射的内容是通过处理上面定义的
优先级。

{{{class="brush: scala"
    // A mapping from operators to their precedence
    private val precedence = {
      val assocs =
        for {
          i <- 0 until opGroups.length
          op <- opGroups(i)
        } yield op -> i
      Map() ++ assocs
    }

    private val unaryPrecedence = opGroups.length
    private val fractionPrecedence = -1
}}}

上面的代码里有一个例外，我们把除法单独拿了出来，并且把它的优先级定义成了`-1`。
这是为了方便处理我们要实现的分子在上分母在下的分数显示方式。

下一个问题是格式化方法的实现。定义一个`format`方法，它有两个参数：

* 第一个参数：是表达式类型的`e: Expr`
* 第二个参数：操作符的优先级`enclPrec: Int`（如果没有这个操作符，那优先级就应该是0）。

注意`format`是私有方法，完成大部分工作。最后一个公开的同名方法`format`提供入口。
内部还有一个`stripDot`方法来去掉如`2.0`的`.0`部分。

{{{class="brush: scala"
  private def format(e: Expr, enclPrec: Int): Element =

    e match {

      case Var(name) =>
        elem(name)

      case Number(num) =>
        def stripDot(s: String) =
          if (s endsWith ".0") s.substring(0, s.length - 2)
          else s
        elem(stripDot(num.toString))

      case UnOp(op, arg) =>
        elem(op) beside format(arg, unaryPrecedence)

      case BinOp("/", left, right) =>
        val top = format(left, fractionPrecedence)
        val bot = format(right, fractionPrecedence)
        val line = elem('-', top.width max bot.width, 1)
        val frac = top above line above bot
        if (enclPrec != fractionPrecedence) frac
        else elem(" ") beside frac beside elem(" ")

      case BinOp(op, left, right) =>
        val opPrec = precedence(op)
        val l = format(left, opPrec)
        val r = format(right, opPrec + 1)
        val oper = l beside elem(" "+ op +" ") beside r
        if (enclPrec <= opPrec) oper
        else elem("(") beside oper beside elem(")")
    }

    def format(e: Expr): Element = format(e, 0)
  }
}}}

上面的代码通过模式匹配实现了四种不同情况的处理：

第一种情况：如果是变量，结果就是变量名。

{{{class="brush: scala"
  case Var(name) =>
    elem(name)
}}}

第二种情况：如果是数字，结果是格式化后的数字，如`2.0`格式化为`2`：

{{{class="brush: scala"
      case Number(num) =>
        def stripDot(s: String) =
          if (s endsWith ".0") s.substring(0, s.length - 2)
          else s
        elem(stripDot(num.toString))
}}}

第三种情况：如果是一元操作符，处理结果为操作`op`和最高环境优先级格式化参数`arg`
的结果组成。这样如果`arg`是除了分数以外的二元操作就不会出现在括号中。

{{{class="brush: scala"
      case UnOp(op, arg) =>
        elem(op) beside format(arg, unaryPrecedence)
}}}

第四种情况：除法，也可以说是分数，则按上下位置放置。但仅仅上下的位置还不够。因为
这样分不清主次：

{{{class="brush: scala"
a
-
b
-
c
}}}

有必要强化层次：

{{{class="brush: scala"
 a
 -
 b
---
 c
}}}

实现的代码这个样子的：

{{{class="brush: scala"
      case BinOp("/", left, right) =>
        val top = format(left, fractionPrecedence)
        val bot = format(right, fractionPrecedence)
        val line = elem('-', top.width max bot.width, 1)
        val frac = top above line above bot
        if (enclPrec != fractionPrecedence) frac
        else elem(" ") beside frac beside elem(" ")
}}}

第五种情况（也是最后一种）：除法以外的其他二元操作符。在这里要注意一下优先级
问题：

二元运算符有两个操作数。其中左操作数的优先级是操作符`op`的`opPrec`，而右操作数的
优先级要再加1。这样保证了括号也同样反映正确的优先级。如：

{{{class="brush: scala"
BinOp("-", Var("a"), BinOp("-", Var("b"), Var("c")))
}}}

将被处理为`a - (b - c)`。如果当前操作符优先级小于外部操作符的优先级，那`oper`
就要被放在括号里，不然按原样返回。

具体实现：

{{{class="brush: scala"
      case BinOp(op, left, right) =>
        val opPrec = precedence(op)
        val l = format(left, opPrec)
        val r = format(right, opPrec + 1)
        val oper = l beside elem(" "+ op +" ") beside r
        if (enclPrec <= opPrec) oper
        else elem("(") beside oper beside elem(")")
}}}

五种可能的情况都处理完毕了。最后再给一个让外部代码公开调用的方法，这个方法不用
优先级参数就可以格式化公式：

{{{class="brush: scala"
    def format(e: Expr): Element = format(e, 0)
}}}

到这里算法的讲解完毕。全部代码如下：

{{{class="brush: scala"
//compile this along with ../compo-inherit/LayoutElement.scala

  package org.stairwaybook.expr
  import layout.Element.elem
  
  sealed abstract class Expr
  case class Var(name: String) extends Expr
  case class Number(num: Double) extends Expr
  case class UnOp(operator: String, arg: Expr) extends Expr
  case class BinOp(operator: String,
      left: Expr, right: Expr) extends Expr
  
  class ExprFormatter {
  
    // Contains operators in groups of increasing precedence
    private val opGroups =
      Array(
        Set("|", "||"),
        Set("&", "&&"),
        Set("^"),
        Set("==", "!="),
        Set("<", "<=", ">", ">="),
        Set("+", "-"),
        Set("*", "%")
      )
  
    // A mapping from operators to their precedence
    private val precedence = {
      val assocs =
        for {
          i <- 0 until opGroups.length
          op <- opGroups(i)
        } yield op -> i
      Map() ++ assocs
    }
  
    private val unaryPrecedence = opGroups.length
    private val fractionPrecedence = -1
  
    // continued in Listing 15.21...

  import org.stairwaybook.layout.Element

  // ...continued from Listing 15.20
  
  private def format(e: Expr, enclPrec: Int): Element =
  
    e match {
  
      case Var(name) =>
        elem(name)
  
      case Number(num) =>
        def stripDot(s: String) =
          if (s endsWith ".0") s.substring(0, s.length - 2)
          else s
        elem(stripDot(num.toString))
  
      case UnOp(op, arg) =>
        elem(op) beside format(arg, unaryPrecedence)
  
      case BinOp("/", left, right) =>
        val top = format(left, fractionPrecedence)
        val bot = format(right, fractionPrecedence)
        val line = elem('-', top.width max bot.width, 1)
        val frac = top above line above bot
        if (enclPrec != fractionPrecedence) frac
        else elem(" ") beside frac beside elem(" ")
  
      case BinOp(op, left, right) =>
        val opPrec = precedence(op)
        val l = format(left, opPrec)
        val r = format(right, opPrec + 1)
        val oper = l beside elem(" "+ op +" ") beside r
        if (enclPrec <= opPrec) oper
        else elem("(") beside oper beside elem(")")
    }
  
    def format(e: Expr): Element = format(e, 0)
  }
}}}

具体调用的演示程序：

{{{class="brush: scala"
  import org.stairwaybook.expr._

  object Express extends Application {

    val f = new ExprFormatter

    val e1 = BinOp("*", BinOp("/", Number(1), Number(2)),
                        BinOp("+", Var("x"), Number(1)))
    val e2 = BinOp("+", BinOp("/", Var("x"), Number(2)),
                        BinOp("/", Number(1.5), Var("x")))
    val e3 = BinOp("/", e1, e2)

    def show(e: Expr) = println(f.format(e)+ "\n\n")

    for (val e <- Array(e1, e2, e3)) show(e)
}
}}}

上面的演示程序继承了`Application`方法，所以虽然没有`main`方法它还是可以运行的
应用程序。可以这样运行：

{{{class="brush: scala"
  scala Express
}}}

输出的结果为：

{{{class="brush: scala"
1
- * (x + 1)
2

x   1.5
- + ---
2    x

1
- * (x + 1)
2
-----------
  x   1.5
  - + ---
  2    x
}}}




= 抽取器（Extractors） =

== 例子：抽取email地址 ==

对于一个email类的话，如果是合法的email地址取出用户名与域名。

{{{class="brush: scala"
  EMail(user, domain)
}}}

模式匹配表达式可以写为：

{{{class="brush: scala"
  s match {
    case EMail(user, domain) => println(user +" AT "+ domain)
    case _ => println("not an email address")
  }
}}}

找到两个连续的同一用户的email地址的模式：

{{{class="brush: scala"
  ss match {
    case EMail(u1, d1) :: EMail(u2, d2) :: _ if (u1 == u2) => ...
    ...
  }
}}}

现在要匹配的email不是一个类，而是字符串。我们先把方法定义出来：

{{{class="brush: scala"
  def isEMail(s: String): Boolean
  def domain(s: String): String
  def user(s: String): String
}}}

调用的时候就是这样的：

{{{class="brush: scala"
  if (isEMail(s)) println(user(s) +" AT "+ domain(s)
  else println("not an email address")
}}}


== 抽取器 ==

在scala对象中与`apply`方法相对的方法是`unapply`方法，而有`unapply`成员方法的对象
就是抽取器。`unapply`是为了匹配并分解值。

下面的例子中`apply`方法注入对象，而`unapply`方法从对象中抽取内容：
  
{{{class="brush: scala"
  object EMail {

    // The injection method (optional)
    def apply(user: String, domain: String) = user +"@"+ domain

    // The extraction method (mandatory)
    def unapply(str: String): Option[(String, String)] = {
      val parts = str split "@"
      if (parts.length == 2) Some(parts(0), parts(1)) else None
    }
  }
}}}

还可以让这个对象继承自Scala的函数类型：

{{{class="brush: scala"
  object EMail extends (String, String) => String { ... }
}}}

对象声明里的`(String, String) => String`的意思相当于`Function2[String, String]`
，是对Email类实现的抽象`apply`方法的声明。这样可以把Email传递给需要
`Function2[String,String]`的方法。

=== unapply返回类型为Option ===

注意`unapply`方法返回类型是`Option`。因为输入参数可能不是正确的email格式。

{{{class="brush: scala"
  unapply("John@epfl.ch")  equals  Some("John", "epfl.ch")
  unapply("John Doe")  equals  None
}}}

=== unapply与模式匹配 ===

现在，当模式匹配到抽取器对象指定的模式就会在选择器表达式中调用抽取器的`unapply`
方法。如下面的代码：

{{{class="brush: scala"
  selectorString match { case EMail(user, domain) => ... }
}}}

`String`类型的`selectorString`其实先被抽取器处理：

{{{class="brush: scala"
  EMail.unapply(selectorString)
}}}

产的结构再进行模式匹配判断。

`selectorString`的类型虽然和`unapply`一样都是`String`，但这并不是必须的。像下面
这样检查任意类型的实例是不是email：

{{{class="brush: scala"
  val x: Any = ...
  x match { case EMail(user, domain) => ... }
}}}

=== apply与unapply应该有对偶关系 ===

一般来说如果包含了注入方法，那应该与抽取方法成对偶关系。如调用：

{{{class="brush: scala"
  EMail.unapply(EMail.apply(user, domain))
}}}

应该返回：

{{{class="brush: scala"
  Some(user, domain)
}}}

也就是说被`Some`包装的同一序列的参数。反过来就是先执行`unapply`再执行`apply`：

{{{class="brush: scala"
  EMail.unapply(obj) match { 
    case Some(u, d) => EMail.apply(u, d) 
  }
}}}

虽然这样的对偶性不是强制要求的，但强烈建议实现。
  

== 只有1个或没有变量的模式 ==

之前`unapply`方法返回的是元组，这在有多个值要返回的时候很有用。但是在只有一个值
或没有值要返回的时候有麻烦，因为元组最小是二元组，没有有一元元组。

所以模式只绑定一个变量的情况要特别对待，把结果直接放在`Some`中：

{{{class="brush: scala"
  object Twice {
    def apply(s: String): String = s + s
    def unapply(s: String): Option[String] = {
      val length = s.length / 2
      val half = s.substring(0, length)
      if (half == s.substring(length)) Some(half) else None
    }
  }
}}}

还有一种情况下抽取器模式不绑定任何变量。这样情况下返回布尔值表示匹配成功或失败：

{{{class="brush: scala"
  object UpperCase {
    def unapply(s: String): Boolean = s.toUpperCase == s
  }
}}}

注意上面的代码没有`apply`，因为本来就没有什么好构造的。

下面的`userTwiceUpper`函数的模式匹配代码集中了前面定义的所有抽取器：

{{{class="brush: scala"
  def userTwiceUpper(s: String) = s match {
    case EMail(Twice(x @ UpperCase()), domain) =>
      "match: "+ x +" in domain "+ domain
    case _ => 
      "no match"
  }
}}}

函数的第一部分匹配email地址，并且用户名部分需要由大家字母形式的相同字符串出现
两次组成。

注意第二行里的`UpperCase`的空参数列表`()`是不能省略的，不然会被解释为与
`UpperCase`对象进行匹配。还要注意虽然`UpperCase()`本身没有绑定任何变量，但还可以
把变量与匹配它的整个模式联系起来。用模式中的变量绑定方案；以`x @ UpperCase()`的
模式把`x`与`UpperCase()`匹配的模式联系起来。例如在第一个`userTwiceUpper`调用中，
`x`被绑定为`DI`，因为匹配于`UpperCase()`模式的值。

{{{class="brush: scala"
  scala> userTwiceUpper("DIDI@hotmail.com")
  res0: java.lang.String = match: DI in domain hotmail.com

  scala> userTwiceUpper("DIDO@hotmail.com")
  res1: java.lang.String = no match

  scala> userTwiceUpper("didi@hotmail.com")
  res2: java.lang.String = no match
}}}


== 可变参数的抽取器 ==

希望的元素个数是可变的，如对域名的处理：

{{{class="brush: scala"
  dom match {
    case Domain("org", "acm") => println("acm.org")
    case Domain("com", "sun", "java") => println("java.sun.com")
    case Domain("net", _*) => println("a .net domain")
  }
}}}

可以看到上面的域名是反向展开的，最后一个情况下下`_*`剩下的所有元素。`unapply`值
的返回个数定下了就不能改了，所以Scala允许为变参数定义不同的抽取方法`unapplySeq`
：

{{{class="brush: scala"
  object Domain {

    // The injection method (optional)
    def apply(parts: String*): String = 
      parts.reverse.mkString(".")

    // The extraction method (mandatory)
    def unapplySeq(whole: String): Option[Seq[String]] = 
      Some(whole.split("\\.").reverse)
  }
}}}

`unapplySeq`以句点拆分字符串包装在`Some`中返回。`unapplySeq`抽取器返回结果类型
必须是`Option[seq[T]]`，这里的元素类型`T`不能限制。`Seq`是各种序列类（List、
Array、RichString等）的共同超类。

这样寻找某个`.com`域名中的email的函数就是这样：

{{{class="brush: scala"
  def isTomInDotCom(s: String): Boolean = s match {
    case EMail("tom", Domain("com", _*)) => true
    case _ => false
  }
}}}

返回期望的结果：

{{{class="brush: scala"
  scala> isTomInDotCom("tom@sun.com")
  res3: Boolean = true

  scala> isTomInDotCom("peter@sun.com")
  res4: Boolean = false

  scala> isTomInDotCom("tom@acm.org")
  res5: Boolean = false
}}}

同样也可以从`unapplySeq`及变化部分返回固定的元素。表达为包含所有元素的元组，变化
部分还是在最后，下面是新的抽取器，其中域名部分已经扩展为序列了：

{{{class="brush: scala"
  object ExpandedEMail {
    def unapplySeq(email: String) : Option[(String, Seq[String])] = {
      val parts = email split "@"
      if (parts.length == 2) 
        Some(parts(0), parts(1).split("\\.").reverse)
      else 
        None
    }
  }
}}}

这里`unapplySeq`方法返回对偶的可选类型。对偶的第一个元素是用户部分，第二个部分是
表示域名的序列。然后就可以这样匹配它：

{{{class="brush: scala"
  scala> val s = "tom@support.epfl.ch"
  s: java.lang.String = [[tom@support.epfl.ch]]

  scala> val ExpandedEMail(name, topdom, subdoms @ _*) = s
  name: String = tom
  topdom: String = ch
  subdoms: Seq[String] = List(epfl, support)
}}}


== 抽取器和序列模式 ==

模式匹配中我们已经知道可以使用序列模式访问列表或数组的元素：

{{{class="brush: scala"
  List()
  List(x, y, _*)
  Array(x, 0, 0, _)
}}}

这里的`List(...)`形式的模式其实是由`scala.List`的伴生对象定义了`unapplySeq`方法
的抽取器，相关定义如下：

{{{class="brush: scala"
  package scala
  object List {
    def apply[T](elems: T*) = elems.toList
    def unapplySeq[T](x: List[T]): Option[Seq[T]] = Some(x)
    ... 
  }
}}}

List对象包含了带可变数量参数的`apply`方法，从而允许编写如下的表达式：

{{{class="brush: scala"
  List()
  List(1, 2, 3)
}}}

它还包含了以序列形式返回列表所有元素的`unapplySeq`方法，从而对`List(...)`模式
提供了支持。`scala.Array`对象定义也非常类似，所以数组也支持注入和抽取方法。

== 抽取器与模式匹配 ==

=== 抽取器中置模式匹配 ===

如果`unapply`方法产出的是一个对偶，就可以在模式匹配`case`语句中使用中置表示法。
对于有两个参数的样本类：

{{{class="brush: scala"
case class Currency(value: Double, unit: String)
val amt = Currency(100.00, "EUR")
}}} 

下面的匹配语句：

{{{class="brush: scala"
amt match { case Currency(a, u) => println(u + " " + a) }
}}}

可用中置表达格式：

{{{class="brush: scala"
amt match { case a Currency u => println(u + " " + a) }
}}} 

中置表示法可以用于任何返回对偶的`unapply`方法，比如：

{{{class="brush: scala"
case object +: {
	def unapply[T](input: List[T]) = 
		if (input.isEmpty)
			None
		else
			Some((input.head, input.tail))
}
}}}

这样就可以直接用`+:`来析构列表了：

{{{class="brush: scala"
1 +: 7 +: 2 +:9 +: Nil match {
	case first +: second +: rest => first + second + rest.length
}
}}}

=== 抽取器 VS. 样本类 ===

样本类会暴露了数据的具体表达方式，让外部看到了类名与构造器等信息，如：

{{{class="brush: scala"
  case C(...)
}}}

对于已经存在的样本类后来写的代码一定要拿来用它们。如果修改了样本类就一定要把用到
的地方都一起改了。抽取器是独立的，没有这个问题。

样本类的优点是容易实现、性能更加高效。而且样本类如果继承自`sealed`，编译器可以
穷举所有可能性检查程序里会漏掉的逻辑。

一般来说，如果是封闭的应用，样本类更加合适；如果是开放的，类层级之类的会有重构，
就更加适合抽取器。

在面临选择的时候可以先从样本类开始做，以后发觉有问题再换抽取器。因为抽取器与
样本类模式在Scala上看上去样子完全一样，所以在客户代码中的模式匹配还是可以继续
工作的。但是像本章的email例子中模式架构与数据表现类不相符的情况下，只能用抽取器
。

== 正则表达式 ==

正则表达式规则看`java.util.regex.Pattern`包的JavaDoc。RTFM！

=== 形成正则表达式 ===

Scala相关正则的类放在`scala.util.matching`包里：

{{{class="brush: scala"
  scala> import scala.util.matching.Regex
}}}

通过`Regex`类构造器传递正则表达式：

{{{class="brush: scala"
  scala> val Decimal = new Regex("(-)?(\\d+)(\\.\\d*)?")
  Decimal: scala.util.matching.Regex = (-)?(\d+)(\.\d*)?
}}}

Scala的照排字符串可以免了java复杂的转义：

{{{class="brush: scala"
  scala> val Decimal = new Regex("""(-)?(\d+)(\.\d*)?""")
  Decimal: scala.util.matching.Regex = (-)?(\d+)(\.\d*)?
}}}

还可以更加简化：

{{{class="brush: scala"
  scala> val Decimal = """(-)?(\d+)(\.\d*)?""".r
  Decimal: scala.util.matching.Regex = (-)?(\d+)(\.\d*)?
}}}

`RichString`类里实现了`r`方法把字符串转为正则表达式：

{{{class="brush: scala"
  package scala.runtime
  import scala.util.matching.Regex

  class RichString(self: String) ... {
    ...
    def r = new Regex(self)
  }
}}}

=== 用正则表达式查找替换 ===

查找首次出现作为`Option`类型结果返回：

{{{class="brush: scala"
regex findFirstIn str
}}}

所有的出现的匹配以`Iterator`类型结果返回：

{{{class="brush: scala"
regex findAllIn str
}}}

查找开始位置匹配出现，返回`Option`类型：

{{{class="brush: scala"
regex findPrefixOf str
}}}

例子：

{{{class="brush: scala"
  scala> val Decimal = """(-)?(\d+)(\.\d*)?""".r
  Decimal: scala.util.matching.Regex = (-)?(\d+)(\.\d*)?

  scala> val input = "for -1.0 to 99 by 3"      
  input: java.lang.String = for -1.0 to 99 by 3

  scala> for (s <- Decimal findAllIn input)
       | println(s)
  -1.0
  99
  3

  scala> Decimal findFirstIn input
  res1: Option[String] = Some(-1.0)

  scala> Decimal findPrefixOf input
  res2: Option[String] = None
}}}


=== 正则表达式抽取值 ===

Scala所有的正则表达式都定义了抽取器，可以用来鉴别匹配于正则表达式分组的子字符串
，相当于买一送一。例如，下面这样解构数值字符串：

{{{class="brush: scala"
  scala> val Decimal(sign, integerpart, decimalpart) = "-1.23"  
  sign: String = -
  integerpart: String = 1
  decimalpart: String = .23
}}}

注意这里用`Decimal(...)`来定义了一个`val`。`Decimal`正则表达式值定义了
`unapplySeq` 方法把字符串与正则匹配到三个模式变量`sign`、`intergerpart`、
`decimalpart`，如果有一个部分缺少就是`null`：

{{{class="brush: scala"
  scala> val Decimal(sign, integerpart, decimalpart) = "1.0"
  sign: String = null
  integerpart: String = 1
  decimalpart: String = .0
}}}

还可以在for表达式中混用抽取器与正则表达式做搜索，如，下面的代码从字符串中找到
所有的数值：

{{{class="brush: scala"
  scala> for (Decimal(s, i, d) <- Decimal findAllIn input)
       |   println("sign: "+ s +", integer: "+
       |       i +", decimal: "+ d)
  sign: -, integer: 1, decimal: .0
  sign: null, integer: 99, decimal: null
  sign: null, integer: 3, decimal: null
}}}



