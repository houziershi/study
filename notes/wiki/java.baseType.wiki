
%title 基础类型

%toc 基础类型

= 数组 =

声明时不能指定大小：`type [] var;`或`type var []`

创建时指定大小：`new type var[size]`

字面量：`{item1, item2, ... }`

{{{class="brush: java"
int[] intArray;   //creating array without initializing or specifying size
int intArray1[];  //another int[] reference variable can hold reference of an integer array
int[] intArray2 = new int[10]; //creating array by specifying size
int[] intArray3 = new int[]{1,2,3,4}; //creating and initializing array in same line.
}}}

Java中数组可以轻易的转换成ArrayList。ArrayList一个基于索引的集合，它是作为数组的
备选方案。ArrayList的优点是可以改变容量大小，只需要创建个更大的数组然后拷贝内容
到新数组，但你不能改变数组的大小。

== arrayCopy ==

Java API同样提供了一些便捷方法通过java.utils.Arrays类去操作数组，通过使用Arrays
你可以排序数组，你可以做二分搜索。

java.lang.System类提供了实用方法拷贝元素到另一个数组。在拷贝内容从一个数组到
另一个数组的时候System.arrayCopy非常强大和灵活。你可以拷贝整个或子数组，
具体看你的需求。System.arraycoy语法：

{{{class="brush: java"
public static void arraycopy(Object src, int srcPos, Object dest, 
		int destPos, int length)
}}}

如你所见，arraycopy允许我们指定索引和长度，能很灵活给你拷贝子数组和存储到需要的
位置或目标数组。这里是一个例子，拷贝前三个元素到目标数组：

{{{class="brush: java"
public static void main(String args[]) {
  int[] source = new int[]{10, 20, 30, 40, 50};
  int[] target = new int[5];

  System.out.println("Before copying");
  for(int i: target){
      System.out.println(i);
  }

  System.arraycopy(source, 0, target, 0, 3);

  System.out.println("after copying");
  
  for(int i: target){
      System.out.println(i);
  }
}
}}}

输出：

{{{class="brush: java"
Before copying
0
0
0
0
0
after copying
10
20
30
0
0
}}}

== 多维数组 ==

{{{class="brush: java"
int[][] multiArray = new int[2][3];
}}}


{{{class="brush: java"
int[][] multiArray = {{1,2,3},{10,20,30}};
System.out.println(multiArray[0].length);
System.out.println(multiArray[1].length);
}}}




= 容器类初始化 =

== 忘设初始容量 ==

在JAVA中，我们常用`Collection`中的`Map`做Cache,但是我们经常会遗忘设置初始容量：

{{{class="brush: java"
cache = new LRULinkedHashMap< K, V>(maxCapacity);
}}}

解决

初始容量的影响有多大？拿`LinkedHashMap`来说，初始容量如果不设置默认是`16`，超过
`16×LOAD_FACTOR`，会`resize(2 * table.length)`扩大2倍。采用：

{{{class="brush: java"
Entry[] newTable = new Entry[newCapacity];
transfer(newTable)
}}}

即整个数组Copy， 那么对于一个需要做大容量CACHE来说，从16变成一个很大的数量，需要
做多少次数组复制可想而知。如果初始容量就设置很大，自然会减少`resize`, 不过可能会
担心，初始容量设置很大时，没有Cache内容仍然会占用过大体积。其实可以参考以下表格
简单计算下, 初始时还没有cache内容, 每个对象仅仅是4字节引用而已。

* memory for reference fields (4 bytes each);
* memory for primitive fields

| Java类型 | 占用字节 |
| boolean  | 1        |
| byte     |          |
| char     | 2        |
| short    |          |
| int      | 4        |
| float    |          |
| long     | 8        |
| double   |          |

不仅是map, 还有`StringBuffer`等，都有容量`resize`的过程，如果数据量很大，就不能
忽视初始容量可以考虑设置下，否则不仅有频繁的`resize`还容易浪费容量。

在Java编程中，除了上面枚举的一些容易忽视的问题，日常实践中还存在很多。相信通过
不断的总结和努力，可以将我们的程序完美呈现给读者。



= 枚举（enum） =

不能用`ordinal`自增当值时，增加一个`value`表示值：

{{{class="brush: java"
public enum CardType {
	Gray(1), White(2), Black(3);

	private int value;

	private static final CardType[] valueArr = CardType.values();

	private CardType(int value) {
		this.value = value;
	}

	public int getValue() {
		return value;
	}

	public static CardType valueOf(int value) {
		for (CardType e : valueArr)
		if (e.value == value)
			return e;
		return null;
	}
}
}}}

通过`ordinal()`、`name()`、`getValue()`取得对应的值：

{{{class="brush: java"
	assertTrue(0 == CardType.Gray.ordinal());
	assertEquals("Gray", CardType.Gray.name());
	assertTrue(1 == CardType.Gray.getValue());

	assertTrue(1 == CardType.White.ordinal());
	assertEquals("White", CardType.White.name());
	assertTrue(2 == CardType.White.getValue());

	assertTrue(2 == CardType.Black.ordinal());
	assertEquals("Black", CardType.Black.name());
	assertTrue(3 == CardType.Black.getValue());
}}}

根据`ordinal`、`name`、`value`生成枚举对象：

{{{class="brush: java"
	int ordinal = 2;
	CardType type = CardType.values()[ordinal];
	assertEquals(type, CardType.Black);

	type = CardType.valueOf("Black");
	assertEquals(type, CardType.Black);

	type = CardType.valueOf(3);
	assertEquals(type, CardType.Black);
}}}


