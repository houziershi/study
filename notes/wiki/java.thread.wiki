%title 线程基础

%toc 线程基础

= 线程 =

== 创建线程 ==

`Runnable`接口的`run`方法是要运行的逻辑。

`Thread`类实现`run`方法。方法里是执行的逻辑。`start()`方法表示启动新线程。

== 线程优先级 ==

线程的成员方法`setPriority`。如设置当前线程的优先级为普通：

{{{class="brush: java"
Thread.currentThread.setPriority(Thread.NORNAL_PRIORITY)
}}}

可用优先级：

* NORMAL_PRIORITY
* MIN_PRIORITY
* MAX_PRIORITY
* 等……

== 守护线程 ==

分为“普通线程”和“守护线程”，区别是如果还有普通线程没有执行完毕，JVM是关不掉的。

普通线程创建的线程默认都是普通线程，除非用`setDaemon(true)`指定：

{{{class="brush: java"
Thread t1 = new Thread(runnable);
t1.setDaemon(true);
t1.start();
}}}


== 多个线程相互协调 ==

=== sleep、yield、join ===

暂停线程：`Thread.sleep()`

让出CPU：`Thread.yield()`

给其他线程执行的机会，如：循环处理多个记录的时候每个循环里`yield`一下，或阻塞
在IO时`yield`一下。

等待其他线程完毕：`t1.join()`

当前的线程停下，等这个`t1`的线程执行完了以后再执行当前线程。

=== 中断 ===

对一个线程发出停止信号，如：`t1.interrupted()`要求线程`t1`停止。

这样`t1`的执行就会抛出`InterruptedException`异常，它是受检查异常，表示当前线程
被其他线程打断。如下面的代码收到异常后就`break`了，那么线程就中断了：

{{{class="brush: java"
class T1 extends Thread {
	while(true) {
		try { 
			/* do something */ 
		} catch (InterruptedException e) { 
			break; 
		}
	}
}
}}}

如果去掉上面的`break`那线程就中断不了了。

执行线程并中断的过程如下：

{{{class="brush: java"
T1 t1 = new T1();
t1.start();
t1.join();
t1.interrupt();
}}}


== 线程协作 ==

每个对象都有`wait`与`notify`和`notifyAll`方法，选一个对象作为标志来同步：

＊ 以对象`o`为标志，当前线程停止，让给其他线程执行：

{{{class="brush: java"
synchronized { o.wait(); } //当前线程停止，等待唤醒。
}}}

这样当前线程就不会再醒过来，除非其他线程里调用对象`o`的`nodify`或是`nodifyAll`
方法：

{{{class="brush: java"
synchronized { o.notifyAll(); } // 唤醒所有以o为标志等待的线程
}}}





= 本地线程变量 =

`ThreadLocal`类给每个线程都准备一个资源的副本。保证每个资源只有当前线程可以
访问。

`ThreadLocal`对象不能简单地赋值就完了。因为它管理的每个线程的内容都要初始化，
所以它每次都会调用自己的`initialValue()`方法。重写这个方法可以完成每个线程的
初始化。

{{{class="brush: java"
private static ThreadLocal<List<String>> threadLod =
	new ThreadLocal<List<String>>() {
		protected List<String> initialValue() {
			return new ArrayList<String>();
		}
	}
}}}

== ThreadLocal是什么 ==

从线程的角度看，目标变量就象是线程的本地变量，这也是类名中`Local`所要表达的意思。

线程局部变量并不是Java的新发明，很多语言（如IBM IBM XL FORTRAN）在语法层面就提供
线程局部变量。在Java中没有提供在语言级支持，而是变相地通过`ThreadLocal`的类提供
支持。

所以，在Java中编写线程局部变量的代码相对来说要笨拙一些，因此造成线程局部变量没有
在Java开发者中得到很好的普及。

== ThreadLocal的接口方法 ==

ThreadLocal类接口很简单，只有4个方法，我们先来了解一下：

* `void set(Object value)`设置当前线程的线程局部变量的值。
* `public Object get()`该方法返回当前线程所对应的线程局部变量。
* `public void remove()`JDK 5.0新增。线程结束后本来就会自动回收，显式调用并不是必要的。
* `protected Object initialValue()`返回初始值，显然是为了让子类覆盖而设计的。

`initialValue()`是一个延迟调用方法，在线程第1次调用`get()`或`set(Object)`时才
执行，并且仅执行1次。`ThreadLocal`中的缺省实现直接返回一个`null`。

值得一提的是，在JDK5.0中，`ThreadLocal`已经支持泛型变为`ThreadLocal<T>`。API方法
也相应进行了调整，新版本的API方法分别是`void set(T value)`、`T get()`以及
`T initialValue()`。

`ThreadLocal`是如何做到为每一个线程维护变量的副本的呢？其实实现的思路很简单：
在`ThreadLocal`类中有一个Map，用于存储每一个线程的变量副本，Map中元素的键为线程
对象，而值对应线程的变量副本。我们自己就可以提供一个简单的实现版本：

{{{class="brush: java"  title="SimpleThreadLocal.java"
public class SimpleThreadLocal {
	private Map valueMap = Collections.synchronizedMap(new HashMap());
	
	public void set(Object newValue) {
		// 键为线程对象，值为本线程的变量副本
		valueMap.put(Thread.currentThread(), newValue);
	}

	public Object get() {
		Thread currentThread = Thread.currentThread();
		//返回本线程对应的变量
		Object o = valueMap.get(currentThread);
		if (o == null && !valueMap.containsKey(currentThread)) {
			// 如果在Map中不存在，放到Map中保存起来。
			o = initialValue();
			valueMap.put(currentThread, o);
		}
		return o;
	}

	public void remove() {
		valueMap.remove(Thread.currentThread());
	}

	public Object initialValue() {
		return null;
	}
}
}}}

虽然这个`ThreadLocal`实现版本显得比较幼稚，但它和JDK所提供的`ThreadLocal`类在
实现思路上是相近的。

== 一个TheadLocal实例 ==

下面，我们通过一个具体的实例了解一下`ThreadLocal`的具体使用方法。

{{{class="brush: java; highlight: [5,12,20,37]"  title="SequenceNumber.java"
package com.baobaotao.basic;
public class SequenceNumber {

	// 通过匿名内部类覆盖ThreadLocal的initialValue()方法，指定初始值
	private static ThreadLocal seqNum = new ThreadLocal() {
		public Integer initialValue() {
			return 0;
		}
	};

	// 获取下一个序列值
	public int getNextNum(){
		seqNum.set(seqNum.get()+1);
		return seqNum.get();
	}

	public static void main(String[] args) {
		SequenceNumber sn = new SequenceNumber();
		// 3个线程共享sn，各自产生序列号
		TestClient t1 = new TestClient(sn);
		TestClient t2 = new TestClient(sn);
		TestClient t3 = new TestClient(sn);
		t1.start();
		t2.start();
		t3.start();
	}

	private static class TestClient extends Thread {
		private SequenceNumber sn;

		public TestClient(SequenceNumber sn) {
			this.sn = sn;
		}

		public void run() {
			// 每个线程打出3个序列值
			for (int i = 0; i < 3; i++) {
			System.out.println("thread[" + Thread.currentThread().getName() 
					+ "] sn[" + sn.getNextNum() + "]");
			}
		}
	}

}
}}}

通常我们通过匿名内部类的方式定义`ThreadLocal`的子类，提供初始的变量值。
`TestClient`线程产生一组序列号，生成3个`TestClient`，它们共享同一个
`SequenceNumber`实例。运行以上代码，在控制台上输出以下的结果：

{{{class="brush: bash"
thread[Thread-2] sn[1]
thread[Thread-0] sn[1]
thread[Thread-1] sn[1]
thread[Thread-2] sn[2]
thread[Thread-0] sn[2]
thread[Thread-1] sn[2]
thread[Thread-2] sn[3]
thread[Thread-0] sn[3]
thread[Thread-1] sn[3]
}}}

考察输出的结果信息，我们发现每个线程所产生的序号虽然都共享同一个`SequenceNumber`
实例，但它们并没有发生相互干扰的情况，而是各自产生独立的序列号，这是因为我们通过
`ThreadLocal`为每一个线程提供了单独的副本。

== Thread同步机制的比较 ==

`ThreadLocal`和线程同步机制相比有什么优势呢？`ThreadLocal`和线程同步机制都是为了
解决多线程中相同变量的访问冲突问题。

在同步机制中，通过对象的锁机制保证同一时间只有一个线程访问变量。这时该变量是多个
线程共享的，使用同步机制要求程序慎密地分析什么时候对变量进行读写，什么时候需要
锁定某个对象，什么时候释放对象锁等繁杂的问题，程序设计和编写难度相对较大。

而`ThreadLocal`则从另一个角度来解决多线程的并发访问。`ThreadLocal`会为每一个线程
提供一个独立的变量副本，从而隔离了多个线程对数据的访问冲突。因为每一个线程都拥有
自己的变量副本，从而也就没有必要对该变量进行同步了。`ThreadLocal`提供了线程安全
的共享对象，在编写多线程代码时，可以把不安全的变量封装进`ThreadLocal`。

由于`ThreadLocal`中可以持有任何类型的对象，低版本JDK所提供的`get()`返回的是
`Object`对象，需要强制类型转换。但JDK 5.0通过泛型很好的解决了这个问题，在一定
程度地简化`ThreadLocal`的使用。

概括起来说，对于多线程资源共享的问题，同步机制采用了“以时间换空间”的方式，而
`ThreadLocal`采用了“以空间换时间”的方式。前者仅提供一份变量，让不同的线程排队
访问，而后者为每一个线程都提供了一份变量，因此可以同时访问而互不影响。

== Spring使用ThreadLocal解决线程安全问题 ==

我们知道在一般情况下，只有无状态的Bean才可以在多线程环境下共享，在Spring中，
绝大部分Bean都可以声明为`singleton`作用域。就是因为Spring对一些Bean（如
`RequestContextHolder`、`TransactionSynchronizationManager`、
`LocaleContextHolder`等）中非线程安全状态采`用ThreadLocal`进行处理，让它们也成为
线程安全的状态，因为有状态的Bean就可以在多线程中共享了。

一般的Web应用划分为展现层、服务层和持久层三个层次，在不同的层中编写对应的逻辑，
下层通过接口向上层开放功能调用。在一般情况下，从接收请求到返回响应所经过的所有
程序调用都同属于一个线程，如图所示：

<img src="images/java.base/07.gif" />

这样你就可以根据需要，将一些非线程安全的变量以`ThreadLocal`存放，在同一次请求
响应的调用线程中，所有关联的对象引用到的都是同一个变量。

下面的实例能够体现Spring对有状态Bean的改造思路：

非线程安全：

{{{class="brush: java" title="TopicDao"
public class TopicDao {
	//一个非线程安全的变量
	private Connection conn;
	
	public void addTopic(){
		//引用非线程安全变量
		Statement stat = conn.createStatement();
		// ...
	}
}
}}}

由于`conn`是成员变量，因为`addTopic()`方法是非线程安全的，必须在使用时创建一个新
`TopicDao`实例（非singleton）。下面使用`ThreadLocal`对`conn`这个非线程安全的
“状态”进行改造：

线程安全：

{{{class="brush: java" title="TopicDao.java"
import java.sql.Connection;
import java.sql.Statement;
public class TopicDao {
	// 使用ThreadLocal保存Connection变量
	private static ThreadLocal connThreadLocal = new ThreadLocal();
	
	public static Connection getConnection() {
		// 如果connThreadLocal没有本线程对应的Connection
		// 创建一个新的Connection，并将其保存到线程本地变量中。
		if (connThreadLocal.get() == null) {
			Connection conn = ConnectionManager.getConnection();
			connThreadLocal.set(conn);
			return conn;
		}else{
			return connThreadLocal.get();//③直接返回线程本地变量
		}
	}

	public void addTopic() {
		// 从ThreadLocal中获取线程对应的Connection
		Statement stat = getConnection().createStatement();
	}
}
}}}

不同的线程在使用`TopicDao`时，先判断`connThreadLocal.get()`是否是`null`，如果是
`null`，则说明当前线程还没有对应的`Connection`对象，这时创建一个`Connection`对象
并添加到本地线程变量中；如果不为`null`，则说明当前的线程已经拥有了`Connection`
对象，直接使用就可以了。这样，就保证了不同的线程使用线程相关的`Connection`，而
不会使用其它线程的`Connection`。因此，这个`TopicDao`就可以做到singleton共享了。

当然，这个例子本身很粗糙，将`Connection`的`ThreadLocal`直接放在DAO只能做到本DAO
的多个方法共享`Connection`时不发生线程安全问题，但无法和其它DAO共用同一个
`Connection`，要做到同一事务多DAO共享同一`Connection`，必须在一个共同的外部类
使用`ThreadLocal`保存`Connection`。

== 小结 ==

`ThreadLocal`是解决线程安全问题一个很好的思路，它通过为每个线程提供一个独立的
变量副本解决了变量并发访问的冲突问题。在很多情况下，`ThreadLocal`比直接使用
`synchronized`同步机制解决线程安全问题更简单，更方便，且结果程序拥有更高的并发性
。



= 内置锁 =

`synchronized`针对一个对象加锁，如果修饰类静态方法，那锁来自于所在的类`Class`
对象。

代码执行到`synchronized`同步块里时会取得锁，而离开时（无论是正常离开还是异常）
都会放开锁。

== 重入 ==

注意内置锁的粒度是“线程”而不是“调用”。一个线程取得了锁，其他线程都不能再
取得锁。但是本线程还是可以在不同的锁代码块中执行，因为锁的粒度是线程而不是
代码块或线程。这就叫“重入”。

例如：父类的方法是`synchronized`的。子类重写了这个方法，并在方法中调用了父类：

{{{class="brush: java"
public class Widget {
	public synchronized void doSomething() {
		//... 
	}
}

public class LogginWidget extends Widget {
	public synchronized void doSomething() {
		//... 
		super.doSomething();
		//... 
	}
}
}}}

上面的代码中，如果锁的粒度是方法调用，那线程就锁死了。但因为粒度是线程，所以可以
顺利执行。


= 锁优化 =

== 处旋锁与自适应自旋 ==

== 锁消除 ==

== 锁粗化 ==

== 轻量级锁 ==

只有两个线程竞争时有用，对象头`Mark World`与线程栈相互指向来简单标记锁状态。
超过两个线程竞争时转为互斥锁。

== 偏向锁 ==

消除在没有竞争状态下的同步原语，连CAS都省了。

