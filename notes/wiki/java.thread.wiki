%title 线程基础

%toc 线程基础

= 线程 =

== 创建线程 ==

`Runnable`接口的`run`方法是要运行的逻辑。

`Thread`类实现`run`方法。方法里是执行的逻辑。`start()`方法表示启动新线程。

== 线程优先级 ==

线程的成员方法`setPriority`。如设置当前线程的优先级为普通：

{{{class="brush: java"
Thread.currentThread.setPriority(Thread.NORNAL_PRIORITY)
}}}

可用优先级：

* NORMAL_PRIORITY
* MIN_PRIORITY
* MAX_PRIORITY
* 等……

== 守护线程 ==

分为“普通线程”和“守护线程”，区别是如果还有普通线程没有执行完毕，JVM是关不掉的。

普通线程创建的线程默认都是普通线程，除非用`setDaemon(true)`指定：

{{{class="brush: java"
Thread t1 = new Thread(runnable);
t1.setDaemon(true);
t1.start();
}}}


== 多个线程相互协调 ==

=== sleep、yield、join ===

暂停线程：`Thread.sleep()`

让出CPU：`Thread.yield()`

给其他线程执行的机会，如：循环处理多个记录的时候每个循环里`yield`一下，或阻塞
在IO时`yield`一下。

等待其他线程完毕：`t1.join()`

当前的线程停下，等这个`t1`的线程执行完了以后再执行当前线程。

=== 中断 ===

对一个线程发出停止信号，如：`t1.interrupted()`要求线程`t1`停止。

这样`t1`的执行就会抛出`InterruptedException`异常，它是受检查异常，表示当前线程
被其他线程打断。如下面的代码收到异常后就`break`了，那么线程就中断了：

{{{class="brush: java"
class T1 extends Thread {
	while(true) {
		try { 
			/* do something */ 
		} catch (InterruptedException e) { 
			break; 
		}
	}
}
}}}

如果去掉上面的`break`那线程就中断不了了。

执行线程并中断的过程如下：

{{{class="brush: java"
T1 t1 = new T1();
t1.start();
t1.join();
t1.interrupt();
}}}


== 线程协作 ==

每个对象都有`wait`与`notify`和`notifyAll`方法，选一个对象作为标志来同步：

＊ 以对象`o`为标志，当前线程停止，让给其他线程执行：

{{{class="brush: java"
synchronized { o.wait(); } //当前线程停止，等待唤醒。
}}}

这样当前线程就不会再醒过来，除非其他线程里调用对象`o`的`nodify`或是`nodifyAll`
方法：

{{{class="brush: java"
synchronized { o.notifyAll(); } // 唤醒所有以o为标志等待的线程
}}}





= 本地线程变量 =

`ThreadLocal`类给每个线程都准备一个资源的副本。保证每个资源只有当前线程可以
访问。

`ThreadLocal`对象不能简单地赋值就完了。因为它管理的每个线程的内容都要初始化，
所以它每次都会调用自己的`initialValue()`方法。重写这个方法可以完成每个线程的
初始化。

{{{class="brush: java"
private static ThreadLocal<List<String>> threadLod =
	new ThreadLocal<List<String>>() {
		protected List<String> initialValue() {
			return new ArrayList<String>();
		}
	}
}}}





= 内置锁 =

`synchronized`针对一个对象加锁，如果修饰类静态方法，那锁来自于所在的类`Class`
对象。

代码执行到`synchronized`同步块里时会取得锁，而离开时（无论是正常离开还是异常）
都会放开锁。

== 重入 ==

注意内置锁的粒度是“线程”而不是“调用”。一个线程取得了锁，其他线程都不能再
取得锁。但是本线程还是可以在不同的锁代码块中执行，因为锁的粒度是线程而不是
代码块或线程。这就叫“重入”。

例如：父类的方法是`synchronized`的。子类重写了这个方法，并在方法中调用了父类：

{{{class="brush: java"
public class Widget {
	public synchronized void doSomething() {
		//... 
	}
}

public class LogginWidget extends Widget {
	public synchronized void doSomething() {
		//... 
		super.doSomething();
		//... 
	}
}
}}}

上面的代码中，如果锁的粒度是方法调用，那线程就锁死了。但因为粒度是线程，所以可以
顺利执行。

