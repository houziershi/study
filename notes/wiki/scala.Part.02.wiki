%title Part II

%toc Part II


= 动态成员 =

静态类型不光是变量类型是确定的，还有比如在使用`qual.sel`时，`sel` 这个属性或是
方法（Scala的访问一致性，属性和方法有时候并没有那么大的区别）必须在`qual`的
类型中声明了的。

Scala 思考再三还是加入了 Dynamic Types，这个特性在Scala 2.9中是试验性的，
必须用`-Xexperimental`进行开启，到了 Scala 2.10.0 中，开启方式有两种：

* 代码中有`import scala.language.dynamics`
* 代码中不引入，但编译时加`-language:dynamics`选项。

虽然Scala 2.10.0加进了Dynamic Types特性，但Scala仍然是静态类型的语言，因为在
编译器同样会检查多出来的类型。

有了Dynamic Types之后，Scala又可更DSL了，方法名的动态上可以让它随时包括深刻的
业务含义。相比Java的DSL的能力就太逊了，我们几乎无法在Java面前提DSL这回事。

通俗点讲动态类型的类必须继承自`Dynamic`。所有的变化就在下面这四个方法中：

* `selectDynamic`
* `updateDynamic`
* `applyDynamic`
* `applyDynamicNamed`

说明：

* 当使用`qual.sel`，而`Qual`类未定义`sel`属性或方法时，
会调用`selectDynamic(method: String)`方法。
* 当`qual.name = "Unmi"`时会调用类似`updateDynamic(method: String)(args: Any)`
这样的方法。
* 还有` applyDynamic`，`applyDynamicNamed`这两个方法的自动调用。

看个完整的例子，我不打算把上面四个方法的应用规则分开来演示：

{{{class="brush: scala"	
import scala.language.dynamics
 
class Person extends Dynamic{
	def selectDynamic(method: String){
		println(s"selectDynamic->$method called\n")
	}

	def applyDynamic(method: String)(args: Any*){
		println(s"applyDynamic->$method called, args: $args\n")
	}

	def updateDynamic(method: String)(args: Any){
		println(s"updateDynamic->$method called, args: $args\n")
	}

	def applyDynamicNamed(method: String)(args: (String, Any)*) {
		println(s"applyDynamicNamed->$method called, args: $args")
		for((key, value) <- args){
			println(s"key: $key, value: $value")
		}
	}
}
 
val p = new Person
 
//calll selectDynamic
p.sayHello
//call applyDynamic
p.config("Hello","Unmi")
//call updateDynamic
p.products = ("iPhone","Nexus")
//call applyDynamicNamed
p.showInfo(screenName="Unmi", email="fantasia@sina.com") 
}}}

上面对`p`的每一个调用都说明了会委派给哪个动态方法，执行结果输出是：

{{{class="brush: scala"
selectDynamic->sayHello called
 
applyDynamic->config called, args: WrappedArray(Hello, Unmi)
 
updateDynamic->products called, args: (iPhone,Nexus)
 
applyDynamicNamed->showInfo called, args:
									WrappedArray((screenName,Unmi), (email,fantasia@sina.com))
key: screenName, value: Unmi
key: email, value: fantasia@sina.com
}}}

现在来看发生了什么，`Person`继承自`Dynamic`，并且有引入
`scala.language.dynamics`。对`p`调用的方法(属性)都不存在，但是都调用到了正常的
动态方法。所以仍然要对这四个动态方法(确切的讲是四种类型的方法，因为比如你可以
		定义多个不同的`updateDynamic`方法，其余三个也同此) 分别加以说明。

== selectDynamic ==

在调用找不到了无参方法时，会去寻找它，调用效果如下：

`p.sayHello`也可以写成`p.selectDynamic("sayHello")`。也就是说编译器在看到
`p.sayHello`调用会根据`selectDynamic(method: String)`。相当于创建了方法
`def sayHello = .......`，也就是把动态方法`selectDynamic(method: String)`换成
`sayHello`。所以说Scala的`Dynamic`类中的`xxxDynamic`方法相当是模板方法。

`applyDynamic`，`updateDynamic`和`applyDynamicNamed`这三个方法第二个括号中的
参数类型，或个数需根据实际应用来定。这四个动态方法的第一个括号中的参数都是
动态调用时的方法名。

== applyDynamic ==

在进行有参数的方法调用时，会去找寻它，调用效果如下：

`p.config("Hello", "Unmi")`可以写成`p.applyDynamic("config")("Hello", "Unmi")`

还是这么理解: 把这个动态方法定义的方法名和第一个括号与参数替换成调用的方法名
就知道怎么回事，例如把：

`def applyDynamic(method: String)(args: Any*)`中的`applyDynamic(method: String)`
替换成被调用方法名`config`，就是：

{{{class="brush: scala"
def config(args: Any*)    //p.config("Hello", "Unmi") 要调用的就是这么个方法
}}}

所以第二个括号中的参数由你自己来定，比如说想这么调用`p.config("Hello", 100, 30)`
，那么你可的动态方法可以这么定义：

{{{class="brush: scala"
def applyDynamic(method: String) (greeting: String, high: Int, low: Int) {
	// ...... 
}
}}}

这个规则同样适用于`updateDynamic`和`applyDynamicNamed`这两个方法。

== updateDynamic ==

等号赋值操作时会调用`updateDynamic`方法，调用效果如下：

{{{class="brush: scala"
p.products = ("iPhone", "Nexus")
}}}

可写成：

{{{class="brush: scala"
p.updateDynamic("products")(("iPhone", "Nexus"))
}}}

按照同样的理解方法，相当于`Person`中定义了`def products(args: Any)`方法。

== applyDynamicNamed ==

同样是`apply`开头，所以这个方法是对`applyDynamic`方法的补充，即使没有
`applyDynamicNamed`，单用`applyDynamic`也能达成我们的要求。

`applyDynamicNamed` 只是让你用命名参数调用时方便，也就是像：

{{{class="brush: scala"
p.showInfo(screenName="Unmi", email="fantasia@sina.com") 
}}}

这样用命名参数的方式来调用动态方法时会调用`updateDynamicNamed`方法。有了这个方法
在命名传递参数就方便处理`key/value`值。

这四个方法在一个动态类中只能分别定义一个版本，否则会产生二义性，这和普通方法的
重载不一样的。柯里化后的函数第二个括号中的参数可根据实际调用来定义，定义成
`(args: Any*)`可包打天下。


= 控制抽象 =

== 可复用的代码 ==

所有的函数都被分割成通用部分（它们在每次函数调用中都相同）以及非通用部分（在不同
的函数调用中可能会变化）。通用部分是函数体，而非通用部分必须由参数提供。

当你把函数值用做参数时，算法的非通用部分就是它代表的某些其它算法。在这种函数的
每一次调用中，你都可以把不同的函数值作为参数传入，于是被调用函数将在每次选用
参数的时候调用传入的函数值。这种高阶函数（higher-order function）带其它函数做
参数的函数提供了机会去组织和简化代码。

例子。一个工具类，提供了很多查找文件的方法，有根据文件结尾的、文件名是否包含
指定字串的、文件名是否匹配正则的：

{{{class="brush: scala"
  object FileMatcher {

    // private method, get file name list in current dir
    private def filesHere = (new java.io.File(".")).listFiles

    // by file name end with string
    def filesEnding(query: String) =
      for (file <- filesHere; if file.getName.endsWith(query))
        yield file
                     
    // by file name end include string
    def filesContaining(query: String) =
      for (file <- filesHere; if file.getName.contains(query))
        yield file
                   
    // by file name match regex
    def filesRegex(query: String) =
      for (file <- filesHere; if file.getName.matches(query))
        yield file
  } 
}}}

如果在Java中对应这种情况，大家应该都知道如何提炼接口来重用代码，这里就不啰嗦了。

如果是在某些动态语言中，要提炼一个工具方法提炼出共用的部分，根据传入不同`method`
作为参数也匹配也很方便，可以直接把代码“拼接”起来：

{{{class="brush: scala" 
  def filesMatching(query: String, method) =
    for (file <- filesHere; if file.getName.method(query))
      yield file
}}}

不过Scala不是动态语言，不能这么拼接。虽然不能把方法名作为参数传递，但可以通过
字面量在运行时产生对应的函数值：

{{{class="brush: scala"
  def filesMatching(
    query: String,
    matcher: (String, String) => Boolean
  ) = {
    for (file <- filesHere; if matcher(file.getName, query))
      yield file
  } 
}}}

字面量只说明了函数的类型是`(String, String) => Boolean`，不用关内部逻辑的。现在
已经有了一个`filesMatching`方法来处理共同的逻辑，三个具体的匹配方法只要调用它
就行了：

{{{class="brush: scala"
  def filesEnding(query: String) =
    filesMatching(query, _.endsWith(_))

  def filesContaining(query: String) =
    filesMatching(query, _.contains(_))

  def filesRegex(query: String) =
    filesMatching(query, _.matches(_)) 
}}}

上面的代码可能太抽象了，加上参数表和参数类型可以更加好理解一些：

{{{class="brush: scala"
  // _.endsWith(_)
  (fileName: String, query: String) => fileName.endsWith(query)
  
  // _.contains(_)
  (fileName: String, query: String) => fileName.contains(query))
  
  // _.matches(_)
  (fileName: String, query: String) => fileName.matches(query))
}}}

代码已经被简化了，但它实际还能更短。注意到`query`传递给了方法`filesMatching`，
但`filesMatching`根本用不着这个参数，只是为了把它传回给传入的`matcher`函数。

所以在这里可以直接把参数`query`绑定到函数字面量中，这样`fileMacthing`方法就不要
`query`这个参数了。 

{{{class="brush: scala"
  object FileMatcher {
    private def filesHere = (new java.io.File(".")).listFiles

    private def filesMatching(matcher: String => Boolean) =
      for (file <- filesHere; if matcher(file.getName))
        yield file
  
    def filesEnding(query: String) =
      filesMatching(_.endsWith(query))
  
    def filesContaining(query: String) =
      filesMatching(_.contains(query))
  
    def filesRegex(query: String) =
      filesMatching(_.matches(query))
  } 
}}}

== 简化客户端代码 ==

高阶函数可以提供更加强大的API，让客户的代码写起来更加简单。

比如List中的高阶函数`exists`方法已经提供了遍历整个集合的抽象，用户只要把判断符合
的函数传入就可以了。下面的两个例子非常简单地实现了检查是否存在负数和是否存在奇数
两个方法：

{{{class="brush: scala"
scala> def containsNeg(nums: List[Int]) = nums.exists(_ < 0)
containsNeg: (nums: List[Int])Boolean

scala> def containsOdd(nums: List[Int]) = nums.exists(_ % 2 == 1)
containsOdd: (nums: List[Int])Boolean
 
scala> List(1, 2, 3, 4)
res1: List[Int] = List(1, 2, 3, 4)

scala> containsNeg(res1)
res3: Boolean = false

scala> containsOdd(res1)
res4: Boolean = true
}}}

如果没有高阶函数`exists`，那就要自己写循环的逻辑，就会有很多重复的代码：

{{{class="brush: scala"
  def containsNeg(nums: List[Int]): Boolean = {
    var exists = false
    for (num <- nums)
      if (num < 0)
        exists = true
    exists
  }
  
  def containsOdd(nums: List[Int]): Boolean = {
    var exists = false
    for (num <- nums)
      if (num % 2 == 1)
        exists = true
    exists
  } 
}}}


== 柯里化（Currying） ==  

理解柯里化可以帮助理解如何建立自己的控制结构。柯里化就是一个函数有多个参数列表。

普通的函数，实现了两个Int型参数，x和y的加法：

{{{class="brush: scala"
  scala> def plainOldSum(x: Int, y: Int) = x + y
  plainOldSum: (Int,Int)Int

  scala> plainOldSum(1, 2)
  res4: Int = 3 
}}}

curry化后的同一个函数，两个列表的各一个参数：

{{{class="brush: scala"
  scala> def curriedSum(x: Int)(y: Int) = x + y
  curriedSum: (Int)(Int)Int

  scala> curriedSum(1)(2)
  res5: Int = 3 
}}}

实际上背靠背地调用了两个传统函数。第一个函数调用带单个的名为`x`的`Int`参数，并
返回第二个函数的函数值。第二个函数带`Int`参数`y`。下面的名为`first`的函数实质上
执行了`curriedSum`的第一个传统函数调用会做的事情：

{{{class="brush: scala"
  scala> def first(x: Int) = (y: Int) => x + y
  first: (Int)(Int) => Int 
}}}

调用第一个函数并传入1——会产生第二个函数：

{{{class="brush: scala"
  scala> val second = first(1)
  second: (Int) => Int = <function> 
}}}

从上面的结果可以看出我们得到的结果是一个函数，并把这个函数赋值给了变量`second`。

通过`second`调用第二个函数传入参数2产生结果：

{{{class="brush: scala"
  scala> second(2)
  res6: Int = 3 
}}}

`first`和`second`函数只演示连接在`curriedSum`函数上的那两个函数，并不直接连接在
`curriedSum`函数上的那两个函数。但我们仍然有一个方式获得实际指向`curriedSum`的
“第二个”函数的引用。你可以用偏应用函数表达式方式，把占位符标注用在`curriedSum`里
，如：

{{{class="brush: scala"
  scala> val onePlus = curriedSum(1)_
  onePlus: (Int) => Int = <function> 
}}}

之前说过，当占位符标注用在传统方法上时，如`println _`，你必须在名称和下划线之间
留一个空格。不然编译器会误认为是要调用名为`println_`的函数。而在这个例子里不需要
，因为`println_`是Scala里合法的标识符，`curriedSum(1)_`不是合法的标识符，所以会
被解释为`curriedSum(1)`与占位符`_`。

现在得到了指向一个函数的引用，这个函数在被调用的时候，传入`Int`参数加一并返回
结果：

{{{class="brush: scala"
  scala> onePlus(2)
  res7: Int = 3 
}}}

由于第二个函数的参数已经有了（传入的是2），现在再用参数2调用第一个函数也能有结果
出来：

{{{class="brush: scala"
  scala> val twoPlus = curriedSum(2)_
  twoPlus: (Int) => Int = <function>

  scala> twoPlus(2)
  res8: Int = 4 
}}}



== 编写新的控制结构 ==

在拥有头等函数的编程语言中，可以在方法中以函数作为参数创造自己的控制结构。

比如有个“重复操作”的方法，它可以把任何操作重复执行两次：

{{{class="brush: scala"
  scala> def twice(op: Double => Double, x: Double) = op(op(x))
  twice: ((Double) => Double,Double)Double

  scala> twice(_ + 1, 5)
  res9: Double = 7.0 
}}}

如果在工作中曾经遇到重复操作两次`(Double) => Double`类型函数的操作的话，这样就把
一个控制结构给抽象出来了。

再考虑一个常用的工作流程：打开一个资源，对它进行操作，然后关闭资源。你可以使用
如下的方法将其捕获并放入控制抽象：

{{{class="brush: scala"
  def withPrintWriter(file: File, op: PrintWriter => Unit) {
    val writer = new PrintWriter(file)
    try {
      op(writer)
    } finally {
      writer.close()
    }
  } 
}}}

以后要使用的时候就只要传入要处理的文件和处理的方法就行了，打开一个资源和关闭资源
都已经在高阶函数中被抽象出来了：

{{{class="brush: scala"
  withPrintWriter(
    new File("date.txt"),
    writer => writer.println(new java.util.Date)
  ) 
}}}

这个技巧被称为贷出模式（loan pattern），因为控制抽象函数，如`withPrintWriter`，
打开了资源并“贷出”给函数。当函数完成的时候，它发出信号说明它不再需要“借”的资源。
于是资源被关闭在`finally`块中，以确信其确实被关闭，而忽略函数是正常结束返回还是
抛出了异常。

让客户代码看上去更像内建控制结构的一种方式是使用大括号代替小括号包围参数列表。
Scala的任何方法调用，如果你确实只传入一个参数，就能可选地使用大括号替代小括号
包围参数：

{{{class="brush: scala"
  scala> println("Hello, world!")
  Hello, world!
  
  scala> println { "Hello, world!" }
  Hello, world!  
}}}

这个大括号技巧仅在你传入一个参数时有效，多个参数只能用小括号：

{{{class="brush: scala"
  scala> val g = "Hello, world!"
  g: java.lang.String = Hello, world!
  
  scala> g.substring(7, 9)
  res12: java.lang.String = wo 

  scala> g.substring { 7, 9 }
  <console>:1: error: ';' expected but ',' found.
         g.substring { 7, 9 }
                        ^ 
}}}

以前面例子里定义的`withPrintWriter`方法举例。在它最近的形式里，`withPrintWriter`
带了两个参数，因此你不能使用大括号。虽然如此，因为传递给`withPrintWriter`的函数
是列表的最后一个参数，你可以使用curry化把第一个参数，`File`拖入分离的参数列表。
这将使函数仅剩下列表的第二个参数作为唯一的参数：

{{{class="brush: scala"
  def withPrintWriter(file: File)(op: PrintWriter => Unit) {
    val writer = new PrintWriter(file)
    try {
      op(writer)
    } finally {
      writer.close()
    }
  } 
}}}

可以用更赏心悦目的语法格式调用这个方法：

{{{class="brush: scala"
  val file = new File("date.txt")

  withPrintWriter(file) {
    writer => writer.println(new java.util.Date)
  } 
}}}

第一个参数列表，包含了一个File参数，被写成包围在小括号中。第二个参数列表，包含了
一个函数参数，被包围在大括号中。


== 传名参数 ==

上节展示的`withPrintWriter`方法不同于语言的内建控制结构，如`if`和`while`，在于
大括号之间的代码带了参数。`withPrintWriter`方法需要一个类型为`PrintWriter`的参数
。这个参数以`writer =>`方式显示出来：

{{{class="brush: scala"
  withPrintWriter(file) {
    writer => writer.println(new java.util.Date)
  } 
}}}

然而如果你想要实现某些更像if或while的东西，根本没有值要传入大括号之间的代码，
那该怎么做呢？为了解决这种情况，Scala提供了传名参数。

为了举一个有现实意义的例子：虽然Scala提供了它自己的`assert`，但是用户想自己实现
一个称为`myAssert`的断言架构。

`myAssert`函数将带一个函数值做输入并参考一个标志位来决定该做什么。如果标志位被
设置了，`myAssert`将调用传入的函数并证实其返回`true`。如果标志位被关闭了，
`myAssert`将安静地什么都不做。 如果没有传名参数，你可以这样写`myAssert`：

{{{class="brush: scala"
  var assertionsEnabled = true

  def myAssert(predicate: () => Boolean) =
    if (assertionsEnabled && !predicate())
      throw new AssertionError 
}}}

用函数字面量的简写方式可以让代码短很多。但函数字面量的简写方式只能用在有参数的
情况下，用占位符`_`来代替参数。没有参数也就不能用函数了面量的简写形式。

所以说现在不爽的地方是虽然用不到参数，但调用时却不能省略`() =>`：

{{{class="brush: scala"
  myAssert(() => 5 > 3) 

  myAssert(5 > 3) // Won't work, because missing () =>  
}}}

传名函数恰好为了实现你的愿望而出现。要实现一个传名函数，要定义参数的类型开始于
`=>`而不是`() =>`。如，改`() => Boolean`为`=> Boolean`：

{{{class="brush: scala"
  def byNameAssert(predicate: => Boolean) =
    if (assertionsEnabled && !predicate)
      throw new AssertionError 
}}}

现在可以省略了，看起来像语言内建的控制结构一样：

{{{class="brush: scala"
  byNameAssert(5 > 3) 
}}}

传名类型中，空的参数列表`()`被省略，它仅在参数中被允许。没有什么传名变量或
传名字段这样的东西。 

对于`myAssert`，我们费了这么大的力气，只是为了让函数字面量看起来像表达式，那
为什么不直接用`Boolean`变量作为参数呢？

{{{class="brush: scala"
  def boolAssert(predicate: Boolean) =
    if (assertionsEnabled && !predicate)
      throw new AssertionError 
}}}

当然这种格式同样合法，并且使用这个版本`boolAssert`的代码看上去仍然与前面的一样：

{{{class="brush: scala"
  boolAssert(5 > 3) 
}}}

虽然如此，这两种方式之间存在一个非常重要的差别须指出：表达式会在传入参数前先被
执行。

所以在上面的例子中，如果断言被禁用，你会看到`boolAssert`括号里的表达式的某些
副作用，而`byNameAssert`却没有。例如，如果断言被禁用，`boolAssert`的例子里尝试
对`x / 0 == 0`的断言将产生一个异常：
                    
{{{class="brush: scala"
  scala> var assertionsEnabled = false
  assertionsEnabled: Boolean = false

  scala> boolAssert(x / 0 == 0)
  java.lang.ArithmeticException: / by zero
  	   at .<init>(<console>:8)
          at .<clinit>(<console>)
          at RequestResult$.<init>(<console>:3)
          at RequestResult$.<clinit>(<console>)...
}}}

但在`byNameAssert`的例子里尝试同样代码的断言将不产生异常：

{{{class="brush: scala"
  scala> byNameAssert(x / 0 == 0) 
}}}



= 组合与继承 =


== 定制一个二维布局库 ==

作为本章运行的例子，我们将创造一个制造和渲染二维布局元素的库。每个元素将代表一个
填充字符的长方形。方便起见，库将提供名为`elem`的工厂方法来通过传入的数据构造新的
元素。例如，你将能通过工厂方法采用下面的写法创建带有字串的元素：

{{{class="brush: scala"
  elem(s: String): Element 
}}}

元素将以名为`Element`的类型为模型。你将能在元素上调用`above`或`beside`，把另一个
元素放在当前元素的右边或是上边：

{{{class="brush: scala" 
  val column1 = elem("hello") above elem("***")
  val column2 = elem("***") above elem("world")
  column1 beside column2
}}}

打印这个表达式的结果将是：

{{{class="brush: scala" 
  hello ***  
   *** world
}}}

== 抽象类 ==

=== abstract声明抽象类 ===

布局元素名为`Element`，存放的文本内容类型为`Array[String]`。提供方法`contents`
取得存放的文本内容，但没有定义实现方式，所以这个类是抽象类，要加上`abstract`
关键字：

{{{class="brush: scala"
  abstract class Element {
    def contents: Array[String]
  } 
}}}

=== 抽象方法 ===

注意：类`Element`的`contents`方法并没带有`abstract`修饰符。不像Java，方法的声明
中不需要（也不允许）抽象修饰符。如果方法没有实现，它就是抽象的。

另一个术语用法需要分辨声明（declaration）和定义（definition）。类`Element`声明了
抽象方法`contents`，但当前没有定义具体方法。

=== 抽象字段 ===

{{{class="brush: scala"
abstract class Person {
	val id: Int
	val Name: String
}}}

这两个字段并没有生成在对应的Java类中，产生的只有对应的方法：

* `val`只有抽象`getter`方法。
* `var`有抽象的`getter`与`setter`方法。

实现类要提供具体的字段，对于抽象的字段不用加`abstract`：

{{{class="brush: scala"
class Employee(val: id: Int) extends Person {
	var name = ""
}
}}}

实现类可以是一个匿名类：

{{{class="brush: scala"
val fred = new Person {
	val id = 1729
	var name = "Fred"
}
}}}

== 定义无参数方法 ==

添加显示宽度和高度的方法：`height`方法返回`contents`里的行数。`width`方法返回
第一行的长度，或如果元素没有行记录，返回零。（也就是说你不能定义一个高度为零但
宽度不为零的元素。）

{{{class="brush: scala"
  abstract class Element {
    def contents: Array[String]
    def height: Int = contents.length
    def width: Int = if (height == 0) 0 else contents(0).length
  } 
}}}

三个方法没一个有参数列表，甚至连个空列表都没有。如：

{{{class="brush: scala"
  def width(): Int
  // 省略括号
  def width: Int 
}}}

推荐的惯例是在没有参数并且方法仅通过读含有对象的方式访问可变状态（专指其不改变
可变状态）时使用无参数方法。这样感觉上就和只读字段一样，其实也可以选择把`width`
和`height`作为字段而不是方法来实现，只要简单地在每个实现里把`def`修改成`val`
即可：

{{{class="brush: scala" 
  abstract class Element {
    def contents: Array[String]
    val height = contents.length
    val width = 
      if (height == 0) 0 else contents(0).length
  }
}}}

两组定义从客户的观点来看是完全相同的。唯一的差别是字段的访问或许稍微比方法调用要
快，因为字段值在类被初始化的时候被预计算，而方法调用在每次调用的时候都要计算。

换句话说，字段在每个`Element`实例上需要更多的内存空间。因此类的使用概况，属性
表达成字段还是方法更好，决定了其实现，并且这个概况还可以随时改变。

重点是`Element`类的客户不应在其内部实现改变的时候受影响。

特别是如果类的字段变成了访问函数，且访问函数是纯的，就是说它没有副作用并且
不依赖于可变状态，那么类`Element`的客户不需要被重写。客户都不应该需要关心这些。

目前为止一切良好。但仍然有些琐碎的复杂的东西要去做以协同Java处理事情的方式。问题
在于Java没有实现统一访问原则。因此Java里是`string.length()`，不是`string.length`
（尽管是`array.length`，不是`array.length()`）。不用说，这让人很困惑。

为了在这道缺口上架一座桥梁，Scala在遇到混合了无参数和空括号方法的情况时很大度。
特别是，你可以用空括号方法重载无参数方法，并且反之亦可。你还可以在调用任何不带
参数的方法时省略空的括号。例如，下面两行在Scala里都是合法的：

{{{class="brush: scala" 
  Array(1, 2, 3).toString
  "abc".length
}}}

原则上Scala的函数调用中可以省略所有的空括号。然而，在调用的方法表达的超过其接收
调用者实例的属性时，推荐仍然写一对空的括号。例如，如果方法执行了I/O，或写入
可重新赋值的变量（var），或读出不是接受调用者的字段的var，无论是直接的还是非直接
的通过使用可变实例，那么空括号是合适的。这种方式是让参数列表扮演一个可见的线索
说明某些有趣的计算正通过调用被触发。例如：

{{{class="brush: scala" 
  "hello".length  // no () because no side-effect
  println()       // better to not drop the ()
}}}

总结起来，Scala里定义不带参数也没有副作用的方法为无参数方法，也就是说，省略空的
括号，是鼓励的风格。另一方面，永远不要定义没有括号的带副作用的方法，因为那样的话
方法调用看上去会像选择一个字段。这样你的客户看到了副作用会很奇怪。相同地，当你
调用带副作用的函数，请确信写这个调用的时候包括了空的括号。另一种考虑这个问题的
方式是，如果你调用的函数执行了操作，使用括号，但如果仅提供了对某个属性的访问，
省略括号。


== 扩展类 ==

实例化一个元素，我们需要创建扩展了`Element`并实现抽象的`contents`方法的子类。

{{{class="brush: scala" 
  class ArrayElement(conts: Array[String]) extends Element {
    def contents: Array[String] = conts
  }
}}}

这种`extends`子句有两个效果：使类`ArrayElement`从类`Element`继承所有非私有的成员
，并且使`ArrayElement`成为`Element`的子类型。由于`ArrayElement`扩展了`Element`，
类`ArrayElement`被称为类`Element`的子类。反过来，`Element`是`ArrayElement`的超类
。

如果你省略`extends`子句，Scala编译器隐式地假设你的类扩展自`scala.AnyRef`，在Java
平台上与`java.lang.Object`一致。因此，类`Element`隐式地扩展了类`AnyRef`。

`ArrayElement`的`contents`方法实现了类`Element`的抽象方法`contents`：

{{{class="brush: scala" 
  scala> val ae = new ArrayElement(Array("hello", "world"))
  ae: ArrayElement = ArrayElement@d94e60

  scala> ae.width
  res1: Int = 5
}}}

子类型化（subtyping）是指子类的值可以被用在需要其超类的值的任何地方。例如：

{{{class="brush: scala" 
  val e: Element = new ArrayElement(Array("hello"))
}}}

如果子类中的字段与超类同名，或是子类的中的方法名称和参数与超类类完全一样，就会
覆盖（override）超类中的版本。而且Scala里强制如果覆盖了就一定要加上`override`
修饰符。

== 重写方法和字段 ==

=== 命名空间 ===

Java为定义准备了四个命名空间：字段，方法，类型和包。

而Scala仅有两个,与Java的四个命名空间相对：

* 值（字段，方法，包还有单例对象）
* 类型（类和特质名）

Scala把字段和方法放进同一个命名空间的理由很清楚，因为这样你就可以使用`val`重重写
无参数的方法，这种你在Java里做不到的事情。

字段和方法属于相同的命名空间。这使得字段重写无参数方法成为可能。比如说，你可以
改变类`ArrayElement`中`contents`的实现，从一个方法变为一个字段，而无需修改类
`Element`中`contents`的抽象方法定义：

{{{class="brush: scala" 
  class ArrayElement(conts: Array[String]) extends Element {
    val contents: Array[String] = conts
  }
}}}

这个`ArrayElement`的版本里，字段`contents`（用`val`定义）完美地实现了类`Element`
里的无参数方法`contents`（用`def`定义）。 

另一方面，Scala里禁止在同一个类里用同样的名称定义字段和方法，而在Java里这样做
被允许。例如，下面的Java类能够很好地编译：

{{{class="brush: scala" 
  // This is Java
  class CompilesFine {
    private int f = 0;
    public int f() {
      return 1;
    }
  }
}}}

但是相应的Scala类将不能编译：

{{{class="brush: scala" 

  class WontCompile {
    private var f = 0 // Won't compile, because a field 
    def f = 1         // and method have the same name
  }

}}}


如果要调试实例的构造顺序，可在编译加上参数`-Xcheckinit`。这样在方法末初始化字段
时会抛出异常。

=== 使用override修饰符 ===

考虑一下这样的场景：

基类和子类是不同的人维护的。原来基类里没有`add`方法，所以子类里加上了。后来
基类里也加上了`add`方法，但维护子类的人不知道。这样的规定是为了防止“脆基类”问题
。

所以Scala里`override`有强制的规定：

* 如果实现了抽象成员，加不加随便。
* 如果重载了具体实现，就一定要加。
* 没有重载就绝不能加。

这样起码保证了维护子类的人知道自己会覆盖超类的方法。


=== 不可重写 final ===

Scala中字段与方法都可以用`final`修饰为不可重写（因为Scala的字段也是可以重写为
方法的）。注意这与Java不一样，Java里`final`字段表示不可改变，而Scala里已经有
`val`表示不可改变了。


=== 重写限制 ===

概括：

* `def`只能重写另一个`def`
* `val`只能重写另一个`val`与无参`def`
* `var`只能重写另一个抽象的`var`

详述：


|           | def                                            | val                                           | var               |
|-----------|------------------------------------------------|-----------------------------------------------|-------------------|
| 用val重写 | 子类有一个私有字段。<br/>重写超类的getter方法  | 超类同名的私有字段。<br/>重写超类的getter方法 | 错误              |
| 用def重写 | 同Java                                         | 错误                                          | 错误              |
| 用var重写 | 同时重写getter/setter。<br/>只重写getter会报错 | 错误                                          | 重写超类的抽象var |

在当前类中，随时可以对`getter`与`setter`重新实现`var`，但在子类中不能通过
`getter`与`setter`重新实现`var`，只能接受现有的实现。

== 类型检查和转换 ==

| Scala                   | Java                 |
|-------------------------|----------------------|
| obj.isInstanceOf[Clazz] | obj instanceof Clazz |
| obj.asInstanceOf[Clazz] | (Clazz) obj          |
| classOf[Clazz]          | Clazz.class          |
| obj.getClass            | obj.getClass         |


{{{class="brush: scala" 
val c = new C
val clazz = c.getClass              // method from java.lang.Object
val clazz2 = classOf[C]             // Scala method: classOf[C] ~ C.class
val methods = clazz.getMethods      // method from java.lang.Class<T>
}}}

类似于Java的`T.class`表达式，Scala的`classOf[T]`方法返回运行时表示的类。

* `classOf[T]`方法可以方便地取得类的相关信息。
* `obj.getClass`成员方法可以取得当前实例的类信息。

然而`classOf[T]`和`getClass`的返回结果会因为JVM的类型擦除机制而略有不同。

{{{class="brush: scala" 
scala> classOf[C]
res0: java.lang.Class[C] = class C

scala> c.getClass
res1: java.lang.Class[_] = class C
}}}

这就是下面代码的结果与预期不同:

{{{class="brush: scala" 
val xClass: Class[X] = new X().getClass //it returns Class[_], nor Class[X]

val integerClass: Class[Integer] = new Integer(5).getClass //similar error
}}}

有一些与`getClass`方法相关的待修复错误，James Moore报告的错误在2001年标记为修复
：

Scala 2.9.1版时`getClass`方法的效果：

{{{class="brush: scala" 
scala> "foo".getClass 
       res0: java.lang.Class[_ <: java.lang.String] = class java.lang.String
}}}


Back in 2009:

It would be useful if Scala were to treat the return from `getClass()` as a 
`java.lang.Class[T]` forSome `{ val T : C }` where `C` is something like the 
erasure of the static type of the expression on which getClass is called

It would let me do something like the following where I want to introspect on 
a class but shouldn't need a class instance.

I also want to limit the types of classes I want to introspect on, so I use 
`Class[_ <: Foo]`. But this prevents me from passing in a Foo class by using 
`Foo.getClass()` without a cast.

Note: regarding getClass, a possible workaround would be:

{{{class="brush: scala" 
class NiceObject[T <: AnyRef](x : T) {
  def niceClass : Class[_ <: T] = x.getClass.asInstanceOf[Class[T]]
}

implicit def toNiceObject[T <: AnyRef](x : T) = new NiceObject(x)

scala> "Hello world".niceClass                                       
res11: java.lang.Class[_ <: java.lang.String] = class java.lang.String
}}}

相比类型检查与转换，Scala更加推荐模式匹配的方式。

== 定义参数化字段 ==

`ArrayElement`类的定义。它有一个参数`conts`，其唯一目的是被复制到`contents`字段
。选择`conts`这个参数的名称只是为了让它看上去更像字段名`contents`而又不会因为
名字一样而发生实际冲突。这是一种“代码异味”，一个表明或许某些不必须的累赘和重复。

可以通过在单一的参数化字段（parametric field）定义中组合参数和字段避免：

{{{class="brush: scala" 
  class ArrayElement(val contents: Array[String]) extends Element
}}}

注意用的是`val`，所以现在拥有一个可以从类外部访问的，（不能重新赋值的）字段
`contents`。字段使用参数值初始化。等同于：

{{{class="brush: scala"
  class ArrayElement(x123: Array[String]) extends Element { 
    val contents: Array[String] = x123
  } 
}}}

同样也可以使用`var`前缀类参数，这种情况下相应的字段将能重新被赋值。还有可能添加
如`private`、`protected`或`override`这类的修饰符到这些参数化字段上，就好象
你可以在其他类成员上做的事情：

{{{class="brush: scala" 
  class Cat {
    val dangerous = false
  }
  class Tiger(
    override val dangerous: Boolean,
    private var age: Int
  ) extends Cat
}}}

Tiger的定义是以下包括重写成员`dangerous`和`private`成员`age`的类定义替代写法的
简写：

{{{class="brush: scala" 
  class Tiger(param1: Boolean, param2: Int) extends Cat {
    override val dangerous = param1
    private var age = param2
  }
}}}



== 调用超类构造器 ==

如果再要新的子类：

{{{class="brush: scala" 
  class LineElement(s: String) extends ArrayElement(Array(s)) {
    override def width = s.length
    override def height = 1
  }
}}}

由于`LineElement`扩展了`ArrayElement`，并且`ArrayElement`的构造器带一个参数
（Array[String]），LineElement需要传递一个参数到它的超类的主构造器。要调用超类
构造器，只要把你要传递的参数或参数列表放在超类名之后的括号里）即可。

=== 只有主构造器可以调用超类构造器 ===

Scala中辅助构造器不能调用超类构造器，只有主构造器可以调用超类构造器。

=== 构造顺序 ===

Scala与Java有一个共同的问题：超类的构造器会调用被子类覆盖的方法。

用动物的视力（或感知以距离）来作为例子：

* 默认动物的视力为10
* 蚂蚁的视力只有2

{{{class="brush: scala" 
class Creature {
	val range: Int = 10
	val env: Array[Int] = new array[Int](range)
}

class Ant extends Creature {
	override val range = 2
}
}}}

如果初始化`Ant`实例，过程比较复杂：

# 调用超类构造器，设置`range`为10。
# 超类构造器初始化`env`长度时要用到`range`，发现`range`被子类重写。
# 调用子类的`range`，但是子类还没有初始化，所以`range`值为`0`。
# `env`被初始化为长度为0的数组。超类构造器执行完毕。
# 子类构造器开始执行，把`range`设置为2.

解决的方案：

* `final val`声明不能覆盖，这样安全但是不灵活。
* `lazy`懒加载。安全但是影响性能。
* 预初始化。接下来就讲。

==== 预初始化 ====

用`with`代替`extends`，并给字段定义加上花括号，放在超类的构造器之前：

{{{class="brush: scala" 
class Ant {
	override val range = 2
} with Creature
}}}

由于预初始化的字段的超类构造器调用前被初始化，所以不能引用正在被构造的实例。所以
对于`this`实际指向的是正被构造的类或对象的实例，而来是被构造的实例本身。

== 多态和动态绑定 ==

创建一个新的子类，它可以按给出的长度宽度，用指定的字符填充：

{{{class="brush: scala" 
  class UniformElement(
    ch: Char, 
    override val width: Int,
    override val height: Int 
  ) extends Element {
    private val line = ch.toString * width
    def contents = Array.make(height, line)
  }
}}}

父类的变量可以存放子类的实例，就是多态的一种体现。这么多子类都可以用父类的变量来
存放：

{{{class="brush: scala" 
  val e1: Element = new ArrayElement(Array("hello", "world"))
  val ae: ArrayElement = new LineElement("hello")
  val e2: Element = ae
  val e3: Element = new UniformElement('x', 2, 3)
}}}

变量和表达式上的方法调用是动态绑定（dynamically bound）的。这意味着被调用的
实际方法实现取决于运行期实例实际的类，而不是变量或表达式的类型。

为了演示这种行为，我们会从我们的`Element`类中临时移除所有存在的成员并添加一个名
为`demo`的方法。我们会在`ArrayElement`和`LineElement`中重写`demo`，但
`UniformElement`除外：

{{{class="brush: scala" 
  abstract class Element {
    def demo() {
      println("Element's implementation invoked")
    }
  }

  class ArrayElement extends Element {
    override def demo() {
      println("ArrayElement's implementation invoked")
    }
  }

  class LineElement extends ArrayElement {
    override def demo() {
      println("LineElement's implementation invoked")
    }
  }

  // UniformElement inherits Element's demo
  class UniformElement extends Element 
}}}

如果你把这些代码输入到了解释器中，那么你就能定义这个带了一个`Element`并调用
`demo`的方法：

{{{class="brush: scala" 
  def invokeDemo(e: Element) {
    e.demo()
  }
}}}

如果你传给`invokeDemo`一个`ArrayElement`，你会看到一条消息指明`ArrayElement`的
`demo`实现被调用，尽管被调用`demo`的变量`e`的类型是`Element`： 

{{{class="brush: scala" 
  scala> invokeDemo(new ArrayElement)
  ArrayElement's implementation invoked
}}}

相同的，如果你传递`LineElement`给`invokeDemo`，你会看到一条指明`LineElement`的
`demo`实现被调用的消息：

{{{class="brush: scala" 
  scala> invokeDemo(new LineElement)
  LineElement's implementation invoked
}}}

传递`UniformElement`时的行为一眼看上去会有些可以，但是正确：

{{{class="brush: scala" 
  scala> invokeDemo(new UniformElement)
  Element's implementation invoked
}}}

因为`UniformElement`没有重写`demo`，它从它的超类`Element`继承了`demo`的实现。
因此，当实例的类是`UniformElement`时，`Element`的实现就是要调用的`demo`的正确
实现。



== 使用组合与继承 ==

组合与继承是利用其它现存类定义新类的两个方法。

如果你接下来的工作主要是代码重用，通常你应采用组合而不是继承。只有继承受脆基类
问题困扰，这种情况你可能会无意中通过改变超类而破坏了子类。

关于继承关系你可以问自己一个问题，是否它建模了一个is-a关系。你能问的另一个问题是
，是否客户想要把子类类型当作超类类型来用。



== 实现示例中的功能 ==

把一个元素放在另一个上面是指串连这两个元素的`contents`值。

{{{class="brush: scala" 
  def above(that: Element): Element =
    new ArrayElement(this.contents ++ that.contents)
}}}

操作符`++`把两个元素靠在一起，我们将创造一个新的元素，其中的每一行都来自于两个
元素的相应行的串连。

{{{class="brush: scala" 
  def beside(that: Element): Element = {
    val contents = new Array[String](this.contents.length)
    for (i <- 0 until this.contents.length) 
      contents(i) = this.contents(i) + that.contents(i)
    new ArrayElement(contents)
  }

}}}

索引数组的循环是指令式风格。这个方法可以替代缩减成一个表达式：

{{{class="brush: scala" 
  new ArrayElement(
    for (
      (line1, line2) <- this.contents zip that.contents
    ) yield line1 + line2
  )
}}}

`zip`操作符转换为一个对子的数组（可以称为`Tupele2`）。`zip`方法从它的两个参数中
拣出相应的元素并组织成对子数组。

例如，表达式：

{{{class="brush: scala" 
  Array(1, 2, 3) zip Array("a", "b")
}}}

将生成：

{{{class="brush: scala" 
  Array((1, "a"), (2, "b"))
}}}

如果两个操作数组的其中一个比另一个长，zip将舍弃余下的元素。

定义`toString`方法返回元素格式化成的字串：

{{{class="brush: scala" 
  override def toString = contents mkString "\n"
}}}

最后是这个样子：

{{{class="brush: scala" 
  abstract class Element {

    def contents: Array[String]

    def width: Int =
      if (height == 0) 0 else contents(0).length

    def height: Int = contents.length

    def above(that: Element): Element =
      new ArrayElement(this.contents ++ that.contents)

    def beside(that: Element): Element =
      new ArrayElement(
        for (
          (line1, line2) <- this.contents zip that.contents
        ) yield line1 + line2
      )

    override def toString = contents mkString "\n"
  }
}}}



== 定义工厂对象 ==

最直接的方案是创建类`Element`的伴生对象并把它做成布局元素的工厂方法。这种方式
唯一要暴露给客户的就是`Element`的类/实例组合，隐藏它的三个实现类`ArrayElement`，
`LineElement`和`UniformElement`。

{{{class="brush: scala" 
  object Element {

    def elem(contents: Array[String]): Element = 
      new ArrayElement(contents)

    def elem(chr: Char, width: Int, height: Int): Element = 
      new UniformElement(chr, width, height)

    def elem(line: String): Element = 
      new LineElement(line)
  }

}}}

这些工厂方法使得改变类`Element`的实现通过使用`elem`工厂方法实现而不用`new`操作
产新的`ArrayElement`实例成为可能。

为了不使用单例对象的名称`Element`从而化调用工厂方法，我们将在源文件引入
`Element.elem`。

换句话说，代之以在`Element`类内部使用`Element.elem`调用工厂方法，我们将引用
`Element.elem`，这样我们只要使用它们的简化名，`elem`，就可以调用工厂方法。

{{{class="brush: scala" 
  import Element.elem

  abstract class Element {

    def contents: Array[String]

    def width: Int =
      if (height == 0) 0 else contents(0).length

    def height: Int = contents.length

    def above(that: Element): Element =
      elem(this.contents ++ that.contents)

    def beside(that: Element): Element =
      elem(
        for (
          (line1, line2) <- this.contents zip that.contents
        ) yield line1 + line2
      )

    override def toString = contents mkString "\n"
  }

}}}

有了工厂方法之后，子类`ArrayElement`，`LineElement`和`UniformElement`不再需要
直接被客户访问，所以可以改成是私有的。

Scala里，你可以在类和单例对象中定义其它的类和单例对象。因此一种让`Element`的子类
私有化的方式就是把它们放在`Element`单例对象中并在那里声明它们为私有。需要的时候
，这些类将仍然能被三个`elem`工厂方法访问。

{{{class="brush: scala"   object Element {
    private class ArrayElement(
      val contents: Array[String]
    ) extends Element

    private class LineElement(s: String) extends Element {
      val contents = Array(s)
      override def width = s.length
      override def height = 1
    }

    private class UniformElement(
      ch: Char,
      override val width: Int,
      override val height: Int
    ) extends Element {
      private val line = ch.toString * width
      def contents = Array.make(height, line)
    }

    def elem(contents:  Array[String]): Element =
      new ArrayElement(contents)

    def elem(chr: Char, width: Int, height: Int): Element =
      new UniformElement(chr, width, height)

    def elem(line: String): Element =
      new LineElement(line)
  }
}}}




== 变高变宽 ==

Element的版本并不完全，因为他不允许客户把不同宽度的元素堆叠在一起，或者不同高度
的元素靠在一起。比方说，下面的表达式将不能正常工作，因为组合元素的第二行比第一行
要长：

{{{class="brush: scala" 
  new ArrayElement(Array("hello")) above 
  new ArrayElement(Array("world!"))
}}}

与之相似的，下面的表达式也不能正常工作：

{{{class="brush: scala" 

  new ArrayElement(Array("one", "two")) beside 
  new ArrayElement(Array("one"))
}}}

添加私有帮助方法`widen`通过带个宽度做参数并返回那个宽度的`Element`。`heighten`，
能在竖直方向执行同样的功能。

{{{class="brush: scala" 
  import Element.elem

  abstract class Element {
    def contents:  Array[String]

    def width: Int = contents(0).length
    def height: Int = contents.length

    def above(that: Element): Element = {
      val this1 = this widen that.width
      val that1 = that widen this.width
      elem(this1.contents ++ that1.contents)
    }

    def beside(that: Element): Element = {
      val this1 = this heighten that.height
      val that1 = that heighten this.height
      elem(
        for ((line1, line2) <- this1.contents zip that1.contents) 
        yield line1 + line2)
    }

    def widen(w: Int): Element = 
      if (w <= width) this
      else {
        val left = elem(' ', (w - width) / 2, height) 
        var right = elem(' ', w - width - left.width, height)
        left beside this beside right
      }

    def heighten(h: Int): Element = 
      if (h <= height) this
      else {
        val top = elem(' ', width, (h - height) / 2)
        var bot = elem(' ', width, h - height - top.height)
        top above this above bot
      }

    override def toString = contents mkString "\n"
  }
}}}

== 完整的示例代码 ==

写一个画给定数量边界的螺旋的程序。

{{{class="brush: scala" 
// In file compo-inherit/Spiral.scala

  import Element.elem

  object Spiral {

    val space = elem(" ")
    val corner = elem("+")

    def spiral(nEdges: Int, direction: Int): Element = {
      if (nEdges == 1)
        elem("+")
      else {
        val sp = spiral(nEdges - 1, (direction + 3) % 4)
        def verticalBar = elem('|', 1, sp.height)
        def horizontalBar = elem('-', sp.width, 1)
        if (direction == 0)
          (corner beside horizontalBar) above (sp beside space)
        else if (direction == 1)
          (sp above space) beside (corner above verticalBar)
        else if (direction == 2)
          (space beside sp) above (horizontalBar beside corner)
        else
          (verticalBar above corner) beside (space above sp)
      }
    }

    def main(args: Array[String]) {
      val nSides = args(0).toInt
      println(spiral(nSides, 0))
    }
  }
}}}



{{{class="brush: scala" 
$ scala Spiral 6    $ scala Spiral 11    $ scala Spiral 17
+-----              +----------          +----------------
|                   |                    |                
| +-+               | +------+           | +------------+ 
| + |               | |      |           | |            | 
|   |               | | +--+ |           | | +--------+ | 
+---+               | | |  | |           | | |        | | 
                    | | ++ | |           | | | +----+ | | 
                    | |    | |           | | | |    | | | 
                    | +----+ |           | | | | ++ | | | 
                    |        |           | | | |  | | | | 
                    +--------+           | | | +--+ | | | 
                                         | | |      | | | 
                                         | | +------+ | | 
                                         | |          | | 
                                         | +----------+ | 
                                         |              | 
                                         +--------------+ 
}}}


= Scala类的层级 =

Scala里，每个类都继承自通用的名为`Any`的超类。因为所有的类都是`Any`的子类，那么
定义在`Any`中的方法就是“普遍”方法：它们可以被任何实例调用。

Scala还在层级的底端定义了`Null`和`Nothing`，主要都扮演通用的子类。例如，就像说
`Any`是所有其它类的超类，`Nothing`是所有其它类的子类。

<img src="images/scala/scala.hirtc.png" alt="scala.hirtc" />



== Scala类的概览 ==

层级的顶端是类`Any`，定义了包含下列的方法：

{{{class="brush: scala" 
  final def ==(that: Any): Boolean
  final def !=(that: Any): Boolean
  def equals(that: Any): Boolean
  def hashCode: Int
  def toString: String
}}}

类Any里的`=`和`!=`，被声明为`final`，因此它们不能在子类里面重载。实际上，`==`
总是与`equals`相同，`!=`总是与`equals`相反。因此独立的类可以通过重载`equals`方法
修改`==`或`!=`的意义。

根类`Any`有两个子类：`AnyVal`和`AnyRef`。

=== 值类型（AnyVal） ===

`AnyVal`是Scala里每个内建值类型的父类。有九个这样的值类型：`Byte`，`Short`，
`Char`，`Int`，`Long`，`Float`，`Double`，`Boolean`和`Unit`。其中的前八个对应到
Java的原始类型，它们的值在运行时表示成Java的原始值。

Scala里这些类的实例都写成字面量，不能使用`new`创造这些类的实例。值类都被定义为
即是抽象的又是`final`的，强制贯彻。因此如果你写了`new`就会出错：

{{{class="brush: scala"   
  scala> new Int
  <console>:5: error: class Int is abstract; cannot be 
  instantiated
         new Int
         ^
}}}

另一个值类型`Unit`大约对应于Java的`void`类型；被用作不返回任何有趣结果的方法的
结果类型。`Unit`只有一个实例值，被写作`()`。

值类型支持作为方法的通用的数学和布尔操作符。例如，`Int`有名为`+`和`*`的方法，
`Boolean`有名为`||`和`&&`的方法。值类型也从类`Any`继承所有的方法：

{{{class="brush: scala" 
  scala> 42 max 43
  res4: Int = 43

  scala> 42 min 43
  res5: Int = 42

  scala> 1 until 5
  res6: Range = Range(1, 2, 3, 4)

  scala> 1 to 5
  res7: Range.Inclusive = Range(1, 2, 3, 4, 5)

  scala> 3.abs
  res8: Int = 3

  scala> (-3).abs
  res9: Int = 3
}}}

值类型的空间是扁平的；所有的值类型都是`scala.AnyVal`的子类型，但是它们不是互相的
子类。代之以它们不同的值类型之间可以隐式地互相转换。例如，需要的时候，类
`scala.Int`的实例可以自动放宽（通过隐式转换）到类`scala.Long`的实例。


隐式转换还用来为值类型添加更多的功能。例如，类型`Int`支持以下所有的操作：

{{{class="brush: scala" 
  scala> 42 max 43
  res4: Int = 43

  scala> 42 min 43
  res5: Int = 42

  scala> 1 until 5
  res6: Range = Range(1, 2, 3, 4)

  scala> 1 to 5
  res7: Range.Inclusive = Range(1, 2, 3, 4, 5)

  scala> 3.abs
  res8: Int = 3

  scala> (-3).abs
  res9: Int = 3
}}}

工作原理：

方法`min`，`max`，`until`，`to`和`abs`都定义在类`scala.runtime.RichInt`里，并且
有一个从类`Int`到`RichInt`的隐式转换。当你在Int上调用没有定义在`Int`上但定义在
`RichInt`上的方法时，这个转换就被应用了：


=== 引用类型（AnyRef） ===

类`Any`的另一个子类是类`AnyRef`。这个是`Scala`里所有引用类的基类。正如前面提到的
，在Java平台上`AnyRef`实际就是类`java.lang.Object`的别名。因此Java里写的类和
`Scala`里写的都继承自`AnyRef`。

存在`AnyRef`别名代替使用`java.lang.Object`名称的理由是，Scala被设计成可以同时
工作在Java和.Net平台。在.NET平台上，`AnyRef`是`System.Object`的别名。 

可以认为`java.lang.Object`是Java平台上实现`AnyRef`的方式。因此，尽管你可以在Java
平台上的Scala程序里交换使用`Object`和`AnyRef`，推荐的风格是在任何地方都只使用
`AnyRef`。

Scala类与Java类不同在于它们还继承自一个名为`ScalaObject`的特别的记号特质。理念是
`ScalaObject`包含了Scala编译器定义和实现的方法，目的是让Scala程序的执行更有效。
到现在为止，Scala实例包含了单个方法，名为`$tag`，用于内部以提速模式匹配。



== 原始类型是如何实现的 ==

Scala以与Java同样的方式存储整数：把它当作32位的字。这对在JVM上的效率以及与Java库
的互操作性方面来说都很重要。标准的操作如加法或乘法都被实现为原始操作。然而，当
整数需要被当作（Java）对象看待的时候，Scala使用了“备份”类`java.lang.Integer`。
如在整数上调用`toString`方法或者把整数赋值给Any类型的变量时，就会这么做。

所有这些听上去都近似Java5里的自动装箱并且它们的确很像。不过有一个关键差异，Scala
里的装箱比Java里的更少看见。尝试下面的Java代码：

{{{class="brush: scala" 
  // This is Java
  boolean isEqual(int x, int y) {
    return x == y;
  }
  System.out.println(isEqual(421, 421));
}}}

当然会得到`true`。现在，把`isEqual`的参数类型变为`java.lang.Integer`（或`Object`
，结果都一样）：

{{{class="brush: scala" 
  // This is Java
  boolean isEqual(Integer x, Integer y) {
    return x == y;
  }
  System.out.println(isEqual(421, 421));
}}}

却得到了`false`！原因是数`421`被装箱了两次，因此参数`x`和`y`是两个不同的实例。

因为在引用类型上`==`表示引用相等，而`Integer`是引用类型，所以结果是`false`。这是
展示了Java不是纯面向对象语言的一个方面。我们能清楚观察到原始类型和引用类型之间的
差别。

现在在Scala里尝试同样的实验：

{{{class="brush: scala" 
  scala> def isEqual(x: Int, y: Int) = x == y
  isEqual: (Int,Int)Boolean

  scala> isEqual(421, 421)
  res10: Boolean = true

  scala> def isEqual(x: Any, y: Any) = x == y
  isEqual: (Any,Any)Boolean

  scala> isEqual(421, 421)
  res11: Boolean = true
}}}

实际上Scala里的相等操作`==`被设计为透明的参考类型代表的东西。对值类型来说，就是
自然的（数学或布尔）相等。对于引用类型，`==`被视为继承自`Object`的`equals`方法的
别名。这个方法被初始地定义为引用相等，但被许多子类重载实现它们种族的相等概念。
这也意味着Scala里你永远也不会落入Java知名的关于字串比较的陷阱。Scala里，字串比较
以其应有的方式工作：

{{{class="brush: scala" 
  scala> val x = "abcd".substring(2)
  x: java.lang.String = cd

  scala> val y = "abcd".substring(2)
  y: java.lang.String = cd

  scala> x == y
  res12: Boolean = true
}}}

Java里，`x`与`y`的比较结果将是`false`。程序员在这种情况应该用`equals`，不过它
容易被忘记。

然而，有些情况你需要使用引用相等代替用户定义的相等。

例如，某些时候效率是首要因素，你想要把某些类哈希合并（hash cons）然后通过引用
相等比较它们的实例（类实例的哈希合并是指把创建的所有实例缓存在弱集合中。然后，
一旦需要类的新实例，首先检查缓存。如果缓存中已经有一个元素等于你打算创建的，你
可以重用存在的实例。这样安排的结果是，任何以`equals()`判断相等的两个实例同样在
引用相等上判断一致。）。

为这种情况，类AnyRef定义了附加的`eq`方法，它不能被重载并且实现为引用相等（也就
是说，它表现得就像Java里对于引用类型的`==`那样）。同样也有一个`eq`的反义词，被
称为`ne`。例如：

{{{class="brush: scala" 
  scala> val x = new String("abc")
  x: java.lang.String = abc

  scala> val y = new String("abc")
  y: java.lang.String = abc

  scala> x == y
  res13: Boolean = true

  scala> x eq y
  res14: Boolean = false

  scala> x ne y
  res15: Boolean = true
}}}

== 底层类型 ==

层级的底部你看到了两个类`scala.Null`和`Scala.Nothing`。它们是用统一的方式处理
某些Scala的面向对象类型系统的“边界情况”的特殊类型。


=== Null ===

类`Null`唯一的实例是`null`值；它是每个引用类（就是说，每个继承自`AnyRef`的类）的
子类。`Null`不兼容值类型。比方说，不可把`null`值赋给整数变量：

{{{class="brush: scala" 
  scala> val i: Int = null
  <console>:4: error: type mismatch;
   found   : Null(null)
   required: Int
}}}

=== Nothing ===

类型`Nothing`在`Scala`的类层级的最底端；它是任何其它类型的子类型。然而，根本没有
这个类型的任何值。要一个没有值的类型有什么意思呢？在控制结构的try-catch中讨论过
，`Nothing`的一个用处是它标明了不正常的终止。例如Scala的标准库中的`Predef`单例
对象有一个`error`方法，如下定义：

{{{class="brush: scala" 
  def error(message: String): Nothing =
    throw new RuntimeException(message)
}}}

`error`的返回类型是`Nothing`，告诉用户方法不是正常返回的（代之以抛出了异常）。
因为`Nothing`是任何其它类型的子类，你可以非常灵活的使用像`error`这样的方法。
例如：

{{{class="brush: scala" 

  def divide(x: Int, y: Int): Int = 
    if (y != 0) x / y 
    else error("can't divide by zero")
}}}

`if`状态分支，`x / y`，类型为Int，而`else`分支，调用了`error`，类型为`Nothing`。
因为`Nothing`是`Int`的子类型，整个状态语句的类型是`Int`，正如需要的那样。

== Unit ==

`Unit`类似于Java中的`void`。`Unit`只有一个实例`()`。



= 特质（Traits） =

trait是Scala里代码复用的基础单元。特质封装了方法和字段的定义，并可以通过混入到
类中重用它们。

== 抽象与实现 ==

特质中的字段可以是抽象的也可以是抽象的。

=== 实现字段 ===

如果字段有初始值，就是已经实现的字段。

==== 字段不可被再次继承 ====

因为JVM中不可多重继承，所以特质中的字段只能作为混入类中的一个不能被子类继承的
成员。

=== 抽象字段 ===

如果字段没有初始值，就是抽象字段。它们必须被实现。

=== 抽象方法 ===

==== 默认抽象 ====

特质中没有实现的方法默认作为抽象方法，不用`abstract`修饰：

{{{class="brush: scala"
trait Logger {
	def log(msg: String)
}
}}}

==== 不用override ====

实现特质中的抽象方法不用加`override`：

{{{class="brush: scala"
class ConsoleLogger extends Logger {
	def log(msg: String) { println(msg) }
}
}}}

=== 实现方法 ===

定义，关键字`trait`：

{{{class="brush: scala"
  trait Philosophical {
    def philosophize() {
      println("I consume memory, therefore I am!")
    }
  }
}}}

==== 需要重新编译 ====

如果特质带有具体实现，那么这个特质一旦改变，所有已经混入该特质的类必须重新编译。

== 单例对象也可以扩展特质 ==

不止是类，单例对象也可以扩展特质。

== 类层级 ==

没有声明超类，因此和类一样，有个缺省的超类`AnyRef`。一旦特质被定义了，就可以使用
`with`关键字，把它混入到类中。如果这个类没有继承基类，可以直接用`extends`关键字
来混入特质：

{{{class="brush: scala"
  class Frog extends Philosophical {
    override def toString = "green"
  }
}}}

类`Frog`是`AnyRef`（`Philosophical`的超类）的子类并混入了`Philosophical`。从特质
继承的方法可以像从超类继承的方法那样使用：

{{{class="brush: scala"
  scala> val frog = new Frog
  frog: Frog = green

  scala> frog.philosophize()
  I consume memory, therefore I am!
}}}

特质同样也是类型。以下是把`Philosophical`用作类型的例子：

{{{class="brush: scala"
  scala> val phil: Philosophical = frog
  phil: Philosophical = green

  scala> phil.philosophize()
  I consume memory, therefore I am!
}}}

`phil`的类型是`Philosophical`，一个特质。因此，变量`phil`可以被初始化为任何混入
了`Philosophical`特质的类的实例。

如果想把特质混入到显式扩展超类的类里，可以用`extends`指明待扩展的超类，用`with`
混入特质：

{{{class="brush: scala"
  class Animal

  class Frog extends Animal with Philosophical {
    override def toString = "green"
  }
}}}

如果想混入多个特质，都加在`with`子句里就可以了：

{{{class="brush: scala"
  class Animal
  trait HasLegs

  class Frog extends Animal with Philosophical with HasLegs {
    override def toString = "green"
  }
}}}

目前为止你看到的例子中，类`Frog`都继承了`Philosophical`的`philosophize`实现。
或者，`Frog`也可以重载`philosophize`方法。语法与重载超类中定义的方法一样。
举例如下：

{{{class="brush: scala"
  class Animal

  class Frog extends Animal with Philosophical {
    override def toString = "green"
    override def philosophize() {
      println("It ain't easy being "+ toString +"!")
    }
  }
}}}

因为`Frog`的这个新定义仍然混入了特质`Philosophize`，你仍然可以把它当作这种类型的
变量使用。但是由于`Frog`重载了`Philosophical`的`philosophize`实现，当你调用它的
时候，你会得到新的回应：

{{{class="brush: scala"
  scala> val phrog: Philosophical = new Frog
  phrog: Philosophical = green

  scala> phrog.philosophize()
  It ain't easy being green!
}}}

== 特质继承 ==

=== 抽象方法延迟绑定 ===

如果重写了特质中的抽象方法，要加上`abstract`修饰。

特质中的方法是抽象的：

{{{class="brush: scala"
trait Logger {
	def log(msg: String)
}
}}}


在实现子类特质的时候，调用的相对父类的方法还是抽象的，所以下而的代码是编译不过
的：

{{{class="brush: scala"
trait TimestampLogger extends Logger {
	override def log(msg: String) {
		super.log(new java.util.Date() + " " + msg) // super.log()还是抽象的，错误
	}
}
}}}

声明为抽象的方法中有一个`super`调用。这种调用对于普通的类来说是非法的，因为继承
的超类是个抽象类，所以在执行时将必然失败。然而对于特质来说，这样的调用实际能够
成功。因为特质里的`super`调用是动态绑定的，特质的`super`调用将直到被混入在另一个
特质或类之后，有了具体的方法定义时才工作。

所以要加上`abstract override`，说明要继承父特质（只有特质，类里是不能这样写的）
才能实际产生作用。

{{{class="brush: scala"
trait TimestampLogger extends Logger {
	abstract override def log(msg: String) {
		super.log(new java.util.Date() + " " + msg)
	}
}
}}}

再来看一个例子：

在基类方法为抽象时情况比较复杂。比如下面这个抽象`Writer`类的抽象方法
`writeMessage()`：

{{{class="brush: scala"
abstract class Writer {
	def writeMessage(message: String)
}
}}}

这样在特质中一定要修饰方法为`abstract override`，这里两个特质的功能分别是转大写
与过滤敏感词：

{{{class="brush: scala"
trait UpperCaseWriter extends Writer  {
	abstract override def writeMessage(message: String) =
		super.writeMessage(message.toUpperCase)
}

trait ProfanityFilteredWriter extends Writer  {
	abstract override def writeMessage(message: String) =
		super.writeMessage(message.replace("stupid","s-----"))
}
}}}

特质的实现里调用了`super.writeMessage(...)`，这样的调用要延迟绑定，以后混入这些
特质的类需要提供这个方法的实现。实现类如下：

{{{class="brush: scala"
class StringWriterDelegate extends Writer {
	val writer = new java.io.StringWriter

	def writeMessage(message: String) = writer.write(message)

	override def toString(): String = writer.toString
}
}}}

混入特质并调用：

{{{class="brush: scala"
val wa = 
	new StringWriterDelegate with UpperCaseWriter with ProfanityFilteredWriter
val wb = 
	new StringWriterDelegate with ProfanityFilteredWriter with UpperCaseWriter

wa writeMessage "There is no sin except stupidity"
wb writeMessage "There is no sin except stupidity"

println(wa)
println(wb)
}}}

输出结果：

{{{class="brush: bash"
THERE IS NO SIN EXCEPT S-----ITY
THERE IS NO SIN EXCEPT STUPIDITY
}}}


=== 特质也可以继承自类 ===

`IntQueue`类有一个`put`方法把整数添加到队列中，和一个`get`方法移除并返回它们：

{{{class="brush: scala"
  abstract class IntQueue {
    def get(): [[Int]]
    def put(x: Int)
  }
}}}

`BasicIntQueue`类根据上面的特质实现了一个队列：

{{{class="brush: scala"
  import scala.collection.mutable.ArrayBuffer

  class BasicIntQueue extends IntQueue {
    private val buf = new ArrayBuffer[Int]
    def get() = buf.remove(0)
    def put(x: Int) { buf += x }
  }
}}}

运行一个队列的效果：

{{{class="brush: scala"
  scala> val queue = new BasicIntQueue
  queue: BasicIntQueue = BasicIntQueue@24655f

  scala> queue.put(10)

  scala> queue.put(20)

  scala> queue.get()
  res9: Int = 10

  scala> queue.get()
  res10: Int = 20
}}}

`Doubling`特质继承自类`IntQueue`，它把整数放入队列的时候对它加倍。

{{{class="brush: scala"
  trait Doubling extends IntQueue {
    abstract override def put(x: Int) { super.put(2 * x) }
  }
}}}

=== 特质只能混入基类的子类 ===

定义了超类`IntQueue`这个定义意味着特质只能混入到扩展了`IntQueue`的类中。

还有前面提到的抽象绑定:

声明为抽象的方法中有一个`super`调用。这种调用对于普通的类来说是非法的，因为继承
的超类是个抽象类，所以在执行时将必然失败。然而对于特质来说，这样的调用实际能够
成功。因为特质里的`super`调用是动态绑定的，特质`Doubling`的`super`调用将直到被
混入在另一个特质或类之后，有了具体的方法定义时才工作。

所以要加上`abstract override`，说明要继承父特质（只有特质，类里是不能这样写的）
才能实际产生作用。

现在一行代码都不用写，下面只有一个`extends`和一个`with`就把类定义好了：

{{{class="brush: scala"
  scala> class MyQueue extends BasicIntQueue with Doubling
  defined class MyQueue

  scala> val queue = new MyQueue
  queue: MyQueue = MyQueue@91f017

  scala> queue.put(10)

  scala> queue.get()
  res12: Int = 20
}}}

这个队列即能入队出队，而且数字还是加倍的。

还可以更加简化到类名都不用写，直接`new BasicIntQueue with Doubling`这个父类名加
上特质就可以把实例拿到了：

{{{class="brush: scala"
  scala> val queue = new BasicIntQueue with Doubling
  queue: BasicIntQueue with Doubling = $anon$1@5fa12d

  scala> queue.put(10)

  scala> queue.get()
  res14: Int = 20
}}}


=== 特质的超类会成为类的超类 ===

之前讨论过特质可以继承自类，那我们就从`Exception`扩展一个特质出来：

{{{class="brush: scala"
trait LoggedException extends Exception with Logged {
	def log() { log(getMessage()) }
}
}}}

这里的`getMessage`方法是从`Exception`继承下来的。接下来把这个特质混入一个类中：

{{{class="brush: scala"
class UnhappyException exteds LoggedException {
	override def getMessage() = "arggh!"
}
}}}

现在特质`LoggedException`的超类`Exception`是`UnhappyException`的超类，对于生成的
Java类来说：

* `UnhappyException`实现了`LoggedException`接口
* `UnhappyException`继承了`Exception`类

==== 只能有一个超类 ====

因为Java没有多继承，所以类的超类和特质的超类不能关联到不同的类：

{{{class="brush: scala"
class UnhappyFrame extends JFrame with LoggedException
}}}

不能同时把`JFrame`和`Exception`作为超类。

但如果类的超类是特质超类的子类就没有问题：

{{{class="brush: scala"
class UnhappyException extends IOException with LoggedException
}}}


== 保证特质能调用到需要的方法 ==

以记录异常log为例：

{{{class="brush: scala"
trait LoggedException {
		def log() { log(getMessage()) }   // error
}
}}}

我们要保证`LoggerException`混入的类要有`getMessage()`方法，因为在`log()`方法中
会调用到它。


为了保证特质一定能调用到指定的方法（如：`getMessage`)，可以有两种方案：

* 特质扩展自指定的类（如：`Exception`）
* 用自身类型限制只能混入指定的类（如：`Exception`）

如果特质是扩展子一个类`B`，那么所以混入这个特质的类都可以作为`B`的子类。

=== 自身类型 ===

Scala还可以通过自身类型（self type），限制只能被混入到指定的类中：

{{{class="brush: scala"
this: MyType =>
}}}

保证特质只能被混入`MyType`的子类中。

例如，要根据现有的日志工具类`Logged`扩展出一个适用于异常日志的`LoggedException`
：

{{{class="brush: scala"
trait LoggedException extends Logged {
	this: Exception =>
		def log() { log(getMessage()) }
}
}}}

因为限制在`Exception`的子类中，所以可以保证肯定会有`getMessage()`方法。


通过`this: Type`来限制类型比继承超类的版本更加灵活。可以避免两个彼此需要的特质
循环依赖。

=== 自身类型不会继承 ===

前面的`LoggedException`的自身类型并不会继承给子类，如果它有子类要再次声明自身
类型：

{{{class="brush: scala"
trait ManagedException extends LoggedException {
	this: Exception =>
		...
}
}}}

=== this的别名 ===

如果把`this`改成别的名字那么在子类中还可以使用这个别名。如：

{{{class="brush: scala"
trait Group {
	outer: Network =>
		class Member { ... }
}
}}}

这里把`this`改成`outer`。`Grout`特质只能在`Network`的子类中，而在`Member`中，
可以用`outer`来代替`Group.this`。


==== 结构类型 ====

结构类型（structural type）只给出类必须拥有的方法，而不是类的名称。这种场景下用
`this: Type`处理更加方便：

自身类型也可以不给出类名，而用结构类型(structural type)来说明要有指定方法：

{{{class="brush: scala"
trait LoggedException extends Logged {
	this: { def getMessage(): String} =>
		def log() { log(getMessage()) }
}
}}}

这样就可以混入任何有`getMessage`方法的类了。

{{{class="brush: scala"
trait LoggedException extends Logged {
	this: { def getMessage(): String }=>
		def log() { log(getMessage()) }
}
}}}


== 混入多个特质 ==

混入多个特质的类型被称作复合类型。如果想混入多个特质，都加在`with`子句里就可以了
：

{{{class="brush: scala"
  class Animal
  trait HasLegs

  class Frog extends Animal with Philosophical with HasLegs {
    override def toString = "green"
  }
}}}

在容器的类型参数里也可以这样用：

{{{class="brush: scala"
val image = new ArrayBuffer[java.awt.Shape with java.io.Serializable]
}}}

存放的成员必须是满足这两个条件的类型，如`Rectangle`

{{{class="brush: scala"
image += new Rectangle(5, 10, 20, 30) // OK
image += new Area(rect)               // error Area类型不是Serializable的
}}}

结构类型也可添加到简单类型或是复合类型的声明中：

{{{class="brush: scala"
val image = new ArrayBuffer[Shape with Serializable { def contains(p: Point): Boolean } ]
}}}

上面的定义不仅要是`Shape`和`Serializable`，还要有一个`contains()`方法。

从技术上来说，如下的结构类型：

{{{class="brush: scala"
AnyRef { def append(str: String): Any }
}}}

可以简写为：

{{{class="brush: scala"
{ def append(str: String): Any }
}}}

这样的复合类型：

{{{class="brush: scala"
Shape with Serializable {}
}}}

可以简写为：

{{{class="brush: scala"
Shape with Serializable
}}}

=== 特质的`super`引用是动态的 ===

类和特质的另一个差别在于：在类中任何地方，`super`调用都是静态绑定的，在特质中
，它们是动态绑定的。如果你在类中写下`super.toString`，你很明确哪个方法实现将被
调用。然而如果你在特质中写了同样的东西，在你定义特质的时候`super`调用的方法实现
尚未被定义。调用的实现将在每一次特质被混入到具体类的时候才被决定。这种处理
`super`的有趣的行为是使得特质能以可堆叠的改变（stackable modifications）方式
工作的关键。


=== 特质的叠加栈 ===

有两个特质，一个在入队时把值加1；另一个过滤掉负数：

{{{class="brush: scala"
  trait Incrementing extends IntQueue {
    abstract override def put(x: Int) { super.put(x + 1) }
  }

  trait Filtering extends IntQueue {
    abstract override def put(x: Int) {
      if (x >= 0) super.put(x)
    }
  }
}}}

队列能够即过滤负数又对每个进队列的数字增量：

{{{class="brush: scala"
  scala> val queue = (new BasicIntQueue
       | with Incrementing with Filtering)
  queue: BasicIntQueue with Incrementing with Filtering...

  scala> queue.put(-1); queue.put(0); queue.put(1)

  scala> queue.get()
  res15: Int = 1

  scala> queue.get()
  res16: Int = 2
}}}

粗略地说，越靠近右侧的特质越先起作用。如果那个方法调用了`super`，它调用其左侧
特质的方法，以此类推。

前面的例子里，`Filtering`的`put`首先被调用，因此它移除了开始的负整数。
`Incrementing`的`put`第二个被调用，因此它对剩下的整数增量。

如果你逆转特质的次序，那么整数首先会加1，然后如果仍然是负的才会被抛弃：

{{{class="brush: scala"
  scala> val queue = (new BasicIntQueue
       | with Filtering with Incrementing)
  queue: BasicIntQueue with Filtering with Incrementing...

  scala> queue.put(-1); queue.put(0); queue.put(1)

  scala> queue.get()
  res17: Int = 0

  scala> queue.get()
  res18: Int = 1

  scala> queue.get()
  res19: Int = 2
}}}

=== 指定调用特质栈 ===

除了用`super.method()`调用下个特质，还可以用`super[traid].method()`来调用指定
具体特质。注意指定的一定是直接一级，不能使用继承层级中更远的特质类。


== 特质的构造过程 ==

=== 特质构造器 ===

特质构造器是由字段初始化和其他特质体中的语句构成的。特质所混入对象被构造时，这些
语句被执行。顺序为：

* 调用超类的构造器
* 特质构造器在超类构造器之后，当前类的构造器之前执行
* 特质从左到右被构造，每个特质的你特质先被构造。
* 如果多个特质共有一个你特质，而且父特质已经被构造过了，不会再次构造
* 所有特质构造完毕，当前类构造器被执行

=== 特质不能有构造器参数 ===

特质不能有任何“类”参数，也就是说，传递给类的主构造器的参数。换句话说，
尽管你可以定义如下的类：

{{{class="brush: scala"
  class Point(x: Int, y: Int)
}}}

=== 预初始化字段 ===

由于特质不能有参数，所以要用别的方法在初始化时传入值。

比如，不能有参数，所以用以下的方法指定日志文件是不行的：

{{{class="brush: scala"
val acct = new SavingAccount with FileLogger("mylog.log")
}}}

另一个方案：

用抽象字段`filenam`来存文件名，这样混入这个特质的类可以重写这个字段：

{{{class="brush: scala"
trait FileLogger extends Logger {
	val filename: String
	val out = new PrintStream(filename)
	def long(msg: String) { out.println(msg); out.flush() }
}}}

但是由于特质的构造器比当前类更先执行，所以特质构造时取得的`filename`还是没有被
子类初始化，抛出空指针异常。

有效的解决方案有两个：

* 预初始化字段。
* 懒加载。

==== 应用于实例 ====

把初始化块放在`new`之后：

{{{class="brush: scala"
val acct = new {
	val filename = "mylog.log"
} with SavingAccount whith FileLogger
}}}

==== 应用于类 ====

初始化块放在`extends`前：

{{{class="brush: scala"
clas SavingAccount extends {
	val filename = "mylog.log"
} with Account with FileLogger {
	// ...
}
}}}

=== 懒加载 ===

除了预初始化外的另一个方案是懒加载：

{{{class="brush: scala"
trait FileLogger extends Logger {
	val filename: String
	lazy val out = new PrintStream(filename)
	def long(msg: String) { out.println(msg); out.flush() }
}
}}}

初始化输出流的操作只有在用到`out`时才执行。




== Scala特质生成Java接口 ==

=== 只有抽象方法 ===

只有抽象方法的特质简单地转为Java接口。

Scala特质：

{{{class="brush: scala"
trait Logger {
	def log(msg: String)
}
}}}

生成的接口：

{{{class="brush: java"
public interface Logger {
	void log(String msg);
}
}}}

=== 有方法实现的情况 ===

会创建一个伴生类，它的静态方法里存放特质的方法。

{{{class="brush: scala"
trait ConsoleLogger exteds Logger {
	def log(msg: String) { println(msg) }
}
}}}

转换成：

{{{class="brush: java"
public interface ConsoleLogger extends Logger {
	void log(String msg);
}
}}}

伴生类：

{{{class="brush: java"
public class ConsoleLogger$class {
	public static void log(ConsoleLogger self, String msg) {
		println(msg);
	}
	
	// ...
}
}}}

=== 特质中的字段 ===

伴生类中不会有字段，字段对应的`getter`和`setter`方法加入到实现了特质的类中：

{{{class="brush: java"
trait ShortLogger extends Logger {
	val maxLength = 15
	// ...
}
}}}

被翻译成：

{{{class="brush: java"
public interface ShortLogger extends Logger {
	public abstract int maxLength();
	public abstract void weird_prefix$maxLength_$eq(int);
	
	// ...
}
}}}

以`weird`开头的`setter`方法是用来初始化字段的。初始化发生在伴生类的一个初始化
方法内：

{{{class="brush: scala"
public class ShortLogger$class {
	public void $init$(ShortLogger self) {
		self.weired-prefix$maxLength_$eq(15)
	}

	// ...
}
}}}

被混入的类会有带`getter`和`setter`的`maxLength`字段，上面的构造器会被调用以初始
化字段。

如果特质扩展自某个超类，则伴生类并不继承这个超类。该超类会被任何实现该特质的类
继承。

== 特质与类的差异 ==

特质就像是带有具体方法的Java接口，不过其实它能做的更多。比方说，特质可以声明字段
和维持状态值。

实际上，你可以用特质定义做任何用类定义做的事，并且语法也是一样的，除了两点：

* 特质不能有构造器参数。
* 特质的`super`引用是动态的。

但是下面定义特质的尝试将遭到失败：

{{{class="brush: scala"
  trait NoPoint(x: Int, y: Int) // Does not compile
}}}


== 应用场景 ==

=== 为什么不是多重继承 ===

特质是一种继承多个类似于类的结构的方式，但是它与许多语言中的多重继承有很重要的
差别。其中的一个尤为重要：`super`的解释。对于多重继承来说，`super`调用导致的方法
调用可以在调用发生的地方明确决定。而对于特质来说，方法调用是由类和被混入到类的
特质的线性化（linearization）所决定的。这种差别让前一节所描述的改动的堆叠成为
可能。

在关注线性化之前，请花一点儿时间考虑一下在传统的多重继承语言中如何堆叠改动。假想
有下列的代码，但是这次解释为多重继承而不是特质混入：

{{{class="brush: scala"
  val q = new BasicIntQueue with Incrementing with Doubling
  q.put(42) // which put would be called?
}}}

第一个问题是，哪个`put`方法会在这个调用中被引用？或许规则会决定最后一个超类胜出
，本例中的`Doubling`将被调用。`Doubling`将加倍它的参数并调用`super.put`，大概
就是这样。增量操作将不会发生！同样，如果规则决定第一个超类胜出，那么结果队列将
增量整数但不会加倍它们。因此怎么排序都不会有效。

或许你会满足于允许程序员显式地指定在他们说`super`的时候他们想要的到底是哪个超类
方法。比方说，假设下列Scala类似代码，`super`似乎被显式地指定为`Incrementing`和
`Doubling`调用：

{{{class="brush: scala"
  trait MyQueue extends BasicIntQueue
      with Incrementing with Doubling {

    def put(x: Int) {
      Incrementing.super.put(x) // (Not real Scala)
      Doubling.super.put(x)
    }
  }
}}}

这种方式将带给我们新的问题。这种尝试的繁冗几乎不算是问题。实际会发生的是基类的
`put`方法将被调用两次——一次带了增量的值另一次带了加倍的值，但是没有一次是带了
增量加倍的值。

显然使用多重继承对这个问题来说没有好的方案。你不得不返回到你的设计并分别提炼出
代码。相反，Scala里的特质方案很直接。你只要简单地混入`Incrementing`和`Doubling`
，`Scala`对`super`的特别照顾让它迎刃而解。这与传统的多重继承相比必然有不同的地方
，但这是什么呢？

就像在前面暗示的，答案就是线性化。当你使用`new`实例化一个类的时候，Scala把这个类
和所有它继承的类还有它的特质以线性（linear）的次序放在一起。然后，当你在其中的
一个类中调用`super`，被调用的方法就是链子的下一节。除了最后一个调用`super`之外的
方法，其净结果就是可堆叠的行为。

线性化的精确次序由语言的规格书描述。虽然有一点儿复杂，但你需要知道的主旨就是，在
任何的线性化中，某个类总是被线性化在所有其超类和混入特质之前。因此，当你写了一个
调用`super`的方法时，这个方法必将改变超类和混入特质的行为，没有其它路可走。

Scala的线性化的主要属性可以用下面的例子演示：假设你有一个类`Cat`，继承自超类
`Animal`以及两个特质`Furry`和`FourLegged`。`FourLegged`又扩展自另一个特质
`HasLegs`：

{{{class="brush: scala"
  class Animal
  trait Furry extends Animal
  trait HasLegs extends Animal
  trait FourLegged extends HasLegs
  class Cat extends Animal with Furry with FourLegged
}}}

<img src="images/scala/Selection_017.png" alt="继承关系" />

类型的线性化看起来是这样的：

{{{class="brush: scala"
    Animal : Any < AnyRef < Animal
     Furry : Any < AnyRef < Animal < Furry
   HasLegs : Any < AnyRef < Animal < HasLegs
FourLegged : Any < AnyRef < Animal < HasLegs < FourLegged
       Cat : Any < AnyRef < Animal < Furry < HasLegs < FourLegged < Cat
}}}

因为`Animal`没有显式扩展超类或混入任何超特质，因此它缺省地扩展了`AnyRef`，并
随之扩展了`Any`。

{{{class="brush: scala"
    Animal : Any < AnyRef < Animal
}}}

第二部分是第一个混入，特质`Furry`的线性化，但是所有已经在`Animal`的线性化之中的
类现在被排除在外，因此`Cat`的线性化中每个类仅出现1次。结果是：

{{{class="brush: scala"
     Furry : Any < AnyRef < Animal < Furry
}}}

它之前是`FourLegged`的线性化，任何已被复制到线性化中的超类及第一个混入再次被排除
在外：

{{{class="brush: scala"
FourLegged : Any < AnyRef < Animal < HasLegs < FourLegged
}}}

最后，`Cat`线性化的第一个类是`Cat`自己：

当这些类和特质中的任何一个通过`super`调用了方法，那么被调用的实现将是它线性化的
右侧的第一个实现。

{{{class="brush: scala"
       Cat : Any < AnyRef < Animal < Furry < HasLegs < FourLegged < Cat
}}}


=== 比较瘦接口与胖接口 ===

瘦接口与胖接口的对阵体现了面向对象设计中常会面临的在实现者与接口用户之间的权衡。

胖接口有更多的方法，对于调用者来说更便捷。客户可以捡一个完全符合他们功能需要的
方法。另一方面瘦接口有较少的方法，对于实现者来说更简单。然而调用瘦接口的客户因此
要写更多的代码。由于没有更多可选的方法调用，他们或许不得不选一个不太完美匹配他们
所需的方法并为了使用它写一些额外的代码。

Java的接口常常是过瘦而非过胖。例如，从Java 1.4开始引入的`CharSequence`接口，是
对于字串类型的类来说通用的瘦接口，它持有一个字符序列。下面是把它看作Scala特质的
定义：

{{{class="brush: scala"
  trait CharSequence {
    def charAt(index: Int): Char
    def length: Int
    def subSequence(start: Int, end: Int): CharSequence
    def toString(): String
  }
}}}

尽管类`String`里现有的成打的方法中的大多数都可以用在任何`CharSequence`上，Java的
`CharSequence`接口定义仅提供了4个方法。如果`CharSequence`代以包含全部`String`
接口，那它将为`CharSequence`的实现者压上沉重的负担。任何实现Java`CharSequence`
接口的程序员将不得不定义一大堆方法。因为Scala特质可以包含具体方法，这使得创建
胖接口大为便捷。

在特质中添加具体方法使得胖瘦对阵的权衡大大倾向于胖接口。不像在Java里那样，在
Scala中添加具体方法是一次性的劳动。你只要在特质中实现方法一次，而不再需要在每个
混入特质的方法中重新实现它。因此，与没有特质的语言相比，Scala里的胖接口没什么
工作要做。

要使用特质丰满接口，只要简单地定义一个具有少量抽象方法的特质——特质接口的瘦部分——
和潜在的大量具体方法，所有的都实现在抽象方法之上。然后你就可以把丰满了的特质混入
到类中，实现接口的瘦部分，并最终获得具有全部胖接口内容的类。

=== 什么情况下要用特质 ===

没有固定的规律，但是包含了几条可供考虑的导则。

如果行为不会被重用，那么就把它做成具体类。具体类没有可重用的行为。

如果要在多个不相关的类中重用，就做成特质。只有特质可以混入到不同的类层级中。

如果你希望从Java代码中继承它，就使用抽象类。因为特质和它的代码没有近似的Java模拟
，在Java类里继承特质是很笨拙的。而继承Scala的类和继承Java的类完全一样。除了一个
例外，只含有抽象成员的Scala特质将直接翻译成Java接口，因此即使你想用Java代码继承
，也可以随心地定义这样的特质。要了解让Java和Scala一起工作的更多信息请看后面其他
的章节。

注意：如果你计划以编译后的方式发布它，并且你希望外部组织能够写一些继承自它的类，
你应更倾向于使用抽象类。原因是当特质获得或失去成员，所有继承自它的类就算没有改变
也都要被重新编译。如果外边客户仅需要调用行为，而不是继承自它，那么使用特质没有
问题。

如果效率非常重要，倾向于类。大多数Java运行时都能让类成员的虚方法调用快于接口方法
调用。特质被编译成接口，因此会付出微小的性能代价。然而，仅当你知道那个存疑的特质
构成了性能瓶颈，并且有证据说明使用类代替能确实解决问题，才做这样的选择。


== 例子 ==

=== 样例：长方形实例 ===

为了使这些长方形实例便于使用，如果库能够提供诸如`width`，`height`，`left`，
`right`，`topLeft`，等等方法。

没有特质的代码的话，首先会有一些基本的集合类如`Point`和`Rectangle`：

{{{class="brush: scala"
  class Point(val x: Int, val y: Int)

  class Rectangle(val topLeft: Point, val bottomRight: Point) {
    def left = topLeft.x
    def right = bottomRight.x
    def width = right - left
    // and many more geometric methods...
  }
}}}

这个`Rectangle`类在它的主构造器中带两个点，分别是左上角和右下角的坐标。然后它
通过对这两个点执行简单的计算实现了许多便捷方法诸如`left`，`right`，和`width`。

图库应该有的另一个类是2-D图像工具：

{{{class="brush: scala"
  abstract class Component {
    def topLeft: Point
    def bottomRight: Point

    def left = topLeft.x
    def right = bottomRight.x
    def width = right - left
    // and many more geometric methods...
  }
}}}

注意`left`，`right`，和`width`在两个类中的定义是一模一样。除了少许的变动外，他们
将在任何其他的长方形实例的类中保持一致。

这种重复可以使用特质消除。这个特质应该具有两个抽象方法：一个返回实例的左上角坐标
，另一个返回右下角的坐标。然后他就可以应用到所有其他的几何查询的具体实现中：

{{{class="brush: scala"
  trait Rectangular {
    def topLeft: Point
    def bottomRight: Point

    def left = topLeft.x
    def right = bottomRight.x
    def width = right - left
    // and many more geometric methods...
  }
}}}

类`Component`可以混入这个特质并获得`Rectangular`提供的所有的几何方法：

{{{class="brush: scala"
  abstract class Component extends Rectangular {
    // other methods...
  }
}}}

可以创建`Rectangle`实例并对它调用如`width`或`left`的几何方法：

{{{class="brush: scala"
  scala> val rect = new Rectangle(new Point(1, 1),
       | new Point(10, 10))
  rect: Rectangle = Rectangle@3536fd

  scala> rect.left
  res2: Int = 1

  scala> rect.right
  res3: Int = 10

  scala> rect.width
  res4: Int = 9
}}}


=== 实现Ordered特质来排序 ===

以前面我们实现的实数类型来说，原来已经有了四个比较大小的方法：

{{{class="brush: scala"
  class Rational(n: Int, d: Int) {
    // ...
    def < (that: Rational) =
      this.numer * that.denom > that.numer * this.denom
    def > (that: Rational) = that < this
    def <= (that: Rational) = (this < that) || (this == that)
    def >= (that: Rational) = (this > that) || (this == that)
  }
}}}

Scala专门提供了`Ordered`特质来简化比较工作。只要实现`Ordered`特质中的`compare`
方法，就可以自动实现其他的`<`、`>`、`<=`、`>=`功能：

{{{class="brush: scala"
  class Rational(n: Int, d: Int) extends Ordered[Rational] {
    // ...
    def compare(that: Rational) =
      (this.numer * that.denom) - (that.numer * this.denom)
  }
}}}

上面定义`compare`方法来比较两个实例，类`Rational`现在具有了所有4种比较方法：

{{{class="brush: scala"
  scala> val half = new Rational(1, 2)
  half: Rational = 1/2

  scala> val third = new Rational(1, 3)
  third: Rational = 1/3

  scala> half < third
  res5: Boolean = false

  scala> half > third
  res6: Boolean = true
}}}

考虑下面的抽象简化了四个比较操作符的实现：

{{{class="brush: scala"
  trait Ordered[T] {
    def compare(that: T): Int

    def <(that: T): Boolean = (this compare that) < 0
    def >(that: T): Boolean = (this compare that) > 0
    def <=(that: T): Boolean = (this compare that) <= 0
    def >=(that: T): Boolean = (this compare that) >= 0
  }
}}}



