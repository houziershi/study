%title Part II

%toc Part II


= 动态成员 =

静态类型不光是变量类型是确定的，还有比如在使用`qual.sel`时，`sel` 这个属性或是
方法（Scala的访问一致性，属性和方法有时候并没有那么大的区别）必须在`qual`的
类型中声明了的。

Scala 思考再三还是加入了 Dynamic Types，这个特性在Scala 2.9中是试验性的，
必须用`-Xexperimental`进行开启，到了 Scala 2.10.0 中，开启方式有两种：

* 代码中有`import scala.language.dynamics`
* 代码中不引入，但编译时加`-language:dynamics`选项。

虽然Scala 2.10.0加进了Dynamic Types特性，但Scala仍然是静态类型的语言，因为在
编译器同样会检查多出来的类型。

有了Dynamic Types之后，Scala又可更DSL了，方法名的动态上可以让它随时包括深刻的
业务含义。相比Java的DSL的能力就太逊了，我们几乎无法在Java面前提DSL这回事。

通俗点讲动态类型的类必须继承自`Dynamic`。所有的变化就在下面这四个方法中：

* `selectDynamic`
* `updateDynamic`
* `applyDynamic`
* `applyDynamicNamed`

说明：

* 当使用`qual.sel`，而`Qual`类未定义`sel`属性或方法时，
会调用`selectDynamic(method: String)`方法。
* 当`qual.name = "Unmi"`时会调用类似`updateDynamic(method: String)(args: Any)`
这样的方法。
* 还有` applyDynamic`，`applyDynamicNamed`这两个方法的自动调用。

看个完整的例子，我不打算把上面四个方法的应用规则分开来演示：

{{{class="brush: scala"	
import scala.language.dynamics
 
class Person extends Dynamic{
	def selectDynamic(method: String){
		println(s"selectDynamic->$method called\n")
	}

	def applyDynamic(method: String)(args: Any*){
		println(s"applyDynamic->$method called, args: $args\n")
	}

	def updateDynamic(method: String)(args: Any){
		println(s"updateDynamic->$method called, args: $args\n")
	}

	def applyDynamicNamed(method: String)(args: (String, Any)*) {
		println(s"applyDynamicNamed->$method called, args: $args")
		for((key, value) <- args){
			println(s"key: $key, value: $value")
		}
	}
}
 
val p = new Person
 
//calll selectDynamic
p.sayHello
//call applyDynamic
p.config("Hello","Unmi")
//call updateDynamic
p.products = ("iPhone","Nexus")
//call applyDynamicNamed
p.showInfo(screenName="Unmi", email="fantasia@sina.com") 
}}}

上面对`p`的每一个调用都说明了会委派给哪个动态方法，执行结果输出是：

{{{class="brush: scala"
selectDynamic->sayHello called
 
applyDynamic->config called, args: WrappedArray(Hello, Unmi)
 
updateDynamic->products called, args: (iPhone,Nexus)
 
applyDynamicNamed->showInfo called, args:
									WrappedArray((screenName,Unmi), (email,fantasia@sina.com))
key: screenName, value: Unmi
key: email, value: fantasia@sina.com
}}}

现在来看发生了什么，`Person`继承自`Dynamic`，并且有引入
`scala.language.dynamics`。对`p`调用的方法(属性)都不存在，但是都调用到了正常的
动态方法。所以仍然要对这四个动态方法(确切的讲是四种类型的方法，因为比如你可以
		定义多个不同的`updateDynamic`方法，其余三个也同此) 分别加以说明。

== selectDynamic ==

在调用找不到了无参方法时，会去寻找它，调用效果如下：

`p.sayHello`也可以写成`p.selectDynamic("sayHello")`。也就是说编译器在看到
`p.sayHello`调用会根据`selectDynamic(method: String)`。相当于创建了方法
`def sayHello = .......`，也就是把动态方法`selectDynamic(method: String)`换成
`sayHello`。所以说Scala的`Dynamic`类中的`xxxDynamic`方法相当是模板方法。

`applyDynamic`，`updateDynamic`和`applyDynamicNamed`这三个方法第二个括号中的
参数类型，或个数需根据实际应用来定。这四个动态方法的第一个括号中的参数都是
动态调用时的方法名。

== applyDynamic ==

在进行有参数的方法调用时，会去找寻它，调用效果如下：

`p.config("Hello", "Unmi")`可以写成`p.applyDynamic("config")("Hello", "Unmi")`

还是这么理解: 把这个动态方法定义的方法名和第一个括号与参数替换成调用的方法名
就知道怎么回事，例如把：

`def applyDynamic(method: String)(args: Any*)`中的`applyDynamic(method: String)`
替换成被调用方法名`config`，就是：

{{{class="brush: scala"
def config(args: Any*)    //p.config("Hello", "Unmi") 要调用的就是这么个方法
}}}

所以第二个括号中的参数由你自己来定，比如说想这么调用`p.config("Hello", 100, 30)`
，那么你可的动态方法可以这么定义：

{{{class="brush: scala"
def applyDynamic(method: String) (greeting: String, high: Int, low: Int) {
	// ...... 
}
}}}

这个规则同样适用于`updateDynamic`和`applyDynamicNamed`这两个方法。

== updateDynamic ==

等号赋值操作时会调用`updateDynamic`方法，调用效果如下：

{{{class="brush: scala"
p.products = ("iPhone", "Nexus")
}}}

可写成：

{{{class="brush: scala"
p.updateDynamic("products")(("iPhone", "Nexus"))
}}}

按照同样的理解方法，相当于`Person`中定义了`def products(args: Any)`方法。

== applyDynamicNamed ==

同样是`apply`开头，所以这个方法是对`applyDynamic`方法的补充，即使没有
`applyDynamicNamed`，单用`applyDynamic`也能达成我们的要求。

`applyDynamicNamed` 只是让你用命名参数调用时方便，也就是像：

{{{class="brush: scala"
p.showInfo(screenName="Unmi", email="fantasia@sina.com") 
}}}

这样用命名参数的方式来调用动态方法时会调用`updateDynamicNamed`方法。有了这个方法
在命名传递参数就方便处理`key/value`值。

这四个方法在一个动态类中只能分别定义一个版本，否则会产生二义性，这和普通方法的
重载不一样的。柯里化后的函数第二个括号中的参数可根据实际调用来定义，定义成
`(args: Any*)`可包打天下。


= 控制抽象 =

== 可复用的代码 ==

所有的函数都被分割成通用部分（它们在每次函数调用中都相同）以及非通用部分（在不同
的函数调用中可能会变化）。通用部分是函数体，而非通用部分必须由参数提供。

当你把函数值用做参数时，算法的非通用部分就是它代表的某些其它算法。在这种函数的
每一次调用中，你都可以把不同的函数值作为参数传入，于是被调用函数将在每次选用
参数的时候调用传入的函数值。这种高阶函数（higher-order function）带其它函数做
参数的函数提供了机会去组织和简化代码。

例子。一个工具类，提供了很多查找文件的方法，有根据文件结尾的、文件名是否包含
指定字串的、文件名是否匹配正则的：

{{{class="brush: scala"
  object FileMatcher {

    // private method, get file name list in current dir
    private def filesHere = (new java.io.File(".")).listFiles

    // by file name end with string
    def filesEnding(query: String) =
      for (file <- filesHere; if file.getName.endsWith(query))
        yield file
                     
    // by file name end include string
    def filesContaining(query: String) =
      for (file <- filesHere; if file.getName.contains(query))
        yield file
                   
    // by file name match regex
    def filesRegex(query: String) =
      for (file <- filesHere; if file.getName.matches(query))
        yield file
  } 
}}}

如果在Java中对应这种情况，大家应该都知道如何提炼接口来重用代码，这里就不啰嗦了。

如果是在某些动态语言中，要提炼一个工具方法提炼出共用的部分，根据传入不同`method`
作为参数也匹配也很方便，可以直接把代码“拼接”起来：

{{{class="brush: scala" 
  def filesMatching(query: String, method) =
    for (file <- filesHere; if file.getName.method(query))
      yield file
}}}

不过Scala不是动态语言，不能这么拼接。虽然不能把方法名作为参数传递，但可以通过
字面量在运行时产生对应的函数值：

{{{class="brush: scala"
  def filesMatching(
    query: String,
    matcher: (String, String) => Boolean
  ) = {
    for (file <- filesHere; if matcher(file.getName, query))
      yield file
  } 
}}}

字面量只说明了函数的类型是`(String, String) => Boolean`，不用关内部逻辑的。现在
已经有了一个`filesMatching`方法来处理共同的逻辑，三个具体的匹配方法只要调用它
就行了：

{{{class="brush: scala"
  def filesEnding(query: String) =
    filesMatching(query, _.endsWith(_))

  def filesContaining(query: String) =
    filesMatching(query, _.contains(_))

  def filesRegex(query: String) =
    filesMatching(query, _.matches(_)) 
}}}

上面的代码可能太乘法了，加上参数表和参数类型可以更加好理解一些：

{{{class="brush: scala"
  // _.endsWith(_)
  (fileName: String, query: String) => fileName.endsWith(query)
  
  // _.contains(_)
  (fileName: String, query: String) => fileName.contains(query))
  
  // _.matches(_)
  (fileName: String, query: String) => fileName.matches(query))
}}}

代码已经被简化了，但它实际还能更短。注意到`query`传递给了方法`filesMatching`，
但`filesMatching`根本用不着这个参数，只是为了把它传回给传入的`matcher`函数。

所以在这里可以直接把参数`query`绑定到函数字面量中，这样`fileMacthing`方法就不要
`query`这个参数了。 

{{{class="brush: scala"
  object FileMatcher {
    private def filesHere = (new java.io.File(".")).listFiles

    private def filesMatching(matcher: String => Boolean) =
      for (file <- filesHere; if matcher(file.getName))
        yield file
  
    def filesEnding(query: String) =
      filesMatching(_.endsWith(query))
  
    def filesContaining(query: String) =
      filesMatching(_.contains(query))
  
    def filesRegex(query: String) =
      filesMatching(_.matches(query))
  } 
}}}

== 简化客户端代码 ==

高阶函数可以提供更加强大的API，让客户的代码写起来更加简单。

比如List中的高阶函数`exists`方法已经提供了遍历整个集合的抽象，用户只要把判断符合
的函数传入就可以了。下面的两个例子非常简单地实现了检查是否存在负数和是否存在奇数
两个方法：

{{{class="brush: scala"
scala> def containsNeg(nums: List[Int]) = nums.exists(_ < 0)
containsNeg: (nums: List[Int])Boolean

scala> def containsOdd(nums: List[Int]) = nums.exists(_ % 2 == 1)
containsOdd: (nums: List[Int])Boolean
 
scala> List(1, 2, 3, 4)
res1: List[Int] = List(1, 2, 3, 4)

scala> containsNeg(res1)
res3: Boolean = false

scala> containsOdd(res1)
res4: Boolean = true
}}}

如果没有高阶函数`exists`，那就要自己写循环的逻辑，就会有很多重复的代码：

{{{class="brush: scala"
  def containsNeg(nums: List[Int]): Boolean = {
    var exists = false
    for (num <- nums)
      if (num < 0)
        exists = true
    exists
  }
  
  def containsOdd(nums: List[Int]): Boolean = {
    var exists = false
    for (num <- nums)
      if (num % 2 == 1)
        exists = true
    exists
  } 
}}}


== 柯里化（Currying） ==  

理解柯里化可以帮助理解如何建立自己的控制结构。柯里化就是一个函数有多个参数列表。

普通的函数，实现了两个Int型参数，x和y的加法：

{{{class="brush: scala"
  scala> def plainOldSum(x: Int, y: Int) = x + y
  plainOldSum: (Int,Int)Int

  scala> plainOldSum(1, 2)
  res4: Int = 3 
}}}

curry化后的同一个函数，两个列表的各一个参数：

{{{class="brush: scala"
  scala> def curriedSum(x: Int)(y: Int) = x + y
  curriedSum: (Int)(Int)Int

  scala> curriedSum(1)(2)
  res5: Int = 3 
}}}

实际上背靠背地调用了两个传统函数。第一个函数调用带单个的名为`x`的`Int`参数，并
返回第二个函数的函数值。第二个函数带`Int`参数`y`。下面的名为`first`的函数实质上
执行了`curriedSum`的第一个传统函数调用会做的事情：

{{{class="brush: scala"
  scala> def first(x: Int) = (y: Int) => x + y
  first: (Int)(Int) => Int 
}}}

调用第一个函数并传入1——会产生第二个函数：

{{{class="brush: scala"
  scala> val second = first(1)
  second: (Int) => Int = <function> 
}}}

从上面的结果可以看出我们得到的结果是一个函数，并把这个函数赋值给了变量`second`。

通过`second`调用第二个函数传入参数2产生结果：

{{{class="brush: scala"
  scala> second(2)
  res6: Int = 3 
}}}

`first`和`second`函数只演示连接在`curriedSum`函数上的那两个函数，并不直接连接在
`curriedSum`函数上的那两个函数。但我们仍然有一个方式获得实际指向`curriedSum`的
“第二个”函数的引用。你可以用偏应用函数表达式方式，把占位符标注用在`curriedSum`里
，如：

{{{class="brush: scala"
  scala> val onePlus = curriedSum(1)_
  onePlus: (Int) => Int = <function> 
}}}

之前说过，当占位符标注用在传统方法上时，如`println _`，你必须在名称和下划线之间
留一个空格。不然编译器会误认为是要调用名为`println_`的函数。而在这个例子里不需要
，因为`println_`是Scala里合法的标识符，`curriedSum(1)_`不是合法的标识符，所以会
被解释为`curriedSum(1)`与占位符`_`。

现在得到了指向一个函数的引用，这个函数在被调用的时候，传入`Int`参数加一并返回
结果：

{{{class="brush: scala"
  scala> onePlus(2)
  res7: Int = 3 
}}}

由于第二个函数的参数已经有了（传入的是2），现在再用参数2调用第一个函数也能有结果
出来：

{{{class="brush: scala"
  scala> val twoPlus = curriedSum(2)_
  twoPlus: (Int) => Int = <function>

  scala> twoPlus(2)
  res8: Int = 4 
}}}



== 编写新的控制结构 ==

在拥有头等函数的编程语言中，可以在方法中以函数作为参数创造自己的控制结构。

比如有个“重复操作”的方法，它可以把任何操作重复执行两次：

{{{class="brush: scala"
  scala> def twice(op: Double => Double, x: Double) = op(op(x))
  twice: ((Double) => Double,Double)Double

  scala> twice(_ + 1, 5)
  res9: Double = 7.0 
}}}

如果在工作中曾经遇到重复操作两次`(Double) => Double`类型函数的操作的话，这样就把
一个控制结构给抽象出来了。

再考虑一个常用的工作流程：打开一个资源，对它进行操作，然后关闭资源。你可以使用
如下的方法将其捕获并放入控制抽象：

{{{class="brush: scala"
  def withPrintWriter(file: File, op: PrintWriter => Unit) {
    val writer = new PrintWriter(file)
    try {
      op(writer)
    } finally {
      writer.close()
    }
  } 
}}}

以后要使用的时候就只要传入要处理的文件和处理的方法就行了，打开一个资源和关闭资源
都已经在高阶函数中被抽象出来了：

{{{class="brush: scala"
  withPrintWriter(
    new File("date.txt"),
    writer => writer.println(new java.util.Date)
  ) 
}}}

这个技巧被称为贷出模式（loan pattern），因为控制抽象函数，如`withPrintWriter`，
打开了资源并“贷出”给函数。当函数完成的时候，它发出信号说明它不再需要“借”的资源。
于是资源被关闭在`finally`块中，以确信其确实被关闭，而忽略函数是正常结束返回还是
抛出了异常。

让客户代码看上去更像内建控制结构的一种方式是使用大括号代替小括号包围参数列表。
Scala的任何方法调用，如果你确实只传入一个参数，就能可选地使用大括号替代小括号
包围参数：

{{{class="brush: scala"
  scala> println("Hello, world!")
  Hello, world!
  
  scala> println { "Hello, world!" }
  Hello, world!  
}}}

这个大括号技巧仅在你传入一个参数时有效，多个参数只能用小括号：

{{{class="brush: scala"
  scala> val g = "Hello, world!"
  g: java.lang.String = Hello, world!
  
  scala> g.substring(7, 9)
  res12: java.lang.String = wo 

  scala> g.substring { 7, 9 }
  <console>:1: error: ';' expected but ',' found.
         g.substring { 7, 9 }
                        ^ 
}}}

以前面例子里定义的`withPrintWriter`方法举例。在它最近的形式里，`withPrintWriter`
带了两个参数，因此你不能使用大括号。虽然如此，因为传递给`withPrintWriter`的函数
是列表的最后一个参数，你可以使用curry化把第一个参数，`File`拖入分离的参数列表。
这将使函数仅剩下列表的第二个参数作为唯一的参数：

{{{class="brush: scala"
  def withPrintWriter(file: File)(op: PrintWriter => Unit) {
    val writer = new PrintWriter(file)
    try {
      op(writer)
    } finally {
      writer.close()
    }
  } 
}}}

可以用更赏心悦目的语法格式调用这个方法：

{{{class="brush: scala"
  val file = new File("date.txt")

  withPrintWriter(file) {
    writer => writer.println(new java.util.Date)
  } 
}}}

第一个参数列表，包含了一个File参数，被写成包围在小括号中。第二个参数列表，包含了
一个函数参数，被包围在大括号中。


== 传名参数 ==

上节展示的`withPrintWriter`方法不同于语言的内建控制结构，如`if`和`while`，在于
大括号之间的代码带了参数。`withPrintWriter`方法需要一个类型为`PrintWriter`的参数
。这个参数以`writer =>`方式显示出来：

{{{class="brush: scala"
  withPrintWriter(file) {
    writer => writer.println(new java.util.Date)
  } 
}}}

然而如果你想要实现某些更像if或while的东西，根本没有值要传入大括号之间的代码，
那该怎么做呢？为了解决这种情况，Scala提供了传名参数。

为了举一个有现实意义的例子：虽然Scala提供了它自己的`assert`，但是用户想自己实现
一个称为`myAssert`的断言架构。

`myAssert`函数将带一个函数值做输入并参考一个标志位来决定该做什么。如果标志位被
设置了，`myAssert`将调用传入的函数并证实其返回`true`。如果标志位被关闭了，
`myAssert`将安静地什么都不做。 如果没有传名参数，你可以这样写`myAssert`：

{{{class="brush: scala"
  var assertionsEnabled = true

  def myAssert(predicate: () => Boolean) =
    if (assertionsEnabled && !predicate())
      throw new AssertionError 
}}}

用函数字面量的简写方式可以让代码短很多。但函数字面量的简写方式只能用在有参数的
情况下，用占位符`_`来代替参数。没有参数也就不能用函数了面量的简写形式。

所以说现在不爽的地方是虽然用不到参数，但调用时却不能省略`() =>`：

{{{class="brush: scala"
  myAssert(() => 5 > 3) 

  myAssert(5 > 3) // Won't work, because missing () =>  
}}}

传名函数恰好为了实现你的愿望而出现。要实现一个传名函数，要定义参数的类型开始于
`=>`而不是`() =>`。如，改`() => Boolean`为`=> Boolean`：

{{{class="brush: scala"
  def byNameAssert(predicate: => Boolean) =
    if (assertionsEnabled && !predicate)
      throw new AssertionError 
}}}

现在可以省略了，看起来像语言内建的控制结构一样：

{{{class="brush: scala"
  byNameAssert(5 > 3) 
}}}

传名类型中，空的参数列表`()`被省略，它仅在参数中被允许。没有什么传名变量或
传名字段这样的东西。 

对于`myAssert`，我们费了这么大的力气，只是为了让函数字面量看起来像表达式，那
为什么不直接用`Boolean`变量作为参数呢？

{{{class="brush: scala"
  def boolAssert(predicate: Boolean) =
    if (assertionsEnabled && !predicate)
      throw new AssertionError 
}}}

当然这种格式同样合法，并且使用这个版本`boolAssert`的代码看上去仍然与前面的一样：

{{{class="brush: scala"
  boolAssert(5 > 3) 
}}}

虽然如此，这两种方式之间存在一个非常重要的差别须指出：表达式会在传入参数前先被
执行。

所以在上面的例子中，如果断言被禁用，你会看到`boolAssert`括号里的表达式的某些
副作用，而`byNameAssert`却没有。例如，如果断言被禁用，`boolAssert`的例子里尝试
对`x / 0 == 0`的断言将产生一个异常：
                    
{{{class="brush: scala"
  scala> var assertionsEnabled = false
  assertionsEnabled: Boolean = false

  scala> boolAssert(x / 0 == 0)
  java.lang.ArithmeticException: / by zero
  	   at .<init>(<console>:8)
          at .<clinit>(<console>)
          at RequestResult$.<init>(<console>:3)
          at RequestResult$.<clinit>(<console>)...
}}}

但在`byNameAssert`的例子里尝试同样代码的断言将不产生异常：

{{{class="brush: scala"
  scala> byNameAssert(x / 0 == 0) 
}}}



= 组合与继承 =


== 定制一个二维布局库 ==

作为本章运行的例子，我们将创造一个制造和渲染二维布局元素的库。每个元素将代表一个
填充字符的长方形。方便起见，库将提供名为`elem`的工厂方法来通过传入的数据构造新的
元素。例如，你将能通过工厂方法采用下面的写法创建带有字串的元素：

{{{class="brush: scala"
  elem(s: String): Element 
}}}

元素将以名为`Element`的类型为模型。你将能在元素上调用`above`或`beside`，把另一个
元素放在当前元素的右边或是上边：

{{{class="brush: scala" 
  val column1 = elem("hello") above elem("***")
  val column2 = elem("***") above elem("world")
  column1 beside column2
}}}

打印这个表达式的结果将是：

{{{class="brush: scala" 
  hello ***  
   *** world
}}}

== 抽象类 ==

=== abstract声明抽象类 ===

布局元素名为`Element`，存放的文本内容类型为`Array[String]`。提供方法`contents`
取得存放的文本内容，但没有定义实现方式，所以这个类是抽象类，要加上`abstract`
关键字：

{{{class="brush: scala"
  abstract class Element {
    def contents: Array[String]
  } 
}}}

=== 抽象方法 ===

注意：类`Element`的`contents`方法并没带有`abstract`修饰符。不像Java，方法的声明
中不需要（也不允许）抽象修饰符。如果方法没有实现，它就是抽象的。

另一个术语用法需要分辨声明（declaration）和定义（definition）。类`Element`声明了
抽象方法`contents`，但当前没有定义具体方法。

=== 抽象字段 ===

{{{class="brush: scala"
abstract class Person {
	val id: Int
	val Name: String
}}}

这两个字段并没有生成在对应的Java类中，产生的只有对应的方法：

* `val`只有抽象`getter`方法。
* `var`有抽象的`getter`与`setter`方法。

实现类要提供具体的字段，对于抽象的字段不用加`abstract`：

{{{class="brush: scala"
class Employee(val: id: Int) extends Person {
	var name = ""
}
}}}

实现类可以是一个匿名类：

{{{class="brush: scala"
val fred = new Person {
	val id = 1729
	var name = "Fred"
}
}}}

== 定义无参数方法 ==

添加显示宽度和高度的方法：`height`方法返回`contents`里的行数。`width`方法返回
第一行的长度，或如果元素没有行记录，返回零。（也就是说你不能定义一个高度为零但
宽度不为零的元素。）

{{{class="brush: scala"
  abstract class Element {
    def contents: Array[String]
    def height: Int = contents.length
    def width: Int = if (height == 0) 0 else contents(0).length
  } 
}}}

三个方法没一个有参数列表，甚至连个空列表都没有。如：

{{{class="brush: scala"
  def width(): Int
  // 省略括号
  def width: Int 
}}}

推荐的惯例是在没有参数并且方法仅通过读含有对象的方式访问可变状态（专指其不改变
可变状态）时使用无参数方法。这样感觉上就和只读字段一样，其实也可以选择把`width`
和`height`作为字段而不是方法来实现，只要简单地在每个实现里把`def`修改成`val`
即可：

{{{class="brush: scala" 
  abstract class Element {
    def contents: Array[String]
    val height = contents.length
    val width = 
      if (height == 0) 0 else contents(0).length
  }
}}}

两组定义从客户的观点来看是完全相同的。唯一的差别是字段的访问或许稍微比方法调用要
快，因为字段值在类被初始化的时候被预计算，而方法调用在每次调用的时候都要计算。

换句话说，字段在每个`Element`对象上需要更多的内存空间。因此类的使用概况，属性
表达成字段还是方法更好，决定了其实现，并且这个概况还可以随时改变。

重点是`Element`类的客户不应在其内部实现改变的时候受影响。

特别是如果类的字段变成了访问函数，且访问函数是纯的，就是说它没有副作用并且
不依赖于可变状态，那么类`Element`的客户不需要被重写。客户都不应该需要关心这些。

目前为止一切良好。但仍然有些琐碎的复杂的东西要去做以协同Java处理事情的方式。问题
在于Java没有实现统一访问原则。因此Java里是`string.length()`，不是`string.length`
（尽管是`array.length`，不是`array.length()`）。不用说，这让人很困惑。

为了在这道缺口上架一座桥梁，Scala在遇到混合了无参数和空括号方法的情况时很大度。
特别是，你可以用空括号方法重载无参数方法，并且反之亦可。你还可以在调用任何不带
参数的方法时省略空的括号。例如，下面两行在Scala里都是合法的：

{{{class="brush: scala" 
  Array(1, 2, 3).toString
  "abc".length
}}}

原则上Scala的函数调用中可以省略所有的空括号。然而，在调用的方法表达的超过其接收
调用者对象的属性时，推荐仍然写一对空的括号。例如，如果方法执行了I/O，或写入
可重新赋值的变量（var），或读出不是接受调用者的字段的var，无论是直接的还是非直接
的通过使用可变对象，那么空括号是合适的。这种方式是让参数列表扮演一个可见的线索
说明某些有趣的计算正通过调用被触发。例如：

{{{class="brush: scala" 
  "hello".length  // no () because no side-effect
  println()       // better to not drop the ()
}}}

总结起来，Scala里定义不带参数也没有副作用的方法为无参数方法，也就是说，省略空的
括号，是鼓励的风格。另一方面，永远不要定义没有括号的带副作用的方法，因为那样的话
方法调用看上去会像选择一个字段。这样你的客户看到了副作用会很奇怪。相同地，当你
调用带副作用的函数，请确信写这个调用的时候包括了空的括号。另一种考虑这个问题的
方式是，如果你调用的函数执行了操作，使用括号，但如果仅提供了对某个属性的访问，
省略括号。


== 扩展类 ==

实例化一个元素，我们需要创建扩展了`Element`并实现抽象的`contents`方法的子类。

{{{class="brush: scala" 
  class ArrayElement(conts: Array[String]) extends Element {
    def contents: Array[String] = conts
  }
}}}

这种`extends`子句有两个效果：使类`ArrayElement`从类`Element`继承所有非私有的成员
，并且使`ArrayElement`成为`Element`的子类型。由于`ArrayElement`扩展了`Element`，
类`ArrayElement`被称为类`Element`的子类。反过来，`Element`是`ArrayElement`的超类
。

如果你省略`extends`子句，Scala编译器隐式地假设你的类扩展自`scala.AnyRef`，在Java
平台上与`java.lang.Object`一致。因此，类`Element`隐式地扩展了类`AnyRef`。

`ArrayElement`的`contents`方法实现了类`Element`的抽象方法`contents`：

{{{class="brush: scala" 
  scala> val ae = new ArrayElement(Array("hello", "world"))
  ae: ArrayElement = ArrayElement@d94e60

  scala> ae.width
  res1: Int = 5
}}}

子类型化（subtyping）是指子类的值可以被用在需要其超类的值的任何地方。例如：

{{{class="brush: scala" 
  val e: Element = new ArrayElement(Array("hello"))
}}}

如果子类中的字段与超类同名，或是子类的中的方法名称和参数与超类类完全一样，就会
覆盖（override）超类中的版本。而且Scala里强制如果覆盖了就一定要加上`override`
修饰符。

== 重写方法和字段 ==

=== 命名空间 ===

Java为定义准备了四个命名空间：字段，方法，类型和包。

而Scala仅有两个,与Java的四个命名空间相对：

* 值（字段，方法，包还有单例对象）
* 类型（类和特质名）

Scala把字段和方法放进同一个命名空间的理由很清楚，因为这样你就可以使用`val`重重写
无参数的方法，这种你在Java里做不到的事情。

字段和方法属于相同的命名空间。这使得字段重写无参数方法成为可能。比如说，你可以
改变类`ArrayElement`中`contents`的实现，从一个方法变为一个字段，而无需修改类
`Element`中`contents`的抽象方法定义：

{{{class="brush: scala" 
  class ArrayElement(conts: Array[String]) extends Element {
    val contents: Array[String] = conts
  }
}}}

这个`ArrayElement`的版本里，字段`contents`（用`val`定义）完美地实现了类`Element`
里的无参数方法`contents`（用`def`定义）。 

另一方面，Scala里禁止在同一个类里用同样的名称定义字段和方法，而在Java里这样做
被允许。例如，下面的Java类能够很好地编译：

{{{class="brush: scala" 
  // This is Java
  class CompilesFine {
    private int f = 0;
    public int f() {
      return 1;
    }
  }
}}}

但是相应的Scala类将不能编译：

{{{class="brush: scala" 

  class WontCompile {
    private var f = 0 // Won't compile, because a field 
    def f = 1         // and method have the same name
  }

}}}


=== 使用override修饰符 ===

考虑一下这样的场景：

基类和子类是不同的人维护的。原来基类里没有`add`方法，所以子类里加上了。后来
基类里也加上了`add`方法，但维护子类的人不知道。这样的规定是为了防止“脆基类”问题
。

所以Scala里`override`有强制的规定：

* 如果实现了抽象成员，加不加随便。
* 如果重载了具体实现，就一定要加。
* 没有重载就绝不能加。

这样起码保证了维护子类的人知道自己会覆盖超类的方法。


=== 不可重写 final ===

Scala中字段与方法都可以用`final`修饰为不可重写（因为Scala的字段也是可以重写为
方法的）。注意这与Java不一样，Java里`final`字段表示不可改变，而Scala里已经有
`val`表示不可改变了。


=== 重写限制 ===

概括：

* `def`只能重写另一个`def`
* `val`只能重写另一个`val`与无参`def`
* `var`只能重写另一个抽象的`var`

详述：

* 用val
	- 重写val：
		* 超类同名的私有字段
		* 重写超类的getter方法
	- 重写def：
		* 子类有一个私有字段
		* 重写超类的getter方法
	- 重写var：错误
* 用def
	- 重写val：错误
	- 重写def：同Java
	- 重写var：错误
* 用var
	- 重写val：错误
	- 重写def：同时重写getter/setter。只重写getter会报错
	- 重写var：重写超类的抽象var

在当前类中，随时可以对`getter`与`setter`重新实现`var`，但在子类中不能通过
`getter`与`setter`重新实现`var`，只能接受现有的实现。

== 类型检查和转换 ==

| Scala                   | Java                 |
| obj.isInstanceOf[Clazz] | obj instanceof Clazz |
| obj.asInstanceOf[Clazz] | (Clazz) obj          |
| classOf[Clazz]          | Clazz.class          |

相比类型检查与转换，Scala更加推荐模式匹配的方式。

== 定义参数化字段 ==

`ArrayElement`类的定义。它有一个参数`conts`，其唯一目的是被复制到`contents`字段
。选择`conts`这个参数的名称只是为了让它看上去更像字段名`contents`而又不会因为
名字一样而发生实际冲突。这是一种“代码异味”，一个表明或许某些不必须的累赘和重复。

可以通过在单一的参数化字段（parametric field）定义中组合参数和字段避免：

{{{class="brush: scala" 
  class ArrayElement(val contents: Array[String]) extends Element
}}}

注意用的是`val`，所以现在拥有一个可以从类外部访问的，（不能重新赋值的）字段
`contents`。字段使用参数值初始化。等同于：

{{{class="brush: scala"
  class ArrayElement(x123: Array[String]) extends Element { 
    val contents: Array[String] = x123
  } 
}}}

同样也可以使用`var`前缀类参数，这种情况下相应的字段将能重新被赋值。还有可能添加
如`private`、`protected`或`override`这类的修饰符到这些参数化字段上，就好象
你可以在其他类成员上做的事情：

{{{class="brush: scala" 
  class Cat {
    val dangerous = false
  }
  class Tiger(
    override val dangerous: Boolean,
    private var age: Int
  ) extends Cat
}}}

Tiger的定义是以下包括重写成员`dangerous`和`private`成员`age`的类定义替代写法的
简写：

{{{class="brush: scala" 
  class Tiger(param1: Boolean, param2: Int) extends Cat {
    override val dangerous = param1
    private var age = param2
  }
}}}



== 调用超类构造器 ==

如果再要新的子类：

{{{class="brush: scala" 
  class LineElement(s: String) extends ArrayElement(Array(s)) {
    override def width = s.length
    override def height = 1
  }
}}}

由于`LineElement`扩展了`ArrayElement`，并且`ArrayElement`的构造器带一个参数
（Array[String]），LineElement需要传递一个参数到它的超类的主构造器。要调用超类
构造器，只要把你要传递的参数或参数列表放在超类名之后的括号里）即可。

=== 只有主构造器可以调用超类构造器 ===

Scala中辅助构造器不能调用超类构造器，只有主构造器可以调用超类构造器。

=== 构造顺序 ===

Scala与Java有一个共同的问题：超类的构造器会调用被子类覆盖的方法。

用动物的视力（或感知以距离）来作为例子：

* 默认动物的视力为10
* 蚂蚁的视力只有2

{{{class="brush: scala" 
class Creature {
	val range: Int = 10
	val env: Array[Int] = new array[Int](range)
}

class Ant extends Creature {
	override val range = 2
}
}}}

如果初始化`Ant`实例，过程比较复杂：

# 调用超类构造器，设置`range`为10。
# 超类构造器初始化`env`长度时要用到`range`，发现`range`被子类重写。
# 调用子类的`range`，但是子类还没有初始化，所以`range`值为`0`。
# `env`被初始化为长度为0的数组。超类构造器执行完毕。
# 子类构造器开始执行，把`range`设置为2.

解决的方案：

* `final val`声明不能覆盖，这样安全但是不灵活。
* `lazy`懒加载。安全但是影响性能。
* 预初始化。接下来就讲。

==== 预初始化 ====

用`with`代替`extends`，并给字段定义加上花括号，放在超类的构造器之前：

{{{class="brush: scala" 
class Ant {
	override val range = 2
} with Creature
}}}

由于预初始化的字段的超类构造器调用前被初始化，所以不能引用正在被构造的对象。所以
对于`this`实际指向的是正被构造的类或对象的对象，而来是被构造的对象本身。

== 多态和动态绑定 ==

创建一个新的子类，它可以按给出的长度宽度，用指定的字符填充：

{{{class="brush: scala" 
  class UniformElement(
    ch: Char, 
    override val width: Int,
    override val height: Int 
  ) extends Element {
    private val line = ch.toString * width
    def contents = Array.make(height, line)
  }
}}}

父类的变量可以存放子类的实例，就是多态的一种体现。这么多子类都可以用父类的变量来
存放：

{{{class="brush: scala" 
  val e1: Element = new ArrayElement(Array("hello", "world"))
  val ae: ArrayElement = new LineElement("hello")
  val e2: Element = ae
  val e3: Element = new UniformElement('x', 2, 3)
}}}

变量和表达式上的方法调用是动态绑定（dynamically bound）的。这意味着被调用的
实际方法实现取决于运行期对象其实的类，而不是变量或表达式的类型。

为了演示这种行为，我们会从我们的`Element`类中临时移除所有存在的成员并添加一个名
为`demo`的方法。我们会在`ArrayElement`和`LineElement`中重写`demo`，但
`UniformElement`除外：

{{{class="brush: scala" 
  abstract class Element {
    def demo() {
      println("Element's implementation invoked")
    }
  }

  class ArrayElement extends Element {
    override def demo() {
      println("ArrayElement's implementation invoked")
    }
  }

  class LineElement extends ArrayElement {
    override def demo() {
      println("LineElement's implementation invoked")
    }
  }

  // UniformElement inherits Element's demo
  class UniformElement extends Element 
}}}

如果你把这些代码输入到了解释器中，那么你就能定义这个带了一个`Element`并调用
`demo`的方法：

{{{class="brush: scala" 
  def invokeDemo(e: Element) {
    e.demo()
  }
}}}

如果你传给`invokeDemo`一个`ArrayElement`，你会看到一条消息指明`ArrayElement`的
`demo`实现被调用，尽管被调用`demo`的变量`e`的类型是`Element`： 

{{{class="brush: scala" 
  scala> invokeDemo(new ArrayElement)
  ArrayElement's implementation invoked
}}}

相同的，如果你传递`LineElement`给`invokeDemo`，你会看到一条指明`LineElement`的
`demo`实现被调用的消息：

{{{class="brush: scala" 
  scala> invokeDemo(new LineElement)
  LineElement's implementation invoked
}}}

传递`UniformElement`时的行为一眼看上去会有些可以，但是正确：

{{{class="brush: scala" 
  scala> invokeDemo(new UniformElement)
  Element's implementation invoked
}}}

因为`UniformElement`没有重写`demo`，它从它的超类`Element`继承了`demo`的实现。
因此，当对象的类是`UniformElement`时，`Element`的实现就是要调用的`demo`的正确
实现。



== 使用组合与继承 ==

组合与继承是利用其它现存类定义新类的两个方法。

如果你接下来的工作主要是代码重用，通常你应采用组合而不是继承。只有继承受脆基类
问题困扰，这种情况你可能会无意中通过改变超类而破坏了子类。

关于继承关系你可以问自己一个问题，是否它建模了一个is-a关系。你能问的另一个问题是
，是否客户想要把子类类型当作超类类型来用。



== 实现示例中的功能 ==

把一个元素放在另一个上面是指串连这两个元素的`contents`值。

{{{class="brush: scala" 
  def above(that: Element): Element =
    new ArrayElement(this.contents ++ that.contents)
}}}

操作符`++`把两个元素靠在一起，我们将创造一个新的元素，其中的每一行都来自于两个
元素的相应行的串连。

{{{class="brush: scala" 
  def beside(that: Element): Element = {
    val contents = new Array[String](this.contents.length)
    for (i <- 0 until this.contents.length) 
      contents(i) = this.contents(i) + that.contents(i)
    new ArrayElement(contents)
  }

}}}

索引数组的循环是指令式风格。这个方法可以替代缩减成一个表达式：

{{{class="brush: scala" 
  new ArrayElement(
    for (
      (line1, line2) <- this.contents zip that.contents
    ) yield line1 + line2
  )
}}}

`zip`操作符转换为一个对子的数组（可以称为`Tupele2`）。`zip`方法从它的两个参数中
拣出相应的元素并组织成对子数组。

例如，表达式：

{{{class="brush: scala" 
  Array(1, 2, 3) zip Array("a", "b")
}}}

将生成：

{{{class="brush: scala" 
  Array((1, "a"), (2, "b"))
}}}

如果两个操作数组的其中一个比另一个长，zip将舍弃余下的元素。

定义`toString`方法返回元素格式化成的字串：

{{{class="brush: scala" 
  override def toString = contents mkString "\n"
}}}

最后是这个样子：

{{{class="brush: scala" 
  abstract class Element {

    def contents: Array[String]

    def width: Int =
      if (height == 0) 0 else contents(0).length

    def height: Int = contents.length

    def above(that: Element): Element =
      new ArrayElement(this.contents ++ that.contents)

    def beside(that: Element): Element =
      new ArrayElement(
        for (
          (line1, line2) <- this.contents zip that.contents
        ) yield line1 + line2
      )

    override def toString = contents mkString "\n"
  }
}}}



== 定义工厂对象 ==

最直接的方案是创建类`Element`的伴生对象并把它做成布局元素的工厂方法。这种方式
唯一要暴露给客户的就是`Element`的类/对象组合，隐藏它的三个实现类`ArrayElement`，
`LineElement`和`UniformElement`。

{{{class="brush: scala" 
  object Element {

    def elem(contents: Array[String]): Element = 
      new ArrayElement(contents)

    def elem(chr: Char, width: Int, height: Int): Element = 
      new UniformElement(chr, width, height)

    def elem(line: String): Element = 
      new LineElement(line)
  }

}}}

这些工厂方法使得改变类`Element`的实现通过使用`elem`工厂方法实现而不用`new`操作
产新的`ArrayElement`实例成为可能。

为了不使用单例对象的名称`Element`从而化调用工厂方法，我们将在源文件引入
`Element.elem`。

换句话说，代之以在`Element`类内部使用`Element.elem`调用工厂方法，我们将引用
`Element.elem`，这样我们只要使用它们的简化名，`elem`，就可以调用工厂方法。

{{{class="brush: scala" 
  import Element.elem

  abstract class Element {

    def contents: Array[String]

    def width: Int =
      if (height == 0) 0 else contents(0).length

    def height: Int = contents.length

    def above(that: Element): Element =
      elem(this.contents ++ that.contents)

    def beside(that: Element): Element =
      elem(
        for (
          (line1, line2) <- this.contents zip that.contents
        ) yield line1 + line2
      )

    override def toString = contents mkString "\n"
  }

}}}

有了工厂方法之后，子类`ArrayElement`，`LineElement`和`UniformElement`不再需要
直接被客户访问，所以可以改成是私有的。

Scala里，你可以在类和单例对象中定义其它的类和单例对象。因此一种让`Element`的子类
私有化的方式就是把它们放在`Element`单例对象中并在那里声明它们为私有。需要的时候
，这些类将仍然能被三个`elem`工厂方法访问。

{{{class="brush: scala"   object Element {
    private class ArrayElement(
      val contents: Array[String]
    ) extends Element

    private class LineElement(s: String) extends Element {
      val contents = Array(s)
      override def width = s.length
      override def height = 1
    }

    private class UniformElement(
      ch: Char,
      override val width: Int,
      override val height: Int
    ) extends Element {
      private val line = ch.toString * width
      def contents = Array.make(height, line)
    }

    def elem(contents:  Array[String]): Element =
      new ArrayElement(contents)

    def elem(chr: Char, width: Int, height: Int): Element =
      new UniformElement(chr, width, height)

    def elem(line: String): Element =
      new LineElement(line)
  }
}}}




== 变高变宽 ==

Element的版本并不完全，因为他不允许客户把不同宽度的元素堆叠在一起，或者不同高度
的元素靠在一起。比方说，下面的表达式将不能正常工作，因为组合元素的第二行比第一行
要长：

{{{class="brush: scala" 
  new ArrayElement(Array("hello")) above 
  new ArrayElement(Array("world!"))
}}}

与之相似的，下面的表达式也不能正常工作：

{{{class="brush: scala" 

  new ArrayElement(Array("one", "two")) beside 
  new ArrayElement(Array("one"))
}}}

添加私有帮助方法`widen`通过带个宽度做参数并返回那个宽度的`Element`。`heighten`，
能在竖直方向执行同样的功能。

{{{class="brush: scala" 
  import Element.elem

  abstract class Element {
    def contents:  Array[String]

    def width: Int = contents(0).length
    def height: Int = contents.length

    def above(that: Element): Element = {
      val this1 = this widen that.width
      val that1 = that widen this.width
      elem(this1.contents ++ that1.contents)
    }

    def beside(that: Element): Element = {
      val this1 = this heighten that.height
      val that1 = that heighten this.height
      elem(
        for ((line1, line2) <- this1.contents zip that1.contents) 
        yield line1 + line2)
    }

    def widen(w: Int): Element = 
      if (w <= width) this
      else {
        val left = elem(' ', (w - width) / 2, height) 
        var right = elem(' ', w - width - left.width, height)
        left beside this beside right
      }

    def heighten(h: Int): Element = 
      if (h <= height) this
      else {
        val top = elem(' ', width, (h - height) / 2)
        var bot = elem(' ', width, h - height - top.height)
        top above this above bot
      }

    override def toString = contents mkString "\n"
  }
}}}

== 完整的示例代码 ==

写一个画给定数量边界的螺旋的程序。

{{{class="brush: scala" 
// In file compo-inherit/Spiral.scala

  import Element.elem

  object Spiral {

    val space = elem(" ")
    val corner = elem("+")

    def spiral(nEdges: Int, direction: Int): Element = {
      if (nEdges == 1)
        elem("+")
      else {
        val sp = spiral(nEdges - 1, (direction + 3) % 4)
        def verticalBar = elem('|', 1, sp.height)
        def horizontalBar = elem('-', sp.width, 1)
        if (direction == 0)
          (corner beside horizontalBar) above (sp beside space)
        else if (direction == 1)
          (sp above space) beside (corner above verticalBar)
        else if (direction == 2)
          (space beside sp) above (horizontalBar beside corner)
        else
          (verticalBar above corner) beside (space above sp)
      }
    }

    def main(args: Array[String]) {
      val nSides = args(0).toInt
      println(spiral(nSides, 0))
    }
  }
}}}



{{{class="brush: scala" 
$ scala Spiral 6    $ scala Spiral 11    $ scala Spiral 17
+-----              +----------          +----------------
|                   |                    |                
| +-+               | +------+           | +------------+ 
| + |               | |      |           | |            | 
|   |               | | +--+ |           | | +--------+ | 
+---+               | | |  | |           | | |        | | 
                    | | ++ | |           | | | +----+ | | 
                    | |    | |           | | | |    | | | 
                    | +----+ |           | | | | ++ | | | 
                    |        |           | | | |  | | | | 
                    +--------+           | | | +--+ | | | 
                                         | | |      | | | 
                                         | | +------+ | | 
                                         | |          | | 
                                         | +----------+ | 
                                         |              | 
                                         +--------------+ 
}}}


= Scala类的层级 =

Scala里，每个类都继承自通用的名为`Any`的超类。因为所有的类都是`Any`的子类，那么
定义在`Any`中的方法就是“普遍”方法：它们可以被任何对象调用。

Scala还在层级的底端定义了`Null`和`Nothing`，主要都扮演通用的子类。例如，就像说
`Any`是所有其它类的超类，`Nothing`是所有其它类的子类。

<img src="images/scala/scala.hirtc.png" alt="scala.hirtc" />



== Scala类的概览 ==

层级的顶端是类`Any`，定义了包含下列的方法：

{{{class="brush: scala" 
  final def ==(that: Any): Boolean
  final def !=(that: Any): Boolean
  def equals(that: Any): Boolean
  def hashCode: Int
  def toString: String
}}}

类Any里的`=`和`!=`，被声明为`final`，因此它们不能在子类里面重载。实际上，`==`
总是与`equals`相同，`!=`总是与`equals`相反。因此独立的类可以通过重载`equals`方法
修改`==`或`!=`的意义。

根类`Any`有两个子类：`AnyVal`和`AnyRef`。

=== 值类型（AnyVal） ===

`AnyVal`是Scala里每个内建值类型的父类。有九个这样的值类型：`Byte`，`Short`，
`Char`，`Int`，`Long`，`Float`，`Double`，`Boolean`和`Unit`。其中的前八个对应到
Java的原始类型，它们的值在运行时表示成Java的原始值。

Scala里这些类的实例都写成字面量，不能使用`new`创造这些类的实例。值类都被定义为
即是抽象的又是`final`的，强制贯彻。因此如果你写了`new`就会出错：

{{{class="brush: scala"   
  scala> new Int
  <console>:5: error: class Int is abstract; cannot be 
  instantiated
         new Int
         ^
}}}

另一个值类型`Unit`大约对应于Java的`void`类型；被用作不返回任何有趣结果的方法的
结果类型。`Unit`只有一个实例值，被写作`()`。

值类型支持作为方法的通用的数学和布尔操作符。例如，`Int`有名为`+`和`*`的方法，
`Boolean`有名为`||`和`&&`的方法。值类型也从类`Any`继承所有的方法：

{{{class="brush: scala" 
  scala> 42 max 43
  res4: Int = 43

  scala> 42 min 43
  res5: Int = 42

  scala> 1 until 5
  res6: Range = Range(1, 2, 3, 4)

  scala> 1 to 5
  res7: Range.Inclusive = Range(1, 2, 3, 4, 5)

  scala> 3.abs
  res8: Int = 3

  scala> (-3).abs
  res9: Int = 3
}}}

值类型的空间是扁平的；所有的值类型都是`scala.AnyVal`的子类型，但是它们不是互相的
子类。代之以它们不同的值类型之间可以隐式地互相转换。例如，需要的时候，类
`scala.Int`的实例可以自动放宽（通过隐式转换）到类`scala.Long`的实例。


隐式转换还用来为值类型添加更多的功能。例如，类型`Int`支持以下所有的操作：

{{{class="brush: scala" 
  scala> 42 max 43
  res4: Int = 43

  scala> 42 min 43
  res5: Int = 42

  scala> 1 until 5
  res6: Range = Range(1, 2, 3, 4)

  scala> 1 to 5
  res7: Range.Inclusive = Range(1, 2, 3, 4, 5)

  scala> 3.abs
  res8: Int = 3

  scala> (-3).abs
  res9: Int = 3
}}}

工作原理：

方法`min`，`max`，`until`，`to`和`abs`都定义在类`scala.runtime.RichInt`里，并且
有一个从类`Int`到`RichInt`的隐式转换。当你在Int上调用没有定义在`Int`上但定义在
`RichInt`上的方法时，这个转换就被应用了：


=== 引用类型（AnyRef） ===

类`Any`的另一个子类是类`AnyRef`。这个是`Scala`里所有引用类的基类。正如前面提到的
，在Java平台上`AnyRef`实际就是类`java.lang.Object`的别名。因此Java里写的类和
`Scala`里写的都继承自`AnyRef`。

存在`AnyRef`别名代替使用`java.lang.Object`名称的理由是，Scala被设计成可以同时
工作在Java和.Net平台。在.NET平台上，`AnyRef`是`System.Object`的别名。 

可以认为`java.lang.Object`是Java平台上实现`AnyRef`的方式。因此，尽管你可以在Java
平台上的Scala程序里交换使用`Object`和`AnyRef`，推荐的风格是在任何地方都只使用
`AnyRef`。

Scala类与Java类不同在于它们还继承自一个名为`ScalaObject`的特别的记号特质。理念是
`ScalaObject`包含了Scala编译器定义和实现的方法，目的是让Scala程序的执行更有效。
到现在为止，Scala对象包含了单个方法，名为`$tag`，用于内部以提速模式匹配。



== 原始类型是如何实现的 ==

Scala以与Java同样的方式存储整数：把它当作32位的字。这对在JVM上的效率以及与Java库
的互操作性方面来说都很重要。标准的操作如加法或乘法都被实现为原始操作。然而，当
整数需要被当作（Java）对象看待的时候，Scala使用了“备份”类`java.lang.Integer`。
如在整数上调用`toString`方法或者把整数赋值给Any类型的变量时，就会这么做。

所有这些听上去都近似Java5里的自动装箱并且它们的确很像。不过有一个关键差异，Scala
里的装箱比Java里的更少看见。尝试下面的Java代码：

{{{class="brush: scala" 
  // This is Java
  boolean isEqual(int x, int y) {
    return x == y;
  }
  System.out.println(isEqual(421, 421));
}}}

当然会得到`true`。现在，把`isEqual`的参数类型变为`java.lang.Integer`（或`Object`
，结果都一样）：

{{{class="brush: scala" 
  // This is Java
  boolean isEqual(Integer x, Integer y) {
    return x == y;
  }
  System.out.println(isEqual(421, 421));
}}}

却得到了`false`！原因是数`421`被装箱了两次，因此参数`x`和`y`是两个不同的对象。

因为在引用类型上`==`表示引用相等，而`Integer`是引用类型，所以结果是`false`。这是
展示了Java不是纯面向对象语言的一个方面。我们能清楚观察到原始类型和引用类型之间的
差别。

现在在Scala里尝试同样的实验：

{{{class="brush: scala" 
  scala> def isEqual(x: Int, y: Int) = x == y
  isEqual: (Int,Int)Boolean

  scala> isEqual(421, 421)
  res10: Boolean = true

  scala> def isEqual(x: Any, y: Any) = x == y
  isEqual: (Any,Any)Boolean

  scala> isEqual(421, 421)
  res11: Boolean = true
}}}

实际上Scala里的相等操作`==`被设计为透明的参考类型代表的东西。对值类型来说，就是
自然的（数学或布尔）相等。对于引用类型，`==`被视为继承自`Object`的`equals`方法的
别名。这个方法被初始地定义为引用相等，但被许多子类重载实现它们种族的相等概念。
这也意味着Scala里你永远也不会落入Java知名的关于字串比较的陷阱。Scala里，字串比较
以其应有的方式工作：

{{{class="brush: scala" 
  scala> val x = "abcd".substring(2)
  x: java.lang.String = cd

  scala> val y = "abcd".substring(2)
  y: java.lang.String = cd

  scala> x == y
  res12: Boolean = true
}}}

Java里，`x`与`y`的比较结果将是`false`。程序员在这种情况应该用`equals`，不过它
容易被忘记。

然而，有些情况你需要使用引用相等代替用户定义的相等。

例如，某些时候效率是首要因素，你想要把某些类哈希合并（hash cons）然后通过引用
相等比较它们的实例（类实例的哈希合并是指把创建的所有实例缓存在弱集合中。然后，
一旦需要类的新实例，首先检查缓存。如果缓存中已经有一个元素等于你打算创建的，你
可以重用存在的实例。这样安排的结果是，任何以`equals()`判断相等的两个实例同样在
引用相等上判断一致。）。

为这种情况，类AnyRef定义了附加的`eq`方法，它不能被重载并且实现为引用相等（也就
是说，它表现得就像Java里对于引用类型的`==`那样）。同样也有一个`eq`的反义词，被
称为`ne`。例如：

{{{class="brush: scala" 
  scala> val x = new String("abc")
  x: java.lang.String = abc

  scala> val y = new String("abc")
  y: java.lang.String = abc

  scala> x == y
  res13: Boolean = true

  scala> x eq y
  res14: Boolean = false

  scala> x ne y
  res15: Boolean = true
}}}

== 底层类型 ==

层级的底部你看到了两个类`scala.Null`和`Scala.Nothing`。它们是用统一的方式处理
某些Scala的面向对象类型系统的“边界情况”的特殊类型。

类`Null`是`null`类型的引用；它是每个引用类（就是说，每个继承自`AnyRef`的类）的
子类。`Null`不兼容值类型。比方说，不可把`null`值赋给整数变量：

{{{class="brush: scala" 
  scala> val i: Int = null
  <console>:4: error: type mismatch;
   found   : Null(null)
   required: Int
}}}

类型`Nothing`在`Scala`的类层级的最底端；它是任何其它类型的子类型。然而，根本没有
这个类型的任何值。要一个没有值的类型有什么意思呢？在控制结构的try-catch中讨论过
，`Nothing`的一个用处是它标明了不正常的终止。例如Scala的标准库中的`Predef`对象
有一个`error`方法，如下定义：

{{{class="brush: scala" 
  def error(message: String): Nothing =
    throw new RuntimeException(message)
}}}

`error`的返回类型是`Nothing`，告诉用户方法不是正常返回的（代之以抛出了异常）。
因为`Nothing`是任何其它类型的子类，你可以非常灵活的使用像`error`这样的方法。
例如：

{{{class="brush: scala" 

  def divide(x: Int, y: Int): Int = 
    if (y != 0) x / y 
    else error("can't divide by zero")
}}}

`if`状态分支，`x / y`，类型为Int，而`else`分支，调用了`error`，类型为`Nothing`。
因为`Nothing`是`Int`的子类型，整个状态语句的类型是`Int`，正如需要的那样。



= 特质（Traits） =

trait是Scala里代码复用的基础单元。特质封装了方法和字段的定义，并可以通过混入到
类中重用它们。


== 概念 ==

定义，关键字`trait`：

{{{class="brush: scala"
  trait Philosophical {
    def philosophize() {
      println("I consume memory, therefore I am!")
    }
  }
}}}

没有声明超类，因此和类一样，有个缺省的超类`AnyRef`。一旦特质被定义了，就可以使用
`with`关键字，把它混入到类中。如果这个类没有继承基类，可以直接用`extends`关键字
来混入特质：

{{{class="brush: scala"
  class Frog extends Philosophical {
    override def toString = "green"
  }
}}}

类`Frog`是`AnyRef`（`Philosophical`的超类）的子类并混入了`Philosophical`。从特质
继承的方法可以像从超类继承的方法那样使用：

{{{class="brush: scala"
  scala> val frog = new Frog
  frog: Frog = green

  scala> frog.philosophize()
  I consume memory, therefore I am!
}}}

特质同样也是类型。以下是把`Philosophical`用作类型的例子：

{{{class="brush: scala"
  scala> val phil: Philosophical = frog
  phil: Philosophical = green

  scala> phil.philosophize()
  I consume memory, therefore I am!
}}}

`phil`的类型是`Philosophical`，一个特质。因此，变量`phil`可以被初始化为任何混入
了`Philosophical`特质的类的对象。

如果想把特质混入到显式扩展超类的类里，可以用`extends`指明待扩展的超类，用`with`
混入特质：

{{{class="brush: scala"
  class Animal

  class Frog extends Animal with Philosophical {
    override def toString = "green"
  }
}}}

如果想混入多个特质，都加在`with`子句里就可以了：

{{{class="brush: scala"
  class Animal
  trait HasLegs

  class Frog extends Animal with Philosophical with HasLegs {
    override def toString = "green"
  }
}}}

目前为止你看到的例子中，类`Frog`都继承了`Philosophical`的`philosophize`实现。
或者，`Frog`也可以重载`philosophize`方法。语法与重载超类中定义的方法一样。
举例如下：

{{{class="brush: scala"
  class Animal

  class Frog extends Animal with Philosophical {
    override def toString = "green"
    override def philosophize() {
      println("It ain't easy being "+ toString +"!")
    }
  }
}}}

因为`Frog`的这个新定义仍然混入了特质`Philosophize`，你仍然可以把它当作这种类型的
变量使用。但是由于`Frog`重载了`Philosophical`的`philosophize`实现，当你调用它的
时候，你会得到新的回应：

{{{class="brush: scala"
  scala> val phrog: Philosophical = new Frog
  phrog: Philosophical = green

  scala> phrog.philosophize()
  It ain't easy being green!
}}}

这时你或许推导出以下哲理：特质就像是带有具体方法的Java接口，不过其实它能做的更多
：比方说，特质可以声明字段和维持状态值。

=== 单例对象也可以扩展物质 ===

不止是类，单例对象也可以扩展特质。

=== 特质不能有构造参数 ===

实际上，你可以用特质定义做任何用类定义做的事，并且语法也是一样的，除了两点：

第一点，特质不能有任何“类”参数，也就是说，传递给类的主构造器的参数。换句话说，
尽管你可以定义如下的类：

{{{class="brush: scala"
  class Point(x: Int, y: Int)
}}}

但是下面定义特质的尝试将遭到失败：

{{{class="brush: scala"
  trait NoPoint(x: Int, y: Int) // Does not compile
}}}

=== 特质的`super`引用是动态的 ===

类和特质的另一个差别在于：在类中任何地方，`super`调用都是静态绑定的，在特质中
，它们是动态绑定的。如果你在类中写下`super.toString`，你很明确哪个方法实现将被
调用。然而如果你在特质中写了同样的东西，在你定义特质的时候`super`调用的方法实现
尚未被定义。调用的实现将在每一次特质被混入到具体类的时候才被决定。这种处理
`super`的有趣的行为是使得特质能以可堆叠的改变（stackable modifications）方式
工作的关键。

== 比较瘦接口与胖接口 ==

瘦接口与胖接口的对阵体现了面向对象设计中常会面临的在实现者与接口用户之间的权衡。

胖接口有更多的方法，对于调用者来说更便捷。客户可以捡一个完全符合他们功能需要的
方法。另一方面瘦接口有较少的方法，对于实现者来说更简单。然而调用瘦接口的客户因此
要写更多的代码。由于没有更多可选的方法调用，他们或许不得不选一个不太完美匹配他们
所需的方法并为了使用它写一些额外的代码。

Java的接口常常是过瘦而非过胖。例如，从Java 1.4开始引入的`CharSequence`接口，是
对于字串类型的类来说通用的瘦接口，它持有一个字符序列。下面是把它看作Scala特质的
定义：

{{{class="brush: scala"
  trait CharSequence {
    def charAt(index: Int): Char
    def length: Int
    def subSequence(start: Int, end: Int): CharSequence
    def toString(): String
  }
}}}

尽管类`String`里现有的成打的方法中的大多数都可以用在任何`CharSequence`上，Java的
`CharSequence`接口定义仅提供了4个方法。如果`CharSequence`代以包含全部`String`
接口，那它将为`CharSequence`的实现者压上沉重的负担。任何实现Java`CharSequence`
接口的程序员将不得不定义一大堆方法。因为Scala特质可以包含具体方法，这使得创建
胖接口大为便捷。

在特质中添加具体方法使得胖瘦对阵的权衡大大倾向于胖接口。不像在Java里那样，在
Scala中添加具体方法是一次性的劳动。你只要在特质中实现方法一次，而不再需要在每个
混入特质的方法中重新实现它。因此，与没有特质的语言相比，Scala里的胖接口没什么
工作要做。

要使用特质丰满接口，只要简单地定义一个具有少量抽象方法的特质——特质接口的瘦部分——
和潜在的大量具体方法，所有的都实现在抽象方法之上。然后你就可以把丰满了的特质混入
到类中，实现接口的瘦部分，并最终获得具有全部胖接口内容的类。

== 样例：长方形对象 ==

为了使这些长方形对象便于使用，如果库能够提供诸如`width`，`height`，`left`，
`right`，`topLeft`，等等方法。

没有特质的代码的话，首先会有一些基本的集合类如`Point`和`Rectangle`：

{{{class="brush: scala"
  class Point(val x: Int, val y: Int)

  class Rectangle(val topLeft: Point, val bottomRight: Point) {
    def left = topLeft.x
    def right = bottomRight.x
    def width = right - left
    // and many more geometric methods...
  }
}}}

这个`Rectangle`类在它的主构造器中带两个点，分别是左上角和右下角的坐标。然后它
通过对这两个点执行简单的计算实现了许多便捷方法诸如`left`，`right`，和`width`。

图库应该有的另一个类是2-D图像工具：

{{{class="brush: scala"
  abstract class Component {
    def topLeft: Point
    def bottomRight: Point

    def left = topLeft.x
    def right = bottomRight.x
    def width = right - left
    // and many more geometric methods...
  }
}}}

注意`left`，`right`，和`width`在两个类中的定义是一模一样。除了少许的变动外，他们
将在任何其他的长方形对象的类中保持一致。

这种重复可以使用特质消除。这个特质应该具有两个抽象方法：一个返回对象的左上角坐标
，另一个返回右下角的坐标。然后他就可以应用到所有其他的几何查询的具体实现中：

{{{class="brush: scala"
  trait Rectangular {
    def topLeft: Point
    def bottomRight: Point

    def left = topLeft.x
    def right = bottomRight.x
    def width = right - left
    // and many more geometric methods...
  }
}}}

类`Component`可以混入这个特质并获得`Rectangular`提供的所有的几何方法：

{{{class="brush: scala"
  abstract class Component extends Rectangular {
    // other methods...
  }
}}}

可以创建`Rectangle`对象并对它调用如`width`或`left`的几何方法：

{{{class="brush: scala"
  scala> val rect = new Rectangle(new Point(1, 1),
       | new Point(10, 10))
  rect: Rectangle = Rectangle@3536fd

  scala> rect.left
  res2: Int = 1

  scala> rect.right
  res3: Int = 10

  scala> rect.width
  res4: Int = 9
}}}


== 实现Ordered特质来排序 ==

以前面我们实现的实数类型来说，原来已经有了四个比较大小的方法：

{{{class="brush: scala"
  class Rational(n: Int, d: Int) {
    // ...
    def < (that: Rational) =
      this.numer * that.denom > that.numer * this.denom
    def > (that: Rational) = that < this
    def <= (that: Rational) = (this < that) || (this == that)
    def >= (that: Rational) = (this > that) || (this == that)
  }
}}}

Scala专门提供了`Ordered`特质来简化比较工作。只要实现`Ordered`特质中的`compare`
方法，就可以自动实现其他的`<`、`>`、`<=`、`>=`功能：

{{{class="brush: scala"
  class Rational(n: Int, d: Int) extends Ordered[Rational] {
    // ...
    def compare(that: Rational) =
      (this.numer * that.denom) - (that.numer * this.denom)
  }
}}}

上面定义`compare`方法来比较两个对象，类`Rational`现在具有了所有4种比较方法：

{{{class="brush: scala"
  scala> val half = new Rational(1, 2)
  half: Rational = 1/2

  scala> val third = new Rational(1, 3)
  third: Rational = 1/3

  scala> half < third
  res5: Boolean = false

  scala> half > third
  res6: Boolean = true
}}}

考虑下面的抽象简化了四个比较操作符的实现：

{{{class="brush: scala"
  trait Ordered[T] {
    def compare(that: T): Int

    def <(that: T): Boolean = (this compare that) < 0
    def >(that: T): Boolean = (this compare that) > 0
    def <=(that: T): Boolean = (this compare that) <= 0
    def >=(that: T): Boolean = (this compare that) >= 0
  }
}}}

== 特质的叠加次序 ==

可以把多个特质加在一个类上，按声明的顺序，它们操作的顺序就像栈一样。

`IntQueue`有一个`put`方法把整数添加到队列中，和一个`get`方法移除并返回它们：

{{{class="brush: scala"
  abstract class IntQueue {
    def get(): Int
    def put(x: Int)
  }
}}}

`BasicIntQueue`类根据上面的特质实现了一个队列：

{{{class="brush: scala"
  import scala.collection.mutable.ArrayBuffer

  class BasicIntQueue extends IntQueue {
    private val buf = new ArrayBuffer[Int]
    def get() = buf.remove(0)
    def put(x: Int) { buf += x }
  }
}}}

运行一个队列的效果：

{{{class="brush: scala"
  scala> val queue = new BasicIntQueue
  queue: BasicIntQueue = BasicIntQueue@24655f

  scala> queue.put(10)

  scala> queue.put(20)

  scala> queue.get()
  res9: Int = 10

  scala> queue.get()
  res10: Int = 20
}}}


`Doubling`特质把整数放入队列的时候对它加倍。

{{{class="brush: scala"
  trait Doubling extends IntQueue {
    abstract override def put(x: Int) { super.put(2 * x) }
  }
}}}

注意：定义了超类`IntQueue`这个定义意味着特质只能混入到扩展了`IntQueue`的类中。

声明为抽象的方法中有一个`super`调用。这种调用对于普通的类来说是非法的，因为继承
的超类是个抽象类，所以在执行时将必然失败。然而对于特质来说，这样的调用实际能够
成功。因为特质里的`super`调用是动态绑定的，特质`Doubling`的`super`调用将直到被
混入在另一个特质或类之后，有了具体的方法定义时才工作。

所以要加上`abstract override`，说明要继承父特质（只有特质，类里是不能这样写的）
才能实际产生作用。

现在一行代码都不用写，下面只有一个`extends`和一个`with`就把类定义好了：

{{{class="brush: scala"
  scala> class MyQueue extends BasicIntQueue with Doubling
  defined class MyQueue

  scala> val queue = new MyQueue
  queue: MyQueue = MyQueue@91f017

  scala> queue.put(10)

  scala> queue.get()
  res12: Int = 20
}}}

这个队列即能入队出队，而且数字还是加倍的。

还可以更加简化到类名都不用写，直接`new BasicIntQueue with Doubling`这个父类名加
上特质就可以把对象拿到了：

{{{class="brush: scala"
  scala> val queue = new BasicIntQueue with Doubling
  queue: BasicIntQueue with Doubling = $anon$1@5fa12d

  scala> queue.put(10)

  scala> queue.get()
  res14: Int = 20
}}}


== 特质的叠加 ==

有两个特质，一个在入队时把值加1；另一个过滤掉负数：

{{{class="brush: scala"
  trait Incrementing extends IntQueue {
    abstract override def put(x: Int) { super.put(x + 1) }
  }

  trait Filtering extends IntQueue {
    abstract override def put(x: Int) {
      if (x >= 0) super.put(x)
    }
  }
}}}

队列能够即过滤负数又对每个进队列的数字增量：

{{{class="brush: scala"
  scala> val queue = (new BasicIntQueue
       | with Incrementing with Filtering)
  queue: BasicIntQueue with Incrementing with Filtering...

  scala> queue.put(-1); queue.put(0); queue.put(1)

  scala> queue.get()
  res15: Int = 1

  scala> queue.get()
  res16: Int = 2
}}}

粗略地说，越靠近右侧的特质越先起作用。如果那个方法调用了`super`，它调用其左侧
特质的方法，以此类推。

前面的例子里，`Filtering`的`put`首先被调用，因此它移除了开始的负整数。
`Incrementing`的`put`第二个被调用，因此它对剩下的整数增量。

如果你逆转特质的次序，那么整数首先会加1，然后如果仍然是负的才会被抛弃：

{{{class="brush: scala"
  scala> val queue = (new BasicIntQueue
       | with Filtering with Incrementing)
  queue: BasicIntQueue with Filtering with Incrementing...

  scala> queue.put(-1); queue.put(0); queue.put(1)

  scala> queue.get()
  res17: Int = 0

  scala> queue.get()
  res18: Int = 1

  scala> queue.get()
  res19: Int = 2
}}}


== 特质方法的延迟绑定 ==

在基类方法为抽象时情况比较复杂。比如下面这个抽象`Writer`类的抽象方法
`writeMessage()`：

{{{class="brush: scala"
abstract class Writer {
	def writeMessage(message: String)
}
}}}

这样在特质中一定要修饰方法为`abstract override`，这里两个特质的功能分别是转大写
与过滤敏感词：

{{{class="brush: scala"
trait UpperCaseWriter extends Writer  {
	abstract override def writeMessage(message: String) =
		super.writeMessage(message.toUpperCase)
}

trait ProfanityFilteredWriter extends Writer  {
	abstract override def writeMessage(message: String) =
		super.writeMessage(message.replace("stupid","s-----"))
}
}}}

特质的实现里调用了`super.writeMessage(...)`，这样的调用要延迟绑定，以后混入这些
特质的类需要提供这个方法的实现。实现类如下：

{{{class="brush: scala"
class StringWriterDelegate extends Writer {
	val writer = new java.io.StringWriter

	def writeMessage(message: String) = writer.write(message)

	override def toString(): String = writer.toString
}
}}}

混入特质并调用：

{{{class="brush: scala"
val wa = 
	new StringWriterDelegate with UpperCaseWriter with ProfanityFilteredWriter
val wb = 
	new StringWriterDelegate with ProfanityFilteredWriter with UpperCaseWriter

wa writeMessage "There is no sin except stupidity"
wb writeMessage "There is no sin except stupidity"

println(wa)
println(wb)
}}}

输出结果：

{{{class="brush: bash"
THERE IS NO SIN EXCEPT S-----ITY
THERE IS NO SIN EXCEPT STUPIDITY
}}}

== 为什么不是多重继承 ==

特质是一种继承多个类似于类的结构的方式，但是它与许多语言中的多重继承有很重要的
差别。其中的一个尤为重要：`super`的解释。对于多重继承来说，`super`调用导致的方法
调用可以在调用发生的地方明确决定。而对于特质来说，方法调用是由类和被混入到类的
特质的线性化（linearization）所决定的。这种差别让前一节所描述的改动的堆叠成为
可能。

在关注线性化之前，请花一点儿时间考虑一下在传统的多重继承语言中如何堆叠改动。假想
有下列的代码，但是这次解释为多重继承而不是特质混入：

{{{class="brush: scala"
  val q = new BasicIntQueue with Incrementing with Doubling
  q.put(42) // which put would be called?
}}}

第一个问题是，哪个`put`方法会在这个调用中被引用？或许规则会决定最后一个超类胜出
，本例中的`Doubling`将被调用。`Doubling`将加倍它的参数并调用`super.put`，大概
就是这样。增量操作将不会发生！同样，如果规则决定第一个超类胜出，那么结果队列将
增量整数但不会加倍它们。因此怎么排序都不会有效。

或许你会满足于允许程序员显式地指定在他们说`super`的时候他们想要的到底是哪个超类
方法。比方说，假设下列Scala类似代码，`super`似乎被显式地指定为`Incrementing`和
`Doubling`调用：

{{{class="brush: scala"
  trait MyQueue extends BasicIntQueue
      with Incrementing with Doubling {

    def put(x: Int) {
      Incrementing.super.put(x) // (Not real Scala)
      Doubling.super.put(x)
    }
  }
}}}

这种方式将带给我们新的问题。这种尝试的繁冗几乎不算是问题。实际会发生的是基类的
`put`方法将被调用两次——一次带了增量的值另一次带了加倍的值，但是没有一次是带了
增量加倍的值。

显然使用多重继承对这个问题来说没有好的方案。你不得不返回到你的设计并分别提炼出
代码。相反，Scala里的特质方案很直接。你只要简单地混入`Incrementing`和`Doubling`
，`Scala`对`super`的特别照顾让它迎刃而解。这与传统的多重继承相比必然有不同的地方
，但这是什么呢？

就像在前面暗示的，答案就是线性化。当你使用`new`实例化一个类的时候，Scala把这个类
和所有它继承的类还有它的特质以线性（linear）的次序放在一起。然后，当你在其中的
一个类中调用`super`，被调用的方法就是链子的下一节。除了最后一个调用`super`之外的
方法，其净结果就是可堆叠的行为。

线性化的精确次序由语言的规格书描述。虽然有一点儿复杂，但你需要知道的主旨就是，在
任何的线性化中，某个类总是被线性化在所有其超类和混入特质之前。因此，当你写了一个
调用`super`的方法时，这个方法必将改变超类和混入特质的行为，没有其它路可走。

Scala的线性化的主要属性可以用下面的例子演示：假设你有一个类`Cat`，继承自超类
`Animal`以及两个特质`Furry`和`FourLegged`。`FourLegged`又扩展自另一个特质
`HasLegs`：

{{{class="brush: scala"
  class Animal
  trait Furry extends Animal
  trait HasLegs extends Animal
  trait FourLegged extends HasLegs
  class Cat extends Animal with Furry with FourLegged
}}}

<img src="images/scala/Selection_017.png" alt="继承关系" />

类型的线性化看起来是这样的：

{{{class="brush: scala"
    Animal : Any < AnyRef < Animal
     Furry : Any < AnyRef < Animal < Furry
   HasLegs : Any < AnyRef < Animal < HasLegs
FourLegged : Any < AnyRef < Animal < HasLegs < FourLegged
       Cat : Any < AnyRef < Animal < Furry < HasLegs < FourLegged < Cat
}}}

因为`Animal`没有显式扩展超类或混入任何超特质，因此它缺省地扩展了`AnyRef`，并
随之扩展了`Any`。

{{{class="brush: scala"
    Animal : Any < AnyRef < Animal
}}}

第二部分是第一个混入，特质`Furry`的线性化，但是所有已经在`Animal`的线性化之中的
类现在被排除在外，因此`Cat`的线性化中每个类仅出现1次。结果是：

{{{class="brush: scala"
     Furry : Any < AnyRef < Animal < Furry
}}}

它之前是`FourLegged`的线性化，任何已被复制到线性化中的超类及第一个混入再次被排除
在外：

{{{class="brush: scala"
FourLegged : Any < AnyRef < Animal < HasLegs < FourLegged
}}}

最后，`Cat`线性化的第一个类是`Cat`自己：

当这些类和特质中的任何一个通过`super`调用了方法，那么被调用的实现将是它线性化的
右侧的第一个实现。

{{{class="brush: scala"
       Cat : Any < AnyRef < Animal < Furry < HasLegs < FourLegged < Cat
}}}

== 什么情况下要用特质 ==

没有固定的规律，但是包含了几条可供考虑的导则。

如果行为不会被重用，那么就把它做成具体类。具体类没有可重用的行为。

如果要在多个不相关的类中重用，就做成特质。只有特质可以混入到不同的类层级中。

如果你希望从Java代码中继承它，就使用抽象类。因为特质和它的代码没有近似的Java模拟
，在Java类里继承特质是很笨拙的。而继承Scala的类和继承Java的类完全一样。除了一个
例外，只含有抽象成员的Scala特质将直接翻译成Java接口，因此即使你想用Java代码继承
，也可以随心地定义这样的特质。要了解让Java和Scala一起工作的更多信息请看后面其他
的章节。

注意：如果你计划以编译后的方式发布它，并且你希望外部组织能够写一些继承自它的类，
你应更倾向于使用抽象类。原因是当特质获得或失去成员，所有继承自它的类就算没有改变
也都要被重新编译。如果外边客户仅需要调用行为，而不是继承自它，那么使用特质没有
问题。

如果效率非常重要，倾向于类。大多数Java运行时都能让类成员的虚方法调用快于接口方法
调用。特质被编译成接口，因此会付出微小的性能代价。然而，仅当你知道那个存疑的特质
构成了性能瓶颈，并且有证据说明使用类代替能确实解决问题，才做这样的选择。




= 包和引用 =

== 定义包 ==

=== package语句 ===

通过把`package`子句放在文件顶端的方式把整个文件内容放进包里：

{{{class="brush: scala"
  package bobsrockets.navigation
  class Navigator 
}}}

同一个包可以定义在不同的多个文件中。

=== 嵌套包 ===

另一种方式很像C#的命名空间。在`package`子句之后用大括号包起来一段要放到包里去的
定义。除此之外，这种语法还能把同一个文件内的不同部分放在不同的包里。

{{{class="brush: scala"
  package bobsrockets {
    package navigation {

      // In package bobsrockets.navigation
      class Navigator

      package tests {

        // In package bobsrockets.navigation.tests
        class NavigatorSuite
      }
    }
  } 
}}}

这种嵌套方式会把路径上所有的包的内容都相入进来。

类似于Java的语法实际上只是括号嵌入风格的语法糖。原理是：如果除了签入另一个包之外
对包不作任何事，你可以下面的方式省去一个缩进：

{{{class="brush: scala"
  package bobsrockets.navigation {
  
		// 这样就跳过了bobsrockets包，它的内容不会被引入

    // In package bobsrockets.navigation
    class Navigator

    package tests {

      // In package bobsrockets.navigation.tests
      class NavigatorSuite
    }
  } 
}}}

=== 包路径是相对的 ===

Java包尽管是分级的，却不是嵌套的。在Java里，在你命名一个包的时候，你必须从包层级
的根开始。

Scala为了简化，采用包风格类似于是相对路径：

{{{class="brush: scala"
  package bobsrockets {
    package navigation {
      class Navigator
    }
    package launch {
      class Booster {
        // No need to say bobsrockets.navigation.Navigator
        val nav = new navigation.Navigator
      }
    }
  } 
}}}

为了避免绝对路径与相对路径之间的歧义，可以用`_root_`表示顶层包，这样就一定是绝对
路径：

{{{class="brush: scala"
val aa = new _root_.scala.collection.mutable.ArrayBuffer[Employee] 
}}}


=== 包层级的作用域 ===

而且内部区域的包可以隐匿被定义在外部区域的同名包。还提供了`_root_`表示顶层包：

{{{class="brush: scala"
  // In file launch.scala
  package launch {
    class Booster3
  }

  // In file bobsrockets.scala
  package bobsrockets {
    package navigation {
      package launch {
        class Booster1
      }
      class MissionControl {
        val booster1 = new launch.Booster1
        val booster2 = new bobsrockets.launch.Booster2
        val booster3 = new _root_.launch.Booster3
      }
    }
    package launch {
      class Booster2
    }
  } 
}}}

上面的代码中，为了访问`Booster3`，Scala提供了所有用户可创建的包之外的名为
`_root_`的包。换句话就是，任何你写的顶层包都被当作是`_root_`包的成员。

因此，`_root_.launch`让你能访问顶层的`launch`包，`_root_.launch.Booster3`指向的
就是最外面的`booster`类。

== 包对象 ==

由于JVM的局限，包里只能放类、对象、物质，不能把变量、常量与函数放在包里。

解决方案是在上级包是定义一个与子包名称一样的包对象，包对象的成员用起来就像是在
子包中一样：

{{{class="brush: scala"
package com.horstmann.impatient

package object people {
	val defaultName = "John Q. Public"
}

package people {
	class Person {
		var name = defaultName // 从包对象取得常量
	}
}
}}}

因为在同一个包中，所以`defaultName`不需要加限制。在其他的地方访问方式可能为：

`com.horstmann.impatient.people.defaultName`

在幕后包对象被编译成带有静态方法和字段的JVM类，名为`package.class`，位于相应的
包下。以这个例子来说就是`com.horstmann.impatient.people.package`，它包含一个静态
字段`defaultName`。

== 引用包 ==

Scala里用`import`子句来引用包和其成员：

{{{class="brush: scala"
  package bobsdelights

  abstract class Fruit(
    val name: String,
    val color: String
  )

  object Fruits {
    object Apple extends Fruit("apple", "red")
    object Orange extends Fruit("orange", "orange")
    object Pear extends Fruit("pear", "yellowish")
    val menu = List(Apple, Orange, Pear)
  } 
}}}

不止是包，其他成员也可以用`import`来引用：

{{{class="brush: scala"
  // easy access to Fruit
  import bobsdelights.Fruit

  // easy access to all members of bobsdelights
  import bobsdelights._

  // easy access to all members of Fruits
  import bobsdelights.Fruits._ 
//
}}}

差别是Scala的按需引用写作尾下划线`_`而不是星号`*`（毕竟`*`是合法的Scala标识符！
）。上面的第三个引用子句与Java的静态类字段引用一致。

`cala`引用可以出现在任何地方，而不是仅仅在编译单元的开始处。同样，它们可以指向
任意值。

{{{class="brush: scala"
  def showFruit(fruit: Fruit) {
    import fruit._
    println(name +"s are "+ color)
  } 
}}}

引用语句的作用范围从引入开始到当前代码块结束。

方法`showFruit`引用了它的参数，`Fruit`类型的`fruit`，的所有成员。之后的
`println`语句就可以直接使用`name`和`color`了。这两个索引等价于`fruit.name`和
`fruit.color`。

Scala的引用很灵活的另一个方面是它们可以引用包自身，而不只是非包成员。这只有你把
内嵌包想象成包含在外围包之内才是自然的。

例如，下面的代码里包`java.util.regex`被引用。这使得`regex`可以用作简单名。要访问
`java.util.regex`包的`Pattern`单例对象，你可以只是写成`regex.Pattern`：

{{{class="brush: scala"
  import java.util.regex

  class AStarB {
    // Accesses java.util.regex.Pattern
    val pat = regex.Pattern.compile("a*b")
  } 
}}}

=== 重命名与隐藏 ===

Scala的引用同样可以重命名或隐藏成员。可以用跟在引用的成员对象之后的包含在括号里
的引用选择子句（import selector clause）做到：

* 重命名子句的格式是`<原始名> => <新命名>`。

* `<原始名> => _`格式的子句从被引用的名字中排除了`<原始名>`。

{{{class="brush: scala"
// 只引用了对象Fruits的Apple和Orange成员。 
import Fruits.{Apple, Orange} 

// Apple对象重命名为McIntosh。
import Fruits.{Apple => McIntosh, Orange}

// 以SDate的名字引用了SQL的日期类，因此你可以在同时引用普通的Java日期类Date。
import java.sql.{Date => SDate}

// 以名称S引用了java.sql包，这样你就可以写成S.Date。
import java.{sql => S}

// 引用了对象Fruits的所有成员。这与import Fruits._同义。
import Fruits.{_}

// 从Fruits对象引用所有成员，不过重命名Apple为McIntosh。
import Fuites.{Apple => McIntosh, _}

// 引用了除Pear之外的所有Fruits成员。
import Fuits.{Pear => _, _}
//
}}}

把某样东西重命名为`_`就是表示把它隐藏掉。这对避免出现混淆的局面有所帮助。比方说
你有两个包，`Fruits`和`Notebooks`，它们都定义了类`Apple`。如果你想只是得到名为
`Apple`的笔记本而不是水果，就需要引用所有的`Notebooks`和除了`Apple`之外所有的
水果：

{{{class="brush: scala"
  import Notebooks._
  import Fruits.{Apple => _, _} 
//
}}}

总而言之，引用选择可以包括下列模式：

* 简单名`x`。把`x`包含进引用名集。
* 重命名子句`x => y`。让名为`x`的成员以名称`y`出现。
* 隐藏子句`x => _`。把`x`排除在引用名集之外。
* 全包括`_`。引用除了前面子句提到的之外的全体成员。如果存在全包括，那么必须是
引用选择的最后一个。
 
本节最初展示的比较简单的引用子句可以被视为带有选择子句的简写。

例如，`import p._`等价于`import p.{_}`：并且`import p.n`等价于`import p.{n}`。


== 隐式引用 ==

Scala隐式地添加了一些引用到每个程序中。本质上，就好象下列的三个引用子句已经被
加载了：

{{{class="brush: scala"
  import java.lang._ // everything in the java.lang package
  import scala._     // everything in the scala package
  import Predef._    // everything in the Predef object 
}}}

=== java.lang ===

`java.lang`包囊括了标准Java类。它永远被隐式包含在Scala的JVM实现中。.NET实现将
代以引用system包，它是`java.lang`的.NET模拟。

=== scala ===

scala包含有标准的Scala库，包括许多通用的类和对象。因为scala被隐式引用，你可以
直接用`List`而不是`scala.List`；`import math._`等同于`import scala.math._`；
`math.sqrt(2)`等同于`scala.math.sqrt(2)`。

=== Predef ===

Predef对象包含了许多Scala程序中常用到的类型，方法和隐式转换的定义。比如，因为
`Predef`是隐式引用，你可以直接写`assert`而不是`Predef.assert`。

上面的这三个引用子句与其它的稍有不同，靠后的引用将遮盖靠前的。

例如，`StringBuilder`类被定义在`scala`包里以及Java版本1.5以后的`java.lang`包中
都有。因为`scala`引用遮盖了`java.lang`引用，所以`StringBuilder`简单名将被看作是
`scala.StringBuilder`，而不是`java.lang.StringBuilder`。


= 访问修饰符 =

Scala与Java对访问修饰符的对待方式有一些重要的差异。

== public ==

没有任何标记就是公开的，可以在任何地方被访问。与Java中默认是`protected`不同，
Scala中默认是`public`的。


== private ==

标记为`private`的成员仅在包含了成员定义的类或对象内部可见。不仅如此，Scala中还
可以进一步限制只在当前的实例中可见。

不同于Java，Scala里这个规则同样应用到了内部类上。这种方式更一致。

{{{class="brush: scala"
  class Outer {
    class Inner {
      private def f() { println("f") }
      class InnerMost {
        f() // OK
      }
    }
    (new Inner).f() // error: f is not accessible
  } 
}}}

Scala里，`(new Inner).f()`访问非法，因为`f`在`Inner`中被声明为`private`所以类
`Inner`外面不能被访问。相反，类`InnerMost`里访问`f`没有问题，因为这个访问包含在
`Inner`类之内。

这点与Java不同，Java会允许这两种访问因为它允许外部类访问其内部类的私有成员。

== protected ==

Java中`protected`可以被子类或同一个包中的类访问。Scala里，只在定义了成员的类的
子类中可以被访问，同一包中的其他类不能访问。

{{{class="brush: scala"
  package p {
    class Super {
      protected def f() { println("f") }
    }
    class Sub extends Super {
      f()
    }
    class Other {
      (new Super).f()  // error: f is not accessible
    }
  } 
}}}

== 保护的范围 ==

Scala里的访问修饰符可以通过使用修饰词增加。格式为`private[X]`或`protected[X]`的
修饰符表示针对`X`的私有或保护，这里`X`指代某些外围的包、类与其单例对象，也可以
用`this`表示只有当前类自己可以访问。

这样允许定义一些在你项目的若干子包中可见但对于项目外部的客户却始终不可见的东西。
同样的技巧在Java里是不可能的：

{{{class="brush: scala"
 package bobsrockets {
   package navigation {
     private[bobsrockets] class Navigator { 
       protected[navigation] def useStarChart() {}
       class LegOfJourney {
         private[Navigator] val distance = 100
       }
       private[this] var speed = 200
     }
   }
   package launch {
     import navigation._
     object Vehicle { 
       private[launch] val guide = new Navigator
     }
   }
 } 
}}}

类`Navigator`被标记为`private[bobsrockets]`。这就是说这个类对包含在`bobsrockets`
包的所有的类和对象可见。特别是对象`Vehicle`里对`Navigator`的访问被允许，因为
`Vehicle`包含在包`launch`中，而`launch`包在`bobsrockets`中。另一方面，包
`bobsrockets`包之外的所有代码都不能访问类Navigator。

`private`修饰词同样可以直接是外围包。对象`Vehicle`类的`guide`对象的访问修饰符是
这样的例子。这种访问修饰符等价于Java的包私有访问。

| 没有修饰符            | 公开访问                     |
| Private[bobsrockets]  | 在外部包中访问               |
| Private[navigation]   | 与Java的包可见度相同         |
| Private[Navigator]    | 与Java的private相同          |
| Private[LegOfJourney] | 与Scala的private相同         |
| Private[this]         | 仅在类的同一个实例中可以访问 |


所有的修饰词也可以用在`protected`上，与`private`意思相同。也就是说，类`C`的
`protected[X]`修饰符允许`C`的所有子类和外围的包、类、或对象`X`访问被标记的定义。
例如，`useStarChart`方法在`Navigator`所有子类以及包含在`navigation`包里的所有
代码能够被访问。这与Java的protected意思完全一致。

`Private`的修饰词还能指向外围类或对象。例如`LegOfJourney`里的`distance`变量被
标记为`private[Navigator]`，因此它在类`Navigator`的任何地方都可见。这与Java里的
内部类的私有成员具有同样的访问能力。`private[C]`里的`C`如果是最外层类，那么
`private`的意思和Java一致。

Scala还具有一种比`private`更严格的访问修饰符。被`private[this]`标记的定义仅能在
包含了定义的同一个实例中被访问。这种定义被称为对象私有（object-private）。例如，
代码13.11中，类`Navigator`的的`speed`定义就是对象私有的。这就是说所有的访问必须
不仅是在`Navigator`类里，而且还要是同一个`Navigator`实例发生的。

因此在`Navigator`内访问`speed`和`this.speed`是合法的。然而以下的访问，将不被允许
，即使它发生在`Navigator`类之中：

{{{class="brush: scala"
  val other = new Navigator
  other.speed // this line would not compile 
}}}

把成员标记为`private[this]`是一个让它不能被同一个类中其它实例访问的保障。这在做
文档时比较有用。有时它也能让写出更通用的变体注释（参见以后会讲到的参数类型化章节
的变体注释）。

== 伴生对象的可见度性 ==

Java里，静态成员和实例成员属于同一个类，因此访问修饰符可以统一地应用在他们之上。
在Scala里没有静态成员，代之以可以拥有包含成员的仅存在一个的伴生对象。

{{{class="brush: scala"
  class Rocket {
    import Rocket.fuel
    private def canGoHomeAgain = fuel > 20
  }

  object Rocket {
    private def fuel = 10
    def chooseStrategy(rocket: Rocket) {
      if (rocket.canGoHomeAgain)
        goHome()
      else
        pickAStar()
    }
    def goHome() {}
    def pickAStar() {}
  }
 
}}}

Scala的访问规则给予了伴生对象和类一些特权。类把它所有的访问权限共享给半生对象，
反过来也是如此。特别的是，对象可以访问所有它的伴生类的私有成员，就好象类也可以
访问所有伴生对象的私有成员一样。

举个例子，上面的`Rocket`类可以访问方法`fuel`，它在`Rocket`对象中被声明为私有。
类似地，`Rocket`对象也可以访问`Rocket`类里面的私有方法`canGetHome`。

有一个例外，说到`protected static`成员时，Scala和Java的相似性被打破了。Java类`C`
的保护静态成员可以被`C`的所有子类访问。相反，伴生对象的`protected`成员没有意义，
因为单例对象没有任何子类。



= 断言 =

`assert`是预定义的方法，`assert(condition)`会在条件不成立时抛出`AssertionError`。

另一个版本`assert(condition, explanation)`，指定了抛出含有指定`explantion`作为
说明的`assertionError`。`explation`的类型为`Any`，所以任何对象都可以作为参数。
`assert`方法会对传入的参数调用`toString`的结果作为放在`AssertionError`中的文字描述。

在前面的“组合与继承”这一章中的`above`方法加上道检查，只有宽度一样的元素才可以
上下连接在一起：

{{{class="brush: scala" 
  def above(that: Element): Element = {
    val this1 = this widen that.width
    val that1 = that widen this.width
    elem(this1.contents ++ that1.contents)
  }
}}}

`assert`方法所在的`Predef`包里还有一个`ensuring`方法可以直接对表达式的返回结果
进行测试而不用先把表达式的结果先存放到变量中：

{{{class="brush: scala" 
  def widen(w: Int): Element =
    if (w <= width) this
    else {
      val left = elem(' ', (w - width) / 2, height)
      var right = elem(' ', w - width - left.width, height)
      left beside this beside right
    } ensuring (w <= _.width)
}}}

`ensuring`接收一个返回类型为Boolean的函数作为参数。注意这里`ensuring`是作用在
if-else表达式的`Element`类结果上的，而不是方法`widen`的返回值上。相当于是：

{{{class="brush: scala" 
  def widen(w: Int): Element = {
    if (w <= width) this
    else {
      val left = elem(' ', (w - width) / 2, height)
      var right = elem(' ', w - width - left.width, height)
      left beside this beside right
    } ensuring (w <= _.width)
  }
}}}

还有一点要明白的是，这里的语法看起来像是对`Element`类对象调用`ensuring`方法（把
`xxx.ensuring(...)`中的点换成了空格）。但是实际上`Emement`对象没有这个成员方法，
而是被隐式转换成了`Ensuring`对象。由于存在隐式转换，所以`ensuring`可以作用在任何
类型上。



= 测试 =

受益于和Java之间无缝操作。Java的测试库，像JUnit、TestNG，可以直接用于scala的
单元测试。

== Junit 4 ==

如果喜欢JUnit4的风格，那么可以写下面这样的单元测试。

{{{class="brush: bash" 
import java.util.ArrayList
import org.junit.Test
import org.junit.Assert._

class SampleTest {

	@Test
	def listAdd() {
		val list = new ArrayList[String]
		list add "milk"
		list add "sugar"
		assertEquals(2, list.size())
	}

}
}}}

产生的测试类可以直接在Java中使用：

{{{class="brush: bash" 
$ scalac -classpath .:junit-4.10.jar tmp.scala

$ java -classpath .:junit-4.10.jar:scala-library-2.10.2.jar \
		org.junit.runner.JUnitCore SampleTest
JUnit version 4.10
.
Time: 0.009

OK (1 test)
}}}



== ScalaTest ==

ScalaTest是专为scala设计的一个测试框架。ScalaTest提供了一些比较方便的功能。注意
ScalaTest除了自己的版本号外，对应不同的Scala版本还有不同的对应版本。拿错了是
用不了的。

先用脚本来测试一下对不对：

{{{class="brush: scala" 
class CanaryTest extends org.scalatest.Suite {

	def testOK() {
		assert(true)
	}

}

(new CanaryTest).execute()
}}}

因为使用的是脚本，所以上面最后一行调用`execute()`方法直接运行。执行：

{{{class="brush: scala" 
$ scala -classpath .:scalatest_2.10-1.9.1.jar tmp.scala
Main$$anon$1$CanaryTest:
- testOK
}}}

=== Runner ===

ScalaTest的`Runner`类来配置运行或不运行哪些套件，配置不同的`reporter`来指定报表
。可以在ScalaTest的文档中查看所有的选项。

{{{class="brush: scala" 
class CanaryTest extends org.scalatest.Suite {

	def testListEmpty() {
		val list = new java.util.ArrayList[Integer]
		assert(0 == list.size)
	}

	def testListAdd() {
		val list = new java.util.ArrayList[Integer]
		list add 1
		list add 4
		assert(2 == list.size)
	}

}
}}}

通过`Runner`打开图形界面，在`view`菜单中可以显示测试过程信息：

{{{class="brush: bash" 
$ scalac -classpath .:scalatest_2.10-1.9.1.jar tmp.scala

$ scala -classpath .:scalatest_2.10-1.9.1.jar org.scalatest.tools.Runner -p .
WARNING: -p has been deprecated and will be reused for a different (but still 
		very cool) purpose in ScalaTest 2.0. Please change all uses of -p to -R.
}}}

上面的参数`-p`指定的查找测试类的路径。

如果不想要图形界面，可以用`-o`重定向结果到标准输出：

{{{class="brush: bash" 
$ scala -classpath .:scalatest_2.10-1.9.1.jar org.scalatest.tools.Runner -p . -o
WARNING: -p has been deprecated and will be reused for a different (but still 
		very cool) purpose in ScalaTest 2.0. Please change all uses of -p to -R.
Run starting. Expected test count is: 2
DiscoverySuite:
CanaryTest:
- testListAdd
- testListEmpty
Run completed in 150 milliseconds.
Total number of tests run: 2
Suites: completed 2, aborted 0
Tests: succeeded 2, failed 0, ignored 0, pending 0
All tests passed.
}}}

还有`-f`参数可以把结果输出到文件。

=== assert()与expect()方法 ===

ScalaTest提供的`assert()`方法测试条件是否成立。还有一个两个参数版本的，第二个
参数设置失败时的提示信息。

{{{class="brush: scala" 
	assert(2 == list.size(), "Unexpected size of list")
}}}

还有一个`expect()`方法作为类似于Junit的`assertEquals()`方法。注意它的第三个参数
是一个闭包：

{{{class="brush: scala" 
	assert(2, "Unexpected size of list") { list.size() }
}}}

注意`expect()`方法已经过期，用`expectResult()`方法代替。

=== 测试异常 ===

有一个比较啰嗦的方案：

{{{class="brush: scala" 
try {
	// .....
	fail("Expected exception here")
} catch {
	case e: IndexOutOfBoundsException => // success
}
}}}

更好的方法是用ScalaTest提供的`intercept()`方法：

{{{class="brush: scala" 
intercept(classOf[IndexOutOfBoundsException], "Expected exception here") {
	// .....
}
}}}

注意上面的格式可能会在ScalaTest的新版本中改变，会是这样的：

{{{class="brush: scala" 
intercept[IndexOutOfBoundsException]("Expected exception here") {
	// .....
}
}}}

`intercept()`方法会把捕获的结果作为返回值，如果需要的话可以对它进行处理。

=== 在测试间共享代码 ===

==== BeforeAndAfter特质 ====

Scala的`BeforeAndAfter`特质提供了`beforeEach()`与`afterEach()`方法会在每个测试
开始与结束前调用；还有`beforeAll()`和`afterAll()`在所有的开始与结束时运行一次。

{{{class="brush: scala" 
class ShareCodeImperation extends org.scalatest.Suite 
	with org.scalatest.BeforeAndAfter
{
		var list: java.util.ArrayList[Integer] = _

		override def beforeEach() { list = new java.util.ArrayList[Integer] }
		override def afterEach()  { list = null }

		def testListEmptyOnCreate() {
			expect(0, "Expected size to be 0") { list.size() }
		}

		def testGetOnEmptyList() {
			intercept[IndexOutOfBoundsException] { list.get(0) }
		}
}

(new ShareCodeImperative).execute()
}}}

==== 通过闭包 ====

{{{class="brush: scala" 
import org.scalatest.Suite
import java.util.ArrayList

class ShareCodeFunctional extends Suite {

	def withList(testFunction : (ArrayList[Integer]) => Unit) {
		// init list
		val list = new ArrayList[Integer]

		try {
			testFunction(list)
		} finally {
			// clean up
		}
	}

	def testListEmptyOnCreate() {
		withList {
			list => expectResult(0, "Expected size to be 0") {
				list.size()
			}
		}
	}

	def testGetOnEmptyList() {
		withList {
			list => intercept[IndexOutOfBoundsException] {
				list.get(0)
			}
		}
	}

}

(new ShareCodeFunctional).execute()
}}}

运行：

{{{class="brush: scala" 
$ scala -deprecation -classpath .:scalatest_2.10-1.9.1.jar tmp.scala
Main$$anon$1$ShareCodeFunctional:
- testGetOnEmptyList
- testListEmptyOnCreate
}}}

=== FunSuite ===

ScalaTest提供了函数式的`FunSuite`（Function Suite）。`test`方法为测试方法，说明
字符串的内容会显示在输出信息中：

{{{class="brush: scala" 
import org.scalatest.FunSuite
import scala.collection.mutable.Stack
 
class ExampleSuite extends FunSuite {
 
  test("pop is invoked on a non-empty stack") {
    val stack = new Stack[Int]
    stack.push(1)
    stack.push(2)
    val oldSize = stack.size
    val result = stack.pop()
    assert(result === 2)
    assert(stack.size === oldSize - 1)
  }
 
  test("pop is invoked on an empty stack") {
    val emptyStack = new Stack[Int]
    intercept[NoSuchElementException] {
      emptyStack.pop()
    }
    assert(emptyStack.isEmpty)
  }
}
}}}

{{{class="brush: bash" 
\-(morgan:%) >>> scalac -cp scalatest_2.9.0-1.9.1.jar ExampleSuite.scala                      
\-(morgan:%) >>> scala -cp .:scalatest_2.9.0-1.9.1.jar org.scalatest.run ExampleSuite 
Run starting. Expected test count is: 2
ExampleSuite:
- pop is invoked on a non-empty stack
- pop is invoked on an empty stack
Run completed in 158 milliseconds.
Total number of tests run: 2
Suites: completed 1, aborted 0
Tests: succeeded 2, failed 0, ignored 0, pending 0
All tests passed.
}}}


ScalaTest中也可以写JUnit风格的测试：

{{{class="brush: scala" 
import org.scalatest.junit.AssertionsForJUnit
import scala.collection.mutable.ListBuffer
import org.junit.Assert._
import org.junit.Test
import org.junit.Before

class ExampleSuite extends AssertionsForJUnit {

  var sb: StringBuilder = _
  var lb: ListBuffer[String] = _

  @Before 
	def initialize() {
    sb = new StringBuilder("ScalaTest is ")
    lb = new ListBuffer[String]
  }

  @Test 
	def verifyEasy() { // Uses JUnit-style assertions
    sb.append("easy!")
    assertEquals("ScalaTest is easy!", sb.toString)
    assertTrue(lb.isEmpty)
    lb += "sweet"
    try {
      "verbose".charAt(-1)
      fail()
    }
    catch {
      case e: StringIndexOutOfBoundsException => // Expected
    }
  }

  @Test 
	def verifyFun() { // Uses ScalaTest assertions
    sb.append("fun!")
    assert(sb.toString === "ScalaTest is fun!")
    assert(lb.isEmpty)
    lb += "sweeter"
    intercept[StringIndexOutOfBoundsException] {
      "concise".charAt(-1)
    }
  }
}
}}}

编译运行：

{{{class="brush: bash" 
\-(morgan:%) >>> scalac -cp scalatest_2.9.0-1.9.1.jar:junit-4.8.2.jar ExampleSuite.scala                      
\-(morgan:%) >>> scala -cp .:scalatest_2.9.0-1.9.1.jar:junit-4.8.2.jar org.junit.runner.JUnitCore ExampleSuite
JUnit version 4.8.2
..
Time: 0.026

OK (2 tests)
}}}

=== 混合ScalaTest与JUnit ===

`org.scalatest.junit.JUnitSuite`已经混入了特质`AssertionsForJUnit`，可以同时被
用于JUnit与ScalaTest方法： 

{{{class="brush: scala" 
import org.scalatest.junit.JUnitSuite
import scala.collection.mutable.ListBuffer
import org.junit.Assert._
import org.junit.Test
import org.junit.Before

class ExampleSuite extends JUnitSuite {

  var sb: StringBuilder = _
  var lb: ListBuffer[String] = _

  @Before
	def initialize() {
    sb = new StringBuilder("ScalaTest is ")
    lb = new ListBuffer[String]
  }

  @Test
	def verifyEasy() { // Uses JUnit-style assertions
    sb.append("easy!")
    assertEquals("ScalaTest is easy!", sb.toString)
    assertTrue(lb.isEmpty)
    lb += "sweet"
    try {
      "verbose".charAt(-1)
      fail()
    }
    catch {
      case e: StringIndexOutOfBoundsException => // Expected
    }
  }

  @Test
	def verifyFun() { // Uses ScalaTest assertions
    sb.append("fun!")
    assert(sb.toString === "ScalaTest is fun!")
    assert(lb.isEmpty)
    lb += "sweeter"
    intercept[StringIndexOutOfBoundsException] {
      "concise".charAt(-1)
    }
  }
}
}}}

JUnit调用：

{{{class="brush: bash" 
\-(morgan:%) >>> scala -cp .:scalatest_2.9.0-1.9.1.jar:junit-4.8.2.jar org.junit.runner.JUnitCore ExampleSuite
JUnit version 4.8.2
..
Time: 0.026

OK (2 tests)
}}}

ScalaTest调用：

{{{class="brush: bash" 
\-(morgan:%) >>> scala -cp .:scalatest_2.9.0-1.9.1.jar:junit-4.8.2.jar org.scalatest.run ExampleSuite
Run starting. Expected test count is: 2
ExampleSuite:
- verifyEasy
- verifyFun
Run completed in 226 milliseconds.
Total number of tests run: 2
Suites: completed 1, aborted 0
Tests: succeeded 2, failed 0, ignored 0, pending 0
All tests passed.
}}}

ScalaTest还提供了函数式的单元测试。

{{{class="brush: scala" 
// 用函数式的方式来写单元测试
// IDE目前对ScalaTest的支持不是特别好
// 加上RunWith就可以用JUnit的方式来运行了
@RunWith(classOf[JUnitRunner])
class ElementSuite3 extends FunSuite {
    test("elem result should have passed width") {
        val ele = elem('x', 2, 3)
        assert(ele.width == 2)
    }
}
}}}

单元测试对提高软件质量很有好处。唯一的不足就是只针对程序员。其它人员要看懂还是
比较困难。ScalaTest提供了BDD（Behavior Driven Development行为驱动开发）测试方式
。下面的这段测试代码在运行时就会打印出可读的解释。
	
{{{class="brush: scala" 
class ElementSpec extends FlatSpec with ShouldMatchers {
    "A UniformElement" should
        "have a width equal to the passed value" in {
        val ele = elem('x', 2, 3)
        ele.width should be(2)
    }
    it should
        "have a height equal to the passed value" in {
        val ele = elem('x', 2, 3)
        ele.height should be(3)
    }
    it should
        "throw an IAE if passed a negative width" in {
        evaluating {
            elem('x', -2, 3)
        } should produce[IllegalArgumentException]
    }
}
}}}

上面的代码会打印出下面这样的提示。

{{{class="brush: scala" 
A UniformElement 
- should have a width equal to the passed value
- should have a height equal to the passed value
- should throw an IAE if passed a negative width
}}}

我们写单元测试时会测试一些边界值。然后再选一些典型的值。如果这些选值有库来做，
不但可以减少单元测试的工作量，而且可以将边界值选取更合理。

下面是如何将`ScalaChecker`和`ScalaTest`联合起来使用的一个例子：

{{{class="brush: scala" 
class ElementSpecChecker extends FlatSpec with ShouldMatchers with Checkers{
    "A UniformElement" should
        "have a width equal to the passed value" in {
        // 这可以用数学化的方式来读
        // 对每个整数w
        // 当w>0时
        // 都有后面的等式成立
        check((w: Int) => w > 0 ==> (elem('x', w, 3).width == w))
    }
}
}}}
