
%title AngularJs

%toc AngularJs

= 入门 =

== Hello World ==

实现了内容与文本框一起改变的功能：
[[../code/angular.js/quickview/index|查看效果]]

代码如下：

{{{class="brush: html; highlight:[2,4,8,9]"  title="quickview/basic.html"
<!doctype html>
<html ng-app>
  <head>
    <script src="../angular.min.js"></script>
  </head>
  <body>
    <div>
      <input type="text" ng-model="yourName" placeholder="Enter a name here">
      <h1>Hello, {{yourName}}!</h1>
    </div>
  </body>
</html>
}}}

就这样没有任何代码就实现了内容与文本框一起改变的功能：

* `ng-app`标记了一个模块，没有它AngularJs不会起作为。
* `ng-model="yourName"`建立了文本框与模型`yourName`的双向绑定。
* `{{yourName}}`显示模型的值。

= 应用实例 =

通过实践创建一个项目`myApp`来学习，把js代码都放在`js/radio.js`中。

== 定义模块 ==

通过`angular.module`方法定义模块，

{{{class="brush: js"  title="radio.v1/radio.js"
var app = angular.module('myApp', []);
}}}

这样在页面上可以声明把模块绑定到指定的DOM中：

{{{class="brush: html; highlight:[2]"  title="radio.v1/radio.html"
<!doctype html>
<html ng-app="myApp">
  <head>
    <script src="../angular.min.js"></script>
    <script src="js/radio.js"></script>
  </head>
  <body>
  </body>
</html>
}}}

绑定的地方就是AngularJs运行应用的地方。

= Scopes =

`$scope`是一个把view（一个DOM元素）连结到controller上的对象。在我们的MVC结构里，
这个`$scope`将成为model，它提供一个绑定到DOM元素（以及其子元素）上的excecution 
context。

尽管听起来有点复杂，但`$scope`实际上就是一个JavaScript对象，controller和view都
可以访问它，所以我们可以利用它在两者间传递信息。在这个`$scope`对象里，我们既存储
数据，又存储将要运行在view上的函数。

== rootScope ==

每一个Angular应用都会有一个`$rootScope`。
这个`$rootScope`是最顶级的scope，它对应着含有`ng-app`指令属性的那个DOM元素。

如果页面上没有明确设定`$scope`，Angular就会把数据和函数都绑定到这里，第一部分中
的例子就是靠这一点成功运行的。

在这个例子里，我们将使用`$rootScope`。在`radio.js`文件里，我们给这个`scope`加一个
`name`属性。把这个函数放进`app.run`函数里执行，我们就保证了它能在应用的其他部分
之前被执行。你可以把`app.run`函数看作是Angular应用的`main`方法。

{{{class="brush: javascript"  title="quickview/js/showscop01.js"
app.run(function($rootScope) {
  $rootScope.name = "Ari Lerner";
});
}}}

现在，我们可以在`view`的任何地方访问这个`name`属性，使用模版表达式`{{}}`，像这样
：

{{{class="brush: html"  title="quickview/showscop.01.html"
{{ name }}
}}}

== Controller连接Scope ==

要真正看到scope的强大功能，让我们给一个DOM元素加上controller，它将创建这个元素的
`$scope` ，让我们跟这个元素互动。

要明确创建一个`$scope`对象，我们就要给DOM元素安上一个controller对象，使用的是
`ng-controller`指令属性：

{{{class="brush: html"
<div ng-controller="MyController">
  {{ person.name }}
</div>
}}}

`ng-controller`指令给所在的DOM元素创建了一个新的scope对象，并将这个scope对象
包含进外层DOM元素的scope对象里。在上面的例子里，这个外层DOM元素的`$scope`对象，
就是`$rootScope`对象。这个scope链是这样的：

<img src="images/AngularJS/01.png" />

现在，`MyController`给我们建立了一个可以从DOM元素内部直接访问的scope对象。下面
我们在的这个scope里创建一个`person`对象，在`radio.js`中：

{{{class="brush: js"  title="radio.v1/radio.js"
app.controller('MyController', function($scope) {
  $scope.person = {
    name: "Ari Lerner"
  };
});
}}}

现在我们可以在有`ng-controller=’MyController’`属性的DOM元素的任何子元素里访问
这个`person`对象，因为它在`$scope`上。

页面上显示出：

== scope继承层级 ==

所有scope都遵循原型继承（prototypal inheritance），这意味着它们
都能访问父scope们。对任何属性和方法，如果AngularJS在当前scope上找不到，就会到父
scope上去找，如果在父scope上也没找到，就会继续向上回溯，一直到`$rootScope`上。

== 独立的scop ==

唯一的例外：有些指令属性可以选择性地创建一个独立的scope，让这个scope不继承它的
父scope们。

举个例子，假设我们有一个`ParentController`，含有一个`person`对象，又有一个
`ChildController`想要访问这个对象：

{{{class="brush: js"
app.controller('ParentController', function($scope) {
  $scope.person = {greeted: false};
});
 
app.controller('ChildController', function($scope) {
  $scope.sayHello = function() {
    $scope.person.greeted = true;
  }
});
}}}

当我们在view里把`ChildController`绑定到`ParentController`之下，在子元素里我们
就能访问`ParentController`创建的父scope的属性，像访问`ChildController`自己的
scope中的属性一样：

{{{class="brush: html"
<div ng-controller="ParentController">
  <div ng-controller="ChildController">
    <input type="text" ng-model="person.name" placeholder="Name"></input>
    <a ng-click="sayHello()">Say hello</a>
  </div>
  {{ person }}
</div>
}}}

<img src="images/AngularJS/02.png" />

[[../code/angular.js/quickview/scop|查看效果]]

== 结合进myApp ==

现在，我们把scope用在我们的NPR应用上。在上一篇结尾我们定义了`app module`，现在
我们开始深入DOM结构，创建基本功能。

像在上面的例子里展示过的那样，我们先创建一个root controller，命名为
`PlayerController`。还有一个`RelatedController`，它将负责管理音频DOM元素、和为
我们取回NPR节目的列表。

回到`radio.js`，现在我们就来创建这两个controller：

{{{class="brush: js" title="radio.v1/radio.js"
var app = angular.module('myApp', []);
 
app.controller('PlayerController', ['$scope', function($scope) { }]);
app.controller('RelatedController', ['$scope', function($scope) { }]);
}}}

== 音频 ==

这两个controller现在还没什么功能，那么，让我们给应用先加上点声音吧。在这个教程里
我们将使用HTML5的音频DOM元素，所以首先你得有个支持HTML5的浏览器（我们推荐Google 
Chrome）。

这个音频DOM元素，我们既可以把它加在HTML里，又可以加在我们的controller里。不过
鉴于我们主要使用controller跟这个音频DOM元素互动，把它创建在controller里更合适。

现在我们就在`PlayerController`里创建一个音频DOM元素。我们要把它储存在scope上，
然后像你已经学过的那样——通过`$scope`对象把view和controller连接起来。

{{{class="brush: js" title="radio.v1/radio.js"
app.controller('PlayerController', ['$scope', function($scope) {
  $scope.audio = document.createElement('audio');
}]);
}}}

这个设定现在可能有点无聊，因为它还不能干什么。我们会在本系列的下一篇介绍取回（
fetching）数据，现在我们先使用一个指定的`.mp4`网址。

还是在这个`PlayerController`里，指定音频文件的`src`属性为一个你能访问的`.mp4`
网址。方便起见，我们在这里使用一个储存在我们自己服务器上的NPR音频文件，不过其实
你可以指向任何网址。现在设定你的音频`src`地址如下：

{{{class="brush: js" title="radio.v1/radio.js"
app.controller('PlayerController', ['$scope', function($scope) {
  $scope.playing = false;
  $scope.audio = document.createElement('audio');
  $scope.audio.src = 'http://r3.soundowl.com/3t10.mp3';
}]);
}}}

音频不会自己播放，我们必须让它播放。要做到这一点，我们可以简单地使用
`$scope.audio.play()`，然后HTML5音频DOM元素就会开始播放mp4媒体流。

我们可以给用户提供一个互动元素：创建一个按钮，把它绑定到scope里的一个动作上。
在下一篇里我们会更深入地介绍这一块，不过先看看上面例子里view的HTML：

{{{class="brush: html" title="radio.v1/radio.html"
<div ng-controller="PlayerController">
  <button ng-click="play()" class="button" ng-show="!playing">Play</button>
  <button ng-click="stop()" class="button alert" ng-show="playing">Stop</button>
  Playing audio: <b>{{ playing }}</b>
</div>
}}}

注意我们并不需要引用在scope里创建的那个音频DOM元素，因为它是当我们载入controller
时在controller内部用`document.createElement("audio")`创建的。在之后的教程里我们
会重构这个部分，因为在controller里操作DOM元素一般都不是个好主意（感谢Brad Green
在评论中指出这一点。）然而为了简便，我们在这里还是保持这个controller如此。

在view里我们已经加入了一些变量，在scope上我们要管理这些变量。这里使用了一些高级
概念，这些在本系列之后的教程里才会详细介绍，所以如果你不能一下子全看明白也不用
担心：

{{{class="brush: js" title="radio.v1/radio.js"
app.controller('PlayerController', ['$scope', function($scope) {
	$scope.audio = document.createElement('audio');
	$scope.audio.src = 'http://r3.soundowl.com/3t10.mp3';

	$scope.playing = false;

	$scope.play = function() {
		$scope.audio.play();
		$scope.playing = true;
	};
	$scope.stop = function() {
		$scope.audio.pause();
		$scope.playing = false;
	};

	$scope.audio.addEventListener('ended', function() {
		$scope.$apply(function() {
			$scope.stop()
		});
	});
}]);
}}}

以上就是对Angular.js的`$scope`功能的介绍。在下一章，我们会介绍Angular.js的双向
数据绑定。

[[../code/angular.js/radio.v1/radio|查看效果]]

= 数据绑定 =

== 双向绑定 ==

view与model双向绑定的意思是：view变了，model的内容也会变；model变了，view也跟着
变。

<img src="images/AngularJS/04.png" />

通过`ng-model`指令把一个文本框绑定到`person.name`属性上：

{{{class="brush: js"
<div ng-controller="MyController">
  <input type="text" ng-model="person.name" placeholder="Enter your name" />
  <h5>Hello {{ person.name }}</h5>
</div>
}}}

== 视图与后端代码绑定 ==

现在我们把model的值放在后端的js文件里，每秒刷新：

{{{class="brush: js" title="quickview/js/bind.js"
var app = angular.module('myApp', []);
 
app.controller('MyController', function($scope) {
	$scope.person = { name: "Ari Lerner" };
	var updateClock = function() { $scope.clock = new Date(); };
	var timer = setInterval(function() { $scope.$apply(updateClock); }, 1000);  
	updateClock();}
);
}}}

显示的view在页面上：

{{{class="brush: html" title="quickview/bind.html"
<!doctype html>
<html ng-app="myApp">
<head>
<script src="../angular.min.js"></script>
<script src="js/bind.js"></script>
</head>
<body>
<div ng-controller="MyController">
	<h5>{{ clock }}</h5>
</div>
</body>
</html>
}}}

== 绑定函数 ==

不光是把数据绑定到用于显示的view上，还可以把函数绑定到DOM元素上。不仅是按钮，
链接等，任何DOM元素都可以通过`ng-click`绑定鼠标点击事件调用的函数（即浏览器通用
的`mousedown`事件）。

方法被绑定到controller所有的`$scope`对象上。注意要将方法名写进带引号的字符串里：

{{{class="brush: html; highlight=[3,4]" title="quickview/bind.html"
<div ng-controller="DemoController">
  <h4>The simplest adding machine ever</h4>
  <button ng-click="add(1)" class="button">Add</button>
  <button ng-click="subtract(1)" class="button">Subtract</button>
  <h4>Current count: {{ counter }}</h4>
</div>
}}}

调用的方法：

{{{class="brush: js" title="quickview/js/bind.js"
app.controller('DemoController', function($scope) {
  $scope.counter = 0;
  $scope.add = function(amount) { $scope.counter += amount; };
  $scope.subtract = function(amount) { $scope.counter -= amount; };
});
}}}


== Ajax ==

Angular.js通过一个`$http`服务提供了多种方式来调用AJAX。
所有Angular.js的核心服务都用`$`前缀。

{{{class="brush: js" title="quickview/js/bind.js"
app.controller('PlayerController', function($scope, $http) {
	$http({ method: 'JSONP',  
		url: 'http://api.openbeerdatabase.com/v1/beers.json?callback=JSON_CALLBACK'
	}).success(function(data, status, headers, config) {  
		// data contains the response  
		// status is the HTTP status  
		// headers is the header getter function  
		// config is the object that was used to create the HTTP request
		$scope.programs = data;
	}).error(function(data, status, headers, config) {});
}
}}}

注意， 像上面例子中那样，原封不动加上以下字符串`callback=JSON_CALLBACK`，
Angular.js就会负责为你处理JSONP请求，将`JSON_CALLBACK`替换成一个合适的回调函数。

{{{class="brush: html" title="quickview/bind.html"
<div ng-controller="PlayerController">
{{ programs }}
</div>
}}}

[[../code/angular.js/quickview/bind|查看效果]]


== 结合电台程序 ==

要调用NPR电脑的API要先注册申请一个API Key：http://www.npr.org/templates/reg/

然后就可以取得节目列表：

{{{class="brush: js" title="radio.v1/radio.js"
var apiKey = 'MDEyNDkyMTc4MDEzODMxMTI3MTkxMjU5OQ001';
var nprUrl = 'http://api.npr.org/query?id=61&fields=relatedLink,title,byline,text,audio,image,pullQuote,all&output=JSON';
 
app.controller('PlayerController', function($scope, $http) {
	// Hidden our previous section's content
	// construct our http request
	$http({
		method: 'JSONP',
		url: nprUrl + '&apiKey=' + apiKey + '&callback=JSON_CALLBACK'
	}).success(function(data, status) {
		// Now we have a list of the stories (data.list.story)
		// in the data object that the NPR API
		// returns in JSON that looks like:
		// data: { "list": {
		//	 "title": ...
		//	 "story": [
		//		 { "id": ...
		//			 "title": ...
		$scope.programs = data.list.story;
	}).error(function(data, status) {
		// Some error occurred
	});
});
}}}

页面上显示：

{{{class="brush: js" title="radio.v1/radio.js"
<div ng-controller="PlayerController">{{ programs }}</div>
}}}

[[../code/angular.js/radio.v2/radio|查看效果]]


= 指令属性 =

目前为止，我们已提到过几次“指令属性”的概念，但从未深入探讨过它到底是什么。实际上
，“指令属性”就是绑定在DOM元素上的函数，它可以调用方法、定义行为、绑定controller
及$scope对象、操作DOM，等等等等。

当浏览器启动、开始解析HTML（像平时一样）时，DOM元素上的指令属性就会跟其他属性
一样被解析。

当一个Angular.js应用启动，Angular编译器就会遍历DOM树（从有`ng-app`指令属性的那个
DOM元素开始，如我们在本系列第一篇里所提过的），解析HTML，寻找这些指令属性函数。

当在一个DOM元素上找到一个或多个这样的指令属性函数，它们就会被收集起来、排序，
然后按照优先级顺序被执行。

每个指令属性都有自己的优先级，在我们关于
[[http://www.ng-newsletter.com/posts/directives.html|指令属性的专题文章里]]
，你可以找到更深入的信息。

Angular.js应用的动态性和响应能力，都要归功于指令属性。之前我们已经看过一些指令
属性的用例，如`ng-model`让标题中的文本与输入框绑定：

{{{class="brush: html" title="quickview/directives.html"
<input ng-model="name" name="Name" placeholder="Enter your name"/>
<h4>Your name: {{ name }}</h4>
}}}

`ng-model`指令属性，被用来将DOM文本输入框的值，跟controller里的`$scope model`
绑定起来。具体的实现过程，是在这个值上绑定了一个`$watch`函数（类似JavaScript里的
事件监听函数）。

`$watch`函数（在使用时）运行在Angular.js的事件循环
（即`$digest`循环）里，让Angular.js能够对DOM进行相应的更新。请关注我们关于
`$digest`循环的高级文章！

在Angular.js应用的开发中，我们用指令属性来将行为绑定到DOM上。指令属性的使用，是
一个应用能否拥有动态性、响应能力的关键。

== 表达式简介 ==

{{{class="brush: html" title="quickview/directives.html"
{{ 表达式 }}
}}}

这个双大括号指令属性，使用`$watch()`函数，给括号内的表达式注册了一个监听器。正是
这个`$watch`函数，让Angular.js能够实时自动更新view。

要想理解指令属性的运作，我们必须先理解表达式，在之前的例子里我们已经见过表达式，
例如`{{ person.name }}`和`{{ clock }}`。

{{{class="brush: html" title="quickview/directives.html"
{{ 8 + 1 }}                // 9
{{ person }}               // {"name":"Ari Lerner"}
{{ 10 * 3.3 | currency }}  // $33.00
}}}

最后的例子里`(10 * 3.3 | currency)`用了一个过滤器。本系列之后的部分，会深入介绍
过滤器。

表达式粗略来看有点像`eval(javascript)`的结果。它们会经过Angular.js的处理，从而
拥有以下重要而独特的性质：

* 所有表达式都在scope这个context里被执行，因此可以使用所有本地`$scope`中的变量。
* 如果一个表达式的执行导致类型错误或引用错误，这些错误将不会被抛出。
* 表达式里不允许任何控制函数流程的功能（如if/else等条件语句）
* 表达式可接受一个或多个串联起来的过滤器。

表达式都运行在调用它们的scope里，所以一个表达式可访问并操作其scope上的一切。由此
，你可以使用表达式遍历其scope的属性（我们在`ng-repeat`中会看到这一应用）、调用
scope里的函数，或者对scope中的变量进行数学运算。

== 常见指令属性 ==

=== ng-init ===

ng-init指令属性是一个在启动时运行的函数（在程序进入运行阶段之前）。它让我们能够
在程序运行前设定初始变量的值：

{{{class="brush: html" title="quickview/directives.html"
<b ng-init='name = "Ari Lerner"'>Hello, {{ name }}</b>
}}}

=== ng-click ===

ng-click指令属性给DOM元素注册了一个点击事件的监听器。当此DOM元素上有点击事件发生
（即当此button或link被点击时），Angular.js就会执行表达式的内容，并相应地更新view
。

{{{class="brush: html" title="quickview/directives.html"
<button ng-click="counter = counter + 1">Add one</button>
Current counter: {{ counter }}
}}}

我们也可以用ng-click来调用在controller里写好并绑定在$scope上的函数，例如：
	
{{{class="brush: html" title="quickview/directives.html"
<div ng-controller="MyController">
	<button ng-click="sayHello()">Say hello</button>
</div>
}}}

controller 里的函数:

{{{class="brush: javascript" title="quickview/js/directives.js"
app.controller('MyController', function($scope) {
   $scope.sayHello = function() {
     alert("hello!");
   }
 });
}}}

=== ng-show / ng-hide ===

ng-show和ng-hide指令，根据赋予它们的表达式的值的真假性(truthy)，来显示和隐藏它们
所属的那一部分DOM。

我们在这里不会深入，但你应该熟悉JavaScript中变量值的`truthy`和`falsy`概念。

{{{class="brush: html" title="quickview/directives.html"
<button ng-init="shouldShow = true" ng-click="shouldShow = !shouldShow">
	Flip the shouldShow variable
</button>

<div ng-show="shouldShow">
  <h3>Showing {{ shouldShow }}</h3>
</div> <div ng-hide="shouldShow">
  <h3>Hiding {{ shouldShow }}</h3>
</div>
}}}

=== ng-repeat ===

ng-repeat指令遍历一个数据集合中的每个数据元素，加载HTML模版把数据渲染出来。被
重复使用的模版元素，就是我们绑定了这个指令属性的DOM元素。每一个使用模版渲染的DOM
元素都有自己的scope。

在更多的解释之前，我们先看一个例子。假设我们的controller里有这样一个数据元素的
数组：

{{{class="brush: javascript" title="quickview/js/directives.js"
$scope.roommates = [
	{ name: 'Ari'},
	{ name: 'Q'},
	{ name: 'Sean'},
	{ name: 'Anand'}
];
}}}


{{{class="brush: html" title="quickview/directives.html"
<ul>
	<li ng-repeat="person in roommates">{{ person.name }}</li>
</ul>
}}}

对赋予ng-repeat的表达式稍作改动，我们还可以用它遍历一个由成对的key-value数据组成
的集合。例如，假设我们有一个人名和他们最喜欢的颜色的数据集合：

{{{class="brush: javascript" title="quickview/js/directives.js"
$scope.people = {
   'Ari': 'orange',
   'Q': 'purple',
   'Sean': 'green'
}
}}}

要遍历它，我们可以给ng-repeat指令属性赋予这个表达式: `(key, value) in object`:

{{{class="brush: html" title="quickview/directives.html"
<ul>
   <li ng-repeat="(name, color) in people">
		{{ name }}'s favorite color is {{ color }}
   </li>
</ul>
}}}


[[../code/angular.js/quickview/directives|查看效果]]


== 指令属性创建指南 ==

Angular.js提供的直接可用的指令属性并不多，但它让我们可以很容易地创建自己的指令
属性。请到这里查看我们的
[[http://www.ng-newsletter.com/posts/directives.html|指令属性创建指南]]

== 收音机应用实例 ==

在上一篇中，我们的收音机应用只从NPR API取回了最新的音频节目列表：

{{{class="brush: javascript" title="radio.v3/radio.html"
$scope.programs = data.list.story;
}}}

现在我们学了遍历一个list的实现方法，可以在我们的收音机应用里，像刚才那样用
ng-repeat来遍历这个节目列表了：

{{{class="brush: html" title="radio.v3/radio.js"
<ul id="programs_list" class="">
   <li ng-repeat="program in programs">
     <span class="large-12">{{ program.title.$text }}</span>
   </li>
</ul>
}}}

NPR API给我们的是一个有`title+$text`的列表，这个结构是NPR API所特有的，而不是
Angular.js的。

现在我们列出了节目和它们的标题，但还不能点击并播放它们。用ng-click我们可以给HTML
元素加上一个点击功能：

{{{class="brush: html" title="radio.v3/radio.html"
<ul id="programs_list" class="">
   <li ng-repeat="program in programs" ng-click="play(program)">
     <span class="large-12">{{ program.title.$text }}</span>
   </li>
</ul>
}}}

通过这一步，我们把一个play动作函数绑定到了列表里的`<li>`DOM元素上。现在，我们在
PlayerController里创建这个play动作函数，然后我们就有了一个功能完备的音频应用：

{{{class="brush: javascript" title="radio.v3/radio.js"
// format.mp4.$text is the route to the mp4 file from the NPR api
$scope.play = function(program) {
	if ($scope.playing) $scope.audio.pause();
	var url = program.audio[0].format.mp4.$text;
	$scope.audio.src = url;
	$scope.audio.play();
	// Store the state of the player as playing
	$scope.playing = true;
}
}}}

现在这个应用功能完备了，但是还不太好看。而且随着我们继续添加新功能，代码也会膨胀
，变得难以管理。我们可以创建自己的指令属性，来帮助我们减少复杂性。

想更多地学习自定义指令属性，可以看看我们
[[http://www.ng-newsletter.com/posts/directives.html|深入探讨指令属性的文章]]

== 使用模板 ==

创建自定义指令属性，我们使用`app`对象的`directive`方法：

{{{class="brush: javascript; highlight: [1,10]" title="radio.v3/radio.js"
app.directive('nprLink', function() {
  return {
    restrict: 'EA',
    require: ['^ngModel'],
    replace: true,
    scope: {
      ngModel: '=',
      play: '&'
    },
    templateUrl: 'views/nprListItem.html',
    link: function(scope, ele, attr) {
      scope.duration = scope.ngModel.audio[0].duration.$text;
    }
  }
});
}}}

我们不会逐个解释每个选项的意义，因为我们有一篇
[[http://www.ng-newsletter.com/posts/directives.html|专门的深入文章]]
来介绍它们。这里我们只需要明白：

* 这个指使名为`nprLink`
* 指向的模版`templateUrl`对应`views/nprListItem.html`

现在，我们的主HTML文件可以保持整洁，而将用来渲染列表内容的view，创建在这个单独
提取出来的模版文件里：

{{{class="brush: html" title="radio.v3/radio.html"
<div class="nprLink row" ng-click="play(ngModel)">
	<span class="name large-8 columns">
		<button class="large-2 small-2 playButton columns">
			<div class="triangle">play</div>
		</button>
		<div class="large-10 small-10 columns">
			<div class="row">
				<span class="large-12">{{ ngModel.title.$text }}</span>
			</div>
			<div class="row">
				<div class="small-1 columns">Go Page:</div>
				<div class="small-2 columns push-8">
					<a href="{{ ngModel.link[0].$text }}">Link</a>
				</div>
			</div>
		</div>
	</span>
</div>
}}}

注意我们在模版文件里用`ngModel`来指向之前的`program`数据，因为在创建自定义指令
属性时，我们做了设置。

现在，我们在主HTML文件里就不用再写上面那么多HTML，而只要简单地换上我们的自定义
指令属性`npr-link`：

{{{class="brush: html" title="radio.v3/radio.html"
<ul id="programs_list" class="">
	<li ng-repeat="program in programs">
		<span npr-link play='play(program)' ng-model="program"></span>
	</li>
</ul>
}}}


[[../code/angular.js/radio.v3/radio|查看效果]]


= 服务 =

目前为止，我们把注意力都放在了如何把视图绑定到$scope和如何用controller管理数据，
从内存和效率角度出发，controllers仅当需要的时候才会被实例化并在不需要的时候
被丢弃掉，这就意味着每一次我们使用route跳转或者重载视图（我们会在下一篇讨论
routing），当前的controller会被销毁。

Services可以让我们在整个应用的生命周期中保存数据并且可以让controllers之间共享
数据。

Services都是单例的，就是说在一个应用中，每一个Serice对象只会被实例化一次（用
`$injector`服务)，主要负责提供一个接口把特定函数需要的方法放在一起，我们就拿
上一章见过的`$http`Service来举例，他就提供了访问底层浏览器的XMLHttpRequest对象的
方法，相较于调用底层的XMLHttpRequest对象，`$http`API使用起来相当的简单。

Angular内建了很多服务供我们日常使用，这些服务对于在复杂应用中建立自己的Services
都是相当有用的。

AngularJS让我们可以轻松的创建自己的services，仅仅注册service即可，一旦注册，
Angular编译器就可以找到并加载他作为依赖供程序运行时使用。

最常见的创建方法就是用`angular.module`API的factory模式：

{{{class="brush: javascript"  title="quickview/service.js"
angular.module('myApp.services', []).factory('githubService', function() {
	var serviceInstance = {};
	// 我们的第一个服务
	return serviceInstance;
});
}}}

当然，我们也可以使用内建的`$provide`service来创建service。

这个服务并没有做实际的事情，但是他向我们展示了如何去定义一个service。创建一个
service就是简单的返回一个函数，这个函数返回一个对象。这个对象是在创建应用实例的
时候创建的（记住，这个对象是单例对象）

我们可以在这个纵贯整个应用的单例对象里处理特定的需求，在上面的例子中，我们开始
创建了GitHub service，接下来让我们添加一些有实际意义的代码去调用GitHub的API：

{{{class="brush: javascript"  title="quickview/service.js"
angular.module('myApp.services', []).factory('githubService', ['$http', 
	function($http) {
		var doRequest = function(username, path) {
			return $http({
				method: 'JSONP',
				url: 'https://api.github.com/users/' + username + '/' + path 
					+ '?callback=JSON_CALLBACK'
			});
		}
		return {
			events: function(username) {
				return doRequest(username, 'events'); 
			},
		};
}]);
}}}

我们创建了一个只有一个方法的GitHub Service，`events`可以获取到给定的GitHub用户
最新的GitHub事件，为了把这个服务添加到我们的controller中。我们建立一个controller
并加载（或者注入）githubService作为运行时依赖，我们把service的名字作为参数传递给
controller 函数（使用中括号`[]`)：

{{{class="brush: javascript"  title="quickview/service.js"
app.controller('ServiceController', ['$scope', 'githubService', 
	function($scope, githubService) { }
]);
}}}

请注意，这种依赖注入的写法对于js压缩是安全的，我们会在以后的章节中深入导论这件
事情。

我们的`githubService`注入到我们的`ServiceController`后，我们就可以像使用其他服务
（我们前面提到的`$http`服务）一样的使用`githubService`了。

我们来修改一下我们的示例代码，对于我们视图中给出的GitHub用户名，调用GitHub API，
就像我们在数据绑定第三章节看到的，我们绑定`username`属性到视图中

{{{class="brush: html"  title="quickview/service.html"
<div ng-controller="ServiceController">
	<label for="username">Type in a GitHub username</label>
	<input type="text" ng-model="username" 
		placeholder="Enter a GitHub username, like auser" />
	<pre ng-show="username">{{ events }}</pre>
</div>
}}}

现在我们可以监视`$scope.username`属性，基于双向数据绑定，只要我们修改了视图，
对应的model数据也会修改：

{{{class="brush: javascript"  title="quickview/service.js"
app.controller('ServiceController', ['$scope', 'githubService', 
	function($scope, githubService) {
    // Watch for changes on the username property.
    // If there is a change, run the function
    $scope.$watch('username', function(newUsername) {
			// uses the $http service to call the GitHub API
			// and returns the resulting promise
			githubService.events(newUsername).success(
				function(data, status, headers) {
					// the success function wraps the response in data
					// so we need to call data.data to fetch the raw data
					$scope.events = data.data;
				}
			)
    });
	}
]);
}}}

因为返回了`$http`promise(像我们上一章一样），我们可以像直接调用
`$http`service一样的去调用`.success`方法。

[[../code/angular.js/quickview/service|查看效果]]

在这个示例中，我们注意到输入框内容改变前有一些延迟，如果我们不设置延迟，那么我们
就会对键入输入框的每一个字符调用GitHub API，这并不是我们想要的，我们可以使用内建
的`$timeout`服务来实现这种延迟。

如果想使用`$timeout`服务，我们只要简单的把他注入到我们的`githubService`中就可以
了：

{{{class="brush: javascript"  title="quickview/service.js"
app.controller('ServiceController', ['$scope', '$timeout', 'githubService',
    function($scope, $timeout, githubService) {
}]);
}}}

注意我们要遵守Angular services依赖注入的规范：

自定义的service要写在内建的Angular services之后，自定义的service之间是没有先后
顺序的。

我们现在就可以使用`$timeout`服务了，在本例中，在输入框内容的改变间隔如果没有超过
350毫秒，`$timeout`service不会发送任何网络请求。换句话说，如果在键盘输入时超过
350毫秒，我们就假定用户已经完成输入，我们就可以开始向GitHub发送请求

{{{class="brush: javascript"  title="quickview/service.js"
app.controller('ServiceController', ['$scope', '$timeout', 'githubService',
  function($scope, $timeout, githubService) {
    // The same example as above, plus the $timeout service
    var timeout;
    $scope.$watch('username', function(newVal) {
      if (newVal) {
        if (timeout) $timeout.cancel(timeout);
        timeout = $timeout(function() {
          githubService.events(newVal)
          .success(function(data, status) {
            $scope.events = data.data;
          });
        }, 350);
      }
    });
  }]);
}}}

从这应用开始，我们只看到了Services是如何把简单的功能整合在一起，Services还可以在
多个controllers之间共享数据。比如，如果我们的应用有一个设置页面供用户设置他们的
GitHub username，那么我们就要需要把`username`与其他controllers共享。

这个系列的最后一章我们会讨论路由以及如何在多页面中跳转。

为了在controllers之间共享`username`，我们需要在service中存储`username`，记住，在
应用的生命周期中Service是一直存在的，所以可以把`username`安全的存储在这里：

{{{class="brush: html" title=""
angular.module('myApp.services', []).factory('githubService', ['$http', 
	function($http) {
		var githubUsername;
		var doRequest = function(path) {
			return $http({
				method: 'JSONP',
				url: 'https://api.github.com/users/' + githubUsername + '/' + path 
					+ '?callback=JSON_CALLBACK'
			});
		}
		return {
			events: function() { return doRequest('events'); },
			setUsername: function(newUsername) { githubUsername = newUsername; }
		};
	}
]);
}}}

== 结合应用 ==

{{{class="brush: html" title=""
}}}


{{{class="brush: html" title=""
}}}


{{{class="brush: html" title=""
}}}


{{{class="brush: html" title=""
}}}


{{{class="brush: html" title=""
}}}


{{{class="brush: html" title=""
}}}


{{{class="brush: html" title=""
}}}


{{{class="brush: html" title=""
}}}


{{{class="brush: html" title=""
}}}


{{{class="brush: html" title=""
}}}


{{{class="brush: html" title=""
}}}


{{{class="brush: html" title=""
}}}


{{{class="brush: html" title=""
}}}


{{{class="brush: html" title=""
}}}


{{{class="brush: html" title=""
}}}


{{{class="brush: html" title=""
}}}


{{{class="brush: html" title=""
}}}


{{{class="brush: html" title=""
}}}


{{{class="brush: html" title=""
}}}


{{{class="brush: html" title=""
}}}


{{{class="brush: html" title=""
}}}


{{{class="brush: html" title=""
}}}


{{{class="brush: html" title=""
}}}


{{{class="brush: html" title=""
}}}


{{{class="brush: html" title=""
}}}


{{{class="brush: html" title=""
}}}


{{{class="brush: html" title=""
}}}


{{{class="brush: html" title=""
}}}


{{{class="brush: html" title=""
}}}


{{{class="brush: html" title=""
}}}


{{{class="brush: html" title=""
}}}


{{{class="brush: html" title=""
}}}


{{{class="brush: html" title=""
}}}


{{{class="brush: html" title=""
}}}

