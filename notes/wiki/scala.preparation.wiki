
%title 准备工作

%toc 准备工作

= 配置 =

== 字符编码问题 ==

在默认字符编码为UTF-8的Linux下没问题。

Mac OS X系统的默认字符编码早就改成了UTF-8但它bundle的Java默认字符编码却一直是
MacRoman。在启动REPL时传入参数`-Dfile.encoding=UTF-8`。

用vim、emacs或者你习惯的文本编辑器打开scala命令，比如：

{{{class="brush: bash"
$ vim `which scala`
}}}

找到如下行：
{{{class="brush: bash"
[ -n "$JAVA_OPTS" ] || JAVA_OPTS="-Xmx256M -Xms32M"
}}}

把`-D`参数加到`JAVA_OPTS`里即可。

== Vim插件 ==

到[[https://github.com/scala/scala-dist]]上下载，
复制`tool-support/src/vim`到`.vim`目录下。


= 使用 =
 
== Scala Shell ==

使用进入REPL环境的方式：

{{{class="brush: bash"
--(morgan-laptop:pts/8)-(13-03-15 9:04:57)-(~/workspace/study/scala)
\-(morgan:%) >>> scala
Welcome to Scala version 2.9.2 (OpenJDK 64-Bit Server VM, Java 1.7.0_15).
Type in expressions to have them evaluated.
Type :help for more information.

scala> 
}}}

输入回车自动换行。

发现输错了，再按几个回车就退出了。

退出`Scala Shell`：`:quit`或`:q`

在REPL环境中只能一行一行读取，所以如果要换行的话，不能让一行在语法上看起来已经
结束：

{{{class="brush: scala"
scala> if(x > 0) { 1
     | } else if(x == 0) 0 else -1
res1: Int = 1
}}}

另一个方法是在REPL中输入`:paste`粘贴代码，按下`Control + D`。

== 脚本 ==

脚本文件，可以接收一个参数并输出欢迎信息：

{{{class="brush: scala" title="helloarg.scala"
/* 可以接收一个参数 */
println("Hello, " + args(0) + "!")
}}}

调用脚本：scala命令、文件名、参数

{{{class="brush: bash"
--(morgan-laptop:pts/8)-(13-03-14 23:28:27)-(~/workspace/study/scala/tmp)
\-(morgan:%) >>> scala helloarg.scala Jade
Hello, Jade!
}}}

可以通过循环处理多个参数的：

{{{class="brush: scala" title="pa.scala"
args.foreach( arg => println(arg) )
}}}

调用：

{{{class="brush: bash"
--(morgan-laptop:pts/8)-(13-03-14 23:49:39)-(~/workspace/study/scala/tmp)
\-(morgan:%) >>> scala pa.scala Scala is even more fun      
Scala
is
even
more
fun
}}}

=== OS可执行脚本 ===

Unix下可执行脚本：

{{{class="brush: scala" title="helloarg"
#!/bin/sh
	exec scala "$0" "$@"
!#

println("hello," + arg(0) + "!")
}}}

执行：

{{{class="brush: bash"
$ chmod +x helloarg

$ ./helloarg globe
}}}

Windows下可执行脚本：

{{{class="brush: scala" title="helloarg.bat"
::#!
@echo off
call scala %0 %*
goto :eof
::!#

println("hello," + arg(0) + "!")
}}}

执行：

{{{class="brush: bash"
> helloarg.bat globe
}}}


== Scala程序 ==

先看一个工具类，它根据字符串来计算出检验和：

{{{class="brush: scala" title="ChecksumAccumulator.scala"
import scala.collection.mutable.Map

class ChecksumAccumulator {
	private var sum = 0
	def add(b: Byte) { sum += b }
	def checksum(): Int =  ~(sum &0xFF) + 1
}

object ChecksumAccumulator {
	private val cache = Map[String, Int]()

	def calculate(s: String): Int =
		if( cache.contains(s) ) {
			cache(s)
		} else {
			val acc = new ChecksumAccumulator
			for (c <- s)
				acc.add(c.toByte)
			val cs = acc.checksum()
			cache += (s -> cs)
			cs
		}
}
}}}

然后是主程序。独立运行的程序一定要有`main`方法（仅有一个参数`Array[String]`而且
结果类型为`Unit`）的单例对象。

{{{class="brush: scala" title="Summer.scala"
import ChecksumAccumulator.calculate

object Summer {

	def main(args: Array[String]) {
		for (arg <- args)
			println(arg + " -> " + calculate(arg))
	}

}
}}}

编译Scala程序：

{{{class="brush: bash"
--(morgan-laptop:pts/8)-(13-03-15 0:28:39)-(~/workspace/study/scala/tmp)
\-(morgan:%) >>> scalac ChecksumAccumulator.scala Summer.scala
}}}

有一个`fast Scala compiler`的后台进程可以在第一次被调用后一直跑在后台，
节省一下每次编译的速度：

{{{class="brush: bash"
--(morgan-laptop:pts/8)-(13-03-15 0:29:11)-(~/workspace/study/scala/tmp)
\-(morgan:%) >>> fsc ChecksumAccumulator.scala Summer.scala   
}}}

可以关掉这个后台进程：

{{{class="brush: bash"
--(morgan-laptop:pts/8)-(13-03-15 0:29:11)-(~/workspace/study/scala/tmp)
\-(morgan:%) >>> fsc -shutdown
}}}

编译完后可以看到生成的`.class`文件：

{{{class="brush: bash"
--(morgan-laptop:pts/8)-(13-03-15 0:44:31)-(~/workspace/study/scala/tmp)
\-(morgan:%) >>> ls *.class
ChecksumAccumulator$$anonfun$calculate$1.class  ChecksumAccumulator$.class    Summer.class
ChecksumAccumulator.class                       Summer$$anonfun$main$1.class  Summer$.class
}}}

运行编译出来的类文件：

{{{class="brush: bash"
--(morgan-laptop:pts/8)-(13-03-15 0:30:58)-(~/workspace/study/scala/tmp)
\-(morgan:%) >>> scala Summer of love
of -> -213
love -> -182
}}}

还有一个加入的`Application`特质的方式实现应用程序，但是有局限：
不能访问命令行参数、只能在单线程下用。所以不推荐用它。

形式类似于：
{{{class="brush: scala" title="myApp.scala"
object MyApp extends Application {
	println("Hello")
}	
}}}


== 脚本与程序的区别 ==

脚本必须以表达式结束，而程序以定义结尾。尝试以`scala`解释器运行程序会报错。


= 构建工具 =

== Ant任务 ==

相关的Ant任务有`scalac`、`fsc`和`scaladoc`，这里只介绍`scalac`。

{{{class="brush: bash" title="build.properties"
scala.home=/opt/morganstudio/language/scala
compile.version=1.7
deploy.name=scala-example
}}}

{{{class="brush: xml" title="build.xml"
<?xml version="1.0" encoding="UTF-8"?>
<project name="scala-example" default="init" basedir=".">
	<description>scala example</description>
	<property file="build.properties" />

	<property name="sources.dir" value="sources" />
	<property name="build.dir" value="build" />

	<target name="init">
		<property name="scala-library.jar" 
			value="${scala.home}/lib/scala-library.jar" />
		<path id="build.classpath">
			<pathelement location="${scala-library.jar}"   />
			<pathelement location="${build.dir}"   />
		</path>
		<taskdef resource="scala/tools/ant/antlib.xml">
			<classpath>
				<pathelement location="${scala.home}/lib/scala-compiler.jar"   />
				<pathelement location="${scala-library.jar}"   />
			</classpath>
		</taskdef>
	</target>

	<target name="build" depends="init">
		<mkdir dir="${build.dir}"   />
		<scalac srcdir="${sources.dir}"
			destdir="${build.dir}"
			classpathref="build.classpath">
			<include name="**/*.scala"   />
		</scalac>
	</target>

	<target name="run" depends="build">
		<java classname="Summer"
			classpathref="build.classpath">
		</java>
	</target>
</project>
}}}

以后可能会用到的jar包还有`scala-actors.jar`和`scala-dbc.jar`.


== maven构建 ==


* 注意不同版本的Scala字节码有差异，所以要指明版本。
* 加入了插件以后要指定版本，如果不清楚的话调用时加上`-U`选项。

{{{class="brush: xml; highlight: [15,26,36]" title="pom.xml"
<project xmlns="http://maven.apache.org/POM/4.0.0" 
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 
	http://maven.apache.org/maven-v4_0_0.xsd">

	<modelVersion>4.0.0</modelVersion>
	<groupId>org.scala-lang.demo</groupId>
	<artifactId>scala-test</artifactId>
	<packaging>jar</packaging>
	<version>1.0-SNAPSHOT</version>
	<name>Demo of maven for Scala Lang website</name>
	<url>http://scala-lang.org</url>

	<properties>
		<scala.version>2.10.2</scala.version>
	</properties>

	<build>
		<sourceDirectory>src/main/scala</sourceDirectory>
		<testSourceDirectory>src/test/scala</testSourceDirectory>

		<plugins>
			<plugin>
				<groupId>net.alchim31.maven</groupId>
				<artifactId>scala-maven-plugin</artifactId>
				<version>3.1.5</version>
				<executions>
					<execution>
						<goals>
							<goal>compile</goal>
							<goal>testCompile</goal>
						</goals>
					</execution>
				</executions>
				<configuration>
					<scalaVersion>${scala.version}</scalaVersion>
				</configuration>
			</plugin>
		</plugins>

	</build>

</project>
}}}

=== 内存参数配置 ===

{{{class="brush: xml; highlight: [17,18]" title="pom.xml"
<project>
  ...
      <plugin>
        <groupId>net.alchim31.maven</groupId>
        <artifactId>scala-maven-plugin</artifactId>
        <version>3.1.5</version>
        <executions>
          <execution>
            <goals>
              <goal>compile</goal>
              <goal>testCompile</goal>
            </goals>
          </execution>
        </executions>
        <configuration>
          <jvmArgs>
            <jvmArg>-Xms64m</jvmArg>
            <jvmArg>-Xmx1024m</jvmArg>
          </jvmArgs>
        </configuration>
      </plugin>
  ...
</project>
}}}


=== 编译开关 ===

{{{class="brush: xml; highlight: [9,10,11]" title="pom.xml"
<project>
  ...
  <plugin>
    <groupId>net.alchim31.maven</groupId>
    <artifactId>scala-maven-plugin</artifactId>
    <version>3.1.5</version>
    <configuration>
      <args>
        <arg>-unchecked</arg>
        <arg>-deprecation</arg>
        <arg>-explaintypes</arg>
      </args>
    </configuration>
  </plugin>
  ...
</project>
}}}

=== 使用本地的scala's jar ===

可以不用maven库里的scala版本而是本地`scala.home`变量指定的版本。但不要这样部署
与安装，这样会搞坏工程的。这里用到了：

* `${scala.home}/lib/scala-library.jar`
* `${scala.home}/lib/scala-compiler.jar`

{{{class="brush: xml; highlight: [17,18]" title="pom.xml"
mvn compile -Dscala.home=<path/of/scalaHome>
}}}


=== 运行 ===

==== 运行Scala程序 ====

定义Scala语言依赖；定义启动器指定运行类与id、参数，启动器可以有多个

{{{class="brush: xml; highlight: [20,21,38,39,41,42]" title="pom.xml"
<project xmlns="http://maven.apache.org/POM/4.0.0" 
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 
	http://maven.apache.org/maven-v4_0_0.xsd">

	<modelVersion>4.0.0</modelVersion>
	<groupId>org.scala-lang.demo</groupId>
	<artifactId>scala-test</artifactId>
	<packaging>jar</packaging>
	<version>1.0-SNAPSHOT</version>
	<name>Demo of maven for Scala Lang website</name>
	<url>http://scala-lang.org</url>

	<properties>
		<scala.version>2.10.2</scala.version>
	</properties>

	<dependencies>
		<dependency>
			<groupId>org.scala-lang</groupId>
			<artifactId>scala-library</artifactId>
			<version>2.10.2</version>
		</dependency>
	</dependencies>

	<build>
		<sourceDirectory>src/main/scala</sourceDirectory>
		<testSourceDirectory>src/test/scala</testSourceDirectory>
		<plugins>
			<plugin>
				<groupId>net.alchim31.maven</groupId>
				<artifactId>scala-maven-plugin</artifactId>
				<version>3.1.5</version>
				<configuration>
					<scalaVersion>${scala.version}</scalaVersion>
					<launchers>
						<launcher>
							<id>foo</id>
							<mainClass>Example</mainClass>
							<args>
								<arg>Hello</arg>
								<arg>World</arg>
							</args>
						</launcher>
					</launchers>
				</configuration>
			</plugin>
		</plugins>
	</build>
</project>
}}}

指定类启动：

{{{class="brush: bash" title="pom.xml"
mvn scala:run -DmainClass=Example
}}}

也可以指定启动器id启动：

{{{class="brush: bash" title="pom.xml"
mvn scala:run -Dlauncher=foo
}}}

==== 运行单元测试 ====

导入ScalaTest与Junit包；定义编译测试任务；

{{{class="brush: xml" title="pom.xml"
	<dependencies>
		<dependency>
			<groupId>org.scala-lang</groupId>
			<artifactId>scala-library</artifactId>
			<version>2.10.2</version>
		</dependency>
		<dependency>
			<groupId>org.scalatest</groupId>
			<artifactId>scalatest_2.10</artifactId>
			<version>1.9.1</version>
			<scope>test</scope>
		</dependency>
		<dependency>
			<groupId>junit</groupId>
			<artifactId>junit</artifactId>
			<version>4.10</version>
			<scope>test</scope>
		</dependency>
	</dependencies>

	<build>
		<sourceDirectory>src/main/scala</sourceDirectory>
		<testSourceDirectory>src/test/scala</testSourceDirectory>
		<plugins>
			<plugin>
				<groupId>net.alchim31.maven</groupId>
				<artifactId>scala-maven-plugin</artifactId>
				<version>3.1.5</version>
			</plugin>
			<plugin>
				<groupId>org.apache.maven.plugins</groupId>
				<artifactId>maven-surefire-plugin</artifactId>
				<version>2.12</version>
			</plugin>
		</plugins>
	</build>
}}}

不过我测试中好像surefire插件一段不加上也能启用sufire任务。

在Scala程序里`@RunWith`注解让surefire能找到继承自`FunSuite`的测试类：

{{{class="brush: scala; highlight: [7,9]" title="TestUnitTest.scala"
package com.tysonhamilton.scalatest.test

import org.scalatest.junit.JUnitRunner
import org.scalatest.FunSuite
import org.junit.runner.RunWith

@RunWith(classOf[JUnitRunner])
class TestUnitTest extends FunSuite {
	test("TwoPlusTwo") {
		val twoPlusTwo = 2 + 2
		assert(twoPlusTwo == 4)
	}
}
}}}

运行的命令：

*  `maven:clean`
*  `scala:compile`
*  `scala:testCompile`
*  `surefire:test`

还可以把测试用例的编译与运行放到Maven的生命周期中去：

{{{class="brush: xml; highlight: [11,18,32]" title="pom.xml"
	<build>
		<sourceDirectory>src/main/scala</sourceDirectory>
		<testSourceDirectory>src/test/scala</testSourceDirectory>
		<plugins>
			<plugin>
				<groupId>net.alchim31.maven</groupId>
				<artifactId>scala-maven-plugin</artifactId>
				<version>3.1.5</version>
				<executions>
					<execution>
						<id>compile-scala</id>
						<phase>compile</phase>
						<goals>
							<goal>compile</goal>
						</goals>
					</execution>
					<execution>
						<id>compile-tests-scala</id>
						<phase>compile</phase>
						<goals>
							<goal>testCompile</goal>
						</goals>
					</execution>
				</executions>
			</plugin>
			<plugin>
				<groupId>org.apache.maven.plugins</groupId>
				<artifactId>maven-surefire-plugin</artifactId>
				<version>2.12</version>
				<executions>
					<execution>
						<id>surefire-test</id>
						<phase>test</phase>
						<goals>
							<goal>test</goal>
						</goals>
					</execution>
				</executions>
			</plugin>
		</plugins>
	</build>
}}}

这样就并到三个周期里去了：

*  `maven:clean`
*  `maven:compile`
*  `maven:test`

=== 构建混合Java与Scala ===

{{{class="brush: xml; highlight: [17,18]" title="pom.xml"
<build>
	<pluginManagement>
		<plugins>
			<plugin>
        <groupId>net.alchim31.maven</groupId>
        <artifactId>scala-maven-plugin</artifactId>
        <version>3.1.5</version>
			</plugin>
			<plugin>
				<groupId>org.apache.maven.plugins</groupId>
				<artifactId>maven-compiler-plugin</artifactId>
				<version>2.0.2</version>
			</plugin>
		</plugins>
	</pluginManagement>
	<plugins>
		<plugin>
      <groupId>net.alchim31.maven</groupId>
      <artifactId>scala-maven-plugin</artifactId>
			<executions>
				<execution>
					<id>scala-compile-first</id>
					<phase>process-resources</phase>
					<goals>
					  <goal>add-source</goal>
						<goal>compile</goal>
					</goals>
				</execution>
				<execution>
					<id>scala-test-compile</id>
					<phase>process-test-resources</phase>
					<goals>
						<goal>testCompile</goal>
					</goals>
				</execution>
			</executions>
		</plugin>
		<plugin>
			<groupId>org.apache.maven.plugins</groupId>
			<artifactId>maven-compiler-plugin</artifactId>
			<executions>
				<execution>
					<phase>compile</phase>
					<goals>
						<goal>compile</goal>
					</goals>
				</execution>
			</executions>
		</plugin>
	</plugins>
</build>
}}}

{{{class="brush: xml; highlight: [17,18]" title="pom.xml"
}}}
