
%title Java并发

%toc Java并发

= 对象组合 =

== 锁错对象 ==

同一个原子操作没有锁住同一个对象：

{{{class="brush: java"
@NotThreadSafe
public class ListHelper<E> {

	// 虽然是并发安全列表，但用的锁是列表自己
	public List<E> list =
		Collections.synchronizedList(new ArrayList<E>());
		
	// ...
	
	// 这里的同步锁用的是this
	public synchronized boolean putIfAbsent(E x) {
		boolean absent = !list.contains(x);
		if (absent) list.add(x);
		return absent;
	}
}
}}}

下面这样就对了，锁住的是同一个对象：

{{{class="brush: java"
@ThreadSafe
public class ListHelper<E> {

	// 虽然是并发安全列表，但用的锁是列表自己
	public List<E> list =
		Collections.synchronizedList(new ArrayList<E>());
		
	// ...
	
	public synchronized boolean putIfAbsent(E x) {
		// 也是锁的list  
		synchronized (list) {
			boolean absent = !list.contains(x);
			if (absent) list.add(x);
			return absent;
		}
	}
}
}}}


== 恢复中断 ==

处理异常以后如果应该中断当前线程，应该中断：

{{{class="brush: java"
public class TaskRunnable implements Runnable {
	BlockingQueue<Task> queue;

	//...

	public void run() {
		try {
			processTask(queue.take());
		} catch (InterruptedException e) {
			// 中断当前线程
			Thread.currentThread().interrupt();
		}
	}
}
}}}



{{{class="brush: java"
}}}



{{{class="brush: java"
}}}



{{{class="brush: java"
}}}



{{{class="brush: java"
}}}



{{{class="brush: java"
}}}



{{{class="brush: java"
}}}



{{{class="brush: java"
}}}



{{{class="brush: java"
}}}



{{{class="brush: java"
}}}



{{{class="brush: java"
}}}



{{{class="brush: java"
}}}



{{{class="brush: java"
}}}



{{{class="brush: java"
}}}



{{{class="brush: java"
}}}


{{{class="brush: java"
}}}
