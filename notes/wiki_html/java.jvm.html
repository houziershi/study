<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">

<script type="text/javascript" src="../../vimwiki-theme/code/theme/scripts/jquery-1.4.2.min.js"></script>

<link type="text/css" rel="stylesheet" href="../../vimwiki-theme/hightlight-code/styles/shCore.css"/>
<link type="text/css" rel="stylesheet" href="../../vimwiki-theme/hightlight-code/styles/shCoreRDark.css"/>
<link type="text/css" rel="stylesheet" href="../../vimwiki-theme/hightlight-code/styles/shThemeRDark.css"/>
<script type="text/javascript" src="../../vimwiki-theme/hightlight-code/scripts/shCore.js"></script>
<script type="text/javascript" src="../../vimwiki-theme/hightlight-code/scripts/shAutoloader.js"></script>

<link type="text/css" rel="stylesheet" href="../../vimwiki-theme/code/theme/styles/style.css" />

<script type="text/javascript" src="../../vimwiki-theme/code/theme/scripts/script.js"></script>


<title>Java虚拟机</title>
</head>
<body  onresize='changeTocSize()'>
	<div class="note-main"> 


<h1>Java虚拟机</h1>
<div class="toc">
<ul>
<li><a href="#toc_1">启动参数</a>
<ul>
<li><a href="#toc_1.1">诊断性能</a>
<ul>
<li><a href="#toc_1.1.1">DisableExplicitGC</a>
</ul>
<li><a href="#toc_1.2">加载配置</a>
<ul>
<li><a href="#toc_1.2.1">HeapDumpOnOutOfMemoryError</a>
<li><a href="#toc_1.2.2">买者自负</a>
<li><a href="#toc_1.2.3">bootclasspath</a>
<li><a href="#toc_1.2.4">verbose</a>
<li><a href="#toc_1.2.5">Command-line-X</a>
</ul>
</ul>
</ul>
</div>

<h1 id="toc_1">启动参数</h1>

<h2 id="toc_1.1">诊断性能</h2>

<h3 id="toc_1.1.1">DisableExplicitGC</h3>

<p>
我已记不清有多少次用户要求我就应用程序性能问题提供咨询了，其实只要跨代码快速运行
<code>grep</code>，就会发现清单1所示的问题—原始Java性能反模式：
</p>

<pre class="brush: java">
// We just released a bunch of objects, so tell the stupid
// garbage collector to collect them already!
System.gc();
</pre>

<p>
显式垃圾收集是一个非常糟糕的主意——就像将您和一个疯狂的斗牛犬锁在一个电话亭里。
尽管调用的语法是依赖实现的，但如果您的JVM正在运行一个分代的垃圾回收器（大多数是
）<code>System.gc()</code>;强迫VM执行一个堆的“全部清扫”，虽然有的没有必要。全部清扫比一个
常规GC操作要昂贵好几个数量级，这只是个简单数学问题。
</p>

<p>
您可以不把我的话放在心上Sun的工程师为这个特殊的人工错误提供一个JVM标志：
<code>-XX:+DisableExplicitGC</code>标志自动将<code>System.gc()</code>调用转换成一个空操作，为您提供运
行代码的机会，您自己看看<code>System.gc()</code>对于整个JVM执行有害还是有利。
</p>

<h2 id="toc_1.2">加载配置</h2>

<h3 id="toc_1.2.1">HeapDumpOnOutOfMemoryError</h3>

<p>
您有没有经历过这样的情况：JVM不能使用，不断抛出<code>OutOfMemoryError</code>，而您又不能为
自己创建调试器来捕获它或查看出现了什么问题？像这类偶发或不确定的问题，通常使
开发人员发疯。
</p>

<h3 id="toc_1.2.2">买者自负</h3>

<p>
并不是任何VM都支持所有命令行标志，Sun/Oracle的VM除外。查明一个标志是否被支持的
最好方法是试用它，看它是否正常工作。倘若这些标志在技术上是不支持的，那么，使用
它们您要承担全部责任。如果这些标志中的任何一个使您的代码、您的数据、您的服务器
或您的一切消失得无影无踪，我、Sun/Oracle和IBM都将不负责任。为以防万一，建议先在
虚拟（非常生产）环境中实验。
</p>

<p>
在这个时刻您想要的是，在JVM消亡之际捕获堆的一个快照，
</p>

<p>
正好<code>-XX:+HeapDumpOnOutOfMemoryError</code>命令可以完成这一操作。
</p>

<p>
运行该命令通知JVM拍摄一个“堆转储快照”，并将其保存在一个文件中以便处理，通常使用
<code>jhat</code>实用工具（我在上一篇文章中介绍过）。您可以使用相应的<code>-XX:HeapDumpPath</code>标志
指定到保存文件的实际路径。（不管文件保存在哪，务必确保文件系统或Java流程必须
要有权限配置，可以在其中写入。）
</p>

<h3 id="toc_1.2.3">bootclasspath</h3>

<p>
定期将一个类放入类路径是很有帮助的，这类路径与库存JRE附带的类路径或者以某种方式
扩展的JRE类路径略有不同。（新Java Crypto API提供商就是一个例子）。如果您想要扩展
JRE，那么您定制的实现必须可以使用引导程序<code>ClassLoader</code>，该引导程序可以加载
<code>rt.jar</code>中的<code>java.lang.Object</code>及其所有相关文件。
</p>

<p>
尽管您可以非法打开<code>rt.jar</code>并将您的定制实现或新数据包移入其中，但从技术上您就违反
了您下载JDK时同意的协议了。
</p>

<p>
相反，使用JVM自己的<code>-Xbootclasspath</code>选项，以及皮肤<code>-Xbootclasspath/p</code>
和<code>-Xbootclasspath/a</code>。
</p>

<p>
<code>-Xbootclasspath</code>使您可以设置完整的引导类路径（这通常包括一个对<code>rt.jar</code>的引用）
，以及一些其他JDK附带的（不是<code>rt.jar</code>的一部分）JAR文件。<code>-Xbootclasspath/p</code>将值
前置到现有<code>bootclasspath</code>中，并将<code>-Xbootclasspath/a</code>附加到其中。
</p>

<p>
例如，如果您修改了库中的<code>java.lang.Integer</code>，并将修改放在一个子路径<code>mods</code>下，那
么<code>-Xbootclasspath/amods</code>参数将新<code>Integer</code>放在默认的参数前面。
</p>

<h3 id="toc_1.2.4">verbose</h3>

<p>
对于虚拟的或任何类型的Java应用程序，<code>-verbose</code>是一个很有用的一级诊断使用程序。
该标志有三个子标志：<code>gc</code>、<code>class</code>和<code>jni</code>。
</p>

<p>
开发人员尝试寻找是否 JVM 垃圾收集器发生故障或者导致性能低下，通常首先要做的就是
执行 gc。不幸的是，解释 gc 输出很麻烦 — 足够写一本书。更糟糕的是，在命令行中打印
的输出在不同的Java或JVM 中会发生改变，这使得正确解释变得更难。
</p>

<p>
一般来说，如果垃圾收集器是一个分代收集器（多数“企业级”VMs都是）。某种虚拟标志
将会出现，来指出一个全部清扫GC通路；在Sun JVM中，标志在GC输出行的开始以
<code>[FullGC...]</code>形式出现。
</p>

<p>
想要诊断ClassLoader或不匹配的类冲突，class可以帮上大忙。它不仅报告类何时加载，
还报告类从何处加载，包括到JAR的路径（如果来自JAR）。
</p>

<p>
jni很少使用，除了使用JNI或本地库时。打开时，它将报告各种JNI事件，比如，本地库
何时加载，方法何时弹回；再一次强调，在不同JVM版本中，输出会发生变化。
</p>

<h3 id="toc_1.2.5">Command-line-X</h3>

<p>
我列出了JVM中提供的我喜欢的命令行选项，但是还有一些更多的需要您自己发现，运行
命令行参数<code>-X</code>，列出JVM提供的所有非标准（但大部分都是安全的）参数—例如：
</p>

<ul>
<li>
<code>-Xint</code>，在解释模式下运行JVM（对于测试JIT编译器实际上是否对您的代码起作用或者验证是否JIT编译器中有一个bug，这都很有用）。

<li>
<code>-Xloggc:</code>，和<code>-verbose:gc</code>做同样的事，但是记录一个文件而不输出到命令行窗口。

</ul>

<p>
JVM命令行选项时常发生变化，因此，定期查看是一个好主意。
</p>
 </div>
</body>
</html>
