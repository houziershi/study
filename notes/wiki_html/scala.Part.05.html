<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">

<script type="text/javascript" src="../../vimwiki-theme/code/theme/scripts/jquery-1.4.2.min.js"></script>

<link type="text/css" rel="stylesheet" href="../../vimwiki-theme/hightlight-code/styles/shCore.css"/>
<link type="text/css" rel="stylesheet" href="../../vimwiki-theme/hightlight-code/styles/shCoreRDark.css"/>
<link type="text/css" rel="stylesheet" href="../../vimwiki-theme/hightlight-code/styles/shThemeRDark.css"/>
<script type="text/javascript" src="../../vimwiki-theme/hightlight-code/scripts/shCore.js"></script>
<script type="text/javascript" src="../../vimwiki-theme/hightlight-code/scripts/shAutoloader.js"></script>

<link type="text/css" rel="stylesheet" href="../../vimwiki-theme/code/theme/styles/style.css" />

<script type="text/javascript" src="../../vimwiki-theme/code/theme/scripts/script.js"></script>


<title>Part V</title>
</head>
<body  onresize='changeTocSize()'>
	<div class="note-main"> 


<h1>Part V</h1>
<div class="toc">
<ul>
<li><a href="#toc_1">实现列表</a>
<ul>
<li><a href="#toc_1.1">List类实现原理</a>
<ul>
<li><a href="#toc_1.1.1">Nil对象</a>
<li><a href="#toc_1.1.2">Cons类</a>
<li><a href="#toc_1.1.3">其他的类方法</a>
<li><a href="#toc_1.1.4">列表构建</a>
<li><a href="#toc_1.1.5">连接列表方法</a>
</ul>
<li><a href="#toc_1.2">ListBuffer类</a>
<li><a href="#toc_1.3">实际的List类实现</a>
<li><a href="#toc_1.4">外在的函数式风格</a>
</ul>
<li><a href="#toc_2">重温for表达式</a>
<ul>
<li><a href="#toc_2.1">For表达式</a>
<li><a href="#toc_2.2">8皇后问题</a>
<li><a href="#toc_2.3">使用for表达式进行查询</a>
<li><a href="#toc_2.4">for表达式的转译</a>
<ul>
<li><a href="#toc_2.4.1">简单变量生成器</a>
<ul>
<li><a href="#toc_2.4.1.1">一个生成器</a>
<li><a href="#toc_2.4.1.2">以一个生成器和过滤器载开头</a>
<li><a href="#toc_2.4.1.3">以两个生成器开始</a>
<li><a href="#toc_2.4.1.4">组合应用生成变量的例子</a>
</ul>
<li><a href="#toc_2.4.2">生成器转译中的模式</a>
<ul>
<li><a href="#toc_2.4.2.1">变量元组</a>
<li><a href="#toc_2.4.2.2">单个模式匹配的情况</a>
</ul>
<li><a href="#toc_2.4.3">多层内嵌定义</a>
<li><a href="#toc_2.4.4">没有返回值的情况</a>
</ul>
<li><a href="#toc_2.5">把高阶函数转为for循环</a>
<li><a href="#toc_2.6">for的应用</a>
</ul>
<li><a href="#toc_3">抽取器（Extractors）</a>
<ul>
<li><a href="#toc_3.1">例子：抽取email地址</a>
<li><a href="#toc_3.2">抽取器</a>
<li><a href="#toc_3.3">只有1个或没有变量的模式</a>
<li><a href="#toc_3.4">可变参数的抽取器</a>
<li><a href="#toc_3.5">抽取器和序列模式</a>
<li><a href="#toc_3.6">抽取器 VS. 样本类</a>
<li><a href="#toc_3.7">正则表达式</a>
<ul>
<li><a href="#toc_3.7.1">形成正则表达式</a>
<li><a href="#toc_3.7.2">用正则表达式查找替换</a>
<li><a href="#toc_3.7.3">正则表达式抽取值</a>
</ul>
</ul>
</ul>
</div>


<h1 id="toc_1">实现列表</h1>

<p>
列表不是Scala语言的内建结构，而是定义在<code>Scala</code>包中的<code>List</code>抽象类。它有一个子类
<code>::</code>和一个子对象<code>Nil</code>。
</p>



<h2 id="toc_1.1">List类实现原理</h2>

<p>
本节的目的是实现一个简化的List实现：
</p>

<pre class="brush: scala">
  package scala
  abstract class List[+T] { ... }
</pre>

<p>
作为一个抽象类<code>List</code>不能用像<code>new List</code>这样的空构造器构建，由类型参数<code>[+T]</code>表明
列表是协变的。
</p>


<pre class="brush: scala">
  scala&gt; val xs = List(1, 2, 3)
  xs: List[Int] = List(1, 2, 3)

  scala&gt; var ys: List[Any] = xs
  ys: List[Any] = List(1, 2, 3)
</pre>

<p>
实现的目标要有以下三个功能：
</p>

<pre class="brush: scala">
    def isEmpty: Boolean
    def head: T
    def tail: List[T]
</pre>

<p>
这三个方法在<code>List</code>类中是抽象的，被定义在<code>Nil</code>和<code>::</code>中。
</p>

<h3 id="toc_1.1.1">Nil对象</h3>

<p>
<code>Nil</code>对象继承自<code>List[Nothing]</code>，它定义了空列表。因为协变的作为它可以兼容任何类型
的<code>List</code>实例：
</p>

<pre class="brush: scala">
  case object Nil extends List[Nothing] {
    override def isEmpty = true
    def head: Nothing =
      throw new NoSuchElementException("head of empty list")
    def tail: List[Nothing] =
      throw new NoSuchElementException("tail of empty list")
  }
</pre>

<p>
成员方法<code>head</code>的实现方法是抛出异常，因为对于成员类型<code>Nothing</code>来说，返回结果必须
是<code>Nothing</code>，而<code>Nothing</code>是个根本不存在的类型，所以它无法正常返回结果，只能抛出
异常。
</p>

<h3 id="toc_1.1.2">Cons类</h3>

<p>
<code>::</code>类读作“cons”，意思是“构造”，它实现了非空列表。“使用列表”这一章中“列表模式”里
说过模式中的每个中缀调用被作为构造器调用。
</p>

<dl>
<dt>就是说：`x </dt>
<dd>xs<code>是对类</code>::<code>的构造器调用</code>::(x, xs)`。</dd>
</dl>

<pre class="brush: scala">
  final case class ::[T](hd: T, tl: List[T]) extends List[T] {
    def head = hd
    def tail = tl
    override def isEmpty: Boolean = false
  }
</pre>

<p>
<code>hd</code>是头一个元素，<code>tl</code>是其他的所有元素。上面的代码可以简化，直接由参数实现超类
<code>List</code>的<code>head</code>和<code>tail</code>方法：
</p>

<pre class="brush: scala">
  final case class ::[T](head: T, tail: List[T])
      extends List[T] {

    override def isEmpty: Boolean = false
  }
</pre>

<h3 id="toc_1.1.3">其他的类方法</h3>

<pre class="brush: scala">
  def length: Int = 
    if (isEmpty) 0 else 1 + tail.length

  def drop(n: Int): List[T] = 
    if (isEmpty) Nil
    else if (n &lt;= 0) this
    else tail.drop(n - 1)

  def map[U](f: T =&gt; U): List[U] =
    if (isEmpty) Nil
    else f(head) :: tail.map(f)
</pre>


<h3 id="toc_1.1.4">列表构建</h3>

<dl>
<dt>对于冒号结束的操作符<code>::</code>和<code>:::</code>都是绑定在右操作数上的。即，`x </dt>
<dd>xs`被看作是</dd>
</dl>
<p>
<code>xs.::(x)</code>。因为<code>x</code>是列表元素可以是任意类型，所以不能假设它正好是具有<code>::</code>方法的
类型。也由于这个原因<code>::</code>方法应该生成一个新的列表。
</p>

<p>
还有值得讨论的地方是新加入元素的类型。思维惯性上会认为和列表元素是同一类型，但
实际上可用的范围更大。以下面的层级关系为例：
</p>

<pre class="brush: scala">
  abstract class Fruit 
  class Apple extends Fruit
  class Orange extends Fruit


  scala&gt; val apples = new Apple :: Nil
  apples: List[Apple] = List(Apple@585fa9)

  scala&gt; val fruits = new Orange :: apples
  fruits: List[Fruit] = List(Orange@cd6798, Apple@585fa9)
</pre>

<p>
上面的例子说明新加入的元素可以产生超类类型的列表。实现这样弹性的<code>::</code>方法：
</p>

<pre class="brush: scala">
  def ::[U &gt;: T](x: U): List[U] = new scala.::(x, this)
</pre>

<p>
注意方法本身是多态的，类型参数是<code>U</code>，添加的元素类型必须是<code>U</code>，返回结果类型是
<code>List[U]</code>。而<code>[U &gt;: T]</code>限定列表元素T的超类。
</p>

<p>
结合前面的例子，<code>U</code>被实例化为<code>Fruit</code>。因为<code>List[Apple]</code>中的<code>Apple</code>是<code>Fruit</code>的
子类，于是<code>U</code>的下界被满足。
</p>

<p>
<img src="images/scala/22.02.png" />
</p>

<p>
实际上对带有下界的<code>T</code>定义不只是为了方便，更加是为类型正确。因为<code>List</code>是协变的，
如果用下面的形式：
</p>

<pre class="brush: scala">
  // Error
  def ::(x: T): List[T] = new scala.::(x, this)
</pre>

<p>
因为方法参数被认为是逆变位置，所以上面的列表元素类型<code>T</code>处于逆变位置。这样<code>List</code>
就不能被声明为<code>T</code>保持协变了。所以使用下界<code>[U &gt;: T]</code>，即加强了类型检查，又让使用
更加有弹性。
</p>


<h3 id="toc_1.1.5">连接列表方法</h3>

<p>
连接列表的实现方法差不多：
</p>

<pre class="brush: scala">
    def :::[U &gt;: T](prefix: List[U]): List[U] = 
      if (prefix.isEmpty) this
      else prefix.head :: prefix.tail ::: this
</pre>

<p>
因为<code>::</code>与<code>:::</code>是右关联的，所以下面四个语句其实相等：
</p>

<pre class="brush: scala">
  prefix.head :: prefix.tail ::: this
  prefix.head :: (prefix.tail ::: this)
  (prefix.tail ::: this).::(prefix.head)
  this.:::(prefix.tail).::(prefix.head)
</pre>


<h2 id="toc_1.2">ListBuffer类</h2>

<p>
列表的典型访问模式是递归，比如有一个让列表所有元素自加1的方法：
</p>

<pre class="brush: scala">
  def incAll(xs: List[Int]): List[Int] = xs match {
    case List() =&gt; List()
    case x :: xs1 =&gt; x + 1 :: incAll(xs1)
  }
</pre>

<p>
这个方法有个问题：<code>incAll</code>是在<code>::</code>运算里面的，不是尾递归，堆栈的爆掉的危险。所以
要换个用循环的方案：
</p>

<pre class="brush: scala">
  for (x &lt;- xs) // ??
</pre>

<p>
那循环体内怎么写？前面的<code>incAll</code>递归方案可以通过加前缀操作；循环只能通过加后缀，
但<code>:::</code>操作时间与第一个列表长度成正比，效率很差：
</p>

<pre class="brush: scala">
  var result = List[Int]()    // a very inefficient approach
  for (x &lt;- xs) result = result ::: List(x + 1)
  result
</pre>

<p>
较好的办法是使用列表缓冲（list buffer）收集元素，最后用<code>toList</code>方法一次转换为
列表。
</p>

<p>
类<code>ListBuffer</code>位于<code>scala.collection.mutable</code>包中，而且它经过优化的增减操作与
<code>toList</code>操作都只要很短的常量时间就可以完成：
</p>

<pre class="brush: scala">
  import scala.collection.mutable.ListBuffer

  val buf = new ListBuffer[Int]
  for (x &lt;- xs) buf += x + 1
  buf.toList
</pre>


<h2 id="toc_1.3">实际的List类实现</h2>

<p>
虽然我们自己实现的<code>List</code>类很简洁，但实际上在遍历列表时为了避免递归一般都使用列表
缓冲与循环结合的方式。比如真正的<code>List</code>类是这样实现<code>map</code>方法的：
</p>

<pre class="brush: scala">
  final override def map[U](f: T =&gt; U): List[U] = {
    val b = new ListBuffer[U]
    var these = this
    while (!these.isEmpty) {
      b += f(these.head)
      these = these.tail
    }
    b.toList
  }
</pre>

<p>
看了以上的代码后，大家可能会对最后<code>b.toList</code>的效率感兴趣。实际上它的效率与列表的
长度无关。关于原因可以看一下<code>::</code>类的实现：
</p>

<pre class="brush: scala">
  final case class ::[U](hd: U, 
      private[scala] var tl: List[U]) extends List[U] {

    def head = hd
    def tail = tl
    override def isEmpty: Boolean = false
  }
</pre>

<p>
可以看到参数<code>tl</code>的类型是<code>var</code>，所以列表除了头一个元素以下的部分还是可以改变的。
而且修饰符<code>private[scala]</code>限定只有<code>scala</code>包中可以访问它。而修改它的是
<code>scala.collection.mutable</code>中的<code>ListBuffer</code>。
</p>

<p>
ListBuffer的元素被表示为列表，而添加新元素操作只对列表中最后一个<code>::</code>单元的<code>t1</code>
字段修改：
</p>

<pre class="brush: scala">
  package scala.collection.immutable
  final class ListBuffer[T] extends Buffer[T] {
    private var start: List[T] = Nil       // 所有元素的列表
    private var last0: ::[T] = _           // 最后一个 '::' 成员
    private var exported: Boolean = false  // 是否执行过toList操作
</pre>

<p>
<code>toList</code>方法的实现也很简单。它返回由<code>start</code>指向的列表，如果列表非空，就设置
<code>exported</code>为<code>true</code>：
</p>

<pre class="brush: scala">
  override def toList: List[T] = {
    exported = !start.isEmpty
    start
  }
</pre>

<p>
<code>toList</code>返回的列表应该是不可变的实例。那如果在这以后又被添加了元素的话，就不得不
改变<code>start</code>指向的列表。所以为了维护正确性，由<code>+=</code>方法转向对一个新列表进行操作：
</p>

<pre class="brush: scala">
  override def += (x: T) {
    if (exported) copy()
    if (start.isEmpty) {
      last0 = new scala.::(x, Nil)
      start = last0
    } else {
      val last1 = last0
      last0 = new scala.::(x, Nil)
      last1.tl = last0
    }
  }
</pre>

<p>
上面的逻辑中可以看出，如果没有被<code>toList</code>过，还可以在原来的列表上修改。如果已经
生成过列表了，那复制操作就不可避免。
</p>


<h2 id="toc_1.4">外在的函数式风格</h2>

<p>
回顾本章的内容可以感受到：指使式方案可以避免重复复制以提高效率；函数式风格以不可
改变与不共享数据让程序变得更加可靠。
</p>

<p>
Scala官方的实现方式让程序在外部看来是函数式，而内部实现在不得已的情况下使用
指令式实现。这样的实现可以被称作“外在函数式风格”。
</p>




<h1 id="toc_2">重温for表达式</h1>

<p>
先讨论一个例子，<code>Person</code>类有名字，性别，孩子三个成员：
</p>

<pre class="brush: scala">
  case class Person(name: String, isMale: Boolean, children: Person*)
</pre>

<p>
根据这个类建立一些实例：
</p>

<pre class="brush: scala">
  val lara = Person("Lara", false)
  val bob = Person("Bob", true)
  val julie = Person("Julie", false, lara, bob)
  val persons = List(lara, bob, julie)
</pre>

<p>
如果要找出所有母亲与孩子的结对，方案一是使用<code>map</code>、<code>flatMap</code>和<code>filter</code>这样的高阶
函数组成这样的查询操作：
</p>

<pre class="brush: scala">
  scala&gt; persons filter (p =&gt; !p.isMale) flatMap (p =&gt;
       |     (p.children map (c =&gt; (p.name, c.name))))
  res5: List[(String, String)] = List((Julie,Lara),
      (Julie,Bob))
</pre>

<p>
上面的代码很看起来挺难理解的，用for表达式来实现另一个版本：
</p>

<pre class="brush: scala">
  scala&gt; for (p &lt;- persons; if !p.isMale; c &lt;- p.children) 
       | yield (p.name, c.name)
  res6: List[(String, String)] = List((Julie,Lara),
      (Julie,Bob))
</pre>

<p>
for循环比高阶函数可读性更加好一些。但实际上Scala编译器把循环版本转为高阶函数版本
：
</p>

<ul>
<li>
所有有<code>yield</code>结果的for表达式会被转为<code>map</code>、<code>flatMap</code>与<code>filter</code>组合的调用。

<li>
所有无<code>yield</code>结果的for表达式被转为<code>filter</code>与<code>foreach</code>的调用。

</ul>


<h2 id="toc_2.1">For表达式</h2>

<p>
for表达式的一般形式：
</p>

<pre class="brush: scala">
  for ( seq ) yield expr
</pre>

<p>
其中的<code>seq</code>部分由生成器、定义、过滤器组成，以分号分隔：
</p>

<pre class="brush: scala">
  for (p &lt;- persons; n = p.name; if (n startsWith "To")) 
  yield n
</pre>

<p>
小括号可以由大括号代替，并且在用大括号的情况下还能省略分号：
</p>

<pre class="brush: scala">
  for {
    p &lt;- persons              // 生成器
    n = p.name                // 定义
    if (n startsWith "To")    // 过滤器
  } yield n
</pre>

<p>
如果有多个生成器，后面的生成器在内层的循环：
</p>

<pre class="brush: scala">
  scala&gt; for (x &lt;- List(1, 2); y &lt;- List("one", "two")) 
       | yield (x, y)
  res0: List[(Int, java.lang.String)] = 
    List((1,one), (1,two), (2,one), (2,two))
</pre>

<h2 id="toc_2.2">8皇后问题</h2>

<p>
8皇后问题：标准棋盘上放8个皇后，相互之间不能处理叫吃的位置上（同行、同列、
同对角线）。
</p>

<p>
对于这个问题，把它扩展为任意尺寸的棋盘：在N*N的棋盘上放N个皇后，反而更加简单。设
左上角的坐标是(1,1)，右下角是(N,N)。
</p>

<p>
定义好了问题以后再看解决方案：
</p>

<p>
同一行的会被叫吃，所以每行只能放一个。那就一行一行地放皇后并检查会不会被叫吃。在
处理过程中还会遇到第K行的皇后把从<code>1</code>到<code>k-1</code>行的皇后全都叫吃的局面，这时就要放弃
这部分操作继续另外一种从1到k-1行皇后的配置方案。
</p>

<p>
另外一个方案更加具有函数式风格：
</p>

<p>
穷举出所有在<code>N*N</code>棋盘上放<code>k</code>个皇后的方案<code>0&lt;k&lt;N</code>。那么每个方案都可以用长度的<code>k</code>的
列表表示，为了处理方便顺序要按堆栈的方式把第k行在最顶层，<code>k-1</code>到<code>k</code>行依次向下。
所有的堆栈在一起组成了所有解决方案的列表。
</p>

<p>
现在我们把在第<code>k+1</code>行放皇后的操作变为对前一个方案多加一个皇后的所有可能的扩展。
这会产一个长度为<code>k+1</code>的列表。
</p>

<p>
下面的<code>placeQueens</code>函数实现了这一算法：
</p>

<pre class="brush: scala">
  def queens(n: Int): List[List[(Int, Int)]] = {
    def placeQueens(k: Int): List[List[(Int, Int)]] =
      if (k == 0) 
        List(List())
      else 
        for {
          queens &lt;- placeQueens(k - 1)
          column &lt;- 1 to n
          queen = (k, column)
          if isSafe(queen, queens) 
        } yield queen :: queens

    placeQueens(n)
  }
</pre>

<p>
两个生成器：
</p>

<ul>
<li>
<code>queens &lt;- placeQueens(k - 1)</code>遍历所有行（递归调用）。

<li>
<code>column &lt;- 1 to n</code>遍历所有列。

</ul>

<p>
过滤器来检查有没有叫吃情况发生：
</p>

<pre class="brush: scala">
  def isSafe(queen: (Int, Int), queens: List[(Int, Int)]) = 
    queens forall (q =&gt; !inCheck(queen, q))

  def inCheck(q1: (Int, Int), q2: (Int, Int)) = 
    q1._1 == q2._1 ||                          // 同一行
    q1._2 == q2._2 ||                          // 同一列
    (q1._1 - q2._1).abs == (q1._2 - q2._2).abs // 对角线
</pre>


<h2 id="toc_2.3">使用for表达式进行查询</h2>

<p>
模拟一个查找图书的应用：
</p>

<pre class="brush: scala">
  case class Book(title: String, authors: String*)

  val books: List[Book] =
    List(
      Book(
        "Structure and Interpretation of Computer Programs",
        "Abelson, Harold", "Sussman, Gerald J."
      ),
      Book(
        "Principles of Compiler Design",
        "Aho, Alfred", "Ullman, Jeffrey"
      ),
      Book(
        "Programming in Modula-2",
        "Wirth, Niklaus"
      ),
      Book(
        "Elements of ML Programming",
        "Ullman, Jeffrey"
      ),
      Book(
        "The Java Language Specification", "Gosling, James",
        "Joy, Bill", "Steele, Guy", "Bracha, Gilad"
      )
    )
</pre>

<p>
查找作者姓“Gosling”的书名：
</p>

<pre class="brush: scala">
  scala&gt; for (b &lt;- books; a &lt;- b.authors
       |      if a startsWith "Gosling")
       | yield b.title
  res0: List[String] = List(The Java Language Specification)
</pre>

<p>
查找书名含“Program”：
</p>

<pre class="brush: scala">
  scala&gt; for (b &lt;- books if (b.title indexOf "Program") &gt;= 0)
       | yield b.title
  res4: List[String] = List(Structure and Interpretation of
    Computer Programs, Programming in Modula-2, Elements
      of ML Programming)
</pre>

<p>
查找编写了两本书以上的作者：
</p>

<pre class="brush: scala">
  scala&gt; for (b1 &lt;- books; b2 &lt;- books if b1 != b2;
       |     a1 &lt;- b1.authors; a2 &lt;- b2.authors if a1 == a2)
       | yield a1
  res5: List[String] = List(Ullman, Jeffrey, Ullman, Jeffrey)
</pre>

<p>
上面的代码有缺陷，同一个作者会出现多次。下面的代码完成去重：
</p>

<pre class="brush: scala">
  scala&gt; def removeDuplicates[A](xs: List[A]): List[A] = {
       |   if (xs.isEmpty) xs
       |   else
       |     xs.head :: removeDuplicates(
       |       xs.tail filter (x =&gt; x != xs.head)
       |     )
       | }
  removeDuplicates: [A](List[A])List[A]

  scala&gt; removeDuplicates(res5)
  res6: List[java.lang.String] = List(Ullman, Jeffrey)
</pre>

<p>
最后一个表达式可以使用for表达式表现为：
</p>

<pre class="brush: scala">
   xs.head :: removeDuplicates(
     for (x &lt;- xs.tail if x != xs.head) yield x
   )
</pre>

<h2 id="toc_2.4">for表达式的转译</h2>

<p>
每个for表达式都可以换成<code>map</code>、<code>flatMap</code>、<code>filter</code>这三个高阶的形式表达。
</p>

<h3 id="toc_2.4.1">简单变量生成器</h3>

<p>
<code>x &lt;- exp1</code>这种生成器生成到简单变量的情况下，大概有三种情况。
</p>

<h4 id="toc_2.4.1.1">一个生成器</h4>

<pre class="brush: scala">
for (x &lt;- exp1) yield exp2
</pre>

<p>
相当于：
</p>

<pre class="brush: scala">
exp1 .map(x =&gt; exp2)
</pre>

<h4 id="toc_2.4.1.2">以一个生成器和过滤器载开头</h4>

<pre class="brush: scala">
for (x &lt;- exp1 if exp2) yield exp3
</pre>

<p>
相当于：
</p>

<pre class="brush: scala">
for (x &lt;- exp1 filter(x =&gt; exp2)) yield exp3
</pre>

<p>
相当于：
</p>

<pre class="brush: scala">
exp1 filter (x =&gt; exp2) map (x =&gt; exp3)
</pre>

<p>
如果过滤器后有更多的元素同理。设<code>seq</code>为任意序列生成器、定义或过滤器，则：
</p>

<pre class="brush: scala">
for (x &lt;- exp1 if exp2 ; seq) yield exp3
</pre>

<p>
相当于：
</p>

<pre class="brush: scala">
for (x &lt;- exp1 filter exp2 ; seq) yield exp3
</pre>

<h4 id="toc_2.4.1.3">以两个生成器开始</h4>

<pre class="brush: scala">
for (x &lt;- exp1 ; y &lt;- exp2 ; seq) yield exp3
</pre>

<p>
设<code>seq</code>为任意序列生成器、定义或过滤器。则相当于<code>flatMap</code>的应用：
</p>

<pre class="brush: scala">
exp1 .flatMap(x =&gt; for (y &lt;- exp2 ; seq) yield exp3)
</pre>

<h4 id="toc_2.4.1.4">组合应用生成变量的例子</h4>

<p>
组合上面三种情况来处理“找出所有出版过至少两本书的作者”：
</p>

<pre class="brush: scala">
for (b1 &lt;- books; b2 &lt;- books if b1 != b2;
     a1 &lt;- b1.authors; a2 &lt;- b2.authors if a1 == a2)
yield a1
</pre>

<p>
相当于：
</p>

<pre class="brush: scala">
books flatMap (b1 =&gt;
  books filter (b2 =&gt; b1 != b2) flatMap (b2 =&gt;
    b1.authors flatMap (a1 =&gt;
      b2.authors filter (a2 =&gt; a1 == a2) map (a2 =&gt;
        a1))))
</pre>

<h3 id="toc_2.4.2">生成器转译中的模式</h3>

<p>
如果生成器不是<code>x &lt;- expq</code>这样生成到简单变量<code>x</code>的情况。转译起来就麻烦了。
</p>

<h4 id="toc_2.4.2.1">变量元组</h4>

<p>
这种情况还简单，看起来像变量差不多。
</p>

<pre class="brush: scala">
for ((x1, ..., xn) &lt;- exp1) yield exp2
</pre>

<p>
相当于：
</p>

<pre class="brush: scala">
exp1 .map { case(x1, ..., xn) =&gt; exp2 }
</pre>

<h4 id="toc_2.4.2.2">单个模式匹配的情况</h4>

<p>
单个模式匹配的情况下：
</p>

<pre class="brush: scala">
for (pat &lt;- exp1) yield exp2
</pre>

<p>
相当于：
</p>

<pre class="brush: scala">
exp1 filter {
	case pat =&gt; true
	case _   =&gt; false
} map {
	case pat =&gt; exp2
}
</pre>

<p>
基本思路是只有匹配于<code>pat</code>的情况才会被映射，所以也保证了模式匹配不会抛出
<code>MatchError</code>。
</p>

<p>
注意这只在单个模式匹配的情况下讨论。其他的情况参考Scala语言规格书“Ode08”。
</p>


<h3 id="toc_2.4.3">多层内嵌定义</h3>

<pre class="brush: scala">
for (x &lt;- exp1; y = exp2; seq) yield exp3
</pre>

<p>
设<code>seq</code>为任意序列生成器、定义或过滤器。上面相当于：
</p>

<pre class="brush: scala">
for((x,y) &lt;- for (x &lt;- exp1) yield (x, exp2); seq) yield exp3
</pre>

<p>
因为<code>exp2</code>用到了<code>x</code>所以每次产<code>x</code>的时候<code>exp2</code>要重新计算。这样浪费了性能，所以：
</p>


<pre class="brush: scala">
  for (x &lt;- 1 to 1000; y = expensiveComputationNotInvolvingX)
  yield x * y
</pre>

<p>
更好的写法是：
</p>

<pre class="brush: scala">
  val y = expensiveComputationNotInvolvingX
  for (x &lt;- 1 to 1000) yield x * y
</pre>

<h3 id="toc_2.4.4">没有返回值的情况</h3>

<p>
前面描述了通过<code>yield</code>生成值的情况。在不产值的情况下一般更简单，只要<code>foreach</code>：
</p>

<pre class="brush: scala">
for (x &lt;- exp1) body
</pre>

<p>
相当于：
</p>

<pre class="brush: scala">
exp1 foreach (x =&gt; body)
</pre>

<p>
更加复杂的情况：
</p>

<pre class="brush: scala">
for (x &lt;- exp1 ; if exp2 ; y &lt;- exp3) body
</pre>

<p>
相当于：
</p>

<pre class="brush: scala">
exp1 filter (x =&gt; exp2) foreach (
	x =&gt; exp3 foreach (y =&gt; body)
)
</pre>

<p>
例子，把列表形式的矩阵所有元素累加在一起：
</p>

<pre class="brush: scala">
  var sum = 0
  for (xs &lt;- xss; x &lt;- xs) sum += x
</pre>

<p>
相当于：
</p>

<pre class="brush: scala">
  var sum = 0
  xss foreach (xs =&gt; 
    xs foreach (x =&gt;
      sum += x))
</pre>

<h2 id="toc_2.5">把高阶函数转为for循环</h2>

<p>
下面的三个函数是用for循环分别实现<code>map</code>、<code>flatMap</code>、<code>filter</code>的演示：
</p>

<pre class="brush: scala">
  object Demo {
    def map[A, B](xs: List[A], f: A =&gt; B): List[B] =
      for (x &lt;- xs) yield f(x)

    def flatMap[A, B](xs: List[A], f: A =&gt; List[B]): List[B] =
      for (x &lt;- xs; y &lt;- f(x)) yield y

    def filter[A](xs: List[A], p: A =&gt; Boolean): List[A] =
      for (x &lt;- xs if p(x)) yield x
  }
</pre>

<h2 id="toc_2.6">for的应用</h2>

<p>
for表达式的实现是基于<code>map</code>、<code>flatMap</code>、<code>filter</code>这些高阶函数。所以可以把for用在
大批量数据上。for可以应用在数组和列表上也是因为这些这两个数组结构实现了这三个
高阶函数，其实可用的还有范围（Range）、迭代器（Iterator）、流（Stream）还有集
（Set）。
</p>

<p>
如果没有实现那三个方法的话要实现以后才能使用for，具体规则为：
</p>

<ul>
<li>
有<code>map</code>可以用单一生成器。

<li>
有<code>flatMap</code>和<code>map</code>可以有多个生成器。

<li>
有<code>foreach</code>可以有单一或多个生成器。

<li>
有<code>filter</code>可以有过滤器。

</ul>

<p>
设一个集合类<code>C</code>，典型的方法签名：
</p>

<pre class="brush: scala">
  abstract class C[A] {
    def map[B](f: A =&gt; B): C[B]
    def flatMap[B](f: A =&gt; C[B]): C[B]
    def filter(p: A =&gt; Boolean): C[A]
    def foreach(b: A =&gt; Unit): Unit
  }
</pre>

<p>
注意：对于参数类型<code>A</code>，方法返回的结果类型为有可能是<code>A</code>、<code>B</code>或<code>Unit</code>。
</p>

<p>
函数式编程里个概念叫单体（monad）有很广泛地应用，包括从集合、IO操作、状态操作、
回溯计算及交易等。<code>map</code>、<code>flatMap</code>、<code>filter</code>这三个方法可以用来定制单体功能。
</p>



<h1 id="toc_3">抽取器（Extractors）</h1>

<h2 id="toc_3.1">例子：抽取email地址</h2>

<p>
对于一个email类的话，如果是合法的email地址取出用户名与域名。
</p>

<pre class="brush: scala">
  EMail(user, domain)
</pre>

<p>
模式匹配表达式可以写为：
</p>

<pre class="brush: scala">
  s match {
    case EMail(user, domain) =&gt; println(user +" AT "+ domain)
    case _ =&gt; println("not an email address")
  }
</pre>

<p>
找到两个连续的同一用户的email地址的模式：
</p>

<pre class="brush: scala">
  ss match {
    case EMail(u1, d1) :: EMail(u2, d2) :: _ if (u1 == u2) =&gt; ...
    ...
  }
</pre>

<p>
现在要匹配的email不是一个类，而是字符串。我们先把方法定义出来：
</p>

<pre class="brush: scala">
  def isEMail(s: String): Boolean
  def domain(s: String): String
  def user(s: String): String
</pre>

<p>
调用的时候就是这样的：
</p>

<pre class="brush: scala">
  if (isEMail(s)) println(user(s) +" AT "+ domain(s)
  else println("not an email address")
</pre>


<h2 id="toc_3.2">抽取器</h2>

<p>
在scala对象中与<code>apply</code>方法相对的方法是<code>unapply</code>方法，而有<code>unapply</code>成员方法的对象
就是抽取器。<code>unapply</code>是为了匹配并分解值。
</p>

<p>
下面的例子中<code>apply</code>方法注入对象，而<code>unapply</code>方法从对象中抽取内容：
</p>
  
<pre class="brush: scala">
  object EMail {

    // The injection method (optional)
    def apply(user: String, domain: String) = user +"@"+ domain

    // The extraction method (mandatory)
    def unapply(str: String): Option[(String, String)] = {
      val parts = str split "@"
      if (parts.length == 2) Some(parts(0), parts(1)) else None
    }
  }
</pre>

<p>
还可以让这个对象继承自Scala的函数类型：
</p>

<pre class="brush: scala">
  object EMail extends (String, String) =&gt; String { ... }
</pre>

<p>
对象声明里的<code>(String, String) =&gt; String</code>的意思相当于<code>Function2[String, String]</code>
，是对Email类实现的抽象<code>apply</code>方法的声明。这样可以把Email传递给需要
<code>Function2[String,String]</code>的方法。
</p>


<p>
注意<code>unapply</code>方法返回类型是<code>Option</code>。因为输入参数可能不是正确的email格式。
</p>

<pre class="brush: scala">
  unapply("John@epfl.ch")  equals  Some("John", "epfl.ch")
  unapply("John Doe")  equals  None
</pre>


<p>
现在，当模式匹配到抽取器对象指定的模式就会在选择器表达式中调用抽取器的<code>unapply</code>
方法。如下面的代码：
</p>

<pre class="brush: scala">
  selectorString match { case EMail(user, domain) =&gt; ... }
</pre>

<p>
<code>String</code>类型的<code>selectorString</code>其实先被抽取器处理：
</p>

<pre class="brush: scala">
  EMail.unapply(selectorString)
</pre>

<p>
产的结构再进行模式匹配判断。
</p>

<p>
<code>selectorString</code>的类型虽然和<code>unapply</code>一样都是<code>String</code>，但这并不是必须的。像下面
这样检查任意类型的实例是不是email：
</p>

<pre class="brush: scala">
  val x: Any = ...
  x match { case EMail(user, domain) =&gt; ... }
</pre>

<p>
一般来说如果包含了注入方法，那应该与抽取方法成对偶关系。如调用：
</p>

<pre class="brush: scala">
  EMail.unapply(EMail.apply(user, domain))
</pre>

<p>
应该返回：
</p>

<pre class="brush: scala">
  Some(user, domain)
</pre>

<p>
也就是说被<code>Some</code>包装的同一序列的参数。反过来就是先执行<code>unapply</code>再执行<code>apply</code>：
</p>

<pre class="brush: scala">
  EMail.unapply(obj) match { 
    case Some(u, d) =&gt; EMail.apply(u, d) 
  }
</pre>

<p>
虽然这样的对偶性不是强制要求的，但强烈建议实现。
</p>
  

<h2 id="toc_3.3">只有1个或没有变量的模式</h2>

<p>
之前<code>unapply</code>方法返回的是元组，这在有多个值要返回的时候很有用。但是在只有一个值
或没有值要返回的时候有麻烦，因为元组最小是二元组，没有有一元元组。
</p>

<p>
所以模式只绑定一个变量的情况要特别对待，把结果直接放在<code>Some</code>中：
</p>

<pre class="brush: scala">
  object Twice {
    def apply(s: String): String = s + s
    def unapply(s: String): Option[String] = {
      val length = s.length / 2
      val half = s.substring(0, length)
      if (half == s.substring(length)) Some(half) else None
    }
  }
</pre>

<p>
还有一种情况下抽取器模式不绑定任何变量。这样情况下返回布尔值表示匹配成功或失败：
</p>

<pre class="brush: scala">
  object UpperCase {
    def unapply(s: String): Boolean = s.toUpperCase == s
  }
</pre>

<p>
注意上面的代码没有<code>apply</code>，因为本来就没有什么好构造的。
</p>

<p>
下面的<code>userTwiceUpper</code>函数的模式匹配代码集中了前面定义的所有抽取器：
</p>

<pre class="brush: scala">
  def userTwiceUpper(s: String) = s match {
    case EMail(Twice(x @ UpperCase()), domain) =&gt;
      "match: "+ x +" in domain "+ domain
    case _ =&gt; 
      "no match"
  }
</pre>

<p>
函数的第一部分匹配email地址，并且用户名部分需要由大家字母形式的相同字符串出现
两次组成。
</p>

<p>
注意第二行里的<code>UpperCase</code>的空参数列表<code>()</code>是不能省略的，不然会被解释为与
<code>UpperCase</code>对象进行匹配。还要注意虽然<code>UpperCase()</code>本身没有绑定任何变量，但还可以
把变量与匹配它的整个模式联系起来。用模式中的变量绑定方案；以<code>x @ UpperCase()</code>的
模式把<code>x</code>与<code>UpperCase()</code>匹配的模式联系起来。例如在第一个<code>userTwiceUpper</code>调用中，
<code>x</code>被绑定为<code>DI</code>，因为匹配于<code>UpperCase()</code>模式的值。
</p>

<pre class="brush: scala">
  scala&gt; userTwiceUpper("DIDI@hotmail.com")
  res0: java.lang.String = match: DI in domain hotmail.com

  scala&gt; userTwiceUpper("DIDO@hotmail.com")
  res1: java.lang.String = no match

  scala&gt; userTwiceUpper("didi@hotmail.com")
  res2: java.lang.String = no match
</pre>


<h2 id="toc_3.4">可变参数的抽取器</h2>

<p>
希望的元素个数是可变的，如对域名的处理：
</p>

<pre class="brush: scala">
  dom match {
    case Domain("org", "acm") =&gt; println("acm.org")
    case Domain("com", "sun", "java") =&gt; println("java.sun.com")
    case Domain("net", _*) =&gt; println("a .net domain")
  }
</pre>

<p>
可以看到上面的域名是反向展开的，最后一个情况下下<code>_*</code>剩下的所有元素。<code>unapply</code>值
的返回个数定下了就不能改了，所以Scala允许为变参数定义不同的抽取方法<code>unapplySeq</code>
：
</p>

<pre class="brush: scala">
  object Domain {

    // The injection method (optional)
    def apply(parts: String*): String = 
      parts.reverse.mkString(".")

    // The extraction method (mandatory)
    def unapplySeq(whole: String): Option[Seq[String]] = 
      Some(whole.split("\\.").reverse)
  }
</pre>

<p>
<code>unapplySeq</code>以句点拆分字符串包装在<code>Some</code>中返回。<code>unapplySeq</code>抽取器返回结果类型
必须是<code>Option[seq[T]]</code>，这里的元素类型<code>T</code>不能限制。<code>Seq</code>是各种序列类（List、
Array、RichString等）的共同超类。
</p>

<p>
这样寻找某个<code>.com</code>域名中的email的函数就是这样：
</p>

<pre class="brush: scala">
  def isTomInDotCom(s: String): Boolean = s match {
    case EMail("tom", Domain("com", _*)) =&gt; true
    case _ =&gt; false
  }
</pre>

<p>
返回期望的结果：
</p>

<pre class="brush: scala">
  scala&gt; isTomInDotCom("tom@sun.com")
  res3: Boolean = true

  scala&gt; isTomInDotCom("peter@sun.com")
  res4: Boolean = false

  scala&gt; isTomInDotCom("tom@acm.org")
  res5: Boolean = false
</pre>

<p>
同样也可以从<code>unapplySeq</code>及变化部分返回固定的元素。表达为包含所有元素的元组，变化
部分还是在最后，下面是新的抽取器，其中域名部分已经扩展为序列了：
</p>

<pre class="brush: scala">
  object ExpandedEMail {
    def unapplySeq(email: String)
        : Option[(String, Seq[String])] = {
      val parts = email split "@"
      if (parts.length == 2) 
        Some(parts(0), parts(1).split("\\.").reverse)
      else 
        None
    }
  }
</pre>

<p>
这里<code>unapplySeq</code>方法返回对偶的可选类型。对偶的第一个元素是用户部分，第二个部分是
表示域名的序列。然后就可以这样匹配它：
</p>

<pre class="brush: scala">
  scala&gt; val s = "tom@support.epfl.ch"
  s: java.lang.String = tom@support.epfl.ch

  scala&gt; val ExpandedEMail(name, topdom, subdoms @ _*) = s
  name: String = tom
  topdom: String = ch
  subdoms: Seq[String] = List(epfl, support)
</pre>


<h2 id="toc_3.5">抽取器和序列模式</h2>

<p>
模式匹配中我们已经知道可以使用序列模式访问列表或数组的元素：
</p>

<pre class="brush: scala">
  List()
  List(x, y, _*)
  Array(x, 0, 0, _)
</pre>

<p>
这里的<code>List(...)</code>形式的模式其实是由<code>scala.List</code>的伴生对象定义了<code>unapplySeq</code>方法
的抽取器，相差定义如下：
</p>

<pre class="brush: scala">
  package scala
  object List {
    def apply[T](elems: T*) = elems.toList
    def unapplySeq[T](x: List[T]): Option[Seq[T]] = Some(x)
    ... 
  }
</pre>

<p>
List对象包含了带可变数量参数的<code>apply</code>方法，从而允许编写如下的表达式：
</p>

<pre class="brush: scala">
  List()
  List(1, 2, 3)
</pre>

<p>
它还包含了以序列形式返回列表所有元素的<code>unapplySeq</code>方法，从而对<code>List(...)</code>模式
提供了支持。<code>scala.Array</code>对象定义也非常类似，所以数组也支持注入和抽取方法。
</p>
  

<h2 id="toc_3.6">抽取器 VS. 样本类</h2>

<p>
样本类会暴露了数据的具体表达方式，让外部看到了类名与构造器等信息，如：
</p>

<pre class="brush: scala">
  case C(...)
</pre>

<p>
对于已经存在的样本类后来写的代码一定要拿来用它们。如果修改了样本类就一定要把用到
的地方都一起改了。抽取器是独立的，没有这个问题。
</p>

<p>
样本类的优点是容易实现、性能更加高效。而且样本类如果继承自<code>sealed</code>，编译器可以
穷举所有可能性检查程序里会漏掉的逻辑。
</p>

<p>
一般来说，如果是封闭的应用，样本类更加合适；如果是开放的，类层级之类的会有重构，
就更加适合抽取器。
</p>

<p>
在面临选择的时候可以先从样本类开始做，以后发觉有问题再换抽取器。因为抽取器与
样本类模式在Scala上看上去样子完全一样，所以在客户代码中的模式匹配还是可以继续
工作的。但是像本章的email例子中模式架构与数据表现类不相符的情况下，只能用抽取器
。
</p>

<h2 id="toc_3.7">正则表达式</h2>

<p>
正则表达式规则看<code>java.util.regex.Pattern</code>包的JavaDoc。RTFM！
</p>

<h3 id="toc_3.7.1">形成正则表达式</h3>

<p>
Scala相差类放在<code>scala.util.matching</code>包里：
</p>

<pre class="brush: scala">
  scala&gt; import scala.util.matching.Regex
</pre>

<p>
通过<code>Regex</code>类构造器传递正则表达式：
</p>

<pre class="brush: scala">
  scala&gt; val Decimal = new Regex("(-)?(\\d+)(\\.\\d*)?")
  Decimal: scala.util.matching.Regex = (-)?(\d+)(\.\d*)?
</pre>

<p>
Scala的照排字符串可以免了java复杂的转义：
</p>

<pre class="brush: scala">
  scala&gt; val Decimal = new Regex("""(-)?(\d+)(\.\d*)?""")
  Decimal: scala.util.matching.Regex = (-)?(\d+)(\.\d*)?
</pre>

<p>
还可以更加简化：
</p>

<pre class="brush: scala">
  scala&gt; val Decimal = """(-)?(\d+)(\.\d*)?""".r
  Decimal: scala.util.matching.Regex = (-)?(\d+)(\.\d*)?
</pre>

<p>
<code>RichString</code>类里实现了<code>r</code>方法把字符串转为正则表达式：
</p>

<pre class="brush: scala">
  package scala.runtime
  import scala.util.matching.Regex

  class RichString(self: String) ... {
    ...
    def r = new Regex(self)
  }
</pre>

<h3 id="toc_3.7.2">用正则表达式查找替换</h3>

<p>
查找首次出现作为<code>Option</code>类型结果返回：
</p>

<pre class="brush: scala">
regex findFirstIn str
</pre>

<p>
所有的出现的匹配以<code>Iterator</code>类型结果返回：
</p>

<pre class="brush: scala">
regex findAllIn str
</pre>

<p>
查找开始位置匹配出现，返回<code>Option</code>类型：
</p>

<pre class="brush: scala">
regex findPrefixOf str
</pre>

<p>
例子：
</p>

<pre class="brush: scala">
  scala&gt; val Decimal = """(-)?(\d+)(\.\d*)?""".r
  Decimal: scala.util.matching.Regex = (-)?(\d+)(\.\d*)?

  scala&gt; val input = "for -1.0 to 99 by 3"      
  input: java.lang.String = for -1.0 to 99 by 3

  scala&gt; for (s &lt;- Decimal findAllIn input)
       | println(s)
  -1.0
  99
  3

  scala&gt; Decimal findFirstIn input
  res1: Option[String] = Some(-1.0)

  scala&gt; Decimal findPrefixOf input
  res2: Option[String] = None
</pre>


<h3 id="toc_3.7.3">正则表达式抽取值</h3>

<p>
Scala所有的正则表达式都定义了抽取器，可以用来鉴别匹配于正则表达式分组的子字符串
。例如，下面这样解构数值字符串：
</p>

<pre class="brush: scala">
  scala&gt; val Decimal(sign, integerpart, decimalpart) = "-1.23"  
  sign: String = -
  integerpart: String = 1
  decimalpart: String = .23
</pre>

<p>
注意这里用<code>Decimal(...)</code>来定义了一个<code>val</code>。<code>Decimal</code>正则表达式值定义了
<code>unapplySeq</code> 方法把字符串与正则匹配到三个模式变量<code>sign</code>、<code>intergerpart</code>、
<code>decimalpart</code>，如果有一个部分缺少就是<code>null</code>：
</p>

<pre class="brush: scala">
  scala&gt; val Decimal(sign, integerpart, decimalpart) = "1.0"
  sign: String = null
  integerpart: String = 1
  decimalpart: String = .0
</pre>

<p>
还可以在for表达式中混用抽取器与正则表达式做搜索，如，下面的代码从字符串中找到
所有的数值：
</p>

<pre class="brush: scala">
  scala&gt; for (Decimal(s, i, d) &lt;- Decimal findAllIn input)
       |   println("sign: "+ s +", integer: "+
       |       i +", decimal: "+ d)
  sign: -, integer: 1, decimal: .0
  sign: null, integer: 99, decimal: null
  sign: null, integer: 3, decimal: null
</pre>



<pre class="brush: scala">
</pre>
<pre class="brush: scala">
</pre>
<pre class="brush: scala">
</pre>
<pre class="brush: scala">
</pre>
<pre class="brush: scala">
</pre>
<pre class="brush: scala">
</pre>
<pre class="brush: scala">
</pre>
<pre class="brush: scala">
</pre>
<pre class="brush: scala">
</pre>
<pre class="brush: scala">
</pre>
<pre class="brush: scala">
</pre>
<pre class="brush: scala">
</pre>
<pre class="brush: scala">
</pre>
<pre class="brush: scala">
</pre>
<pre class="brush: scala">
</pre>
<pre class="brush: scala">
</pre>
<pre class="brush: scala">
</pre>
<pre class="brush: scala">
</pre>
<pre class="brush: scala">
</pre>
<pre class="brush: scala">
</pre>
<pre class="brush: scala">
</pre>
 </div>
</body>
</html>
