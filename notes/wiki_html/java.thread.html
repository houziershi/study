<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">

<script type="text/javascript" src="../../vimwiki-theme/code/theme/scripts/jquery-1.4.2.min.js"></script>

<link type="text/css" rel="stylesheet" href="../../vimwiki-theme/hightlight-code/styles/shCore.css"/>
<link type="text/css" rel="stylesheet" href="../../vimwiki-theme/hightlight-code/styles/shThemeDefault.css"/>
<script type="text/javascript" src="../../vimwiki-theme/hightlight-code/scripts/shCore.js"></script>
<script type="text/javascript" src="../../vimwiki-theme/hightlight-code/scripts/shAutoloader.js"></script>

<script type="text/javascript" src="../../vimwiki-theme/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

<script type="text/javascript" src="../../vimwiki-theme/code/theme/scripts/script.js"></script>
<link type="text/css" rel="stylesheet" href="../../vimwiki-theme/code/theme/styles/style.css" />


<title>线程基础</title>
</head>
<body  onresize='changeTocSize()'>
	<div class="note-main"> 

<h1>线程基础</h1>
<div class="toc">
<ul>
<li><a href="#toc_1">线程</a>
<ul>
<li><a href="#toc_1.1">创建线程</a>
<li><a href="#toc_1.2">线程优先级</a>
<li><a href="#toc_1.3">守护线程</a>
<li><a href="#toc_1.4">多个线程相互协调</a>
<ul>
<li><a href="#toc_1.4.1">sleep、yield、join</a>
<li><a href="#toc_1.4.2">中断</a>
</ul>
<li><a href="#toc_1.5">线程协作</a>
</ul>
<li><a href="#toc_2">本地线程变量</a>
<ul>
<li><a href="#toc_2.1">ThreadLocal是什么</a>
<li><a href="#toc_2.2">ThreadLocal的接口方法</a>
<li><a href="#toc_2.3">一个TheadLocal实例</a>
<li><a href="#toc_2.4">Thread同步机制的比较</a>
<li><a href="#toc_2.5">Spring使用ThreadLocal解决线程安全问题</a>
<li><a href="#toc_2.6">小结</a>
</ul>
<li><a href="#toc_3">内置锁</a>
<ul>
<li><a href="#toc_3.1">重入</a>
</ul>
<li><a href="#toc_4">锁优化</a>
<ul>
<li><a href="#toc_4.1">处旋锁与自适应自旋</a>
<li><a href="#toc_4.2">锁消除</a>
<li><a href="#toc_4.3">锁粗化</a>
<li><a href="#toc_4.4">轻量级锁</a>
<li><a href="#toc_4.5">偏向锁</a>
</ul>
</ul>
</div>

<h1 id="toc_1">线程</h1>

<h2 id="toc_1.1">创建线程</h2>

<p>
<code>Runnable</code>接口的<code>run</code>方法是要运行的逻辑。
</p>

<p>
<code>Thread</code>类实现<code>run</code>方法。方法里是执行的逻辑。<code>start()</code>方法表示启动新线程。
</p>

<h2 id="toc_1.2">线程优先级</h2>

<p>
线程的成员方法<code>setPriority</code>。如设置当前线程的优先级为普通：
</p>

<pre class="brush: java">
Thread.currentThread.setPriority(Thread.NORNAL_PRIORITY)
</pre>

<p>
可用优先级：
</p>

<ul>
<li>
NORMAL_PRIORITY

<li>
MIN_PRIORITY

<li>
MAX_PRIORITY

<li>
等……

</ul>

<h2 id="toc_1.3">守护线程</h2>

<p>
分为“普通线程”和“守护线程”，区别是如果还有普通线程没有执行完毕，JVM是关不掉的。
</p>

<p>
普通线程创建的线程默认都是普通线程，除非用<code>setDaemon(true)</code>指定：
</p>

<pre class="brush: java">
Thread t1 = new Thread(runnable);
t1.setDaemon(true);
t1.start();
</pre>


<h2 id="toc_1.4">多个线程相互协调</h2>

<h3 id="toc_1.4.1">sleep、yield、join</h3>

<p>
暂停线程：<code>Thread.sleep()</code>
</p>

<p>
让出CPU：<code>Thread.yield()</code>
</p>

<p>
给其他线程执行的机会，如：循环处理多个记录的时候每个循环里<code>yield</code>一下，或阻塞
在IO时<code>yield</code>一下。
</p>

<p>
等待其他线程完毕：<code>t1.join()</code>
</p>

<p>
当前的线程停下，等这个<code>t1</code>的线程执行完了以后再执行当前线程。
</p>

<h3 id="toc_1.4.2">中断</h3>

<p>
对一个线程发出停止信号，如：<code>t1.interrupted()</code>要求线程<code>t1</code>停止。
</p>

<p>
这样<code>t1</code>的执行就会抛出<code>InterruptedException</code>异常，它是受检查异常，表示当前线程
被其他线程打断。如下面的代码收到异常后就<code>break</code>了，那么线程就中断了：
</p>

<pre class="brush: java">
class T1 extends Thread {
	while(true) {
		try { 
			/* do something */ 
		} catch (InterruptedException e) { 
			break; 
		}
	}
}
</pre>

<p>
如果去掉上面的<code>break</code>那线程就中断不了了。
</p>

<p>
执行线程并中断的过程如下：
</p>

<pre class="brush: java">
T1 t1 = new T1();
t1.start();
t1.join();
t1.interrupt();
</pre>


<h2 id="toc_1.5">线程协作</h2>

<p>
每个对象都有<code>wait</code>与<code>notify</code>和<code>notifyAll</code>方法，选一个对象作为标志来同步：
</p>

<p>
＊ 以对象<code>o</code>为标志，当前线程停止，让给其他线程执行：
</p>

<pre class="brush: java">
synchronized { o.wait(); } //当前线程停止，等待唤醒。
</pre>

<p>
这样当前线程就不会再醒过来，除非其他线程里调用对象<code>o</code>的<code>nodify</code>或是<code>nodifyAll</code>
方法：
</p>

<pre class="brush: java">
synchronized { o.notifyAll(); } // 唤醒所有以o为标志等待的线程
</pre>





<h1 id="toc_2">本地线程变量</h1>

<p>
<code>ThreadLocal</code>类给每个线程都准备一个资源的副本。保证每个资源只有当前线程可以
访问。
</p>

<p>
<code>ThreadLocal</code>对象不能简单地赋值就完了。因为它管理的每个线程的内容都要初始化，
所以它每次都会调用自己的<code>initialValue()</code>方法。重写这个方法可以完成每个线程的
初始化。
</p>

<pre class="brush: java">
private static ThreadLocal&lt;List&lt;String&gt;&gt; threadLod =
	new ThreadLocal&lt;List&lt;String&gt;&gt;() {
		protected List&lt;String&gt; initialValue() {
			return new ArrayList&lt;String&gt;();
		}
	}
</pre>

<h2 id="toc_2.1">ThreadLocal是什么</h2>

<p>
从线程的角度看，目标变量就象是线程的本地变量，这也是类名中<code>Local</code>所要表达的意思。
</p>

<p>
线程局部变量并不是Java的新发明，很多语言（如IBM IBM XL FORTRAN）在语法层面就提供
线程局部变量。在Java中没有提供在语言级支持，而是变相地通过<code>ThreadLocal</code>的类提供
支持。
</p>

<p>
所以，在Java中编写线程局部变量的代码相对来说要笨拙一些，因此造成线程局部变量没有
在Java开发者中得到很好的普及。
</p>

<h2 id="toc_2.2">ThreadLocal的接口方法</h2>

<p>
ThreadLocal类接口很简单，只有4个方法，我们先来了解一下：
</p>

<ul>
<li>
<code>void set(Object value)</code>设置当前线程的线程局部变量的值。

<li>
<code>public Object get()</code>该方法返回当前线程所对应的线程局部变量。

<li>
<code>public void remove()</code>JDK 5.0新增。线程结束后本来就会自动回收，显式调用并不是必要的。

<li>
<code>protected Object initialValue()</code>返回初始值，显然是为了让子类覆盖而设计的。

</ul>

<p>
<code>initialValue()</code>是一个延迟调用方法，在线程第1次调用<code>get()</code>或<code>set(Object)</code>时才
执行，并且仅执行1次。<code>ThreadLocal</code>中的缺省实现直接返回一个<code>null</code>。
</p>

<p>
值得一提的是，在JDK5.0中，<code>ThreadLocal</code>已经支持泛型变为<code>ThreadLocal&lt;T&gt;</code>。API方法
也相应进行了调整，新版本的API方法分别是<code>void set(T value)</code>、<code>T get()</code>以及
<code>T initialValue()</code>。
</p>

<p>
<code>ThreadLocal</code>是如何做到为每一个线程维护变量的副本的呢？其实实现的思路很简单：
在<code>ThreadLocal</code>类中有一个Map，用于存储每一个线程的变量副本，Map中元素的键为线程
对象，而值对应线程的变量副本。我们自己就可以提供一个简单的实现版本：
</p>

<pre class="brush: java"  title="SimpleThreadLocal.java">
public class SimpleThreadLocal {
	private Map valueMap = Collections.synchronizedMap(new HashMap());
	
	public void set(Object newValue) {
		// 键为线程对象，值为本线程的变量副本
		valueMap.put(Thread.currentThread(), newValue);
	}

	public Object get() {
		Thread currentThread = Thread.currentThread();
		//返回本线程对应的变量
		Object o = valueMap.get(currentThread);
		if (o == null &amp;&amp; !valueMap.containsKey(currentThread)) {
			// 如果在Map中不存在，放到Map中保存起来。
			o = initialValue();
			valueMap.put(currentThread, o);
		}
		return o;
	}

	public void remove() {
		valueMap.remove(Thread.currentThread());
	}

	public Object initialValue() {
		return null;
	}
}
</pre>

<p>
虽然这个<code>ThreadLocal</code>实现版本显得比较幼稚，但它和JDK所提供的<code>ThreadLocal</code>类在
实现思路上是相近的。
</p>

<h2 id="toc_2.3">一个TheadLocal实例</h2>

<p>
下面，我们通过一个具体的实例了解一下<code>ThreadLocal</code>的具体使用方法。
</p>

<pre class="brush: java; highlight: [5,12,20,37]"  title="SequenceNumber.java">
package com.baobaotao.basic;
public class SequenceNumber {

	// 通过匿名内部类覆盖ThreadLocal的initialValue()方法，指定初始值
	private static ThreadLocal seqNum = new ThreadLocal() {
		public Integer initialValue() {
			return 0;
		}
	};

	// 获取下一个序列值
	public int getNextNum(){
		seqNum.set(seqNum.get()+1);
		return seqNum.get();
	}

	public static void main(String[] args) {
		SequenceNumber sn = new SequenceNumber();
		// 3个线程共享sn，各自产生序列号
		TestClient t1 = new TestClient(sn);
		TestClient t2 = new TestClient(sn);
		TestClient t3 = new TestClient(sn);
		t1.start();
		t2.start();
		t3.start();
	}

	private static class TestClient extends Thread {
		private SequenceNumber sn;

		public TestClient(SequenceNumber sn) {
			this.sn = sn;
		}

		public void run() {
			// 每个线程打出3个序列值
			for (int i = 0; i &lt; 3; i++) {
			System.out.println("thread[" + Thread.currentThread().getName() 
					+ "] sn[" + sn.getNextNum() + "]");
			}
		}
	}

}
</pre>

<p>
通常我们通过匿名内部类的方式定义<code>ThreadLocal</code>的子类，提供初始的变量值。
<code>TestClient</code>线程产生一组序列号，生成3个<code>TestClient</code>，它们共享同一个
<code>SequenceNumber</code>实例。运行以上代码，在控制台上输出以下的结果：
</p>

<pre class="brush: bash">
thread[Thread-2] sn[1]
thread[Thread-0] sn[1]
thread[Thread-1] sn[1]
thread[Thread-2] sn[2]
thread[Thread-0] sn[2]
thread[Thread-1] sn[2]
thread[Thread-2] sn[3]
thread[Thread-0] sn[3]
thread[Thread-1] sn[3]
</pre>

<p>
考察输出的结果信息，我们发现每个线程所产生的序号虽然都共享同一个<code>SequenceNumber</code>
实例，但它们并没有发生相互干扰的情况，而是各自产生独立的序列号，这是因为我们通过
<code>ThreadLocal</code>为每一个线程提供了单独的副本。
</p>

<h2 id="toc_2.4">Thread同步机制的比较</h2>

<p>
<code>ThreadLocal</code>和线程同步机制相比有什么优势呢？<code>ThreadLocal</code>和线程同步机制都是为了
解决多线程中相同变量的访问冲突问题。
</p>

<p>
在同步机制中，通过对象的锁机制保证同一时间只有一个线程访问变量。这时该变量是多个
线程共享的，使用同步机制要求程序慎密地分析什么时候对变量进行读写，什么时候需要
锁定某个对象，什么时候释放对象锁等繁杂的问题，程序设计和编写难度相对较大。
</p>

<p>
而<code>ThreadLocal</code>则从另一个角度来解决多线程的并发访问。<code>ThreadLocal</code>会为每一个线程
提供一个独立的变量副本，从而隔离了多个线程对数据的访问冲突。因为每一个线程都拥有
自己的变量副本，从而也就没有必要对该变量进行同步了。<code>ThreadLocal</code>提供了线程安全
的共享对象，在编写多线程代码时，可以把不安全的变量封装进<code>ThreadLocal</code>。
</p>

<p>
由于<code>ThreadLocal</code>中可以持有任何类型的对象，低版本JDK所提供的<code>get()</code>返回的是
<code>Object</code>对象，需要强制类型转换。但JDK 5.0通过泛型很好的解决了这个问题，在一定
程度地简化<code>ThreadLocal</code>的使用。
</p>

<p>
概括起来说，对于多线程资源共享的问题，同步机制采用了“以时间换空间”的方式，而
<code>ThreadLocal</code>采用了“以空间换时间”的方式。前者仅提供一份变量，让不同的线程排队
访问，而后者为每一个线程都提供了一份变量，因此可以同时访问而互不影响。
</p>

<h2 id="toc_2.5">Spring使用ThreadLocal解决线程安全问题</h2>

<p>
我们知道在一般情况下，只有无状态的Bean才可以在多线程环境下共享，在Spring中，
绝大部分Bean都可以声明为<code>singleton</code>作用域。就是因为Spring对一些Bean（如
<code>RequestContextHolder</code>、<code>TransactionSynchronizationManager</code>、
<code>LocaleContextHolder</code>等）中非线程安全状态采<code>用ThreadLocal</code>进行处理，让它们也成为
线程安全的状态，因为有状态的Bean就可以在多线程中共享了。
</p>

<p>
一般的Web应用划分为展现层、服务层和持久层三个层次，在不同的层中编写对应的逻辑，
下层通过接口向上层开放功能调用。在一般情况下，从接收请求到返回响应所经过的所有
程序调用都同属于一个线程，如图所示：
</p>

<p>
<img src="images/java.base/07.gif" />
</p>

<p>
这样你就可以根据需要，将一些非线程安全的变量以<code>ThreadLocal</code>存放，在同一次请求
响应的调用线程中，所有关联的对象引用到的都是同一个变量。
</p>

<p>
下面的实例能够体现Spring对有状态Bean的改造思路：
</p>

<p>
非线程安全：
</p>

<pre class="brush: java" title="TopicDao">
public class TopicDao {
	//一个非线程安全的变量
	private Connection conn;
	
	public void addTopic(){
		//引用非线程安全变量
		Statement stat = conn.createStatement();
		// ...
	}
}
</pre>

<p>
由于<code>conn</code>是成员变量，因为<code>addTopic()</code>方法是非线程安全的，必须在使用时创建一个新
<code>TopicDao</code>实例（非singleton）。下面使用<code>ThreadLocal</code>对<code>conn</code>这个非线程安全的
“状态”进行改造：
</p>

<p>
线程安全：
</p>

<pre class="brush: java" title="TopicDao.java">
import java.sql.Connection;
import java.sql.Statement;
public class TopicDao {
	// 使用ThreadLocal保存Connection变量
	private static ThreadLocal connThreadLocal = new ThreadLocal();
	
	public static Connection getConnection() {
		// 如果connThreadLocal没有本线程对应的Connection
		// 创建一个新的Connection，并将其保存到线程本地变量中。
		if (connThreadLocal.get() == null) {
			Connection conn = ConnectionManager.getConnection();
			connThreadLocal.set(conn);
			return conn;
		}else{
			return connThreadLocal.get();//③直接返回线程本地变量
		}
	}

	public void addTopic() {
		// 从ThreadLocal中获取线程对应的Connection
		Statement stat = getConnection().createStatement();
	}
}
</pre>

<p>
不同的线程在使用<code>TopicDao</code>时，先判断<code>connThreadLocal.get()</code>是否是<code>null</code>，如果是
<code>null</code>，则说明当前线程还没有对应的<code>Connection</code>对象，这时创建一个<code>Connection</code>对象
并添加到本地线程变量中；如果不为<code>null</code>，则说明当前的线程已经拥有了<code>Connection</code>
对象，直接使用就可以了。这样，就保证了不同的线程使用线程相关的<code>Connection</code>，而
不会使用其它线程的<code>Connection</code>。因此，这个<code>TopicDao</code>就可以做到singleton共享了。
</p>

<p>
当然，这个例子本身很粗糙，将<code>Connection</code>的<code>ThreadLocal</code>直接放在DAO只能做到本DAO
的多个方法共享<code>Connection</code>时不发生线程安全问题，但无法和其它DAO共用同一个
<code>Connection</code>，要做到同一事务多DAO共享同一<code>Connection</code>，必须在一个共同的外部类
使用<code>ThreadLocal</code>保存<code>Connection</code>。
</p>

<h2 id="toc_2.6">小结</h2>

<p>
<code>ThreadLocal</code>是解决线程安全问题一个很好的思路，它通过为每个线程提供一个独立的
变量副本解决了变量并发访问的冲突问题。在很多情况下，<code>ThreadLocal</code>比直接使用
<code>synchronized</code>同步机制解决线程安全问题更简单，更方便，且结果程序拥有更高的并发性
。
</p>



<h1 id="toc_3">内置锁</h1>

<p>
<code>synchronized</code>针对一个对象加锁，如果修饰类静态方法，那锁来自于所在的类<code>Class</code>
对象。
</p>

<p>
代码执行到<code>synchronized</code>同步块里时会取得锁，而离开时（无论是正常离开还是异常）
都会放开锁。
</p>

<h2 id="toc_3.1">重入</h2>

<p>
注意内置锁的粒度是“线程”而不是“调用”。一个线程取得了锁，其他线程都不能再
取得锁。但是本线程还是可以在不同的锁代码块中执行，因为锁的粒度是线程而不是
代码块或线程。这就叫“重入”。
</p>

<p>
例如：父类的方法是<code>synchronized</code>的。子类重写了这个方法，并在方法中调用了父类：
</p>

<pre class="brush: java">
public class Widget {
	public synchronized void doSomething() {
		//... 
	}
}

public class LogginWidget extends Widget {
	public synchronized void doSomething() {
		//... 
		super.doSomething();
		//... 
	}
}
</pre>

<p>
上面的代码中，如果锁的粒度是方法调用，那线程就锁死了。但因为粒度是线程，所以可以
顺利执行。
</p>


<h1 id="toc_4">锁优化</h1>

<h2 id="toc_4.1">处旋锁与自适应自旋</h2>

<h2 id="toc_4.2">锁消除</h2>

<h2 id="toc_4.3">锁粗化</h2>

<h2 id="toc_4.4">轻量级锁</h2>

<p>
只有两个线程竞争时有用，对象头<code>Mark World</code>与线程栈相互指向来简单标记锁状态。
超过两个线程竞争时转为互斥锁。
</p>

<h2 id="toc_4.5">偏向锁</h2>

<p>
消除在没有竞争状态下的同步原语，连CAS都省了。
</p>
 </div>
</body>
</html>
