<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">

<!--
<script type="text/javascript" src="../../vimwiki-theme/3rd-libs/jquery-1.4.2.min.js"></script>
-->
<script type="text/javascript" src="../../vimwiki-theme/3rd-libs/zepto-1.1.2.min.js"></script>

<link type="text/css" rel="stylesheet" href="../../vimwiki-theme/3rd-libs/hightlight-code/styles/shCore.css"/>
<link type="text/css" rel="stylesheet" href="../../vimwiki-theme/3rd-libs/hightlight-code/styles/shThemeDefault.css"/>
<script type="text/javascript" src="../../vimwiki-theme/3rd-libs/hightlight-code/scripts/shCore.js"></script>
<script type="text/javascript" src="../../vimwiki-theme/3rd-libs/hightlight-code/scripts/shAutoloader.js"></script>

<script type="text/javascript" src="../../vimwiki-theme/3rd-libs/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

<script type="text/javascript" src="../../vimwiki-theme/templates/code-default/scripts/script.js"></script>
<link type="text/css" rel="stylesheet" href="../../vimwiki-theme/templates/code-default/styles/style.css" />


<title>Part VIII</title>
</head>
<body  onresize='changeTocSize()'>
	<div class="note-main"> 

<h1>Part VIII</h1>
<div class="toc">
<ul>
<li><a href="#toc_1">结合Scala与Java</a>
<ul>
<li><a href="#toc_1.1">在Java中使用Scala</a>
<ul>
<li><a href="#toc_1.1.1">一般性原则</a>
<li><a href="#toc_1.1.2">值类型</a>
<li><a href="#toc_1.1.3">高阶函数</a>
<li><a href="#toc_1.1.4">单例对象与伴生对象</a>
<ul>
<li><a href="#toc_1.1.4.1">单例对象</a>
<li><a href="#toc_1.1.4.2">伴生对象</a>
</ul>
<li><a href="#toc_1.1.5">作为接口的特质</a>
</ul>
<li><a href="#toc_1.2">注解</a>
<ul>
<li><a href="#toc_1.2.1">标准注解的额外效果</a>
<ul>
<li><a href="#toc_1.2.1.1">过期</a>
<li><a href="#toc_1.2.1.2">volatile字段</a>
<li><a href="#toc_1.2.1.3">序列化</a>
</ul>
<li><a href="#toc_1.2.2">抛出的异常</a>
<li><a href="#toc_1.2.3">Java注解</a>
<li><a href="#toc_1.2.4">编写自己的注解</a>
</ul>
</ul>
<li><a href="#toc_2">Actor和并发</a>
<ul>
<li><a href="#toc_2.1">多线程</a>
<li><a href="#toc_2.2">actor和消息传递</a>
<ul>
<li><a href="#toc_2.2.1">实现Actor特质</a>
<li><a href="#toc_2.2.2">start()方法启动</a>
<li><a href="#toc_2.2.3">Actor.actor()方法</a>
<li><a href="#toc_2.2.4">!()方法发送消息</a>
<li><a href="#toc_2.2.5">receive()方法接收消息</a>
<ul>
<li><a href="#toc_2.2.5.1">处理掉不匹配的消息</a>
<li><a href="#toc_2.2.5.2">处理消息是串行化的</a>
</ul>
<li><a href="#toc_2.2.6">actor未启动也会收到消息</a>
</ul>
<li><a href="#toc_2.3">把原生线程当作actor</a>
<ul>
<li><a href="#toc_2.3.1">receiveWithin()</a>
<li><a href="#toc_2.3.2">future</a>
</ul>
<li><a href="#toc_2.4">简单的并行计算例子</a>
<li><a href="#toc_2.5">小结</a>
<ul>
<li><a href="#toc_2.5.1">消息传递</a>
<li><a href="#toc_2.5.2">发送不阻塞</a>
<li><a href="#toc_2.5.3">接收消息不中断</a>
<li><a href="#toc_2.5.4">接收消息阻塞</a>
</ul>
<li><a href="#toc_2.6">使用同步的方式传递消息</a>
<li><a href="#toc_2.7">通过重用线程取得更好的性能</a>
<ul>
<li><a href="#toc_2.7.1">react工作原理</a>
<li><a href="#toc_2.7.2">reactWithin</a>
<li><a href="#toc_2.7.3">loop与loopWhile</a>
</ul>
<li><a href="#toc_2.8">控制线程执行</a>
<li><a href="#toc_2.9">消息通道</a>
<li><a href="#toc_2.10">Actor的生命周期</a>
<ul>
<li><a href="#toc_2.10.1">exit()方法停止actor</a>
<li><a href="#toc_2.10.2">因为异常停止</a>
</ul>
<li><a href="#toc_2.11">链接多个Actor</a>
<li><a href="#toc_2.12">良好的actor风格</a>
<ul>
<li><a href="#toc_2.12.1">actor不应该阻塞</a>
<li><a href="#toc_2.12.2">只通过消息与actor通信</a>
<li><a href="#toc_2.12.3">不要调用Actor的方法</a>
<li><a href="#toc_2.12.4">优选不可变消息</a>
<li><a href="#toc_2.12.5">让消息自包含</a>
<li><a href="#toc_2.12.6">最小化回复</a>
<li><a href="#toc_2.12.7">监管Actor的终止</a>
</ul>
<li><a href="#toc_2.13">更加长的例子：并行离散事件模拟</a>
<ul>
<li><a href="#toc_2.13.1">总体设计</a>
<li><a href="#toc_2.13.2">实现模拟架构</a>
<li><a href="#toc_2.13.3">实现一个电路模拟</a>
<li><a href="#toc_2.13.4">把所有内容结合在一起</a>
</ul>
</ul>
<li><a href="#toc_3">定界延续</a>
<ul>
<li><a href="#toc_3.1">捕获并执行延续</a>
<li><a href="#toc_3.2">定界</a>
<li><a href="#toc_3.3">延续捕获的原理</a>
<li><a href="#toc_3.4">reset和shift的控制流程</a>
<li><a href="#toc_3.5">reset表达式的值</a>
<li><a href="#toc_3.6">reset和shift表达式的类型</a>
<li><a href="#toc_3.7">CPS注解</a>
<li><a href="#toc_3.8">把递归访问转为迭代</a>
<li><a href="#toc_3.9">控制反转</a>
<li><a href="#toc_3.10">CPS变换</a>
<li><a href="#toc_3.11">转换嵌套的控制上下文</a>
</ul>
</ul>
</div>



<h1 id="toc_1">结合Scala与Java</h1>

<h2 id="toc_1.1">在Java中使用Scala</h2>

<p>
要保证<code>classpath</code>里有<code>scala-librasy.jar</code>。虽然Scala代码被编译成了Java字节码，但
还是要知道编译成了字节码以后长什么样子。
</p>

<h3 id="toc_1.1.1">一般性原则</h3>

<p>
Scala尽可能把Scala特性编译成对等的Java特性，如：类、方法、字符串、异常等。
</p>

<p>
虽然在运行时进行确定重载方法是一个很好的方案，但是为了和Java的重载一致Scala还是
和Java保持一致使用编译时解析重载。这样Scala的方法与调用方式可以和Java的一致。
</p>

<p>
但是像特质这样在Java里没有对应的特性就比较麻烦，还有Java和Scala的泛型要细节上是
有冲突的，只能用别的方式解决。注意在不同版本中这样的解决方案会不断的优化改变。
所以可靠的方式还是用<code>javap</code>工具检查<code>.class</code>文件。
</p>

<h3 id="toc_1.1.2">值类型</h3>

<p>
<code>Int</code>这样的值类型会尽量用Java的<code>Int</code>表示。但有些情况下如<code>List[Any]</code>时不能确定用
的是哪一种类型，所以会用<code>Interger</code>这样的包装器类。
</p>

<h3 id="toc_1.1.3">高阶函数</h3>

<p>
Java不支持高阶函数与闭包等特性，所以用不了。如果预计以后要给Java用的话，就再定义
一个不用高阶函数实现的函数给Java代码调用……
</p>

<h3 id="toc_1.1.4">单例对象与伴生对象</h3>

<p>
由于在Java里没有对应的特性，所以采用静态和实例方法结合的方式。每个Scala的单例
对象编译器都会创建一个名称后加美元符号的Java类。对于名为<code>App</code>的单例对象编译器
产出一个名为<code>App$</code>的Java类。这个类拥有Scala单例对象的所有字段和方法，这个Java类
同时还有一个名为<code>MODULE$</code>的静态字段，保存该类在运行期创建的一个实例。
</p>

<p>
完整的例子：
</p>

<pre class="brush: scala">
  object App {
    def main(args: Array[String]) {
      println("Hello, world!")
    }
  }
</pre>

<p>
会生成一个Java类<code>App$</code>：
</p>

<pre class="brush: scala">
  $ javap App$
  public final class App$ extends java.lang.Object
  implements scala.ScalaObject{
      public static final App$ MODULE$;
      public static {};
      public App$();
      public void main(java.lang.String[]);
      public int $tag();
  }
</pre>


<h4 id="toc_1.1.4.1">单例对象</h4>

<p>
编译器还要为单例对象<code>App</code>自动创建一个叫<code>App</code>的Java类。这个类对于每个Scala单例
对象的方法都有一个静态转发方法与之对应：
</p>

<pre class="brush: scala">
  $ javap App
  Compiled from "App.scala"
  public final class App extends java.lang.Object{
      public static final int $tag();
      public static final void main(java.lang.String[]);
  }
</pre>

<p>
在Java中调用单例对象的例子：
</p>

<pre class="brush: scala">
object Single {
	def greet() { println("hello") }
}
</pre>

<p>
在Java里调用时就像用静态方法一样：
</p>

<pre class="brush: java">
public class SingleUser {
	public static void main(String [] args) {
		Single.greet()
	}
}
</pre>

<h4 id="toc_1.1.4.2">伴生对象</h4>

<p>
反之如果已经有一个名为<code>App</code>的类了，Scala会创建一个相对应的Java类<code>App</code>来保存定义
<code>App</code>类的成员。在这种情况下就不包含任何转发到同名单例对象的方法，Java代码必须
通过<code>MODULE$</code>字段来访问这个单例。
</p>

<pre class="brush: scala">
class Buddy {
	def greet() { println("this is Buddy class") }
}

object Buddy {
	def greet() { println("this is Buddy object") }
}
</pre>

<p>
在Java里调用伴生对象要通过<code>MODULE$</code>：
</p>

<pre class="brush: java">
public class BUddyUser {
	public static void main(String [] args) {
		new Buddy().greet();
		Buddy$.MODULE$.greet();
	}
}
</pre>

<h3 id="toc_1.1.5">作为接口的特质</h3>

<p>
每个特质都会创建一个同名的Java接口。这个接口可以作为Java类型使用，可以通过这个
接口类型的变量来调用Scala的对象方法。
</p>

<p>
反过来如果要在Java中建立一个Scala特质的情况非常罕见，但也有特殊情况下需要这样做
。如果Scala特质只有抽象方法的话就直接翻译成Java接口。所以本质上说能Scala语法来
编写Java接口。
</p>

<p>
举例来说，如果一个特质没有实现方法，那个Java代码里可以把它作为接口来用：
</p>

<pre class="brush: scala">
trait Writable {
	def wirte(msg: String) : Unit
}
</pre>

<p>
Java代码里可以实现它：
</p>

<pre class="brush: java">
public class AWritableJavaClass implements Writable {
	public void write(String msg) {}
}
</pre>

<p>
如果特质里有实现：
</p>

<pre class="brush: scala">
trait Printable {
	def print() {}
}
</pre>

<p>
那在Java里就不能实现它了，但可以反它作为一个类型，持有它的一个引用。
</p>

<h2 id="toc_1.2">注解</h2>

<h3 id="toc_1.2.1">标准注解的额外效果</h3>

<p>
有一些注解编译器在针对Java平台编译时会产额外的信息。编译器会首先按Scala原则去
处理，然后针对Java做一些额外的工作。
</p>

<h4 id="toc_1.2.1.1">过期</h4>

<p>
<code>@deprecated</code>标记的方法或类，编译器会为产的代码添加Java自己的过期注解。所以Java
也会警告过期。
</p>

<h4 id="toc_1.2.1.2">volatile字段</h4>

<p>
对应到Java里的<code>volatile</code>修饰符。所以这两套机制一样，对volatile字段的访问也完全
根据Java内存模型所规定的volatile字段处理原则来进行排列。
</p>

<h4 id="toc_1.2.1.3">序列化</h4>

<p>
<code>@serializable</code>被加上Java的<code>Serializable</code>接口。<code>@SerialVersionUID</code>被转成Java的
版本字段：
</p>

<pre class="brush: scala">
@SerialVersionUID(42L) class Person extends Serializable
</pre>

<p>
对应的Java：
</p>

<pre class="brush: java">
public class Person implements java.io.Serializable {
  private final static long SerialVersionUID = 1234L
  
	// ...
}
</pre>

<p>
<code>@transient</code>变量会被加上Java的<code>transient</code>修饰符： 
</p>


<h3 id="toc_1.2.2">抛出的异常</h3>

<p>
Scala不检查抛出的异常是否被捕获。也就是说Scala没有<code>throws</code>声明。所以所有的Scala
都被翻译成不抛出任何异常的Java方法。这样做的原因是<code>throws</code>声明就是为了强制开发
人员一定要处理异常。但是的很多开发人员写Java在捕获了以后也不处理，这样语法上虽然
过了但是等于没有抛出声明。比如下面这样的<code>catch</code>块里一句语句也没有：
</p>

<pre class="brush: scala">
try {
	...
} catch (IOException e) {
	// do nothing
}
</pre>

<p>
这样异常没有处理，反而还给代码包了一层<code>try-catch</code>。Scala为了代码干净就直接不声明
抛出异常了。
</p>

<p>
但是为了和Java程序对接，声明一下会抛出哪些异常还是有必要的。不然Java代码就不能
捕获可能抛出的异常。所以通过注解标签<code>@throws</code>来说明：
</p>

<pre class="brush: scala">
  import java.io._
  class Reader(fname: String) {
    private val in =
      new BufferedReader(new FileReader(fname))
 
    @throws(classOf[IOException])
    def read() = in.read()
  }
</pre>

<p>
从Java看来是这个样子的：
</p>

<pre class="brush: scala">
  $ javap Reader
  Compiled from "Reader.scala"
  public class Reader extends java.lang.Object implements
  scala.ScalaObject{
      public Reader(java.lang.String);
      public int read()       throws java.io.IOException;
      public int $tag();
  }
  $
</pre>

<p>
这样Java中调用Scala代码时才能捕获异常：
</p>

<pre class="brush: java">
try {
	reader.read();
} catch (IOException e) {
	// ...
}
</pre>

<p>
Scala里对异常的捕获：
</p>

<pre class="brush: java">
import java.io.FileReader  
import java.io.FileNotFoundException  
import java.io.IOException  
try {  
	val f = new FileReader("input.txt")  
	// Use and close file  
} catch {  
	case ex: FileNotFoundException =&gt; // Handle missing file  
	case ex: IOException =&gt; // Handle other I/O error  
}  
</pre>

<p>
finally子句：
</p>

<pre class="brush: java">
import java.io.FileReader  
val file = openFile()  
try {  
	// 使用文件  
} finally {  
	file.close() // 确保关闭文件  
}  
</pre>

<p>
有返回值：
</p>

<p>
和其它大多数Scala控制结构一样，try-catch-finally也产生值。
</p>

<ul>
<li>
如果没有异常抛出，则对应于try子句；

<li>
如果抛出异常并被捕获，则对应于相应的catch子句；

<li>
如果异常被抛出但没被捕获，表达式就没有返回值。

<li>
如果finally子句计算得到的值被抛弃。

</ul>

<pre class="brush: java">
import java.net.URL  
import java.net.MalformedURLException  
def urlFor(path: String) =  
try {  
	new URL(path)  
} catch {  
	case e: MalformedURLException =&gt; new URL("http://www.scalalang.org")  
}  
</pre>

<p>
上面代码展示了如何尝试拆分URL，但如果URL格式错误就使用缺省值。
</p>

<p>
通常finally子句做一些清理类型的工作如关闭文件；他们不应该改变在主函数体
或try的catch子句中计算的值。
</p>

<p>
如：
</p>

<pre class="brush: java">
def f(): Int = try { return 1 } finally { return 2 }  
</pre>

<p>
调用<code>f()</code>产生结果值2，因为finally虽然不返回值，但是和Java一样它的内容<code>return 2</code>
一定会在最后被执行。
</p>

<p>
相反：
</p>

<pre class="brush: java">
def g(): Int = try { 1 } finally { 2 }  
</pre>

<p>
调用<code>g()</code>产生1，这是因为finally的值是被抛弃的，所以表达式的结果是1。
</p>

<p>
这两个例子展示了有可能另大多数程序员感到惊奇的行为，因此通常最好还是避免从
finally子句中返回值。最好是把finally子句当作确保某些副作用，如关闭打开的文件，
发生的途径。
</p>


<h3 id="toc_1.2.3">Java注解</h3>

<p>
Java注解可以直接在Scala代码中用，任何Java框架都会看到这些注解。如Junit的注解：
</p>

<pre class="brush: scala">
  import org.junit.Test
  import org.junit.Assert.assertEquals

  class SetTest {

    @Test
    def testMultiAdd {
      val set = Set() + 1 + 2 + 3 + 1 + 2 + 3
      assertEquals(3, set.size)
    }
  }
</pre>

<p>
Scala可以直接用：
</p>

<pre class="brush: scala">
  $ scala -cp junit-4.3.1.jar:. org.junit.runner.JUnitCore SetTest
  JUnit version 4.3.1
  .
  Time: 0.023
 
  OK (1 test)
</pre>


<h3 id="toc_1.2.4">编写自己的注解</h3>

<p>
为了让注解对Java反射可见，必须用Java语法编写并用<code>javac</code>编译。将来Scala可能会有
自己的反射，但现在Scala还没有办法来实现Java注解的全部功能。
</p>

<p>
但是有可以要使用Scala反射来访问Scala的注解。所以要先用Java来写：
</p>

<pre class="brush: scala">
  import java.lang.annotation.*;
  @Retention(RetentionPolicy.RUNTIME)
  @Target(ElementType.METHOD)
  public @interface Ignore { }
</pre>

<p>
使用<code>javac</code>编译过以后，Scala里使用的方式：
</p>

<pre class="brush: scala">
  object Tests {
    @Ignore
    def testData = List(0, 1, -1, 5, -5)

    def test1 {
      assert(testData == (testData.head :: testData.tail))
    }

    def test2 {
      assert(testData.contains(testData.head))
    }
  }
</pre>

<p>
这里的<code>test1</code>和<code>test2</code>应该是测试方法，尽管<code>testData</code>以<code>test</code>开头，但实际上应该
被忽略。
</p>

<p>
通过Java的反身API来观察这些注解是否被用到：
</p>

<pre class="brush: scala">
  for {
    method &lt;- Tests.getClass.getMethods
    if method.getName.startsWith("test")
    if method.getAnnotation(classOf[Ignore]) == null
  } {
    println("found a test method: " + method)
  }
</pre>

<p>
在这里用反射方法<code>getClass</code>和<code>getMethods</code>来检查输入对象类的所有字段。与注解相关的
部分是<code>getAnnotation</code>方法，它用来查找特定类型的注解，这里用来查找我们定义的
<code>Ignore</code>类型的注解。运行起来是这样的：
</p>

<pre class="brush: scala">
  $ javac Ignore.java
  $ scalac Tests.scala
  $ scalac FindTests.scala
  $ scala FindTests
  found a test method: public void Tests$.test2()
  found a test method: public void Tests$.test1()
</pre>

<p>
注意这些方法在Java反射看来是位于<code>Test$</code>类而不是<code>Test</code>类中，因为这是单例对象。
</p>

<p>
还要注意Java注解的限制，比如，注解的参数只能用常量不能用表达式。（可以用
<code>@serial(1234)</code>而不能用<code>@serial(x*2)</code>）。
</p>






<h1 id="toc_2">Actor和并发</h1>

<h2 id="toc_2.1">多线程</h2>

<p>
虽然推荐使用Actor模式，但还是讲一下传统的多线程控制方式吧。
</p>

<p>
<code>AnyRef</code>类追加了来自<code>Object</code>类的<code>wait</code>与<code>notify</code>、<code>notifyAll</code>方法。并且提供了带
参数的<code>synchronized</code>方法，等同于Java的<code>synchronized</code>块：
</p>

<pre class="brush: scala">
account.synchronized {
	account.balance += amount
}
</pre>

<h2 id="toc_2.2">actor和消息传递</h2>

<p>
actor是一个类似线程的实体，它有一个接收消息的邮箱。
</p>

<h3 id="toc_2.2.1">实现Actor特质</h3>

<p>
Scala里实现actor的方法是混入<code>scala.actors.Actor</code>特质并实现其<code>act()</code>方法。
下面一个简单的例子都不检查它的邮箱，只是把一个消息打印五次然后退出：
</p>

<pre class="brush: scala">
  import scala.actors._

  object SillyActor extends Actor {
    def act() { 
      for (i &lt;- 1 to 5) {
        println("I'm acting!")
        Thread.sleep(1000)
      }
    }
  }
</pre>

<p>
注意：如果没有继承任何类，可以用关键字<code>extends</code>来混入特质。
</p>

<h3 id="toc_2.2.2">start()方法启动</h3>

<p>
启动方法和Java线程类似，也是调用<code>start()</code>方法：
</p>

<pre class="brush: scala">
  scala&gt; SillyActor.start()
  I'm acting!
  res4: scala.actors.Actor = SillyActor$@1945696

  scala&gt; I'm acting!
  I'm acting!
  I'm acting!
  I'm acting!
</pre>

<p>
注意输出的文本与Scala交互程序的回显交错在一起了，因为这是在另一个独立的线程里。
所以运行是独立的。再来看第二版的actor：
</p>

<pre class="brush: scala">
  import scala.actors._

  object SeriousActor extends Actor {
    def act() { 
      for (i &lt;- 1 to 5) {
        println("To be or not to be.")
        Thread.sleep(1000)
      }
    }
  }
</pre>

<p>
这里同时运行两个actor：
</p>

<pre class="brush: scala">
  scala&gt; SillyActor.start(); SeriousActor.start()
  res3: scala.actors.Actor = seriousActor$@1689405

  scala&gt; To be or not to be.
  I'm acting!
  To be or not to be.
  I'm acting!
  To be or not to be.
  I'm acting!
  To be or not to be.
  I'm acting!
  To be or not to be.
  I'm acting!
</pre>

<h3 id="toc_2.2.3">Actor.actor()方法</h3>

<p>
还可以用伴生对象<code>scala.actor.Actor</code>的<code>actor()</code>方法来创建actor，它接收一个函数值/
闭包做参数：
</p>

<pre class="brush: scala">
  scala&gt; import scala.actors.Actor._

  scala&gt; val seriousActor2 = actor {
       |    for (i &lt;- 1 to 5)
       |      println("That is the question.")
       |    Thread.sleep(1000)
       | }

  scala&gt; That is the question.
  That is the question.
  That is the question.
  That is the question.
  That is the question.
</pre>

<p>
注意上面用<code>actor()</code>方法创建的actor在创建后是立即启动的。
</p>

<h3 id="toc_2.2.4">!()方法发送消息</h3>

<p>
actor之间的协作方式是通过<code>!()</code>方法来发送消息，发送操作是并发非阻塞的：
</p>

<pre class="brush: scala">
  scala&gt; SillyActor ! "hi there"
</pre>

<p>
虽然消息<code>"hi there"</code>被发给了<code>SillyActor</code>，但消息只是放在邮箱里保持未读状态。
</p>

<h3 id="toc_2.2.5">receive()方法接收消息</h3>

<p>
<code>receive()</code>方法从消息队列中取出一条消息来处理。它可以接收一个闭包作为参数。如
下面这样只是把消息打印出来：
</p>

<pre class="brush: scala">
  val echoActor = actor {
    while (true) {
      receive {
        case msg =&gt;
          println("received message: "+ msg)
      }
    }
  }
</pre>

<p>
注意这里的使用的偏函数字面量，除了没有<code>match</code>关键字外，和match表达式样子很像。
</p>

<p>
当actor发消息时并不会阻塞，收到消息时处理的过程是阻塞的，不会被打断。发送的消息
在接收的actor的邮箱里等待被处理，直到actor调用<code>receive</code>方法：
</p>

<pre class="brush: scala">
  scala&gt; echoActor ! "hi there"
  received message: hi there

  scala&gt; echoActor ! 15

  scala&gt; received message: 15
</pre>

<p>
这里要解释一下<code>receive</code>以偏函数字面量作为参数。除了没有<code>match</code>关键字外，和match
表达式样子很像，而且不像match表达式一样要匹配所有的可能性，的会直接忽略掉没有
匹配的情况（即偏函数没有定义）。
</p>

<p>
正如“模式匹配”一章中“模式无处不在”这一节中所说的，偏函数（可以表示为特质
<code>PartialFunction[Any, T]</code>的实例。其中<code>T</code>是<code>case =&gt;</code>语句右边表达式计算的结果类型
）并不是完整的函数。所以它不对所有输入值有都定义。除了接受单个<code>apply</code>方法
外，偏函数还提供一个<code>isDefineAt</code>方法，同样只接收单个参数。如果偏函数能处理传给
<code>isDefineAt</code>函数的参数，那么<code>isDefineAt</code>返回<code>true</code>。把这个消息传递给偏函数的
<code>apply</code>方法，<code>apply</code>方法就会处理这个消息。
</p>

<p>
例如<code>echoActor</code>的<code>apply</code>方法会打印<code>"received message: "</code>，然后再输出消息对象的
<code>toString</code>结果。如果邮箱里没有让<code>isDefineAt</code>返回<code>true</code>的消息，则被调用<code>receive</code>
的actor将会被阻塞，直到有匹配的消息。
</p>

<p>
举例来说，以下是只处理<code>Int</code>类型消息的actor：
</p>

<pre class="brush: scala">
  scala&gt; val intActor = actor {
       |   receive {
       |     case x: Int =&gt; // I only want Ints
       |       println("Got an Int: "+ x)
       |   }
       | }
  intActor: scala.actors.Actor = 
    scala.actors.Actor$$anon$1@34ba6b
</pre>

<p>
如果是<code>String</code>或<code>Double</code>类型的消息会被忽略：
</p>

<pre class="brush: scala">
  scala&gt; intActor ! "hello"
  scala&gt; intActor ! Math.Pi
</pre>

<p>
给个<code>Int</code>就会有响应：
</p>

<pre class="brush: scala">
  scala&gt; intActor ! 12
  Got an Int: 12
</pre>

<h4 id="toc_2.2.5.1">处理掉不匹配的消息</h4>

<p>
注意：如果邮箱可能会被不能匹配<code>case</code>条件的消息挤满，可以用一个<code>case _</code>匹配所有
情况来处理掉那些消息。
</p>

<h4 id="toc_2.2.5.2">处理消息是串行化的</h4>

<p>
因为消息处理是串行化的，所以不会有并发的竞争状况。比如下面的<code>balance</code>是安全的，
不会出现同时加减：
</p>

<pre class="brush: scala">
class AccountActor extends Actor {
	private var balance = 0.0
	
	def act() {
		while (true) {
			receive {
				case Deposit(account)  =&gt; balance += amount
				case Withdraw(account) =&gt; balance -= amount
			}
		}
	}

}
</pre>

<p>
但是这只能保证同一个Actor对象中的成员安全。如果多个Actor共用的话，必然会有竞争
状况。
</p>

<p>
所以Actor <strong>绝对不应该</strong> 访问自身外部的状态对象，虽然Scala并没有强制。
</p>

<h3 id="toc_2.2.6">actor未启动也会收到消息</h3>

<p>
如果actor还没有启动，收到的消息也会放在队列里，不是不会马上处理。在<code>start()</code>方法
被调用后也会开始处理：
</p>

<pre class="brush: scala">
myAct ! "before start 1" 
myAct ! "before start 2" 
myAct ! "before start 3" 
myAct ! "before start 4" 

myAct.start()

myAct ! "after start 1" 
myAct ! "after start 2" 
myAct ! "after start 3" 
myAct ! "after start 4" 
</pre>

<h2 id="toc_2.3">把原生线程当作actor</h2>

<p>
Actor子系统会管理线程，所以定义了actor以后开发人员不用操心actor与线程的对应关系
是怎么样的。
</p>

<p>
Java里可以用<code>Thread.current</code>得到当前线程的引用，类似地，Scala里<code>Actor</code>对象的
<code>Actor.self()</code>方法可以取得用当前线程生成的Actor的引用。这样在交互环境可以少写
很多代码，如：
</p>

<pre class="brush: scala">
scala&gt; import scala.actors.Actor
import scala.actors.Actor

scala&gt; Actor.self ! "hello"

scala&gt; Actor.self.receive { case x =&gt; x }
res2: Any = hello
</pre>

<p>
也可以直接引入<code>Actor._</code>，这样可以把<code>Actor.self</code>简写为<code>self</code>：
</p>

<pre class="brush: scala">
  scala&gt; import scala.actors.Actor._
  import scala.actors.Actor._

  scala&gt; self ! "hello"

  scala&gt; self.receive { case x =&gt; x }
  res6: Any = hello
</pre>

<p>
上面的<code>receive()</code>方法返回由传递给它的偏函数计算出的值。在本例中，偏函数返回消息
本身，所以消息被交互环境打印了出来。
</p>

<h3 id="toc_2.3.1">receiveWithin()</h3>

<p>
因为<code>receive()</code>是阻塞的，所以不知道要等到啥时候。所以如果使用了这项技巧，最好是
用<code>receive()</code>的变种<code>receiveWithin()</code>。因为它可以指定一个以毫秒计的超时时限：
</p>

<pre class="brush: scala">
  scala&gt; self.receiveWithin(1000) { case x =&gt; x } // wait a sec!
  res7: Any = TIMEOUT
</pre>

<p>
可以用<code>case TIMEOUT</code>来匹配超时的情况，这里指的是<code>Actor.TIMEOUT</code>。
</p>

<h3 id="toc_2.3.2">future</h3>

<p>
通过<code>!!()</code>方法表示接收一个Future对象，它表示一个未来会得到的结果，但现在先不
计算它。类似于惰性求值：
</p>

<pre class="brush: scala">
val replyFuture = account !! Deposit(1000)
</pre>

<p>
上面的代码因为不求出结果，所以可以看作是不阻塞的。在取出值时阻塞：
</p>

<pre class="brush: scala">
val reply = replyFuture()
</pre>


<h2 id="toc_2.4">简单的并行计算例子</h2>

<p>
要计算从1到n的所有整数累加，可以分成多段并行执行。下面是处理每一段的方法：
</p>

<pre class="brush: scala">
import scala.actors._
import scala.actors.Actor._

def sumPart(floor:Int, top:Int) = {
	(0 /: (floor to top)) {
		(sum, i) =&gt; { sum + i }
	}
}
</pre>

<p>
把整个区间分成多个段并行执行：
</p>

<pre class="brush: scala; highlight:[4,9,13]">
def sumAll(num:Int) = {
	val RANGE = 10
	val partCount = (num.toDouble / RANGE).ceil.toInt
	val caller = self  // this is Actor.self()

	for (i &lt;- 0 until partCount) {
		val floor = i * RANGE + 1;
		val top = num min (i + 1) * RANGE
		actor { caller ! sumPart(floor, top) }  // Actor.actor() create new Actor
	}

	(0 /: (0 until partCount)) {
		(allSum, i) =&gt; receive {    // this is Actor.receive()
			case sumInRange:Int =&gt; { allSum + sumInRange }
		}
	}
}
</pre>


<p>
能够实现并行操作的关键在于：actor发送消息是不阻塞的，打个比方就是每个发送操作都
在新建的线程中执行。结合上面代码的第9行是在发送的操作中调用的计算局部的方法，
所以每个局部计算的工作都是在新的线程中进行的。
</p>

<p>
调用：
</p>

<pre class="brush: scala">
println( sumAll(100) )
</pre>


<h2 id="toc_2.5">小结</h2>

<h3 id="toc_2.5.1">消息传递</h3>

<p>
每个actor都有自己的消息队列：
</p>

<ul>
<li>
<code>InputChannel[Any]</code>接收队列。

<li>
<code>OutputChannel[Any]</code>发送队列。

</ul>

<p>
注意actor传递消息有两个重要的特性：
</p>



<h3 id="toc_2.5.2">发送不阻塞</h3>

<p>
对于以下的代码来说：
</p>

<pre class="brush: scala">
op1();
myActor ! "msg"
op2();
</pre>

<p>
即使中间一步发消息的动作如果要花很长时间，感觉也像是<code>op1()</code>执行以后接着就是
<code>op2()</code>的执行，好像发消息的动作不占用时间一样。
</p>

<h3 id="toc_2.5.3">接收消息不中断</h3>

<p>
如果不用<code>receive</code>方法去检查接收队列，actor根本不知道有没有消息进来，所以对于以下
的代码：
</p>

<pre class="brush: scala">
op1();
op2();
receive { case msg =&gt; println(msg) }
</pre>

<p>
在<code>op1()</code>和<code>op2()</code>执行过程中如果外部有发消息给当前actor，由于还没有调用<code>receive</code>
方法，actor根本就不知道有消息进来，所以<code>op1()</code>和<code>op2()</code>的执行不会被打断。
</p>


<h3 id="toc_2.5.4">接收消息阻塞</h3>

<p>
如果在调用<code>receive</code>方法时消息队列里没有消息，那么<code>receive</code>方法会阻塞。
</p>

<h2 id="toc_2.6">使用同步的方式传递消息</h2>

<p>
虽然异步方式能利用并发，但也有需要用同步的情况存在。这时可以用<code>!?()</code>方法，注意
这样会导致阻塞，所以推荐用带超时参数的版本：<code>!?(timeout, msg)</code>。它在正常时返回
<code>Option[Any]</code>；超时时返回<code>None</code>，但actor还是会收到这条消息，并把它发给自己。可以
通过一个特殊的case类<code>![a](val ch:Channel[a], val msg:a)</code>表示actor发给自己的消息
，这样就能得到超时丢失的消息。
</p>

<p>
<code>sender</code>引用的总是最近一个发送消息的actor，用<code>reply</code>方法也可以说明把消息发送给
<code>sender</code>。
</p>

<p>
如果发送消息给一个actor以后不希望它把响应发回给自己，而是希望它发给另外一个actor
，就可以用<code>send()</code>方法。
</p>

<pre class="brush: scala; highlight:[8,21,28]">
import scala.actors._
import Actor._

val fortuneTeller = actor {
    for (i &lt;- 1 to 4) {
        Thread.sleep(1000)
        receive {
            case _ =&gt; sender ! "your day will rock! " + i  // reply to sender
            // case _ =&gt; reply("your day will rock! " + i) // same as above
        }
    }
}

println( fortuneTeller !? (2000, "what's ahead") ) // async send with timeout
println( fortuneTeller !? (200,  "what's ahead") )

val aPrinter = actor {
    receive { case msg =&gt; println("Ah, Fortune message for you: " + msg) }
}

fortuneTeller.send("what's up", aPrinter)  // use send() to send another actor
fortuneTeller ! "How's my future?"

Thread.sleep(3000)
receive { case msg : String =&gt; println("received " + msg) }

println("let's get that message")
receive { case !(channel, msg) =&gt; println("received belated message " + msg) }
</pre>

<p>
上面的代码最后一行拿到的是超时丢弃的消息。运行时输出如下：
</p>

<pre class="brush: bash">
└─(1:pts/4:%)=&gt; scala tmp.scala
Some(your day will rock! 1)
None
Ah, Fortune message for you: your day will rock! 3
received your day will rock! 4
let's get that message
received belated message your day will rock! 2
</pre>


<h2 id="toc_2.7">通过重用线程取得更好的性能</h2>

<p>
Acter建立在普通的Java线程上，用之前的方法每actor的<code>receive</code>方法个都占一个线程。
就是说，在没有消息的时候，阻塞着的<code>receive</code>方法也会一直占一个线程。为了重用线程，
Scala提供了<code>react</code>方法从线程池里取已经有的线程（还有一个带超时的<code>reactWithin</code>）
。它处理消息以后不会返回，返回类型是<code>Nothing</code>。其实在后台，<code>react</code>在完成后会抛出
一个异常。
</p>

<p>
<code>react</code>方法执行完毕以后就会放弃对线程的占用，所以在<code>react</code>方法后面的代码是执行
不到的。如果还有其他代码要执行，就一定要放在<code>react</code>方法内。
</p>

<p>
下面同时用了<code>receive</code>和<code>react</code>两个方法比较：
</p>

<pre class="brush: scala">
import scala.actors.Actor._

def info(msg: String) = println(msg + " received by " + Thread.currentThread())

def receiveMessage(id : Int) {
  for(i &lt;- 1 to 2) {
      receiveWithin(20000) { 
        case msg : String =&gt; info("receive: " + id + msg) }
  }
}

def reactMessage(id : Int) {              
  react {
    case msg : String =&gt; info("react:   " + id + msg)
    reactMessage(id)
  }
}

val actors = Array(
  actor { info("react:   1 actor created"); reactMessage(1) },
  actor { info("react:   2 actor created"); reactMessage(2) },
  actor { info("receive: 3 actor created"); receiveMessage(3) },
  actor { info("receive: 4 actor created"); receiveMessage(4) }
  ) 
  
Thread.sleep(1000)               
for(i &lt;- 0 to 3) { actors(i) ! " hello"; Thread.sleep(2000) }
Thread.sleep(2000)
for(i &lt;- 0 to 3) { actors(i) ! " hello"; Thread.sleep(2000) }
</pre>

<p>
调用：
</p>

<pre class="brush: bash; highlight:[7,11]">
create actor by Thread[ForkJoinPool-1-worker-3,5,main]
create actor by Thread[ForkJoinPool-1-worker-3,5,main]
create actor by Thread[ForkJoinPool-1-worker-1,5,main]
create actor by Thread[ForkJoinPool-1-worker-5,5,main]
  react: 1hello by Thread[ForkJoinPool-1-worker-7,5,main]
  react: 2hello by Thread[ForkJoinPool-1-worker-5,5,main]
receive: 3hello by Thread[ForkJoinPool-1-worker-1,5,main]
receive: 4hello by Thread[ForkJoinPool-1-worker-3,5,main]
  react: 1hello by Thread[ForkJoinPool-1-worker-5,5,main]
  react: 2hello by Thread[ForkJoinPool-1-worker-5,5,main]
receive: 3hello by Thread[ForkJoinPool-1-worker-1,5,main]
receive: 4hello by Thread[ForkJoinPool-1-worker-3,5,main]
</pre>

<p>
从输出可以看到，同一个actor的<code>receiveWithin</code>方法总是在同一个线程。如：
</p>

<ul>
<li>
actor3总是在线程<code>Thread[ForkJoinPool-1-worker-1,5,main]</code>中；

<li>
actor4总是在同一个线程<code>Thread[ForkJoinPool-1-worker-3,5,main]</code>；

<li>
<code>react()</code>方法就不固定了，可能会多个actor共用一个线程，也可能会一个actor用多个
  线程。

</ul>

<p>
因为<code>react</code>不返回所以接收消息处理器必须同时处理消息并执行actor所有剩下的工作。
通常做法是用一个顶级的工作方法，比如<code>act</code>自身，以供处理器在完成时调用。下面的
例子显示了这种方式。等待内容为主机名的字符串，如果有的话，返回那个主机名对应的
IP地址：
</p>

<pre class="brush: scala; highlight:[4,8,14]">
  object NameResolver extends Actor {
    import java.net.{InetAddress, UnknownHostException}

    def act() { 
      react {
        case (name: String, actor: Actor) =&gt;
          actor ! getIp(name)
          act()                         // 尾递归再次调用
        case "EXIT" =&gt;
          println("Name resolver exiting.")
          // quit
        case msg =&gt;
          println("Unhandled message: "+ msg)
          act()                         // 尾递归再次调用
      }
    }

    def getIp(name: String): Option[InetAddress] = {
      try {
        Some(InetAddress.getByName(name))
      } catch {
        case _:UnknownHostException =&gt; None
      }
    }
  }
</pre>

<p>
调用方式：
</p>

<pre class="brush: scala">
  scala&gt; NameResolver.start()
  res0: scala.actors.Actor = NameResolver$@90d6c5

  scala&gt; NameResolver ! ("www.scala-lang.org", self)

  scala&gt; self.receiveWithin(0) { case x =&gt; x }
  res2: Any = Some(www.scala-lang.org/128.178.154.102)

  scala&gt; NameResolver ! ("wwwwww.scala-lang.org", self)

  scala&gt; self.receiveWithin(0) { case x =&gt; x }
  res4: Any = None
</pre>

<p>
因为不返回所以当前线程的调用栈可以被再次使用，所以如果全用<code>react</code>的话只要一个
线程就可以运行所有的actor。实例应用中应该用少用几个<code>receive</code>，尽量多用<code>react</code>。
</p>

<h3 id="toc_2.7.1">react工作原理</h3>

<p>
返回类型<code>Nothing</code>表示永远不会正常返回的函数，相反，总是以一个异常方式完成。
</p>

<p>
因为<code>react</code>会因为异常退出，所以不能把它放在<code>while</code>循环中。如：
</p>

<pre class="brush: scala">
def act() {
	while (true) {
		react {
			case Withdraw(amount) =&gt; println("Withdrawing " + amount)
		}
	}
}
</pre>

<p>
因为<code>react()</code>方法的参数是一个没有返回对象的偏函数：
</p>

<pre class="brush: scala">
{ case Withdraw(amount) =&gt; println("Withdrawing " + amount) }
</pre>

<p>
所以它不能返回到循环当中去，所以要实现循环的方法之一是在消息处理器中再次调用
<code>act()</code>方法：
</p>

<pre class="brush: scala">
def act() {
	react {
		case Withdraw(amount) =&gt; {
			println("Withdrawing " + amount)
			act()
		}
	}
}
</pre>

<p>
这样的作法相当于用一个无穷的递归替换掉无穷的循环。但由于每次<code>react()</code>调用都会
抛出异常，所以栈被清空，不会占用太大的栈空间。
</p>

<p>
虽然不同版本中实现方式还在不断调整，但可以认为<code>react</code>是这样工作的：
</p>

<p>
actor的<code>start</code>方法被调用时，<code>start</code>方法会以某种方式确保最终会有某个线程来调用
actor的<code>act</code>方法。如果<code>act</code>调用了<code>react</code>，则<code>react</code>方法会在actor邮箱里查找偏函数
能够处理的消息。如果找到<code>react</code>会安排在未来某个时间处理该消息并抛出异常。如果
没有act还是处于“冷存储”状态等待邮箱里有新消息时重新激活并抛出异常。无论哪种情况
<code>react</code>都会以这个异常的方式完成其执行，<code>act</code>方法也随之结束。调用<code>act</code>的线程会
捕获这个异常，并忘记这个actor，转而处理其他任务。
</p>

<p>
这就是为什么想要<code>react</code>在处理第一个消息之外做更多的事，就需要在偏函数中再次调用
<code>act</code>方法，或使用其他手段让<code>react</code>再次被调用。
</p>

<h3 id="toc_2.7.2">reactWithin</h3>

<p>
<code>reactWithin</code>在超时没有收到消息时会匹配<code>case TIMEOUT</code>。下面有一个累加器的实现：
</p>

<pre class="brush: scala; highlight:[7,10]">
import scala.actors._
import Actor._ 

val caller = self

def accumulate() {
  var sum = 0
  reactWithin(500) {
    case number: Int =&gt; sum += number
    accumulate()
    case TIMEOUT =&gt; 
      println("Timed out! Will send result now")
      caller ! sum
  }
  println("This will not be called...")
}

val accumulator = actor { accumulate() }
accumulator ! 1
accumulator ! 7
accumulator ! 8

receiveWithin(10000) { case result =&gt; println("Total is " + result) }
</pre>

<p>
结果是错误的，没有累加输出：
</p>

<pre class="brush: bash">
Timed out! Will send result now
Total is 0
</pre>

<p>
问题在于再次调用<code>accumulate</code>方法时对<code>sum</code>产生了新的闭包，可以把<code>sum</code>放到外面作为
全局变量，但这样不够函数式。更加函数式的修改方案是把每次的结果作为参数：
</p>

<pre class="brush: scala; highlight:[6,8]">
import scala.actors._
import Actor._ 

val caller = self

def accumulate(sum : Int) {
  reactWithin(500) {
    case number: Int =&gt; accumulate(sum + number)
    case TIMEOUT =&gt; 
      println("Timed out! Will send result now")
      caller ! sum
  }
  println("This will not be called...")
}

val accumulator = actor { accumulate(0) }
accumulator ! 1
accumulator ! 7
accumulator ! 8

receiveWithin(10000) { case result =&gt; println("Total is " + result) }
</pre>

<p>
这次得到了正确的结果：
</p>

<pre class="brush: bash">
Timed out! Will send result now
Total is 16
</pre>

<h3 id="toc_2.7.3">loop与loopWhile</h3>

<p>
由于通过<code>react</code>重用线程的方案非常普遍，所以actor库对此有特别的支持。<code>actor.loop</code>
函数重复执行一个代码块，哪怕代码调用的是<code>react</code>。下面用<code>loop</code>来重写
<code>NameResolver</code>的<code>act</code>方法。下面的例子与前一个例子不同的地方是它并不退出来响应
<code>"EXIT"</code>消息，而是一直循环响应消息：
</p>

<pre class="brush: scala">
  def act() { 
    loop {
      react {
        case (name: String, actor: Actor) =&gt;
          actor ! getIp(name)
        case msg =&gt;
          println("Unhandled message: " + msg)
      }
    }
  }
</pre>

<p>
还有带循环条件的版本<code>loopWhile(...)</code>。
</p>

<pre class="brush: scala">
loopWhile(count &lt; max) {
	react {
		...
	}
}
</pre>

<p>
还有<code>eventloop()</code>方法可以制作聘个无穷循套环<code>react()</code>的简化版本，不过前提是偏函数
不会再次调用<code>react</code>：
</p>

<pre class="brush: scala">
def act() {
	eventloop {
		case Withdraw(amount) =&gt; println("Withdrawing " + amount)
	}
}
</pre>

<pre class="brush: scala">
</pre>

<pre class="brush: scala">
</pre>

<h2 id="toc_2.8">控制线程执行</h2>

<p>
Scala会让单例对象<code>Scheduler</code>去运行actor，通过设置<code>Scheduler.impl</code>的各种实现，
可以整个应用的actor的调度策略。
</p>

<p>
通过下面的例子<code>SingleThreadedScheduler</code>可以控制Scala在主线程里运行actor:
</p>

<pre class="brush: scala">
import scala.Actor._
import scala.actors._
import scheduler._

if (args.length &gt; 0 &amp;&amp; args(0) == "Single") {
  println("Command-line argument Single found")
  Scheduler.impl = new SingleThreadedScheduler
}
println("Main running in " + Thread.currentThread)

actor { println("Actor1 running in " + Thread.currentThread) }
actor { println("Actor2 running in " + Thread.currentThread) }

receiveWithin(3000) { case _ =&gt; }
</pre>

<p>
如果没有参数，两个actor和主线程会分别执行：
</p>

<pre class="brush: bash">
$ scala InMainThread.scala
Main running in Thread[main,5,main]
Actor1 running in Thread[ForkJoinPool-1-worker-5,5,main]
Actor2 running in Thread[ForkJoinPool-1-worker-5,5,main]
</pre>

<p>
如果加上参数，会在同一线程中执行：
</p>

<pre class="brush: bash">
$ scala InMainThread.scala Single
Command-line argument Single found
Main running in Thread[main,5,main]
Actor1 running in Thread[main,5,main]
Actor2 running in Thread[main,5,main]
</pre>

<p>
上面是例子配置的两个应用的线程调度。其实通过继承<code>Actor</code>特质时改写<code>scheduler()</code>
方法还可以更加细粒度地控制具体actor是在主线程，一部分在新线程中。
</p>

<pre class="brush: scala; highlight: [6]">
import scala.Actor._
import scala.actors._
import scheduler._

trait SingleThreadedActor extends Actor {
  override def scheduler() = new SingleThreadedScheduler
}

class MyActor1 extends Actor {
  def act() = println("Actor1 running in " + Thread.currentThread)
}
                      
class MyActor2 extends SingleThreadedActor {                     
  def act() = println("Actor2 running in " + Thread.currentThread)
}                                                      

println("Main running in " + Thread.currentThread)
new MyActor1().start()
new MyActor2().start()
actor { println("Actor3 running in " + Thread.currentThread) }

receiveWithin(5000) { case _ =&gt; }
</pre>

<p>
可以看到主线程与fork出的线程：
</p>

<pre class="brush: scala">
$ scala InMainThreadSelective.scala
Main running in Thread[main,5,main]
Actor1 running in Thread[ForkJoinPool-1-worker-5,5,main]
Actor2 running in Thread[main,5,main]
Actor 3 running in Thread[ForkJoinPool-2-worker-7,5,main]
</pre>




<h2 id="toc_2.9">消息通道</h2>

<p>
除了共享Actor的引用，还可以通过共享消息通道的方式。消息通道有以下优点：
</p>

<ul>
<li>
消息通道是类型安全的，只能发送或接受某个特定类型的消息。

<li>
防止调用到某个Actor的方法。

</ul>

<p>
消息通道可以是一个OutputChannel特质（带有<code>!</code>方法）或是一个InputChannel特技（带有
<code>receive</code>或<code>react</code>方法）。也可以有<code>Channel</code>特质同时扩展这两个特质。
</p>

<p>
消息通道的构造函数需要一个Actor作为参数：
</p>

<pre class="brush: scala">
val channel - new Channel[Int](someActor)
</pre>

<p>
如果不提供参数，那就是绑定到当前执行的Actor上。
</p>

<p>
通常，会指定Actor发送消息到一个输出消息通道：
</p>

<pre class="brush: scala; highlight: [44]">
import scala.actors._
import scala.actors.Actor._

case class Compute(data: Seq[Int], result: Channel[Int])

class PrimeCounter extends Actor {
  def isPrime(n: Int) = new java.math.BigInteger("" + n).isProbablePrime(20)

  def act() {
    while (true) {
      receive {
        case Compute(data, continuation) =&gt; {
          val answer = data.count(isPrime)
          continuation ! answer // Send the answer to the channel
        }
      }
    }
  }

}

object Main extends App {
  val max = 100000 
  // try with 1000000 
  val nactors = 10
  val groupSize = max / nactors / 10

  val primeCounters = for (i &lt;- 0 until nactors) yield new PrimeCounter
  for (a &lt;- primeCounters) a.start()

  actor {
    val c = new Channel[Int] // A channel to this actor
    
    val groups = (2 to max).grouped(groupSize).zipWithIndex.toSeq
    var count = groups.length
    var total = 0

    for ((g, i) &lt;- groups)  {
      val a = primeCounters(i % primeCounters.length)
      a ! Compute(g, c) // a is an actor, not a channel
    }

    while (count &gt; 0) {
      c.receive { 
        case t =&gt; { // The channel receives an Int
          total += t
          count -= 1
        }
      }
    }
    println(total + " primes")
    System.exit(0)
  }
}
</pre>

<p>
注意这里调用的是消息通道的<code>receive()</code>方法而不是Actor自己的。如果要通过Actor来
接收，可以匹配一个<code>!</code>样本类：
</p>

<pre class="brush: scala">
receive {
	case !(channel, x) =&gt; ...
}
</pre>

<h2 id="toc_2.10">Actor的生命周期</h2>

<p>
Actor的<code>act()</code>方法在<code>start()</code>方法被调用时开始执行。然后通常情况下都是进入某个
循环：
</p>

<pre class="brush: scala">
def act() {
	while (...) {
		receive {
			...
		}
	}
}
</pre>

<p>
会让Actor终止的情况：
</p>

<ol>
<li>
<code>act()</code>方法返回。

<li>
<code>act()</code>方法因异常终止。

<li>
<code>actor</code>调用<code>exit()</code>方法。

</ol>

<h3 id="toc_2.10.1">exit()方法停止actor</h3>

<p>
<code>exit()</code>方法是一个受保护的方法，只能被<code>Actor</code>的子类调用。<code>exit()</code>方法会抛出异常
，以试图停止当前线程的方式停止actor。它还有一个版本接收一个参数作为退出原因：
</p>

<pre class="brush: scala; highlight:[8]">
import scala.actors._
import Actor._

class MyAct extends Actor {
    def act() {
        while (true) {
            receive {
                case "quit" =&gt; exit
                case msg    =&gt; println(msg)
            }
        }
    }
}

val myAct = new MyAct

myAct.start()

myAct ! "Hello World!" 
myAct ! "nice Day!" 
myAct ! "quit" 
</pre>

<p>
如果不带原因，那就相当于<code>exit('normal)</code>。
</p>


<h3 id="toc_2.10.2">因为异常停止</h3>

<p>
如果因为异常终止，退出原因就是<code>UncaughtException</code>样本类的一个实例。它有以下属性
：
</p>

<ul>
<li>
actor：抛出异常的Actor。

<li>
message：<code>Some(msg)</code>，其中的<code>msg</code>就是该Actor处理的最后一条消息；或为<code>None</code>，
  表示Actor在没有来得及处理任何消息时就挂掉了。

<li>
sender：<code>Some(channel)</code>，最后一条消息发送方的输出通道；为<code>None</code>表示Actor在没有
  来得及处理任何消息时就挂掉了。

<li>
thread：退出时所在的线程。

<li>
cause：相应的异常。

</ul>

<p>
默认情况下所有末处理的异常都会造成一个<code>UncaughtException</code>原因的退出。必要时可以
重写<code>exceptionHandler()</code>方法来改变这个行为，它应该产出一个偏函数，类型为：
</p>

<pre class="brush: scala">
PartialFunction[Exception, Unit]
</pre>

<p>
这样如果这个偏函数有效就被调用，Actor以<code>'normal</code>原因退出。
</p>

<p>
例如在需要不把非受检异常当作非正常的话，可以提供以下处理器：
</p>

<pre class="brush: scala">
override def exceptionHandler = {
	case e: RuntimeException =&gt; log(e)
}
</pre>

<h2 id="toc_2.11">链接多个Actor</h2>

<p>
通过<code>link()</code>方法链接多个Actor可以在一个Actor终止得通知另一个：
</p>

<pre class="brush: scala">
def act() {
	link(master)
	...
</pre>

<p>
链接是双向的，一个终止会通知另外一个。但是并不是对称的，比如上面的：
</p>

<pre class="brush: scala">
link(master)
</pre>

<p>
并不能用：
</p>

<pre class="brush: scala">
master.link(self)
</pre>

<p>
来代替。<code>link()</code>方法必须由请求链接的Actor调用。
</p>

<p>
默认情况下，只要链接到的Actor中有一个以非<code>'normal</code>原因退出，当前Actor就会终止。
退出的原因和链接到的那个Actor一样。
</p>

<p>
要改变这一行为的方法是设置<code>trapExit</code>为<code>true</code>。这样Acotr会收到一个类型为<code>Exit</code>的
消息，包含了终止的Actor和退出的原因：
</p>

<pre class="brush: scala">
override def act() {
	trapExit = true
	link(worker)
	while(...) {
		recieve {
			...
			case Exit(linked, UncaughtException(_, _, _, _, cause)) =&gt; ...
			case Exit(linked, reason) =&gt; ...
		}
	}
}
</pre>

<p>
让Actor挂掉是很正常的，但要连接到一个监管它的Actor来处理失败的处理方案，如：重新
分配工作、或是重启。
</p>

<p>
在大型的系统中，可以给Actor分成多个区域，各区域安排一个监管的actor。
</p>

<p>
对于已经终止的Actor，它们依然保留内部状态与邮箱。可以用它的<code>restart()</code>方法重新
启动。在这样做之前，可能会想要修复内部状态或设置一个标志来表示这个Actor正在以
修复模式运行。另外还需要重新建立链接，因为终止时连接也被移除了。
</p>




<h2 id="toc_2.12">良好的actor风格</h2>

<h3 id="toc_2.12.1">actor不应该阻塞</h3>

<p>
当一个阻塞时，另一个actor可以会发出别的请求。多个actor等一个阻塞的actor会带来
死锁。actor应该允许某种表示动作可以执行的消息发送给它。通常这样要安排其他的actor
帮助。例如通过调用<code>Thread.sleep</code>代替并阻塞当前的actor，可以创建一个助手actor，
这个actor睡眠并在一定时间后发加一个消息：
</p>

<pre class="brush: scala">
  actor {
    Thread.sleep(time)
    mainActor ! "WAKEUP"
  } 
</pre>

<p>
这个助手actor虽然阻塞了，但是由于它不会收到消息，所以这是OK的。主actor可以继续
响应新的请求。
</p>


<p>
下面的<code>emoteLater</code>方法展示了这种处理方式的用法。它创建了一个新的actor来执行
<code>sleep</code>以便主actor不阻塞。以确保它向正确的actor发送<code>"Emote"</code>消息，我们必须小心地
在主actor中对<code>self</code>求值而不是在助手actor中：
</p>

<pre class="brush: scala">
  val sillyActor2 = actor {
    def emoteLater() {
      val mainActor = self
      actor {
        Thread.sleep(1000)
        mainActor ! "Emote"
      }
    }
 
    var emoted = 0
    emoteLater()

    loop {
      react {
        case "Emote" =&gt;
          println("I'm acting!")
          emoted += 1
          if (emoted &lt; 5)
            emoteLater()
        case msg =&gt;
          println("Received: "+ msg)
      }
    }
  }
</pre>

<p>
由于这个actor并不在<code>sleep</code>方法中阻塞，而是助手actor阻塞，所以主actor可以在等待
下次表演前继续做其他的事情。与早先的<code>SillyActor</code>不同，这个actor会在等待下一个
输出的同时继续打印消息：
</p>

<pre class="brush: scala">
  scala&gt; sillyActor2 ! "hi there"
  scala&gt; Received: hi there
  I'm acting!
  I'm acting!
  I'm acting!
</pre>

<h3 id="toc_2.12.2">只通过消息与actor通信</h3>

<p>
Scala可以混用actor模式与共享数据／锁模式两种方式。但第二种方式有锁死线程和线程
不安全变量的风险。
</p>


<h3 id="toc_2.12.3">不要调用Actor的方法</h3>

<p>
如果调用了Actor的方法那就等于引入所有传统并发的同步问题。
</p>

<h3 id="toc_2.12.4">优选不可变消息</h3>

<p>
虽然actor模式对于线程来说数据是不共享的，但还是有共享数据的情况：就是消息会在
多个actor中传递，如果传递过程中被改变的话是被谁改的都不知道。
</p>

<p>
而且下面会说到，有些消息会有一个指向自己的引用。所以尽量使用不可变的消息。
</p>

<h3 id="toc_2.12.5">让消息自包含</h3>

<p>
因为actor是非阻塞的，发出一个请求不等响应就做别的事情的。等响应回来都不知道是
响应哪个请求的。所以一个简单的方案是以发出的消息里包含与请求相关的冗余信息。
</p>

<p>
如果请求是一个不可变的对象，花费代价很少的一个方案是在返回值中包含一个指向请求
自己的引用。这样就知道响应是对应哪个请求的了。
</p>

<p>
举例，IP查询功能的actor在返回IP时带一个当时请求的主机名该有多好：
</p>

<pre class="brush: scala">
 def act() { 
   loop {
     react {
       case (name: String, actor: Actor) =&gt;
         actor ! (name, getIp(name))
     }
   }
 }
</pre>

<p>
另一个增加冗余的方案是为每类消息制作样本类。比如当字符串看起来意义不是很明确：
</p>

<pre class="brush: scala">
  lookerUpper ! ("www.scala-lang.org", self)
</pre>

<p>
但有了类型名字看起来就好理解多了：
</p>

<pre class="brush: scala">
  case class LookupIP(hostname: String, requester: Actor)

  lookerUpper ! LookupIP("www.scala-lang.org", self)
</pre>

<p>
下面是使用样本类而不是简单的元组来查询IP的程序：
</p>

<pre class="brush: scala">
  import scala.actors.Actor._
  import java.net.{InetAddress, UnknownHostException}

  case class LookupIP(name: String, respondTo: Actor)
  case class LookupResult(
    name: String, 
    address: Option[InetAddress]
  )

  object NameResolver2 extends Actor {

    def act() { 
      loop {
        react {
          case LookupIP(name, actor) =&gt;
            actor ! LookupResult(name, getIp(name))
        }
      }
    }

    def getIp(name: String): Option[InetAddress] = {
      // As before (in Listing 30.3)
    }
  }
</pre>


<h3 id="toc_2.12.6">最小化回复</h3>

<p>
Actor的目的不是远程调用，任务应该被分发到一个Actor组成的网网络。每个Actor算出
部分答案，发给一个知道如何合并出全部答案的Actor。
</p>


<h3 id="toc_2.12.7">监管Actor的终止</h3>

<p>
Actor会终止是正常的。在大型的系统中，可以给Actor分成多个区域，各区域安排一个监管
的actor。
</p>




<h2 id="toc_2.13">更加长的例子：并行离散事件模拟</h2>

<p>
把“有状态对象”一章的电路模拟强化成并行化的。
</p>

<h3 id="toc_2.13.1">总体设计</h3>

<p>
核心思路是把每个模拟的对象都用actor，状态位于actor内部。这样实现并行性。
</p>

<p>
在类层级上，因为不同的模拟对象可能会有一些共通行为，所以抽象一个<code>Simulant</code>特质
出来。线路、门等都可以加上这个特质：
</p>

<pre class="brush: scala">
  trait Simulant extends Actor
  class Wire extends Simulant
</pre>

<p>
时间同步问题：每个参与者都自己的任务列表顺序而不看任务的时间处理任务的话，可能
参与者A正在处理时间点90秒的任务；参与者B已经在处理时间点100的任务。A的任务要与
B的任务协作时就有问题。所以要同步，任何参与者都不应该当其他参与者完成时间位于
<code>n-1</code>的任务前，处理时间位于<code>n</code>的任务。
</p>

<p>
专门有一个actor来控制时钟，给模拟对象发出<code>ping</code>消息，模拟对象在准备好让钟走到下
一个时间单位时发出<code>pong</code>消息给时钟：
</p>

<pre class="brush: scala">
  case class Ping(time: Int)
  case class Pong(time: Int, from: Actor)
</pre>

<p>
这两个消息里可以没有字段，但这里的冗余是有好处的。<code>ping</code>里的<code>time</code>是为了回写到
<code>pong</code>的<code>time</code>里，知道对应成功的是哪个时间。
</p>

<p>
现在的原则是每个模拟对象在处理完了要完成的任务以后才会响应<code>ping</code>消息。但问题是
任务也可能是别的模拟对象要发给它的，所以当前任务做完了并不一定是真的做完了，
可能是其他模拟对象还没有把任务发过来。
</p>

<p>
为了简化这个问题，要再增加两个限制。首先，要假设模拟对象之间不直接发送消息，而
只是相互安排事件日程。其次，它们不向当前的时间点<code>n</code>提交事件，而是给<code>n+1</code>以上的
时间提交事件。虽然有点限制，但对于模拟的事件来说，有点时延还是可以接受的。
</p>

<p>
还有一个方案：模拟对象可以相互发消息，但是要精心设计一个机制来决定一个actor何时
可以安全地送回一个<code>Pong</code>。每个模拟对象都应该延迟响应<code>Ping</code>消息直到它发出的所有
请求都已经完成了处理。所以传递的消息要加一些额外的内容。
</p>

<p>
现在假定模拟对象之间不发直接消息，只发送事件日程表。这样还要有一个工作项的日程表
这个日程表也可能由时钟actor所持有。这样时钟actor就可以等到当前时间点所有工作项的
请求都发送完成后再发出<code>Ping</code>消息。Actor们知道收到<code>Ping</code>时就表示当前时间点所有的
工作项都已经拿到了，可以马上送回<code>Pong</code>，因为不会有更多的工作发过来了。时钟由类
<code>Clock</code>实现：
</p>

<pre class="brush: scala">
  class Clock extends Actor {
    private var running = false
    private var currentTime = 0
    private var agenda: List[WorkItem] = List()
  }
</pre>

<p>
最后要设计如何设置好一个初始模拟场景。一种自然的方式是在时钟停止的状态下创建模拟
，添加所有的模拟对象再连接在一起，然后启动时钟。注意一定要绝对确认所有的东西都
连接好了再启动时钟。
</p>

<p>
所以关键在于如何确定都已经连接好了，方案有很多。这里用最简单的方法是在设置过程中
不向actor发消息，这样当最后一个消息调用返回就知道模拟被完整地构建好了。最终的
编码模式是用常规的方法调用将模拟设置好，然后可以在模拟运行时使用actor发消息。
</p>

<p>
基本设计完成其他的就比较直接。<code>WorkItem</code>还是像“有状态对象”里实现的那样有一个时间
和一个动作成员，区别在动作模拟，老版本是用无参函数，在这里的并行版本中使用目标
actor和发往该actor的消息：
</p>

<pre class="brush: scala">
  case class WorkItem(time: Int, msg: Any, target: Actor)
</pre>

<p>
<code>afterDelay</code>方法变成了发往时钟的<code>AfterDelay</code>消息。无参函数被替换成了一个消息和
一个目标actor：
</p>

<pre class="brush: scala">
  case class AfterDelay(delay: Int, msg: Any, target: Actor)
</pre>

<p>
定义要求模拟启动和停止的消息：
</p>

<pre class="brush: scala">
  case object Start
  case object Stop
</pre>

<p>
总体设计就是这样，时钟<code>Clock</code>有当前时间和日程表，它只会在<code>Ping</code>了所有模拟对象并
确保它们准备好了以后才往前进。<code>Simulant</code>特质来模拟参与者，它们所代表的参与者们
通过向时钟发送工作项增加到日程表的方式来和其他参与者们通信。
</p>

<h3 id="toc_2.13.2">实现模拟架构</h3>

<p>
<code>Clock</code>类的<code>running</code>初始为<code>false</code>。模拟初始化全都完成以后，会发<code>Start</code>消息给它，
才会变成<code>true</code>。保证初始化完成以后才会运行：
</p>

<pre class="brush: scala">
  class Clock extends Actor {
    private var running = false
    private var currentTime = 0
    private var agenda: List[WorkItem] = List()
    private var allSimulants: List[Actor] = List()
    private var busySimulants: Set[Actor] = Set.empty
</pre>

<p>
时钟可以在创建后后马上调用<code>start()</code>方法，因为<code>running</code>还是<code>false</code>。所以不会真的
运行：
</p>

<pre class="brush: scala">
  start()
</pre>

<p>
<code>allSimulants</code>是所有模拟对象，不会变所以用列表；<code>busySimulants</code>是正有任务的，会
不断添加删除所以用集。一旦模拟器开始运行，它只有当<code>busySimulants</code>为空时才会进入
下一个时间单位，并把<code>allSimulants</code>的成员全放到<code>busySimulants</code>里：
</p>

<pre class="brush: scala">
  def add(sim: Simulant) {
    allSimulants = sim :: allSimulants
  }
</pre>

<p>
以上是时钟状态的描述，再来看时钟活动。它的主循环由两个职责交替：让时钟前进、响应
消息。一旦时间　前进，它只能在至少收到一个消息时才会再次前进，所以把主循环定义为
这两个活动交替是安全的：
</p>

<pre class="brush: scala">
  def act() {
    loop {
      if (running &amp;&amp; busySimulants.isEmpty)
        advance()

      reactToOneMessage()
    }
  }
</pre>

<p>
时间的推进除了简单地<code>currentTime</code>步进之外还有些额外的工作：
</p>

<p>
首先，如果日程表是空的而且模拟不是刚刚开始，那么模拟需要退出。
</p>

<p>
其次，如果日程表非空，则当前时间点所有的工作需要现在进行。
</p>

<p>
再次，所有的模拟对象要放到<code>busySimulant</code>中，并发<code>Ping</code>消息给它们。等它们全响应
之后才能再次推进时间。
</p>

<pre class="brush: scala">
  def advance() {
    if (agenda.isEmpty &amp;&amp; currentTime &gt; 0) {
      println("** Agenda empty.  Clock exiting at time "+
              currentTime+".")
      self ! Stop
      return
    }
      
    currentTime += 1
    println("Advancing to time "+currentTime)

    processCurrentEvents()
    for (sim &lt;- allSimulants)
      sim ! Ping(currentTime)
      
    busySimulants = Set.empty ++ allSimulants
  }
</pre>

<p>
处理当前事件只示过是简单地处理所有在日程表最上方时间为<code>currentTime</code>的事件：
</p>

<pre class="brush: scala">
  private def processCurrentEvents() {
    val todoNow = agenda.takeWhile(_.time &lt;= currentTime)

    agenda = agenda.drop(todoNow.length)

    for (WorkItem(time, msg, target) &lt;- todoNow) {
      assert(time == currentTime)
      target ! msg
    }
  }
</pre>

<p>
上面的方法有三步：首先，<code>takeWile</code>取出所有当前时间的条目存入<code>todoNow</code>。然后，用
<code>drop</code>从日程表中去掉这些。最后遍历这些条目并向它们的发送目标消息。<code>assert</code>是为了
确保排程器的逻辑没有问题。
</p>

<p>
有了这些基础工作，处理时间可能收到的消息就会很简单。<code>AfterDelay</code>消息把新的条目
添加到工作队列；<code>Pong</code>消息从忙碌列表中去掉一个；<code>Start</code>让模拟开始；<code>Stop</code>让时钟
停止：
</p>

<pre class="brush: scala">
  def reactToOneMessage() {
    react {
      case AfterDelay(delay, msg, target) =&gt;
        val item = WorkItem(currentTime + delay, msg, target)
        agenda = insert(agenda, item)

      case Pong(time, sim) =&gt;
        assert(time == currentTime)
        assert(busySimulants contains sim)
        busySimulants -= sim
          
      case Start =&gt; running = true

      case Stop =&gt;
        for (sim &lt;- allSimulants)
          sim ! Stop
        exit()
    }
  }
</pre>

<p>
<code>insert</code>方法和老版本的一样，就不列出来了。它把条目加入日程表并保证顺序正确。
</p>

<p>
时钟类到这里实现完毕，现在来看模拟特质。本质上说一个<code>Simulant</code>可以是理解模拟消息
<code>Stop</code>和<code>Ping</code>并与它们合作的任何actor。其<code>act</code>方法简单这样实现：
</p>

<pre class="brush: scala">
  def act() {
    loop {
      react {
        case Stop =&gt; exit()
        case Ping(time) =&gt;
          if (time == 1) simStarting()
          clock ! Pong(time, self)
        case msg =&gt; handleSimMessage(msg)
      }
    }
  }
</pre>

<p>
每当收到<code>Stop</code>，它就退出；收到<code>Ping</code>就响应一个<code>Pong</code>；如果<code>Ping</code>的时间为<code>1</code>，则
在返回<code>Pong</code>前调用<code>simStarting</code>让子类可以定义当模拟开始运行时应该发生的行为。
其他的所有消息都由子类来翻译，给抽象方法<code>handleSimMessage</code>方法。
</p>

<p>
还有一个抽象成员<code>clock</code>记录时钟以回复<code>Ping</code>消息并安排新的工作项。由于在时钟发
消息来以前不会做任何事情，所以可以在对象创建以后马上运行：
</p>

<pre class="brush: scala">
  trait Simulant extends Actor {
    val clock: Clock
    def handleSimMessage(msg: Any)
    def simStarting() { }
    def act() {
      loop {
        react {
          case Stop =&gt; exit()
          case Ping(time) =&gt;
            if (time == 1) simStarting()
            clock ! Pong(time, self)
          case msg =&gt; handleSimMessage(msg)
        }
      }
    }
    start()
  }
</pre>

<h3 id="toc_2.13.3">实现一个电路模拟</h3>

<p>
电路类<code>Circuit</code>：
</p>

<pre class="brush: scala">
  class Circuit {
    val clock = new Clock
    // 模拟消息
    // 延时常量
    // Wire 类和 Gate 类的方法
    // 其他工具方法
  }
</pre>

<p>
模拟消息这块：一旦模拟开始运行，线路和门就只能通过发消息通信，所以要对每一种信息
定义一个消息类型。这样消息只有两种：门要告诉线路改输出状态，线路要告诉门输入状态
改了：
</p>

<pre class="brush: scala">
  case class SetSignal(sig: Boolean)
  case class SignalChanged(wire: Wire, sig: Boolean)
</pre>

<p>
电路是有时间延迟的，不过这个值不确定，就先用个<code>val</code>放着吧：
</p>

<pre class="brush: scala">
  val WireDelay = 1
  val InverterDelay = 2
  val OrGateDelay = 3
  val AndGateDelay = 3
</pre>

<p>
<code>Wire</code>和<code>Gate</code>类。线路记录当前的信号状态并观察门的列表的模拟对象。因为混入了
<code>Simulant</code>特质所以也需要指定一个时间：
</p>

<pre class="brush: scala">
  class Wire(name: String, init: Boolean) extends Simulant {
    def this(name: String) { this(name, false) }
    def this() { this("unnamed") }

    val clock = Circuit.this.clock
    clock.add(this)

    private var sigVal = init
    private var observers: List[Actor] = List()
</pre>

<p>
<code>handleSimMessage</code>方法来处理收到的消息。线路只会收到<code>SetSignal</code>消息设定信号，
注意只有新的信号与当前的信号不同时会改变状态并发出消息通知别的模拟对象：
</p>

<pre class="brush: scala">
  def handleSimMessage(msg: Any) {
    msg match {
      case SetSignal(s) =&gt;
        if (s != sigVal) {
          sigVal = s
          signalObservers()
        }
    }
  }
    
  def signalObservers() {
    for (obs &lt;- observers)
      clock ! AfterDelay(
        WireDelay,
        SignalChanged(this, sigVal),
        obs)
  }
</pre>

<p>
上面的代码中将线路初始状态传给任何作为观察者的门也很重要。这个动作只在初始化时做
一次，以后只收改变信号的消息。模拟开始的发送初始信号也只要简单地提供一个
<code>simStarting()</code>方法：
</p>

<pre class="brush: scala">
  override def simStarting() { signalObservers() }
</pre>

<p>
还有怎么连接门的问题。用一个新的方法来连接门，并加上一个<code>toString</code>方法:
</p>

<pre class="brush: scala">
  def addObserver(obs: Actor) {
    observers = obs :: observers
  }

  override def toString = "Wire("+ name +")"
</pre>

<p>
线路的实现完成，现在再来看门。与门和或门有两个输入而非门只有一个输入，为了代码
简单那就设定所有的门都有两个入口而非门会忽视第二个入口。被忽视的可以设为某个永远
为<code>false</code>的线路：
</p>

<pre class="brush: scala">
  private object DummyWire extends Wire("dummy")
</pre>

<p>
通用的门超类：
</p>

<pre class="brush: scala">
  abstract class Gate(in1: Wire, in2: Wire, out: Wire)
      extends Simulant {
</pre>

<p>
抽象方法算出输出信号：
</p>

<pre class="brush: scala">
  def computeOutput(s1: Boolean, s2: Boolean): Boolean
</pre>

<p>
不同的门有不同的延迟：
</p>

<pre class="brush: scala">
  val delay: Int
</pre>

<p>
时钟可以在创建好后马上加上：
</p>

<pre class="brush: scala">
  val clock = Circuit.this.clock
  clock.add(this)
</pre>

<p>
连接两个线路作为输入连上门：
</p>

<pre class="brush: scala">
  in1.addObserver(this)
  in2.addObserver(this)
</pre>

<p>
门唯一的本地状态就是它每一输入线路最近一次信号。这个状态要保存，因为线路只会在
状态变化时才发信号，而输出信号要两个线路的信号一起才能算出来：
</p>

<pre class="brush: scala">
  var s1, s2 = false
</pre>

<p>
响应消息是在收到输入线路信号变化时重新算输出信号，并用<code>SetSignal</code>发消息给输出
线路：
</p>

<pre class="brush: scala">
  def handleSimMessage(msg: Any) {
    msg match {
      case SignalChanged(w, sig) =&gt;
        if (w == in1)
          s1 = sig
        if (w == in2)
          s2 = sig
        clock ! AfterDelay(delay,
            SetSignal(computeOutput(s1, s2)),
            out)
    }
  }
</pre>

<p>
具体的门实现就简单了：
</p>

<pre class="brush: scala">
  def orGate(in1: Wire, in2: Wire, output: Wire) = 
    new Gate(in1, in2, output) {
      val delay = OrGateDelay
      def computeOutput(s1: Boolean, s2: Boolean) = s1 || s2 
    }
  
  def andGate(in1: Wire, in2: Wire, output: Wire) = 
    new Gate(in1, in2, output) {
      val delay = AndGateDelay
      def computeOutput(s1: Boolean, s2: Boolean) = s1 &amp;&amp; s2 
    }
</pre>

<p>
非门有一个假的输入：
</p>

<pre class="brush: scala">
  def inverter(input: Wire, output: Wire) = 
    new Gate(input, DummyWire, output) {
      val delay = InverterDelay
      def computeOutput(s1: Boolean, ignored: Boolean) = !s1
    }
</pre>

<p>
模拟电路的功能已经完成了。但增加一个查看器观察线路的变化还是有必要的。定义一个
接收<code>Wire</code>类作为参数的并输出文本的<code>probe</code>方法。这个方法可以简单地制作一个新把
自己连接到指定线路和模拟对象来实现。这个模拟对象可以通过打印出新的信号来响应
<code>SignalChanged</code>消息：
</p>

<pre class="brush: scala">
  def probe(wire: Wire) = new Simulant {
    val clock = Circuit.this.clock
    clock.add(this)
    wire.addObserver(this)
    def handleSimMessage(msg: Any) {
      msg match {
        case SignalChanged(w, s) =&gt;
           println("signal "+ w +" changed to "+ s)
      }
    }
  }
</pre>

<p>
这里基本上<code>Circuit</code>类就完成了。调用时创建一个<code>Circuit</code>类实例，和一组门电路，在
需要观察的线路上加上<code>prob</code>，开始模拟。启动模拟的方法只要向时钟发<code>Start</code>消息
就行：
</p>

<pre class="brush: scala">
  def start() { clock ! Start }
</pre>

<p>
和前面非并行的版本不同我们把半加器和全加器包装成了<code>Adders</code>特质。由于继承自
<code>Circuit</code>所以它可以访问<code>Circuit</code>的成员如<code>Wire</code>和<code>orGate</code>：
</p>

<pre class="brush: scala">
  trait Adders extends Circuit {
    def halfAdder(a: Wire, b: Wire, s: Wire, c: Wire) {
      val d, e = new Wire
      orGate(a, b, d)
      andGate(a, b, c)
      inverter(c, e)
      andGate(d, e, s)
    }

    def fullAdder(a: Wire, b: Wire, cin: Wire,
        sum: Wire, cout: Wire) {
      val s, c1, c2 = new Wire
      halfAdder(a, cin, s, c1)
      halfAdder(b, s, sum, c2)
      orGate(c1, c2, cout)
    }
  }


  val circuit = new Circuit with Adders
</pre>

<p>
上面最后一行的<code>circuit</code>变量保存了拥有所有<code>Circuit</code>方法和所有<code>Adders</code>方法的电路。
这就是通过特质而不是用类来组合逻辑的强大之处。可以混入任何想要用的组件：
</p>

<pre class="brush: scala">
  val circuit =
    new Circuit 
      with Adders 
      with Multiplexers
      with FlipFlops
      with MultiCoreProcessors
</pre>

<h3 id="toc_2.13.4">把所有内容结合在一起</h3>

<p>
一切大功告成。简单地演示如下：
</p>

<pre class="brush: scala">
  object Demo {
    def main(args: Array[String]) {
      val circuit = new Circuit with Adders
      import circuit._

      val ain = new Wire("ain", true)
      val bin = new Wire("bin", false)
      val cin = new Wire("cin", true)
      val sout = new Wire("sout")
      val cout = new Wire("cout")

      probe(ain)
      probe(bin)
      probe(cin)
      probe(sout)
      probe(cout)
    
      fullAdder(ain, bin, cin, sout, cout)

      circuit.start()
    }
  }
</pre>

<p>
这里<code>import</code>了所有成员，所以可以把<code>circuit.probe(ain)</code>简写成<code>probe(ain)</code>。
</p>

<p>
创建了两条输出<code>sout</code>、<code>cout</code>。还创建了三条输入线路：<code>ain</code>初始化为<code>true</code>、<code>bin</code>
初始化为<code>false</code>、<code>cin</code>初始化为<code>true</code>。意思是给数值<code>0</code>加<code>1</code>，并带入一个进位<code>1</code>。
</p>

<p>
五条线路上都有<code>probe</code>观测。把线路加到全加器中，模拟开始，输出如下：
</p>

<pre class="brush: scala">
  Advancing to time 1
  Advancing to time 2
  signal Wire(cout) changed to false
  signal Wire(cin) changed to true
  signal Wire(ain) changed to true
  signal Wire(sout) changed to false
  signal Wire(bin) changed to false
  Advancing to time 3
  Advancing to time 4
  Advancing to time 5
  Advancing to time 6
  Advancing to time 7
  Advancing to time 8
  Advancing to time 9
  Advancing to time 10
  signal Wire(cout) changed to true
  Advancing to time 11
  Advancing to time 12
  Advancing to time 13
  Advancing to time 14
  Advancing to time 15
  Advancing to time 16
  Advancing to time 17
  Advancing to time 18
  signal Wire(sout) changed to true
  Advancing to time 19
  Advancing to time 20
  Advancing to time 21
  signal Wire(sout) changed to false
  ** Agenda empty.  Clock exiting at time 21.
</pre>

<p>
对于输入<code>1,0,1</code>输出进位<code>1</code>和为<code>0</code>。
</p>





<h1 id="toc_3">定界延续</h1>

<h2 id="toc_3.1">捕获并执行延续</h2>

<p>
延续可以让程序回到之间的一个位置上。比如IO操作异常时发现文件不存在：
</p>

<pre class="brush: scala">
contents = scala.io.Souce.fromFile(filename, "UTF-8").mkString
</pre>

<p>
可以通过延续回到失败点然后重试。
</p>

<p>
要实现这一效果，首先要通过<code>shift</code>结构捕获一个延续，然后指定对这个捕获到的延续
进行什么操作。比如说，把这个延续保存下来：
</p>

<pre class="brush: scala">
var cont: (Unit =&gt; Unit) = null
...
shift { k: (Unit =&gt; Unit) =&gt; // 延续被传递给了shift
	cont = k // 保存下来备用
}
</pre>

<p>
这里用到的延续是一个不带参数也不带返回值的函数（严格地说，参数和返回值都是<code>Unit</code>
类型），以后会看到有带参数和返回值的延续。
</p>

<p>
以后要回到<code>shift</code>这个位置，需要执行这个延续：做法就是简单地调用<code>cont</code>。
</p>

<h2 id="toc_3.2">定界</h2>

<p>
在Scala中，延续是定界的：它只能延展到指定的边界。这个边界由<code>reset {...}</code>标出：
</p>

<pre class="brush: scala">
reset {
	...
	shift { k: (Unit =&gt; Unit) =&gt;
		count = k
	} // 对count的调用将从这里开始
	...
}   // 到这里结束
</pre>

<p>
当调用<code>count</code>时，执行将从<code>shift</code>处开始，蒋一直延展到<code>reset</code>块的边界。
</p>

<p>
例子，读一个文件并捕获延续：
</p>

<pre class="brush: scala">
import scala.util.continuations._

object Main extends App {
  var cont : (Unit =&gt; Unit) = null  
  var filename = "myfile.txt"
  var contents = ""

  reset {
    while (contents == "") {
      try {
        contents = scala.io.Source.fromFile(filename, "UTF-8").mkString
      } catch { case _ =&gt; }
      shift { k : (Unit =&gt; Unit) =&gt; 
        cont = k 
      }
    }
  }
  
	// 如果要重试的话，只要执行延续即可：
  if (contents == "") {
    println("Try another filename: ");
    filename = readLine
    cont()
  }
  println(contents)
}
</pre>

<p>
在Scala 2.9中，要启动延续插件才可以编译使用了延续的程序：
</p>

<pre class="brush: scala">
scalac -P:continuations:enable Continuations.scala
</pre>


<h2 id="toc_3.3">延续捕获的原理</h2>

<p>
可以把<code>shift</code>块想象成一个位于<code>reset</code>块中的空位。当执行延续时可以把一个值传到这个
空位里，运算继续，就好像<code>shift</code>本身就是哪个值一样。
</p>

<p>
例如：
</p>

<pre class="brush: scala">
  var cont : (Int =&gt; Double) = null  
  reset {
    0.5 * shift { k: (Int =&gt; Double) =&gt; { cont = k } } + 1
  }
</pre>

<p>
把整个<code>shift</code>替换成一个空位：
</p>

<pre class="brush: scala">
    0.5 * /* hole */ + 1
</pre>

<p>
当调用<code>cont(3)</code>时，这个位置被填上值<code>3</code>。
</p>

<p>
也就是说<code>cont</code>可以被看作这样一个函数：
</p>

<pre class="brush: scala">
x: Int =&gt; 0.5 * x + 1
</pre>

<p>
延续的类型为<code>Int =&gt; Double</code>，因为填入的类型为<code>Int</code>并计算出<code>Double</code>。
</p>

<h2 id="toc_3.4">reset和shift的控制流程</h2>

<pre class="brush: scala">
import scala.util.continuations._

object Main extends App {
  var cont : (Unit =&gt; Unit) = null  
  reset { 
    println("Before shift")
    shift { 
        k : (Unit =&gt; Unit) =&gt; { 
          cont = k 
          println("Inside shift")
        } 
    }
    println("After shift")
  }
  println("After reset")
  cont()
}
</pre>

<p>
执行的顺序：
</p>

<pre class="brush: scala">
Before shift  // reset执行时
Inside shift
After reset   // 退出reset块
After shift   // 调用cont时，执行跳回reset
</pre>

<p>
shift之前的代码不是延续的一部分。延续将从包含shift的表达式（该表达式会变成那个
空位）开始，一直延展到reset的末尾。以来例来说就是：
</p>

<pre class="brush: scala">
/* hole */ : Unit =&gt; /* hole */ ;
print("After shift")
</pre>

<p>
<code>cont()</code>方法参数为<code>Unit</code>，这里的空位只是简单地被替换成了<code>()</code>。
</p>

<p>
从这里可以看出，reset中的shift会立即跳出reset。当执行一个跳入reset的延续时，如果
再次遇到shift（在循环中的话会遇到同一个shift），它同样会立即跳出reset。函数调用
也会立即退出，返回shift的值。
</p>

<h2 id="toc_3.5">reset表达式的值</h2>

<p>
如果是因为执行了shift而退出了reset，那么得到的值就是shift的值：
</p>

<pre class="brush: scala">
val result1 = reset { shift { k: (String =&gt; String) =&gt; "Exit" }; "End" }
println(result1) // result is "Exit" 
</pre>

<p>
如果没有执行到shift而是reset执行到结尾，值就是reset块的值（即块中的最后一个
表达式）：
</p>

<pre class="brush: scala">
val result2 = reset { 
	if (false)
		shift { k: (String =&gt; String) =&gt; "Exit" };
	else
		"End" 
}
println(result2) // result is "End"
</pre>

<h2 id="toc_3.6">reset和shift表达式的类型</h2>

<p>
类型分别是<code>reset[B, C]</code>和<code>shift[A, B, C]</code>。可以这样看：
</p>

<pre class="brush: scala">
reset {

	// shift之前
	
	shift { k: (A =&gt; B) =&gt; // 由这里推断A与B

		// shift中 类型C

	} // shift代表的空位，类型为A

	// shift之后的部分，必须产出类型B的值

}
</pre>

<p>
如果reset块可能返回一个类型为B或C的值（由于分支或循环的原因），那么B必须是C的
子类型。
</p>

<p>
这里如果编译器无法正确判断类型，会引发错误。
</p>

<p>
正确的代码：
</p>

<pre class="brush: scala">
val result = reset { 
  if (scala.util.Random.nextBoolean()) {
    shift { 
      k: (String =&gt; String) =&gt; { // A与B都是String
        "Exit"                   // C是String
      }
    }                            // 空位的类型同是String
  } 
  else "End"                     // 和B一样是String
}
</pre>

<p>
错误的代码：
</p>

<pre class="brush: scala; highlight:[4]">
val result = reset { 
  if (scala.util.Random.nextBoolean()) {
    shift { 
      k: (Unit =&gt; Unit) =&gt; {     // A与B都是Unit
        "Exit"                   // C是String
      }
    }                            // 空位的类型同A一样是Unit
  } 
  else "End"                     // 错：应该和B一样是Unit，但这里是String
}
</pre>

<p>
提示：如果推断出的类型不符合期望，可以给reset与shift添加类型参数。如把延续类型
改为<code>Unit =&gt; Any</code>，并用<code>reset[Any, Any]</code>来让上面的代码通过编译。
</p>

<p>
当类型推断错误时报错信息可能会非常难以理解，很容易进入瞎改类型赶到能正确编译的
状态中。尽量不要这样做，仔细考虑延续发生时，希望的行为是什么。虽然说起来很抽象，
但是在解决实际问题时程序员应该知道当调用延续时想传入的类型与结果的类型。这样可
确定A与B的类型。再适当组织代码让C与B相等。这样无论reset是如何退出的都会产出B类型
。
</p>


<h2 id="toc_3.7">CPS注解</h2>

<p>
某些虚拟机中，延续实现方式是抓取运行时栈的快照，在调用延续时恢复。
</p>

<p>
JVM不允许这样的操作，所以Scala编译器对reset块中的代码进行了“延续传递风格”（CPS）
的变换。
</p>

<p>
经过CPS变换的方法与常规的Scala方法不一样，不能混用。所以如果一个普通的方法包含
了shift，就要加上注释。
</p>

<p>
更明确地说，reset和shift之间不能隔着方法，不然这个方法就要加上注释。如：
reset块里有一个或多个方法，方法里用shift块，那中间的方法就都要加上注释。
</p>

<p>
这样看起来很麻烦，但这些注解本来不是给开发应用的程序员用的，而是给设计类库的开发
人员设计特殊控制流程结构的。不应该让外部的人看到。
</p>

<p>
至于注解如何使用，联系之前说过shift方法的类型为<code>shift[A, B, C]</code>，则：
</p>

<ul>
<li>
使用注解时，要声明<code>@cpsParam(B, C)</code>。

<li>
如果<code>B</code>与<code>C</code>类型相同时可以用<code>@cps[B]</code>。

<li>
<code>@cps[Unit]</code>可以写为<code>@suspendable</code>。但还不如<code>@cps[Unit]</code>简洁明了，所以很少用。

</ul>

<p>
例，在一个循环读文件的方法中使用shift块必须要加CPS注解声明：
</p>

<pre class="brush: scala">
def tryRead(): Unit @cps[Unit] = {
  while (contents == "") {
    try {
      contents = scala.io.Source.fromFile(filename, "UTF-8").mkString
    } catch { case _ =&gt; }
    shift { k : (Unit =&gt; Unit) =&gt; 
      cont = k 
    }
  }
}
</pre>

<p>
注意：给方法添加注解时，必须指定返回类型，并且必须要加上<code>=</code>（哪怕是返回Unit），
这是注解语法的限制，与延续无关。
</p>


<h2 id="toc_3.8">把递归访问转为迭代</h2>

<p>
例，递归遍历树形结构，如目录下所有文件：
</p>

<pre class="brush: scala">
def processDirectory(dir: File) {
	val files = dir.listFiles
	for (f &lt;- files) {
		if (f.isDirectory)
			processDirectory(f)
		else
			println(f)
	}
}
</pre>

<p>
递归时不能控制在读到100个文件时跳出。但用延续就简单了：每读到一个文件就跳出递归
如果不满100个就再跳回去。实现方案是在需要中断的点放一个shift：
</p>

<pre class="brush: scala">
if (f.isDirectory)
	processDirectory(f)
else {
	shift {
		k: (Unit =&gt; Unit) =&gt; { cont = k }
	}
	println(f)
}
</pre>

<p>
这里的shit有两个作用：
</p>

<ol>
<li>
每当执行时跳到reset的末尾，还要捕获延续，这样以后才能跳回来。

<li>
把整个过程的启动点用reset包起来，然后就可以用需要的调用的次数来调用捕获到的
  延续了

</ol>

<pre class="brush: scala">
reset {
	processDirectory(new File(rootDirName))
}
for (i &lt;- 1 to 100) cont()
</pre>

<p>
还要加上CPS注解：
</p>

<pre class="brush: scala">
def processDirectory(dir : File) : Unit @cps[Unit]
</pre>

<p>
还有一个问题：for循环会被翻译成一个<code>foreach()</code>方法调用，这是一个没有被注解为
CPS变换的方法。只能用while循环来代替<code>foreach()</code>方法调：
</p>

<pre class="brush: scala">
var i = 0
while (i &lt; files.length) {
	val f = file(i)
	i += 1
	...
}
</pre>

<p>
完整的程序：
</p>

<pre class="brush: scala; highlight: [20, 22, 29, 30, 32]">
// Compile as scalac -P:continuations:enable PrintFiles.scala
import scala.util.continuations._
import java.io._

object PrintFiles extends App {

  var cont : (Unit =&gt; Unit) = null

  def processDirectory(dir : File) : Unit @cps[Unit] = {
    val files = dir.listFiles
    var i = 0
    while (i &lt; files.length) {
      val f = files(i)
      i += 1
      if (f.isDirectory)
        processDirectory(f)
      else {
        shift {
          k: (Unit =&gt; Unit) =&gt; {
            cont = k                // ➋
          }
        }                           // ➎
        println(f)
      }
    }
  }

  reset {
    processDirectory(new File("/")) // ➊
  }                                 // ➌

  for (i &lt;- 1 to 100) cont()        // ➍
}
</pre>

<ol>
<li>
进入reset块时，<code>processDirectory()</code>被调用➊。

<li>
一旦该方法找到第一个不是目录的文件，就进入shift块➋。

<li>
延续函数被保存到<code>cont</code>，程序跳到reset块的末尾➌。

<li>
<code>cont()</code>被调用➍。程序重新跳加递归➎。

<li>
递归继续，赶到下一个文件被找到，再次进入shift。

</ol>


<h2 id="toc_3.9">控制反转</h2>

<p>
场景：两个页面上有两个表单，分别让用户填姓和名，这种情况下如果可以直接这样写会
很方便：
</p>

<pre class="brush: scala">
val firstname = getResponse(page1)
val lastname = getResponse(page2)
</pre>

<p>
但http Web应用下的请求响应是无状态的，而且流程是不受控制的。但基于延续的Web框架
可以解决这样的问题：
</p>

<p>
在第一个页面等待用户响应时保留下延续，等响应到来以后再调用延续。而这一切对于程序
开发人员是透明的。
</p>

<p>
为简单起见先用一个GUI程序来说明，在第一个界面让用户输入first name，然后用户点
下一步按钮，调用到<code>getResponse()</code>方法。
</p>

<pre class="brush: scala; highlight: [3, 5, 7]">
def run() {
  reset {
    val response1 = getResponse("What is your first name?") // ➊
    val response2 = getResponse("What is your last name?")
    process(response1, response2)                           // ➎
  }
}                                                           // ➌

def process(s1: String, s2: String) {
  label.setText("Hello, " + s1 + " " + s2)
}
</pre>

<p>
注意<code>process()</code>方法并没有包含shift，所以不用加上CPS注解。CPS注解要加在捕获延续的
<code>getResponse()</code>方法上：
</p>

<pre class="brush: scala; highlight: [6, 7]">
def getResponse(prompt: String): String @cps[Unit] = {
  label.setText(prompt)
  setListener(button) { cont() }
  shift {
    k: (Unit =&gt; Unit) =&gt; {
      cont = k                     // ➋
    }                              // ➍
  }
  setListener(button) { }
  textField.getText
}
</pre>

<ul>
<li>
<code>run()</code>方法中的业务逻辑被包在了一个reset块中：当第一次调用<code>getResponse()</code>时➊
  ，它将进入<code>shift</code>块➋，捕获到延续，然后返回到reset块的末尾➌，退出<code>run()</code>方法。

<li>
当用户输入first name并点下一步时，按钮的事件处理器会执行延续，程序从➍开始
  继续，用户输入被返回给<code>run()</code>方法。<code>run()</code>方法第二次调用<code>getResponse()</code>，
	又会在延续被捕获时退出。

<li>
用户输入last name并点一下步，结果被送到<code>run()</code>方法并传递给<code>process()</code>➎

</ul>

<p>
有趣的是整个活动都在事件分发线程中完成，而且没有阻塞。为了展示这个效果，可以直接
在按钮监听器中启动<code>run()</code>方法。 
</p>

<p>
完整的代码：
</p>

<pre class="brush: scala; highlight: [12, 29, 31, 33, 46, 47]">
// Compile as scalac -P:continuations:enable InvControl.scala

import java.awt._
import java.awt.event._
import javax.swing._
import scala.util.continuations._

object Main extends App {
  val frame = new JFrame
  val button = new JButton("Next")
  
  setListener(button) { run() }

  val textField = new JTextArea(10, 40)
  textField.setEnabled(false)
  val label = new JLabel("Welcome to the demo app")
  frame.add(label, BorderLayout.NORTH)
  frame.add(textField)
  
  val panel = new JPanel
  panel.add(button)
  frame.add(panel, BorderLayout.SOUTH)
  frame.pack()
  frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE)
  frame.setVisible(true)

  def run() {
    reset {
      val response1 = getResponse("What is your first name?") // ➊
      val response2 = getResponse("What is your last name?")
      process(response1, response2)                           // ➎
    }
  }                                                           // ➌

  def process(s1: String, s2: String) {
    label.setText("Hello, " + s1 + " " + s2)
  }

  var cont: Unit =&gt; Unit = null

  def getResponse(prompt: String): String @cps[Unit] = {
    label.setText(prompt)
    setListener(button) { cont() }
    shift {
      k: (Unit =&gt; Unit) =&gt; {
        cont = k                                               // ➋
      }                                                        // ➍
    }
    setListener(button) { }
    textField.getText
  }

  def setListener(button: JButton)(action: =&gt; Unit) {
    for (l &lt;- button.getActionListeners) button.removeActionListener(l)
    button.addActionListener(new ActionListener {
      override def actionPerformed(event: ActionEvent) { action }
    })
  }
}
</pre>


<h2 id="toc_3.10">CPS变换</h2>

<p>
前面说过JVM不支持延续，所以Scala通过CPS来实现延续。CPS变换会产出一些对象，这些
对象会指定如何处理“剩下的运算”的函数。如下面的shift方法：
</p>

<pre class="brush: scala">
shift { 函数 }
</pre>

<p>
shift的代码体是一个<code>(A =&gt; B) =&gt; C</code>的函数，它的参数类型是<code>A =&gt; B</code>的延续作为函数，
返回值为<code>C</code>，这个值被传递到包含延续的reset块之外。所以shift会返回一个对象：
</p>

<pre class="brush: scala">
ControlContext[A, B, C](函数)
</pre>

<p>
这里的控制上下文（ControlContext）已经简化处理过了，真实的版本还包含了异常处理与
常量优化等内容。
</p>

<p>
这个上下文描述了如何处理延续函数。它可能会把函数推到一边；也有可能会计算出结果。
上下文并不知道如何处理延续函数，它只是预期接收延续，计算要依赖其他人。 
</p>

<p>
延续是必须被计算，要计算的内容可以分为我们知道的内容（用<code>f</code>表示）和不知道的内容
（用<code>k1</code>表示）。为了简化问题，直接用上<code>f</code>，这样只需要假定其他人会算完<code>k1</code>再给
我们。这样就可以先应用<code>f</code>再应用<code>k1</code>来完成整个运算。
</p>

<p>
把上面的想法对应到上下文中：shift被翻译成一个知道如何处理shift之后所有事情的
上下文。现在<code>f</code>到了shift以后。可以再做出一个新的控制上下文来处理<code>f</code>之后余下的
运算。像是这样：
</p>

<pre class="brush: scala">
new ControlContext(k1 =&gt; fun(a =&gt; k1(f(a))))
</pre>

<p>
<code>a =&gt; k1(f(a))</code>先运行<code>f()</code>然后再完成<code>k1</code>指定的运算。而<code>fun</code>则按通常的方法处理
去处的结果。
</p>

<p>
以上是控制上下文的基本操作，被称为map。以下是<code>map()</code>方法的定义：
</p>

<pre class="brush: scala">
class ControlContext[+A, -B, +C] (val fun: (A =&gt; B) =&gt; C) {

	def map[A1] (f: A =&gt; A1) = new ControlContext[A1, B, C] (
			(k1: (A1 =&gt; B)) =&gt; fun(x: A =&gt; k1(f(x)))
		)

}
</pre>

<p>
这里的<code>map()</code>方法和后面会涉及的<code>flatMap()</code>方法与映射并没有关系。叫<code>map</code>这个名字
是因为与映射方法一样遵从单子法则（monad laws）。这个法则就不解释了，扯远了。
</p>

<p>
<code>map</code>方法看起来很复杂，但用起来很直观：<code>cc.map(f)</code>接收一个上下文，产生一个处理
过<code>f</code>之后的新的上下文。这样一级一级传下去，直到所有的<code>f</code>都被处理过了，没有什么
要处理的了就是最终状态。这就是抵达reset边界的时候，只要把一个什么都不做的方法
传给<code>fun()</code>。就得到最终的shift结果。
</p>

<p>
reset正是这样定义的：
</p>

<pre class="brush: scala">
def reset[B, C] (cc: ControlContext[B, B, C]) = cc.fun(x =&gt; x)
</pre>

<p>
看一个简单的例子：
</p>

<pre class="brush: scala">
 var cont : (Int =&gt; Double) = null  
 
 reset {
   0.5 * shift { 
       k: (Int =&gt; Double) =&gt; { 
         cont = k 
       } 
   } + 1
 }
</pre>

<p>
这时只要一步就可以计算出整个延续：
</p>

<pre class="brush: scala">
 =&gt; 0.5 * /* hole */ + 1
</pre>

<p>
所以，我们得到了：
</p>

<pre class="brush: scala">
reset {
	new ControlContext[Int, Double, Unit] (k =&gt; cont = k).map(
			/* hole */ =&gt; 0.5 * /* hole */ + 1
	)
}
</pre>

<p>
即：
</p>

<pre class="brush: scala">
reset {
	new ControlContext[Double, Double, Unit] (
			k1 =&gt; cont = k1(x: Int =&gt; 0.5 * x + 1)
	)
}
</pre>

<p>
这样reset就可以求值了，k1是一个恒等函数，结果为：
</p>

<pre class="brush: scala">
cont = x: Int =&gt; 0.5 * x + 1
</pre>

<p>
可以通过<code>-Xprint:selectivecps</code>编译参数看到CPS变换生成的代码： 
</p>

<pre class="brush: scala">
// Compile as scalac -P:continuations:enable -Xprint:selectivecps Continuations.scala

import scala.util.continuations._

object Main extends App {
  
  var cont : (Int =&gt; Double) = null  
  reset {
    0.5 * shift { 
        k: (Int =&gt; Double) =&gt; { 
          cont = k 
        } 
    } + 1
  }
  println(cont(10))
  println(cont(20))
}


/*
[[syntax trees at end of selectivecps]]// Scala source: cont3.scala
package &lt;empty&gt; {
  final object Main extends java.lang.Object with App with ScalaObject {
    def this(): object Main = {
      Main.super.this();
      ()
    };
    private[this] var cont: Int =&gt; Double = null;
    &lt;accessor&gt; def cont: Int =&gt; Double = Main.this.cont;
    &lt;accessor&gt; def cont_=(x$1: Int =&gt; Double): Unit = Main.this.cont = x$1;
    scala.util.continuations.`package`.reset[Double, Unit]({
      package.this.shiftR[Int, Double, Unit](((k: Int =&gt; Double) =&gt; Main.this.cont_=(k))).map[Double](((tmp1: Int) =&gt; 0.5.*(tmp1).+(1)))
    });
    scala.this.Predef.println(Main.this.cont.apply(10));
    scala.this.Predef.println(Main.this.cont.apply(20))
  }
}
*/
</pre>

<h2 id="toc_3.11">转换嵌套的控制上下文</h2>

<p>
如果有多层CPS嵌套的话就复杂了，比如把递归转为迭代的场景。
</p>

<p>
递归访问树太复杂了，这里以访问一个链表为例：
</p>

<pre class="brush: scala">
var cont: Unit =&gt; String = null

def visit(a: List[String]): String @cps[String] = {
  if (a.isEmpty) "" else {
    shift {
      k: (Unit =&gt; String) =&gt; { 
        cont = k
        a.head
      }
    }
    visit(a.tail)
  }
}
</pre>

<p>
shift生成的上下文和前一个为：
</p>

<pre class="brush: scala">
new ControlContext[Unit, String, String] (k =&gt; { cont = k; a.head }
</pre>

<p>
但除了shift以外，还有一个<code>visit()</code>调用，它也要生成一个上下文。虽然<code>visit()</code>方法
的返回类型是<code>String</code>，但<code>@cps</code>注解让编译器经过CPS变换以后实际返回的类型成了
<code>ControlContext</code>。
</p>

<p>
更加确切地说，shift被替换成了<code>()</code>，因为延续函数的参数类型为<code>Unit</code>。这样一下，
剩下的运算就是：
</p>

<pre class="brush: scala">
() =&gt; visit(a.tail)
</pre>

<p>
前一节中我们会把这个函数作为参数调用<code>map()</code>方法，但由于它的返回类型是一个控制
上下文，所以我们要调用<code>flatMap()</code>：
</p>

<pre class="brush: scala">
if 
	(a.isEmpty) new ControlContext(k =&gt; k(""))
else 
	new Controlcontext(k =&gt; { cont = k; a.head }).flatMap(() =&gt; visit(a.tail))
</pre>

<p>
<code>flatMap()</code>的定义为：
</p>

<pre class="brush: scala">
class ControlContext[+A, -B, +C] (val fun: (A =&gt; B) =&gt; C) {

	def flatMap[A1, B1, C1 &lt;: B] (f: A =&gt; Shift[A1, B1, C1]) = 
		new ControlContext[A1, B1, C] (
			(k1: (A1 =&gt; B1)) =&gt; fun(x: A =&gt; f(x).fun(k1))
		)
}
</pre>

<p>
以上代码的大概意思是：如果剩下的运算是由另一个想要处理剩下运算的上下文开始的话，
就让它开始做。这将定义出一个延续，由我们来处理。
</p>

<p>
注意类型界定<code>C1 &lt;: B</code>。这是因为<code>f(x).fun(k1)</code>的类型为<code>C1</code>，但是<code>fun()</code>的参数类型
是<code>A =&gt; B</code>的函数。
</p>

<p>
现在来模拟一次调用：
</p>

<pre class="brush: scala">
val lst = List("Fred")
reset { viset(lst) }
</pre>

<p>
由于<code>lst</code>不为空，所以得到： 
</p>

<pre class="brush: scala">
reset {
	new Controlcontext(k =&gt; { cont = k; a.head }).flatMap(() =&gt; visit(a.tail))
}
</pre>

<p>
根据<code>flatMap()</code>的定义，可以得到：
</p>

<pre class="brush: scala">
reset {
	new Controlcontext(
		k =&gt; {
			cont = () =&gt; visit(a.tail).fun(k1);
			lst.head 
		}
	)
}
</pre>

<p>
然后reset把<code>k1</code>设为恒等函数，我们得到：
</p>

<pre class="brush: scala">
cont = () =&gt; visit(lst.tail).fun(x =&gt; x)
lst.head
</pre>

<p>
如果是更长的列表的话会得到同样的结果，不同的是<code>visit(lst.tail.tail)</code>。本例的列表
因为只有一个元素已经调用完了，<code>visit(lst.tail)</code>将返回：
</p>

<pre class="brush: scala">
new ControlContext(k =&gt; k(""))
</pre>

<p>
应用恒等函数，得到结果<code>""</code>。这里用空字符串作为返回结果显得比较造作，但是因为
<code>cont</code>预期返回一个类型为<code>String</code>的值，所以不能用<code>Unit</code>。
</p>

<p>
全部代码如下：
</p>

<pre class="brush: scala">
// Compile as scalac -P:continuations:enable -Xprint:selectivecps Visig.scala

import scala util.continuations._

object Main extends App {
  var cont: Unit =&gt; String = null

  def visit(a: List[String]): String @cps[String] = {
    if (a.isEmpty) "" else {
      shift {
        k: (Unit =&gt; String) =&gt; { 
          cont = k
          a.head
        }
      }
      visit(a.tail)
      println("After visit")
      ""
    }
  }

  reset {
    visit(List("Mary", "had", "a", "little", "lamb"))
  }
  println(cont())
  println(cont())
}

/*

[[syntax trees at end of selectivecps]]// Scala source: cont11.scala
package &lt;empty&gt; {
  final object Main extends java.lang.Object with App with ScalaObject {
    def this(): object Main = {
      Main.super.this();
      ()
    };
    private[this] var cont: Unit =&gt; String = null;
    &lt;accessor&gt; def cont: Unit =&gt; String = Main.this.cont;
    &lt;accessor&gt; def cont_=(x$1: Unit =&gt; String): Unit = Main.this.cont = x$1;
    def visit(a: List[String]): scala.util.continuations.ControlContext[String,String,String] = if (a.isEmpty)
      package.this.shiftUnitR[java.lang.String(""), String]("")
    else
      {
        val tmp1$shift: scala.util.continuations.ControlContext[Unit,String,String] = package.this.shiftR[Unit, String, String](((k: Unit =&gt; String) =&gt; {
          Main.this.cont_=(k);
          a.head
        }));
        if (tmp1$shift.isTrivial)
          {
            val tmp1: Unit = tmp1$shift.getTrivialValue;
            tmp1;
            Main.this.visit(a.tail)
          }
        else
          tmp1$shift.flatMap[String, String, String](((tmp1: Unit) =&gt; {
            tmp1;
            Main.this.visit(a.tail)
          }))
      };
    scala.util.continuations.`package`.reset[String, String](Main.this.visit(immutable.this.List.apply[java.lang.String]("Mary", "had", "a", "little", "lamb")));
    scala.this.Predef.println(Main.this.cont.apply(()));
    scala.this.Predef.println(Main.this.cont.apply(()))
  }
}

*/
</pre>
 </div>
</body>
</html>
