<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">

<script type="text/javascript" src="../../vimwiki-theme/code/theme/scripts/jquery-1.4.2.min.js"></script>

<link type="text/css" rel="stylesheet" href="../../vimwiki-theme/hightlight-code/styles/shCore.css"/>
<link type="text/css" rel="stylesheet" href="../../vimwiki-theme/hightlight-code/styles/shThemeDefault.css"/>
<script type="text/javascript" src="../../vimwiki-theme/hightlight-code/scripts/shCore.js"></script>
<script type="text/javascript" src="../../vimwiki-theme/hightlight-code/scripts/shAutoloader.js"></script>

<script type="text/javascript" src="../../vimwiki-theme/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

<script type="text/javascript" src="../../vimwiki-theme/code/theme/scripts/script.js"></script>
<link type="text/css" rel="stylesheet" href="../../vimwiki-theme/code/theme/styles/style.css" />


<title>AngularJs</title>
</head>
<body  onresize='changeTocSize()'>
	<div class="note-main"> 


<h1>AngularJs</h1>
<div class="toc">
<ul>
<li><a href="#toc_1">入门</a>
<ul>
<li><a href="#toc_1.1">Hello World</a>
</ul>
<li><a href="#toc_2">应用实例</a>
<ul>
<li><a href="#toc_2.1">定义模块</a>
</ul>
<li><a href="#toc_3">Scopes</a>
<ul>
<li><a href="#toc_3.1">rootScope</a>
<li><a href="#toc_3.2">Controller连接Scope</a>
<li><a href="#toc_3.3">scope继承层级</a>
<li><a href="#toc_3.4">独立的scop</a>
<li><a href="#toc_3.5">结合进myApp</a>
<li><a href="#toc_3.6">音频</a>
</ul>
<li><a href="#toc_4">数据绑定</a>
<ul>
<li><a href="#toc_4.1">双向绑定</a>
<li><a href="#toc_4.2">视图与后端代码绑定</a>
<li><a href="#toc_4.3">绑定函数</a>
<li><a href="#toc_4.4">Ajax</a>
<li><a href="#toc_4.5">结合电台程序</a>
</ul>
<li><a href="#toc_5">指令属性</a>
<ul>
<li><a href="#toc_5.1">表达式简介</a>
<li><a href="#toc_5.2">常见指令属性</a>
<ul>
<li><a href="#toc_5.2.1">ng-init</a>
<li><a href="#toc_5.2.2">ng-click</a>
<li><a href="#toc_5.2.3">ng-show / ng-hide</a>
<li><a href="#toc_5.2.4">ng-repeat</a>
</ul>
<li><a href="#toc_5.3">指令属性创建指南</a>
<li><a href="#toc_5.4">收音机应用实例</a>
<li><a href="#toc_5.5">使用模板</a>
</ul>
</ul>
</div>

<h1 id="toc_1">入门</h1>

<h2 id="toc_1.1">Hello World</h2>

<p>
实现了内容与文本框一起改变的功能：
<a href="../code/angular.js/quickview/index.html">查看效果</a>
</p>

<p>
代码如下：
</p>

<pre class="brush: html; highlight:[2,4,8,9]"  title="quickview/basic.html">
&lt;!doctype html&gt;
&lt;html ng-app&gt;
  &lt;head&gt;
    &lt;script src="../angular.min.js"&gt;&lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div&gt;
      &lt;input type="text" ng-model="yourName" placeholder="Enter a name here"&gt;
      &lt;h1&gt;Hello, {{yourName}}!&lt;/h1&gt;
    &lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;
</pre>

<p>
就这样没有任何代码就实现了内容与文本框一起改变的功能：
</p>

<ul>
<li>
<code>ng-app</code>标记了一个模块，没有它AngularJs不会起作为。

<li>
<code>ng-model="yourName"</code>建立了文本框与模型<code>yourName</code>的双向绑定。

<li>
<code>{{yourName}}</code>显示模型的值。

</ul>

<h1 id="toc_2">应用实例</h1>

<p>
通过实践创建一个项目<code>myApp</code>来学习，把js代码都放在<code>js/radio.js</code>中。
</p>

<h2 id="toc_2.1">定义模块</h2>

<p>
通过<code>angular.module</code>方法定义模块，
</p>

<pre class="brush: js"  title="radio.v1/radio.js">
var app = angular.module('myApp', []);
</pre>

<p>
这样在页面上可以声明把模块绑定到指定的DOM中：
</p>

<pre class="brush: html; highlight:[2]"  title="radio.v1/radio.html">
&lt;!doctype html&gt;
&lt;html ng-app="myApp"&gt;
  &lt;head&gt;
    &lt;script src="../angular.min.js"&gt;&lt;/script&gt;
    &lt;script src="js/radio.js"&gt;&lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;
  &lt;/body&gt;
&lt;/html&gt;
</pre>

<p>
绑定的地方就是AngularJs运行应用的地方。
</p>

<h1 id="toc_3">Scopes</h1>

<p>
<code>$scope</code>是一个把view（一个DOM元素）连结到controller上的对象。在我们的MVC结构里，
这个<code>$scope</code>将成为model，它提供一个绑定到DOM元素（以及其子元素）上的excecution 
context。
</p>

<p>
尽管听起来有点复杂，但<code>$scope</code>实际上就是一个JavaScript对象，controller和view都
可以访问它，所以我们可以利用它在两者间传递信息。在这个<code>$scope</code>对象里，我们既存储
数据，又存储将要运行在view上的函数。
</p>

<h2 id="toc_3.1">rootScope</h2>

<p>
每一个Angular应用都会有一个<code>$rootScope</code>。
这个<code>$rootScope</code>是最顶级的scope，它对应着含有<code>ng-app</code>指令属性的那个DOM元素。
</p>

<p>
如果页面上没有明确设定<code>$scope</code>，Angular就会把数据和函数都绑定到这里，第一部分中
的例子就是靠这一点成功运行的。
</p>

<p>
在这个例子里，我们将使用<code>$rootScope</code>。在<code>radio.js</code>文件里，我们给这个<code>scope</code>加一个
<code>name</code>属性。把这个函数放进<code>app.run</code>函数里执行，我们就保证了它能在应用的其他部分
之前被执行。你可以把<code>app.run</code>函数看作是Angular应用的<code>main</code>方法。
</p>

<pre class="brush: javascript"  title="quickview/js/showscop01.js">
app.run(function($rootScope) {
  $rootScope.name = "Ari Lerner";
});
</pre>

<p>
现在，我们可以在<code>view</code>的任何地方访问这个<code>name</code>属性，使用模版表达式<code>{{}}</code>，像这样
：
</p>

<pre class="brush: html"  title="quickview/showscop.01.html">
{{ name }}
</pre>

<h2 id="toc_3.2">Controller连接Scope</h2>

<p>
要真正看到scope的强大功能，让我们给一个DOM元素加上controller，它将创建这个元素的
<code>$scope</code> ，让我们跟这个元素互动。
</p>

<p>
要明确创建一个<code>$scope</code>对象，我们就要给DOM元素安上一个controller对象，使用的是
<code>ng-controller</code>指令属性：
</p>

<pre class="brush: html">
&lt;div ng-controller="MyController"&gt;
  {{ person.name }}
&lt;/div&gt;
</pre>

<p>
<code>ng-controller</code>指令给所在的DOM元素创建了一个新的scope对象，并将这个scope对象
包含进外层DOM元素的scope对象里。在上面的例子里，这个外层DOM元素的<code>$scope</code>对象，
就是<code>$rootScope</code>对象。这个scope链是这样的：
</p>

<p>
<img src="images/AngularJS/01.png" />
</p>

<p>
现在，<code>MyController</code>给我们建立了一个可以从DOM元素内部直接访问的scope对象。下面
我们在的这个scope里创建一个<code>person</code>对象，在<code>radio.js</code>中：
</p>

<pre class="brush: js"  title="radio.v1/radio.js">
app.controller('MyController', function($scope) {
  $scope.person = {
    name: "Ari Lerner"
  };
});
</pre>

<p>
现在我们可以在有<code>ng-controller=’MyController’</code>属性的DOM元素的任何子元素里访问
这个<code>person</code>对象，因为它在<code>$scope</code>上。
</p>

<p>
页面上显示出：
</p>

<h2 id="toc_3.3">scope继承层级</h2>

<p>
所有scope都遵循原型继承（prototypal inheritance），这意味着它们
都能访问父scope们。对任何属性和方法，如果AngularJS在当前scope上找不到，就会到父
scope上去找，如果在父scope上也没找到，就会继续向上回溯，一直到<code>$rootScope</code>上。
</p>

<h2 id="toc_3.4">独立的scop</h2>

<p>
唯一的例外：有些指令属性可以选择性地创建一个独立的scope，让这个scope不继承它的
父scope们。
</p>

<p>
举个例子，假设我们有一个<code>ParentController</code>，含有一个<code>person</code>对象，又有一个
<code>ChildController</code>想要访问这个对象：
</p>

<pre class="brush: js">
app.controller('ParentController', function($scope) {
  $scope.person = {greeted: false};
});
 
app.controller('ChildController', function($scope) {
  $scope.sayHello = function() {
    $scope.person.greeted = true;
  }
});
</pre>

<p>
当我们在view里把<code>ChildController</code>绑定到<code>ParentController</code>之下，在子元素里我们
就能访问<code>ParentController</code>创建的父scope的属性，像访问<code>ChildController</code>自己的
scope中的属性一样：
</p>

<pre class="brush: html">
&lt;div ng-controller="ParentController"&gt;
  &lt;div ng-controller="ChildController"&gt;
    &lt;input type="text" ng-model="person.name" placeholder="Name"&gt;&lt;/input&gt;
    &lt;a ng-click="sayHello()"&gt;Say hello&lt;/a&gt;
  &lt;/div&gt;
  {{ person }}
&lt;/div&gt;
</pre>

<p>
<img src="images/AngularJS/02.png" />
</p>

<p>
<a href="../code/angular.js/quickview/scop.html">查看效果</a>
</p>

<h2 id="toc_3.5">结合进myApp</h2>

<p>
现在，我们把scope用在我们的NPR应用上。在上一篇结尾我们定义了<code>app module</code>，现在
我们开始深入DOM结构，创建基本功能。
</p>

<p>
像在上面的例子里展示过的那样，我们先创建一个root controller，命名为
<code>PlayerController</code>。还有一个<code>RelatedController</code>，它将负责管理音频DOM元素、和为
我们取回NPR节目的列表。
</p>

<p>
回到<code>radio.js</code>，现在我们就来创建这两个controller：
</p>

<pre class="brush: js" title="radio.v1/radio.js">
var app = angular.module('myApp', []);
 
app.controller('PlayerController', ['$scope', function($scope) { }]);
app.controller('RelatedController', ['$scope', function($scope) { }]);
</pre>

<h2 id="toc_3.6">音频</h2>

<p>
这两个controller现在还没什么功能，那么，让我们给应用先加上点声音吧。在这个教程里
我们将使用HTML5的音频DOM元素，所以首先你得有个支持HTML5的浏览器（我们推荐Google 
Chrome）。
</p>

<p>
这个音频DOM元素，我们既可以把它加在HTML里，又可以加在我们的controller里。不过
鉴于我们主要使用controller跟这个音频DOM元素互动，把它创建在controller里更合适。
</p>

<p>
现在我们就在<code>PlayerController</code>里创建一个音频DOM元素。我们要把它储存在scope上，
然后像你已经学过的那样——通过<code>$scope</code>对象把view和controller连接起来。
</p>

<pre class="brush: js" title="radio.v1/radio.js">
app.controller('PlayerController', ['$scope', function($scope) {
  $scope.audio = document.createElement('audio');
}]);
</pre>

<p>
这个设定现在可能有点无聊，因为它还不能干什么。我们会在本系列的下一篇介绍取回（
fetching）数据，现在我们先使用一个指定的<code>.mp4</code>网址。
</p>

<p>
还是在这个<code>PlayerController</code>里，指定音频文件的<code>src</code>属性为一个你能访问的<code>.mp4</code>
网址。方便起见，我们在这里使用一个储存在我们自己服务器上的NPR音频文件，不过其实
你可以指向任何网址。现在设定你的音频<code>src</code>地址如下：
</p>

<pre class="brush: js" title="radio.v1/radio.js">
app.controller('PlayerController', ['$scope', function($scope) {
  $scope.playing = false;
  $scope.audio = document.createElement('audio');
  $scope.audio.src = 'http://r3.soundowl.com/3t10.mp3';
}]);
</pre>

<p>
音频不会自己播放，我们必须让它播放。要做到这一点，我们可以简单地使用
<code>$scope.audio.play()</code>，然后HTML5音频DOM元素就会开始播放mp4媒体流。
</p>

<p>
我们可以给用户提供一个互动元素：创建一个按钮，把它绑定到scope里的一个动作上。
在下一篇里我们会更深入地介绍这一块，不过先看看上面例子里view的HTML：
</p>

<pre class="brush: html" title="radio.v1/radio.html">
&lt;div ng-controller="PlayerController"&gt;
  &lt;button ng-click="play()" class="button" ng-show="!playing"&gt;Play&lt;/button&gt;
  &lt;button ng-click="stop()" class="button alert" ng-show="playing"&gt;Stop&lt;/button&gt;
  Playing audio: &lt;b&gt;{{ playing }}&lt;/b&gt;
&lt;/div&gt;
</pre>

<p>
注意我们并不需要引用在scope里创建的那个音频DOM元素，因为它是当我们载入controller
时在controller内部用<code>document.createElement("audio")</code>创建的。在之后的教程里我们
会重构这个部分，因为在controller里操作DOM元素一般都不是个好主意（感谢Brad Green
在评论中指出这一点。）然而为了简便，我们在这里还是保持这个controller如此。
</p>

<p>
在view里我们已经加入了一些变量，在scope上我们要管理这些变量。这里使用了一些高级
概念，这些在本系列之后的教程里才会详细介绍，所以如果你不能一下子全看明白也不用
担心：
</p>

<pre class="brush: js" title="radio.v1/radio.js">
app.controller('PlayerController', ['$scope', function($scope) {
	$scope.audio = document.createElement('audio');
	$scope.audio.src = 'http://r3.soundowl.com/3t10.mp3';

	$scope.playing = false;

	$scope.play = function() {
		$scope.audio.play();
		$scope.playing = true;
	};
	$scope.stop = function() {
		$scope.audio.pause();
		$scope.playing = false;
	};

	$scope.audio.addEventListener('ended', function() {
		$scope.$apply(function() {
			$scope.stop()
		});
	});
}]);
</pre>

<p>
以上就是对Angular.js的<code>$scope</code>功能的介绍。在下一章，我们会介绍Angular.js的双向
数据绑定。
</p>

<p>
<a href="../code/angular.js/radio.v1/radio.html">查看效果</a>
</p>

<h1 id="toc_4">数据绑定</h1>

<h2 id="toc_4.1">双向绑定</h2>

<p>
view与model双向绑定的意思是：view变了，model的内容也会变；model变了，view也跟着
变。
</p>

<p>
<img src="images/AngularJS/04.png" />
</p>

<p>
通过<code>ng-model</code>指令把一个文本框绑定到<code>person.name</code>属性上：
</p>

<pre class="brush: js">
&lt;div ng-controller="MyController"&gt;
  &lt;input type="text" ng-model="person.name" placeholder="Enter your name" /&gt;
  &lt;h5&gt;Hello {{ person.name }}&lt;/h5&gt;
&lt;/div&gt;
</pre>

<h2 id="toc_4.2">视图与后端代码绑定</h2>

<p>
现在我们把model的值放在后端的js文件里，每秒刷新：
</p>

<pre class="brush: js" title="quickview/js/bind.js">
var app = angular.module('myApp', []);
 
app.controller('MyController', function($scope) {
	$scope.person = { name: "Ari Lerner" };
	var updateClock = function() { $scope.clock = new Date(); };
	var timer = setInterval(function() { $scope.$apply(updateClock); }, 1000);  
	updateClock();}
);
</pre>

<p>
显示的view在页面上：
</p>

<pre class="brush: html" title="quickview/bind.html">
&lt;!doctype html&gt;
&lt;html ng-app="myApp"&gt;
&lt;head&gt;
&lt;script src="../angular.min.js"&gt;&lt;/script&gt;
&lt;script src="js/bind.js"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div ng-controller="MyController"&gt;
	&lt;h5&gt;{{ clock }}&lt;/h5&gt;
&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>

<h2 id="toc_4.3">绑定函数</h2>

<p>
不光是把数据绑定到用于显示的view上，还可以把函数绑定到DOM元素上。不仅是按钮，
链接等，任何DOM元素都可以通过<code>ng-click</code>绑定鼠标点击事件调用的函数（即浏览器通用
的<code>mousedown</code>事件）。
</p>

<p>
方法被绑定到controller所有的<code>$scope</code>对象上。注意要将方法名写进带引号的字符串里：
</p>

<pre class="brush: html; highlight=[3,4]" title="quickview/bind.html">
&lt;div ng-controller="DemoController"&gt;
  &lt;h4&gt;The simplest adding machine ever&lt;/h4&gt;
  &lt;button ng-click="add(1)" class="button"&gt;Add&lt;/button&gt;
  &lt;button ng-click="subtract(1)" class="button"&gt;Subtract&lt;/button&gt;
  &lt;h4&gt;Current count: {{ counter }}&lt;/h4&gt;
&lt;/div&gt;
</pre>

<p>
调用的方法：
</p>

<pre class="brush: js" title="quickview/js/bind.js">
app.controller('DemoController', function($scope) {
  $scope.counter = 0;
  $scope.add = function(amount) { $scope.counter += amount; };
  $scope.subtract = function(amount) { $scope.counter -= amount; };
});
</pre>


<h2 id="toc_4.4">Ajax</h2>

<p>
Angular.js通过一个<code>$http</code>服务提供了多种方式来调用AJAX。
所有Angular.js的核心服务都用<code>$</code>前缀。
</p>

<pre class="brush: js" title="quickview/js/bind.js">
app.controller('PlayerController', function($scope, $http) {
	$http({ method: 'JSONP',  
		url: 'http://api.openbeerdatabase.com/v1/beers.json?callback=JSON_CALLBACK'
	}).success(function(data, status, headers, config) {  
		// data contains the response  
		// status is the HTTP status  
		// headers is the header getter function  
		// config is the object that was used to create the HTTP request
		$scope.programs = data;
	}).error(function(data, status, headers, config) {});
}
</pre>

<p>
注意， 像上面例子中那样，原封不动加上以下字符串<code>callback=JSON_CALLBACK</code>，
Angular.js就会负责为你处理JSONP请求，将<code>JSON_CALLBACK</code>替换成一个合适的回调函数。
</p>

<pre class="brush: html" title="quickview/bind.html">
&lt;div ng-controller="PlayerController"&gt;
{{ programs }}
&lt;/div&gt;
</pre>

<p>
<a href="../code/angular.js/quickview/bind.html">查看效果</a>
</p>


<h2 id="toc_4.5">结合电台程序</h2>

<p>
要调用NPR电脑的API要先注册申请一个API Key：<a href="http://www.npr.org/templates/reg/">http://www.npr.org/templates/reg/</a>
</p>

<p>
然后就可以取得节目列表：
</p>

<pre class="brush: js" title="radio.v1/radio.js">
var apiKey = 'MDEyNDkyMTc4MDEzODMxMTI3MTkxMjU5OQ001';
var nprUrl = 'http://api.npr.org/query?id=61&amp;fields=relatedLink,title,byline,text,audio,image,pullQuote,all&amp;output=JSON';
 
app.controller('PlayerController', function($scope, $http) {
	// Hidden our previous section's content
	// construct our http request
	$http({
		method: 'JSONP',
		url: nprUrl + '&amp;apiKey=' + apiKey + '&amp;callback=JSON_CALLBACK'
	}).success(function(data, status) {
		// Now we have a list of the stories (data.list.story)
		// in the data object that the NPR API
		// returns in JSON that looks like:
		// data: { "list": {
		//	 "title": ...
		//	 "story": [
		//		 { "id": ...
		//			 "title": ...
		$scope.programs = data.list.story;
	}).error(function(data, status) {
		// Some error occurred
	});
});
</pre>

<p>
页面上显示：
</p>

<pre class="brush: js" title="radio.v1/radio.js">
&lt;div ng-controller="PlayerController"&gt;{{ programs }}&lt;/div&gt;
</pre>

<p>
<a href="../code/angular.js/radio.v2/radio.html">查看效果</a>
</p>


<h1 id="toc_5">指令属性</h1>

<p>
目前为止，我们已提到过几次“指令属性”的概念，但从未深入探讨过它到底是什么。实际上
，“指令属性”就是绑定在DOM元素上的函数，它可以调用方法、定义行为、绑定controller
及$scope对象、操作DOM，等等等等。
</p>

<p>
当浏览器启动、开始解析HTML（像平时一样）时，DOM元素上的指令属性就会跟其他属性
一样被解析。
</p>

<p>
当一个Angular.js应用启动，Angular编译器就会遍历DOM树（从有<code>ng-app</code>指令属性的那个
DOM元素开始，如我们在本系列第一篇里所提过的），解析HTML，寻找这些指令属性函数。
</p>

<p>
当在一个DOM元素上找到一个或多个这样的指令属性函数，它们就会被收集起来、排序，
然后按照优先级顺序被执行。
</p>

<p>
每个指令属性都有自己的优先级，在我们关于
<a href="http://www.ng-newsletter.com/posts/directives.html">指令属性的专题文章里</a>
，你可以找到更深入的信息。
</p>

<p>
Angular.js应用的动态性和响应能力，都要归功于指令属性。之前我们已经看过一些指令
属性的用例，如<code>ng-model</code>让标题中的文本与输入框绑定：
</p>

<pre class="brush: html" title="quickview/directives.html">
&lt;input ng-model="name" name="Name" placeholder="Enter your name"/&gt;
&lt;h4&gt;Your name: {{ name }}&lt;/h4&gt;
</pre>

<p>
<code>ng-model</code>指令属性，被用来将DOM文本输入框的值，跟controller里的<code>$scope model</code>
绑定起来。具体的实现过程，是在这个值上绑定了一个<code>$watch</code>函数（类似JavaScript里的
事件监听函数）。
</p>

<p>
<code>$watch</code>函数（在使用时）运行在Angular.js的事件循环
（即<code>$digest</code>循环）里，让Angular.js能够对DOM进行相应的更新。请关注我们关于
<code>$digest</code>循环的高级文章！
</p>

<p>
在Angular.js应用的开发中，我们用指令属性来将行为绑定到DOM上。指令属性的使用，是
一个应用能否拥有动态性、响应能力的关键。
</p>

<h2 id="toc_5.1">表达式简介</h2>

<pre class="brush: html" title="quickview/directives.html">
{{ 表达式 }}
</pre>

<p>
这个双大括号指令属性，使用<code>$watch()</code>函数，给括号内的表达式注册了一个监听器。正是
这个<code>$watch</code>函数，让Angular.js能够实时自动更新view。
</p>

<p>
要想理解指令属性的运作，我们必须先理解表达式，在之前的例子里我们已经见过表达式，
例如<code>{{ person.name }}</code>和<code>{{ clock }}</code>。
</p>

<pre class="brush: html" title="quickview/directives.html">
{{ 8 + 1 }}                // 9
{{ person }}               // {"name":"Ari Lerner"}
{{ 10 * 3.3 | currency }}  // $33.00
</pre>

<p>
最后的例子里<code>(10 * 3.3 | currency)</code>用了一个过滤器。本系列之后的部分，会深入介绍
过滤器。
</p>

<p>
表达式粗略来看有点像<code>eval(javascript)</code>的结果。它们会经过Angular.js的处理，从而
拥有以下重要而独特的性质：
</p>

<ul>
<li>
所有表达式都在scope这个context里被执行，因此可以使用所有本地<code>$scope</code>中的变量。

<li>
如果一个表达式的执行导致类型错误或引用错误，这些错误将不会被抛出。

<li>
表达式里不允许任何控制函数流程的功能（如if/else等条件语句）

<li>
表达式可接受一个或多个串联起来的过滤器。

</ul>

<p>
表达式都运行在调用它们的scope里，所以一个表达式可访问并操作其scope上的一切。由此
，你可以使用表达式遍历其scope的属性（我们在<code>ng-repeat</code>中会看到这一应用）、调用
scope里的函数，或者对scope中的变量进行数学运算。
</p>

<h2 id="toc_5.2">常见指令属性</h2>

<h3 id="toc_5.2.1">ng-init</h3>

<p>
ng-init指令属性是一个在启动时运行的函数（在程序进入运行阶段之前）。它让我们能够
在程序运行前设定初始变量的值：
</p>

<pre class="brush: html" title="quickview/directives.html">
&lt;b ng-init='name = "Ari Lerner"'&gt;Hello, {{ name }}&lt;/b&gt;
</pre>

<h3 id="toc_5.2.2">ng-click</h3>

<p>
ng-click指令属性给DOM元素注册了一个点击事件的监听器。当此DOM元素上有点击事件发生
（即当此button或link被点击时），Angular.js就会执行表达式的内容，并相应地更新view
。
</p>

<pre class="brush: html" title="quickview/directives.html">
&lt;button ng-click="counter = counter + 1"&gt;Add one&lt;/button&gt;
Current counter: {{ counter }}
</pre>

<p>
我们也可以用ng-click来调用在controller里写好并绑定在$scope上的函数，例如：
</p>
	
<pre class="brush: html" title="quickview/directives.html">
&lt;div ng-controller="MyController"&gt;
	&lt;button ng-click="sayHello()"&gt;Say hello&lt;/button&gt;
&lt;/div&gt;
</pre>

<p>
controller 里的函数:
</p>

<pre class="brush: javascript" title="quickview/js/directives.js">
app.controller('MyController', function($scope) {
   $scope.sayHello = function() {
     alert("hello!");
   }
 });
</pre>

<h3 id="toc_5.2.3">ng-show / ng-hide</h3>

<p>
ng-show和ng-hide指令，根据赋予它们的表达式的值的真假性(truthy)，来显示和隐藏它们
所属的那一部分DOM。
</p>

<p>
我们在这里不会深入，但你应该熟悉JavaScript中变量值的<code>truthy</code>和<code>falsy</code>概念。
</p>

<pre class="brush: html" title="quickview/directives.html">
&lt;button ng-init="shouldShow = true" ng-click="shouldShow = !shouldShow"&gt;
	Flip the shouldShow variable
&lt;/button&gt;

&lt;div ng-show="shouldShow"&gt;
  &lt;h3&gt;Showing {{ shouldShow }}&lt;/h3&gt;
&lt;/div&gt; &lt;div ng-hide="shouldShow"&gt;
  &lt;h3&gt;Hiding {{ shouldShow }}&lt;/h3&gt;
&lt;/div&gt;
</pre>

<h3 id="toc_5.2.4">ng-repeat</h3>

<p>
ng-repeat指令遍历一个数据集合中的每个数据元素，加载HTML模版把数据渲染出来。被
重复使用的模版元素，就是我们绑定了这个指令属性的DOM元素。每一个使用模版渲染的DOM
元素都有自己的scope。
</p>

<p>
在更多的解释之前，我们先看一个例子。假设我们的controller里有这样一个数据元素的
数组：
</p>

<pre class="brush: javascript" title="quickview/js/directives.js">
$scope.roommates = [
	{ name: 'Ari'},
	{ name: 'Q'},
	{ name: 'Sean'},
	{ name: 'Anand'}
];
</pre>


<pre class="brush: html" title="quickview/directives.html">
&lt;ul&gt;
	&lt;li ng-repeat="person in roommates"&gt;{{ person.name }}&lt;/li&gt;
&lt;/ul&gt;
</pre>

<p>
对赋予ng-repeat的表达式稍作改动，我们还可以用它遍历一个由成对的key-value数据组成
的集合。例如，假设我们有一个人名和他们最喜欢的颜色的数据集合：
</p>

<pre class="brush: javascript" title="quickview/js/directives.js">
$scope.people = {
   'Ari': 'orange',
   'Q': 'purple',
   'Sean': 'green'
}
</pre>

<p>
要遍历它，我们可以给ng-repeat指令属性赋予这个表达式: <code>(key, value) in object</code>:
</p>

<pre class="brush: html" title="quickview/directives.html">
&lt;ul&gt;
   &lt;li ng-repeat="(name, color) in people"&gt;
		{{ name }}'s favorite color is {{ color }}
   &lt;/li&gt;
&lt;/ul&gt;
</pre>


<p>
<a href="../code/angular.js/quickview/directives.html">查看效果</a>
</p>


<h2 id="toc_5.3">指令属性创建指南</h2>

<p>
Angular.js提供的直接可用的指令属性并不多，但它让我们可以很容易地创建自己的指令
属性。请到这里查看我们的
<a href="http://www.ng-newsletter.com/posts/directives.html">指令属性创建指南</a>
</p>

<h2 id="toc_5.4">收音机应用实例</h2>

<p>
在上一篇中，我们的收音机应用只从NPR API取回了最新的音频节目列表：
</p>

<pre class="brush: javascript" title="radio.v3/radio.html">
$scope.programs = data.list.story;
</pre>

<p>
现在我们学了遍历一个list的实现方法，可以在我们的收音机应用里，像刚才那样用
ng-repeat来遍历这个节目列表了：
</p>

<pre class="brush: html" title="radio.v3/radio.js">
&lt;ul id="programs_list" class=""&gt;
   &lt;li ng-repeat="program in programs"&gt;
     &lt;span class="large-12"&gt;{{ program.title.$text }}&lt;/span&gt;
   &lt;/li&gt;
&lt;/ul&gt;
</pre>

<p>
NPR API给我们的是一个有<code>title+$text</code>的列表，这个结构是NPR API所特有的，而不是
Angular.js的。
</p>

<p>
现在我们列出了节目和它们的标题，但还不能点击并播放它们。用ng-click我们可以给HTML
元素加上一个点击功能：
</p>

<pre class="brush: html" title="radio.v3/radio.html">
&lt;ul id="programs_list" class=""&gt;
   &lt;li ng-repeat="program in programs" ng-click="play(program)"&gt;
     &lt;span class="large-12"&gt;{{ program.title.$text }}&lt;/span&gt;
   &lt;/li&gt;
&lt;/ul&gt;
</pre>

<p>
通过这一步，我们把一个play动作函数绑定到了列表里的<code>&lt;li&gt;</code>DOM元素上。现在，我们在
PlayerController里创建这个play动作函数，然后我们就有了一个功能完备的音频应用：
</p>

<pre class="brush: javascript" title="radio.v3/radio.js">
// format.mp4.$text is the route to the mp4 file from the NPR api
$scope.play = function(program) {
	if ($scope.playing) $scope.audio.pause();
	var url = program.audio[0].format.mp4.$text;
	$scope.audio.src = url;
	$scope.audio.play();
	// Store the state of the player as playing
	$scope.playing = true;
}
</pre>

<p>
现在这个应用功能完备了，但是还不太好看。而且随着我们继续添加新功能，代码也会膨胀
，变得难以管理。我们可以创建自己的指令属性，来帮助我们减少复杂性。
</p>

<p>
想更多地学习自定义指令属性，可以看看我们
<a href="http://www.ng-newsletter.com/posts/directives.html">深入探讨指令属性的文章</a>
</p>

<h2 id="toc_5.5">使用模板</h2>

<p>
创建自定义指令属性，我们使用<code>app</code>对象的<code>directive</code>方法：
</p>

<pre class="brush: javascript; highlight: [1,10]" title="radio.v3/radio.js">
app.directive('nprLink', function() {
  return {
    restrict: 'EA',
    require: ['^ngModel'],
    replace: true,
    scope: {
      ngModel: '=',
      play: '&amp;'
    },
    templateUrl: 'views/nprListItem.html',
    link: function(scope, ele, attr) {
      scope.duration = scope.ngModel.audio[0].duration.$text;
    }
  }
});
</pre>

<p>
我们不会逐个解释每个选项的意义，因为我们有一篇
<a href="http://www.ng-newsletter.com/posts/directives.html">专门的深入文章</a>
来介绍它们。这里我们只需要明白：
</p>

<ul>
<li>
这个指使名为<code>nprLink</code>

<li>
指向的模版<code>templateUrl</code>对应<code>views/nprListItem.html</code>

</ul>

<p>
现在，我们的主HTML文件可以保持整洁，而将用来渲染列表内容的view，创建在这个单独
提取出来的模版文件里：
</p>

<pre class="brush: html" title="radio.v3/radio.html">
&lt;div class="nprLink row" ng-click="play(ngModel)"&gt;
	&lt;span class="name large-8 columns"&gt;
		&lt;button class="large-2 small-2 playButton columns"&gt;
			&lt;div class="triangle"&gt;play&lt;/div&gt;
		&lt;/button&gt;
		&lt;div class="large-10 small-10 columns"&gt;
			&lt;div class="row"&gt;
				&lt;span class="large-12"&gt;{{ ngModel.title.$text }}&lt;/span&gt;
			&lt;/div&gt;
			&lt;div class="row"&gt;
				&lt;div class="small-1 columns"&gt;Go Page:&lt;/div&gt;
				&lt;div class="small-2 columns push-8"&gt;
					&lt;a href="{{ ngModel.link[0].$text }}"&gt;Link&lt;/a&gt;
				&lt;/div&gt;
			&lt;/div&gt;
		&lt;/div&gt;
	&lt;/span&gt;
&lt;/div&gt;
</pre>

<p>
注意我们在模版文件里用<code>ngModel</code>来指向之前的<code>program</code>数据，因为在创建自定义指令
属性时，我们做了设置。
</p>

<p>
现在，我们在主HTML文件里就不用再写上面那么多HTML，而只要简单地换上我们的自定义
指令属性<code>npr-link</code>：
</p>

<pre class="brush: html" title="radio.v3/radio.html">
&lt;ul id="programs_list" class=""&gt;
	&lt;li ng-repeat="program in programs"&gt;
		&lt;span npr-link play='play(program)' ng-model="program"&gt;&lt;/span&gt;
	&lt;/li&gt;
&lt;/ul&gt;
</pre>


<p>
<a href="../code/angular.js/radio.v3/radio.html">查看效果</a>
</p>


<pre class="brush: html" title="">
</pre>


<pre class="brush: html" title="">
</pre>


<pre class="brush: html" title="">
</pre>


<pre class="brush: html" title="">
</pre>


<pre class="brush: html" title="">
</pre>


<pre class="brush: html" title="">
</pre>
 </div>
</body>
</html>
