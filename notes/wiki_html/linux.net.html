<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=cp936">

<script type="text/javascript" src="../../vimwiki-theme/code/theme/scripts/jquery-1.4.2.min.js"></script>

<link type="text/css" rel="stylesheet" href="../../vimwiki-theme/hightlight-code/styles/shCore.css"/>
<link type="text/css" rel="stylesheet" href="../../vimwiki-theme/hightlight-code/styles/shCoreRDark.css"/>
<link type="text/css" rel="stylesheet" href="../../vimwiki-theme/hightlight-code/styles/shThemeRDark.css"/>
<script type="text/javascript" src="../../vimwiki-theme/hightlight-code/scripts/shCore.js"></script>
<script type="text/javascript" src="../../vimwiki-theme/hightlight-code/scripts/shAutoloader.js"></script>

<link type="text/css" rel="stylesheet" href="../../vimwiki-theme/code/theme/styles/style.css" />

<script type="text/javascript" src="../../vimwiki-theme/code/theme/scripts/script.js"></script>


<title>网络基础</title>
</head>
<body>




<h1>网络基础</h1>
<div class="toc">
<ul>
<li><a href="#toc_1">基本知识</a>
<li><a href="#toc_2">网络配置</a>
<ul>
<li><a href="#toc_2.1">检查网卡</a>
<li><a href="#toc_2.2">网络的启动与关闭</a>
<li><a href="#toc_2.3">配置主机名</a>
<li><a href="#toc_2.4">网卡设定</a>
<li><a href="#toc_2.5">域名解析</a>
<li><a href="#toc_2.6">无线网络</a>
<li><a href="#toc_2.7">查找无线网络</a>
</ul>
<li><a href="#toc_3">基本工具</a>
</ul>
</div>

<h1 id="toc_1">基本知识</h1>

<p>
IP地址与MAC地址
</p>

<p>
我们的主机上网路卡可以透过 ifconfig来查询到MAC，如第一个以太网为一般叫作eth0：
</p>

<pre class="brush: bash">
$ ifconfig eth0

eth0      Link encap:Ethernet  HWaddr 00:25:b3:69:16:59  
          inet addr:192.168.1.104  Bcast:192.168.1.255  Mask:255.255.255.0
          inet6 addr: fe80::225:b3ff:fe69:1659/64 Scope:Link
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:87822 errors:0 dropped:0 overruns:0 frame:0
          TX packets:65169 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000 
          RX bytes:95827160 （95.8 MB）  TX bytes:9333772 （9.3 MB）
          Interrupt:17 
</pre>

<p>
但数据在网卡之间的传输要通过ARP （Address Resolution Protocol）解析IP与MAC的对照关系得到网卡的MAC。当我们的主机想要找出目标IP时，就会对整个区域网路进行广播封包（broadcast）的传送， 这个广播封包可以对所有区域网路内的电脑要求回报他的IP与MAC， 当目标IP看到这个广播封包时，就会回应您主机相关的 MAC 资讯，如果非目标主机接到这个封包， 就会主动的忽略。这样就可以取得标主机的MAC，而这个目
标主机的MAC就会被记录到你的主机内存中的ARP table（不过还是要再次的提醒，MAC是不能跨路由的）。
</p>

<p>
如果想要查看ARP记录，可以通过arp命令：
</p>

<p>
参数-n 加主机名可以将主机名称以 IP 的型态显示：
</p>

<pre class="brush: bash">
[root@linux ~]# arp -n
Address       HWtype HWaddress         Flags Mask Iface
192.168.1.100 ether  00:01:03:01:02:03 C          eth0
192.168.1.240 ether  00:01:03:01:DE:0A C          eth0
192.168.1.254 ether  00:01:03:55:74:AB C          eth0
</pre>

<p>
从上面的结果中可以看到由于有记录MAC与IP的对应，因此当下回资料又传送到同一部主机时会主动的传送到同一个MAC去，而不需要再次透过broadcast来查询MAC，所以省去了很多网路延迟的时间。ARP table是动态的资讯，会随时随着网域里面电脑的IP更动而变化，所以，即使常常更动的电脑IP，ARP table也会自动的重新。
</p>

<p>
如果有特殊需求也可以利用参数“-s hostname（IP） Hardware_address”来定义静态的 ARP 对应:
</p>

<pre class="brush: bash">
[root@linux ~]# arp -s 192.168.1.100 01:00:2D:23:A1:0E
</pre>

<p>
还可以通过参数 -d 将 hostname 的 hardware_address 由 ARP table 当中删除掉。
</p>


<p>
IP地址格式
</p>

<p>
IP地址一共有32位二进制：
</p>

<pre class="brush: bash">
00000000.00000000.00000000.00000000 ==&gt; 0.0.0.0
11111111.11111111.11111111.11111111 ==&gt; 255.255.255.255
</pre>

<p>
这32位被分为两部分：“网络号”与“主机号”。如果多个IP地址拥有相同的网格号与各自不同的主机号，那么这些机器就是处于同一个“物理网段”内。如下面这个典型的C类网段，前24位是网络号，后8位是主机号：
</p>

<pre class="brush: bash">
|----------Net_ID--------| |-host-|
11000000.10101000.00000000.00000000 ==&gt; 192.168.0.0 
11000000.10101000.00000000.11111111 ==&gt; 192.168.0.255
</pre>


<p>
在同一个网段内，Net_ID 是不变的，Host_ID则是不可重复。而此外， Host_ID在二进位的表示法当中，不可同时为0也不可同时为1，例如上面的例子当中，192.168.0.0 （Host_ID全部为0）以及 192.168.0.255（Host_ID全部为1）不可用来作为网段内主机的IP。
</p>

<p>
在同一个物理网段之内，如果两部主机设定成不同的IP网段，则两部主机无法直接以MAC讯框格式进行资料的传递，因为广播封包无法查询到MAC 与IP的对应。
</p>

<p>
IP的分级
目前 Internet将IP简单的分类成为A， B， C三种常见的等级:
以二进位说明 Network 第一个数字的定义:
</p>

<pre class="brush: bash">
A Class : 0xxxxxxx.xxxxxxxx.xxxxxxxx.xxxxxxxx ==&gt; NetI_D 的开头是 0
          |--net-| |--------host------------|  0.xx.xx.xx ~ 126.xx.xx.xx

B Class : 10xxxxxx.xxxxxxxx.xxxxxxxx.xxxxxxxx ==&gt; NetI_D 的开头是 10
          |------net------| |-----host------| 128.xx.xx.xx ~ 191.xx.xx.xx

C Class : 110xxxxx.xxxxxxxx.xxxxxxxx.xxxxxxxx ==&gt; NetI_D 的开头是 110
          |-----------net----------| |-host-| 192.xx.xx.xx ~ 223.xx.xx.xx
</pre>

<p>
A类网中还有一个127.xxx.xxx.xxx被操作系统占用作为圆环调用（lookback）。
</p>

<p>
子网掩码：把网络号全1，把主机号全0。
</p>

<p>
IP地址中主机地址全0表示是这个网络的网络号；主机号全1表示是广播地址（Broadcast）。
</p>

<pre class="brush: bash">
            |----------Net_ID--------| |-host-|
  Net Mask: 11111111.11111111.11111111.00000000 ==&gt; 255.255.255.0
    Net ID: 11000000.10101000.00000000.00000000 ==&gt; 192.168.0.0
First Addr: 11000000.10101000.00000000.00000001 ==&gt; 192.168.0.1
 Last Addr: 11000000.10101000.00000000.11111110 ==&gt; 192.168.0.254
 Broadcast: 11000000.10101000.00000000.11111111 ==&gt; 192.168.0.255
</pre>

<p>
表示网络号与掩码直接表示某网络前24位都是掩码：192.168.0.0/24
</p>



<p>
拆分子网：
</p>

<p>
再拿出主机号中的n位来表示网络，这样就成了2的n次方个子网：
</p>

<p>
例如原本的C网：
</p>

<pre class="brush: bash">
            |----------Net_ID--------| |-host-|
  Net Mask: 11111111.11111111.11111111.00000000 ==&gt; 255.255.255.0
    Net ID: 11000000.10101000.00000000.00000000 ==&gt; 192.168.0.0
First Addr: 11000000.10101000.00000000.00000001 ==&gt; 192.168.0.1
 Last Addr: 11000000.10101000.00000000.11111110 ==&gt; 192.168.0.254
 Broadcast: 11000000.10101000.00000000.11111111 ==&gt; 192.168.0.255

切成两个子网路之后的Net_ID与Host_ID为

{{{class="brush: bash"
            |----------Net_ID--------| |-host-|
  Net Mask: 11111111.11111111.11111111.10000000 ==&gt; 255.255.255.128
  Net ID 1: 11000000.10101000.00000000.00000000 ==&gt; 192.168.0.0
Broadcast1: 11000000.10101000.00000000.01111111 ==&gt; 192.168.0.127
  Net ID 2: 11000000.10101000.00000000.10000000 ==&gt; 192.168.0.128
Broadcast2: 11000000.10101000.00000000.11111111 ==&gt; 192.168.0.255
</pre>

<p>
第一个子网络为：
</p>
<pre class="brush: bash">
192.168.0.0/25 或 192.168.0.0/255.255.255.128 
</pre>

<p>
第二个子网路为：
</p>
<pre class="brush: bash">
192.168.0.128/25 或 192.168.0.128/255.255.255.128
</pre>



<p>
IP地址的类型
</p>

<p>
在IPv4里面就只有两种IP的类别，分别是：
Public IP：公共IP，经由INTERNIC所统一规划的IP，只有这种IP才可以连上Internet；
Private IP：有IP或保留IP，不能直接连上Internet的IP，主要用于区域网路内的主机连线规划。
</p>

<p>
早在 IPv4 规划的时候就担心 IP 会有不足的情况，而且为了应付某些私有网路的网路设定，于是就有了私有 IP （ Private IP ） 的产生了。 私有IP也分别在A，B，C三个Class当中各保留一段作为私有IP网段，那就是：
</p>

<pre class="brush: bash">
A Class:10.0.0.0 - 10.255.255.255
B Class:172.16.0.0 - 172.31.255.255
C Class:192.168.0.0 - 192.168.255.255
</pre>

<p>
由于这三个Class的IP是预留使用的，所以并不能直接作为Internet上面的连接之用有底下的几个限制:
私有位址的路由资讯不能对外散播；
使用私有位址作为来源或目的地址的封包，不能透过Internet来转送：
关于私有位址的参考纪录（如 DNS），只能限于内部网路使用；
</p>

<p>
如果要将这些私有IP送上Internet可以设定一个简单的防火墙加上NAT（Network Address Transfer）主机设定，你就可以透过IP伪装来使你的私有 IP 的电脑也可以连上 Internet。
</p>

<p>
回环地址（lo）被放在127.0.0.0/8这个A Class，而且预设的主机（localhost）的IP是127.0.0.1。不用装网卡都可以访问到。
</p>



<p>
路由
</p>

<p>
当目标机器与自己是同一网络中，可以通过查自己的ARP记录直接利用MAC通讯。不在同一网段（网络号不同）不能直接通讯，要通过路由。
</p>

<p>
首先发送机会查看自己的路由表，如果没有相关的设置就往默认网关（default gateway）上发。默认网关一般都是路由器，它根据收到包的IP来判断把包发到对应网络的目标机。
</p>

<p>
每个机器都有路由表，可以通过route命令查看。参数-n表示以ip地址形式查看：
</p>

<pre class="brush: bash">
# route
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
default         192.168.1.1     0.0.0.0         UG    0      0        0 wlan0
link-local      *               255.255.0.0     U     1000   0        0 wlan0
192.168.1.0     *               255.255.255.0   U     2      0        0 wlan0


# route -n
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
0.0.0.0         192.168.1.1     0.0.0.0         UG    0      0        0 wlan0
169.254.0.0     0.0.0.0         255.255.0.0     U     1000   0        0 wlan0
192.168.1.0     0.0.0.0         255.255.255.0   U     2      0        0 wlan0
</pre>

<p>
上面输出的资料共有八个栏位,您需要注意的有几个地方：
Destination其实就是 Network 的意思
Gateway就是该介面的 Gateway 那个 IP 啦!若为 0.0.0.0（不加参数-n时显示为*）表示不需要额外的 IP（需要经过网关）
Genmask就是Netmask。与 Destination 组合成为一部主或网域
Flags共有多个旗标可以来表示该网域或主机代表的意义：
</p>
<ul>
<li>
U代表该路由可用

<li>
G代表该网域需要经由Gateway 来帮忙转递

<li>
H代表该行路由为一部主机,而非一整个网域

<li>
Iface就是Interface的意思

</ul>




<p>
TCP协议
</p>

<pre class="brush: bash">
 4 bits    6 bits      6 bits        8 bits          8 bits     
|------||----------||----------||--------------||--------------|
----------------------------------------------------------------
|        Source Port           ||      Destination Port        |
----------------------------------------------------------------
|                  Sequence Number                             |
----------------------------------------------------------------
|                 Acknowledge Number                           |
----------------------------------------------------------------
| Data || Reserved ||  Code    ||       Window                 |
|Offset||          ||          ||                              |
----------------------------------------------------------------
|         Checksum             ||        Urgent Pointer        |
----------------------------------------------------------------
|          Options             ||          Padding             |
----------------------------------------------------------------
|                        Data                                  |
----------------------------------------------------------------
</pre>

<p>
Source Port &amp; Destination Port ( 来源埠口 &amp; 目标埠口 )
</p>

<p>
Sequence Number ( 封包序号 )
由于 TCP 封包必须要带入 IP 封包当中,所以如果 TCP 资料太大时(大于 IP封包的容许程度), 就得要进行分段。这个 Sequence Number 就是记录每个封包的序号, 可以让收受端重新将 TCP 的资料组合起来。
</p>

<p>
Acknowledge Number ( 回应序号 )
为了确认主机端确实有收到我们 client 端所送出的封包资料,我们 client 端当然希望能够收到主机方面的回应,那就是这个 Acknowledge Number 的用途了。当 client 端收到这个确认码时,就能够确定之前传递的封包已经被正确的收下了。
</p>

<p>
Data Offset (资料补偿)
在图十二倒数第二行有个 Options 栏位对吧! 那个 Options 的栏位长度是非固定的, 而为了要确认整个 TCP 封包的大小,就需要这个标志来说明整个封包区段的起始位置。
</p>

<p>
Reserved (保留)
未使用的保留栏位。
</p>

<p>
Code (Control Flag, 控制标志码)
当我们在进行网路连线的时候,必须要说明这个连线的状态,好让接收端t解这个封包的主要动作。这可是一个非常重要的控制码喔!这个栏位共有 6 个bits ,分别代表 6 个控制码,若为 1 则为启动。分别说明如下:
	URG(Urgent):若为 1 则代表该封包为紧急封包, 接收端应该要紧急处理,且图十二当中的 Urgent Pointer 栏位也会被启用。
	ACK(Acknowledge):若为 1 代表这个封包为回应封包, 则与上面提到的 Acknowledge Number 有关。
	PSH(Push function):若为 1 时, 代表要求对方立即传送缓冲区内的其他对应封包,而无须等待缓冲区满了才送。
	RST(Reset):如果 RST 为 1 的时候, 表示连线会被马上结束,而无需等待终止确认手续。这也就是说,这是个强制结束的连线, 且发送端已断线。
	SYN(Synchronous):若为 1 , 表示发送端希望双方建立同步处理,也就是要求建立连线。通常带有 SYN 标志的封包表示『主动』要连接到对方的意思。
	FIN(Finish):若为 1 ,表示传送结束, 所以通知对方资料传毕,是否同意断线,只是发送者还在等待对方的回应而已。
	其中比较常见到的应该是 ACK/SYN/FIN 等,这三个控制码是务必要记下来的,这样未来在谈到防火墙的时候,您才会比较清楚为啥每个 TCP 封包都有所谓的『状态』条件! 那就是因为连线方向的不同所致啊! 底下我们会进一步讨论喔!
</p>

<p>
Window (滑动视窗)
主要是用来控制封包的流量的,可以告知对方目前本身有的缓冲器容量(Receive Buffer) 还可以接收封包。当 Window=0 时,代表缓冲器已经额满,所以应该要暂停传输资料。 Window 的单位是 byte。
</p>

<p>
Checksum(确认检查码)
当资料要由发送端送出前,会进行一个检验的动作,并将该动作的检验值标注在这个栏位上; 而接收者收到这个封包之后,会再次的对封包进行验证,并且比对原发送的 Checksum 值是否相符,如果相符就接受,若不符就会假设该封包已经损毁,进而要求对方重新发送此封包!
</p>

<p>
Urgent Pointer(紧急资料)
这个栏位是在 Code 栏位内的 URG = 1 时才会产生作用。可以告知紧急资料所在的位置。
</p>

<p>
Options(任意资料)
目前此栏位仅应用于表示接收端可以接收的最大资料区段容量,若此栏位不使用, 表示可以使用任意资料区段的大小。这个栏位较少使用。
</p>

<p>
Padding(补足栏位)
如同 IP 封包需要有固定的 32bits 表头一样, Options 由于栏位为非固定, 所以也需要 Padding 栏位来加以补齐才行。同样也是 32 bits 的整数。
</p>



<p>
三次握手建立连线
</p>

<p>
在封包连接模式当中，在建立连线之前都必须要通过三个确认的动作，所以这种连线方式也就被称为三向交握（Three-way handshake）。们将整个流程分成ABCD四个阶段来说明一下:
</p>

<p>
A：封包发起（SYN=1,Seq=10001）。
</p>

<p>
当用户端想要对伺服器端连线时，就必须要送出一个要求连线的封包，此时用户端必须随机取用一个大于1024以上的端口。然后在TCP的表头当中，必须要带有SYN的主动连线（SYN=1）,并且记下发送出连线封包给伺服器端的序号（Sequence number = 10001）。
</p>

<p>
B：认封包传送（ACK=1,ack=10002;SYN=1,seq=20001）。
</p>

<p>
当伺服器接到这个封包，并且确定要接收这个封包后，就会开始制作一个同时带有SYN=1，ACK=1的封包。其中那个acknowledge的号码是要给client端确认用的，所以该数字会比（A步骤）里面的Sequence号码多一号（ack = 10001+1 = 10002）。
</p>

<p>
伺服器也必须要确认用户端确实可以接收我们的封包才行，所以也会发送出一个Sequence(seq=20001) 给用户端,并且开始等待用户端回应。
</p>

<p>
C：回送确认封包（ACK=1,ack=20002）
</p>

<p>
当用户端收到来自伺服器端的ACK数字(10002)后就能够确认之前那个要求封包被正确的收受了，接下来如果用户端也同意与伺服器端建立连线时,就会再次的发送一个确认封包 (ACK=1) 给伺服器,亦即是 acknowledge = 20001+1 = 20002。
</p>

<p>
D：取得最后确认
若一切都顺利。在伺服器端收到带有ACK=1且ack=20002序号的封包后,就能够建立起这次的连线了。
</p>

<p>
在建立了连线之后该次连线通道就可以在用户端与伺服器端建立起一对socket pair，然后通过该socket pair进行TCP封包的PSH、FIN等传输与连线中断等动作。
</p>


<p>
UDP协议
</p>

<p>
UDP协议中不用进行三次握手验证所以速度快，但可靠性也低。
</p>

<pre class="brush: bash">
            16 bits                         16 bits             
|------------------------------||------------------------------|
----------------------------------------------------------------
|        Source Port           ||      Destination Port        |
----------------------------------------------------------------
|        Message Length        ||        Check Sum             |
----------------------------------------------------------------
|                        Data                                  |
----------------------------------------------------------------
</pre>


<p>
ICMP协议
</p>

<p>
ICMP的全称是Internet Control Message Protocol，网际网路讯息控制协定。基本上ICMP是一个错误侦测与回报的机制，最大的功能就是可以确保我们网路的连线状态与连线的正确性。最简单的指令就是ping与traceroute。这两个指令可以透过ICMP封包的辅助来确认与回报网路主机的状态。
</p>


<p>
类别代号对应的名称与意义：
0 Echo Reply (代表一个回应信息)
3 Destination Unreachable (表示目的地不可到达)
4 Source Quench (当 router 的负载过高时,此类别码可用来让发送端停止发送讯息)
5 Redirect (用来重新导向路由路径的资讯)
8 Echo Request (请求回应讯息)
11 Time Exceeded for a Datagram (当资料封包在某些路由传送的现象中造成逾时状态,此类别码可告知来源该封包已被忽略的讯息)
12 Parameter Problem on a Datagram (当一个 ICMP 封包重复之前的错误时,会回覆来源主机关于参数错误的讯息)
13 Timestamp Request (要求对方送出时间讯息,用以计算路由时间的差异,以满足同步性协定的要求)
14 Timestamp Reply (此讯息纯粹是回应 Timestamp Request 用的)
15 Information Request (在 RARP 协定应用之前,此讯息是用来在开机时取得网路信息)
16 Information Reply (用以回应 Infromation Request 讯息)
17 Address Mask Request (这讯息是用来查询子网路 mask 设定信息)
18 Address Mask Reply (回应子网路 mask 查询讯息的)
</p>

<p>
在设定防火墙的时候, 我们最容易忽略的就是这个 ICMP 的封包了,因为只会记住TCP/UDP 而已~事实上, ICMP 封包可以帮助连线的状态回报,除了上述的 8 可以考虑关闭之外,基本上, ICMP 封包也不应该全部都挡掉喔!
</p>

<h1 id="toc_2">网络配置</h1>

<h2 id="toc_2.1">检查网卡</h2>

<p>
检查网卡是否被系统内核检测到：
</p>

<pre class="brush: bash">
# dmesg | grep -in eth                                                                                                                                                                                         ──(Tue,Sep11)─┘
...
1063:[   17.994372] sky2 0000:86:00.0: eth0: Link is up at 1000 Mbps, full duplex, flow control rx
1064:[   17.994846] ADDRCONF(NETDEV_CHANGE): eth0: link becomes ready
...
</pre>

<p>
可以看到etho对应的模块号“0000:86:00.0”。通过这个号找到网卡对应的相关模块信息：
</p>

<pre class="brush: bash">
# lspci
...
86:00.0 Ethernet controller: Marvell Technology Group Ltd. 88E8072 PCI-E Gigabit Ethernet Controller (rev 10)
</pre>

<p>
再根据模块去找对应的驱动程序：
</p>

<pre class="brush: bash">
# cd /lib/modules/`uname -r`/kernel/drivers/net
# modinfo 3c59x.ko

filename:
3c59x.ko
author:
Donald Becker &lt;becker@scyld.com&gt;
description:
3Com 3c59x/3c9xx ethernet driver LK1.1.19 10 Nov 2002
license:
GPL
version:
LK1.1.19 DBFD1C112761D573276AC45
parm:
debug:3c59x debug level (0-6)
.....以下省略.....
</pre>







<h2 id="toc_2.2">网络的启动与关闭</h2>

<p>
重启网络：
</p>
<pre class="brush: bash">
/etc/init.d/network restart
Debian系：
{{{class="brush: bash"
/etc/init.d/networking restart
</pre>

<p>
启动/关闭网络：
</p>
<pre class="brush: bash">
ifup eth0
ifdown eth0
</pre>
<p>
Debian系：
</p>
<pre class="brush: bash">
ifconfig eth0 up
ifconfig eth0 down
</pre>



<h2 id="toc_2.3">配置主机名</h2>
 
<pre class="brush: bash">
/etc/sysconfig/network
</pre>
<p>
Debian系为：       
</p>
<pre class="brush: bash">
/etc/hostname
</pre>



<h2 id="toc_2.4">网卡设定</h2>
<p>
Debian系配置文件为： /etc/network/interfaces                                                                                                                                                     ──(Tue,Sep11)─┘
</p>

<p>
动态取IP把内容设置为：
</p>

<pre class="brush: bash">
auto lo
iface lo inet loopback
</pre>

<p>
如果要静态IP则把内容设置为：
</p>

<pre class="brush: bash">
auto eth1
iface eth1 inet static
address 10.10.103.77
netmask 255.255.255.0
gateway 10.10.103.20
</pre>

<p>
重启网卡后生效。除了配置文件，也通过命令动态取IP：
</p>

<pre class="brush: bash">
sudo dhclient eth0
</pre>



<h2 id="toc_2.5">域名解析</h2>

<p>
本地域名解析：
</p>
<pre class="brush: bash">
/etc/hosts
</pre>

<p>
DNS域名解析：
</p>
<pre class="brush: bash">
/etc/resolv.conf
</pre>
<p>
内容形式为：
</p>
<pre class="brush: bash">
nameserver 202.119.230.8
</pre>

<p>
测试域名解析：
</p>
            
<pre class="brush: bash">
# nslookup www.google.com                                                                                                                                                         ──(Tue,Sep11)─┘
Server:		127.0.0.1
Address:	127.0.0.1#53

Non-authoritative answer:
www.google.com	canonical name = www.l.google.com.
Name:	www.l.google.com
Address: 74.125.141.103
Name:	www.l.google.com
Address: 74.125.141.104
Name:	www.l.google.com
Address: 74.125.141.105
Name:	www.l.google.com
Address: 74.125.141.106
Name:	www.l.google.com
Address: 74.125.141.147
Name:	www.l.google.com
Address: 74.125.141.99
</pre>


<p>
TCP/IP服务对应的端口：  
</p>
<pre class="brush: bash">
/etc/services
</pre>

<p>
IP封包设定：      
</p>
<pre class="brush: bash">
/etc/protocols
</pre>




<h2 id="toc_2.6">无线网络</h2>
<p>
每一台AP都有一个ESSID/SSID。
</p>

<p>
查看无线连接信息：  
</p>
<pre class="brush: bash">
# iwconfig                                                                                                                                                                        ──(Tue,Sep11)─┘
lo        no wireless extensions.

wlan0     IEEE 802.11abgn  ESSID:off/any  
          Mode:Managed  Access Point: Not-Associated   Tx-Power=15 dBm   
          Retry  long limit:7   RTS thr:off   Fragment thr:off
          Power Management:off
          
eth0      no wireless extensions.
</pre>


<h2 id="toc_2.7">查找无线网络</h2>

<pre class="brush: bash">
# iwlist scanning                                                                                                                                                                 ──(Tue,Sep11)─┘
lo        Interface doesn't support scanning.

wlan0     Scan completed :
          Cell 01 - Address: 28:94:0F:79:8A:01
                    Channel:1
                    Frequency:2.412 GHz (Channel 1)
                    Quality=46/70  Signal level=-64 dBm  
                    Encryption key:on
                    ESSID:"GoldenDay"
                    Bit Rates:1 Mb/s; 2 Mb/s; 5.5 Mb/s; 11 Mb/s; 6 Mb/s
                              9 Mb/s; 12 Mb/s; 18 Mb/s
                    Bit Rates:24 Mb/s; 36 Mb/s; 48 Mb/s; 54 Mb/s
                    ESSID:""
                    ESSID:""
                    Mode:Master
                    Extra:tsf=00000000000f9d80
                    Extra: Last beacon: 5940ms ago
                    IE: Unknown: 0009476F6C64656E446179
                    IE: Unknown: 010882848B960C121824
                    IE: Unknown: 030101
                    IE: Unknown: 050400010300
                    IE: Unknown: 2A0100
                    IE: IEEE 802.11i/WPA2 Version 1
                        Group Cipher : TKIP
                        Pairwise Ciphers (2) : CCMP TKIP
                        Authentication Suites (1) : PSK
                       Preauthentication Supported
                    IE: WPA Version 1
                        Group Cipher : TKIP
                        Pairwise Ciphers (2) : CCMP TKIP
                        Authentication Suites (1) : PSK
                    IE: Unknown: 32043048606C
                    IE: Unknown: DD180050F2020101840003A4000027A4000042435E006232DDDD
                    IE: Unknown: DD1E00904C334E101BFFFF000000000000000000000000000000000000000000
                    IE: Unknown: 2D1A4E101BFFFF000000000000000000000000000000000000000000
                    IE: Unknown: DD1A0090483001001B00000000000000000000000000000000000000
                    IE: Unknown: 391201001B000000000000000000000000000000
                    IE: Unknown: 0000
                    IE: Unknown: 0000
                    IE: Unknown: 4A0E14000A002C01C800140005001900
                    IE: Unknown: 7F0101
                    IE: Unknown: DD0900037F01010000FF7F
                    IE: Unknown: DD0A00037F04010006004000
                    IE: Unknown: DD3F0050F204104A0001101044000102104700100000000000001000000028940F798A01103C000103104900140024E26002000101600000020001600100020001
          Cell 02 - Address: BC:AE:C5:C3:86:6A
                    Channel:6
                    Frequency:2.437 GHz (Channel 6)
                    Quality=45/70  Signal level=-65 dBm  
                    Encryption key:on
                    ESSID:"izenesoft"
                    Bit Rates:1 Mb/s; 2 Mb/s; 5.5 Mb/s; 11 Mb/s; 18 Mb/s
                              24 Mb/s; 36 Mb/s; 54 Mb/s
                    Bit Rates:6 Mb/s; 9 Mb/s; 12 Mb/s; 48 Mb/s
                    Mode:Master
                    Extra:tsf=00000032de35f203
                    Extra: Last beacon: 5404ms ago
                    IE: Unknown: 0009697A656E65736F6674
                    IE: Unknown: 010882848B962430486C
                    IE: Unknown: 030106
                    IE: Unknown: 050400010000
                    IE: Unknown: 2A0104
                    IE: Unknown: 2F0104
                    IE: IEEE 802.11i/WPA2 Version 1
                        Group Cipher : CCMP
                        Pairwise Ciphers (1) : CCMP
                        Authentication Suites (1) : PSK
                    IE: Unknown: 32040C121860
                    IE: Unknown: 2D1AEC181BFFFF000000000000000000000000000000000000000000
                    IE: Unknown: 3D1606080400000000000000000000000000000000000000
                    IE: Unknown: DD09001018020FF0050000
                    IE: Unknown: DD180050F2020101800003A4000027A4000042435E0062322F00

eth0      Interface doesn't support scanning.
</pre>


<p>
可以看到每个可用网络的ESSID，然后可以手动连接：
</p>
 
<pre class="brush: bash">
# iwconfig wlan0 essid 'izenesoft' key 'p@ssw0rd'
</pre>

<p>
查看连接信息：
</p>
 
<pre class="brush: bash">
# iwconfig wlan0
</pre>


<h1 id="toc_3">基本工具</h1>



<ol>
<li>
===========================

</ol>
<p>
#
</p>
<ol>
<li>
ifconfig

</ol>
<p>
#
</p>
<ol>
<li>
===========================

</ol>

<p>
ifconfig 主要是可以手动的启动、观察与修改网络接口的相关参数:
</p>

<p>
[root@www ~]# ifconfig {interface} {up|down} &lt;== 观察与启动接口
[root@www ~]# ifconfig interface {options}   &lt;== 设定与修改接口
</p>

<p>
选项与参数:
	interface:网络卡接口代号,包括 eth0, eth1, ppp0 等等
	options :可以接的参数,包括如下:
	up, down :启动 (up) 或关闭 (down) 该网络接口(不涉及任何参数)
	mtu :可以设定不同的 MTU 数值,例如 mtu 1500 (单位为 byte)
	netmask :就是子屏蔽网络;
	broadcast:就是广播地址啊!
</p>

<p>
一般来说, 直接输入 ifconfig 就会列出目前已经被启动的卡,不论这个卡是否有给予都会被显示出来。 
</p>

<p>
而如果是输入 ifconfig eth0, 则仅会秀出这张接口的相关数据, IP, 而不管该接口是否有启动。
</p>

<ol>
<li>
范例一:观察所有的网络接口(直接输入 ifconfig)

</ol>

<p>
[root@www ~]# ifconfig eth0
Link encap:Ethernet HWaddr 08:00:27:71:85:BD
inet addr:192.168.1.100 Bcast:192.168.1.255 Mask:255.255.255.0
inet6 addr: fe80::a00:27ff:fe71:85bd/64 Scope:Link
UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1
RX packets:2555 errors:0 dropped:0 overruns:0 frame:0
TX packets:70 errors:0 dropped:0 overruns:0 carrier:0 
collisions:0 txqueuelen:1000
RX bytes:239892 (234.2 KiB) TX bytes:11153 (10.8 KiB)
</p>

<p>
各参数的意义：
	eth0:就是网络卡的代号,也有 lo 这个 loopback ;
	HWaddr:就是网络卡的硬件地址,俗称的 MAC 是也;
	inet addr:IPv4 的 IP 地址,
		后续的 Bcast, Mask 分别代表的是Broadcast 与 netmask
	inet6 addr:是 IPv6 的版本的 IP ,我们没有使用,所以略过;
	MTU:就是第二章谈到的 MTU 啊!
	RX:那一行代表的是网络由启动到目前为止的封包接收情况, 
		packets 代表封包数、
		errors 代表封包发生错误的数量、 
		dropped 代表封包由于有问题而遭丢弃的数量等等
	TX:与 RX 相反,为网络由启动到目前为止的传送情况;
	collisions:代表封包碰撞的情况,如果发生太多次, 表示你的网络状况不太好;
	txqueuelen:代表用来传输数据的缓冲区的储存长度;
	RX bytes, TX bytes:总接收、发送字节总量
</p>


<p>
范例二:暂时修改网络接口,给予 eth0 一个 192.168.100.100/24 的参数
如果不加任何其他参数,则系统会依照该 IP 所在的 class 范围,自动的 计算出netmask 以及 network, broadcast 等 IP 参数,
</p>

<p>
[root@www ~]# ifconfig eth0 192.168.100.100
</p>

<p>
若想改其他参数则:
</p>

<p>
[root@www ~]# ifconfig eth0 192.168.100.100 netmask 255.255.255.128 mtu 8000
</p>
<ol>
<li>
设定不同参数的网络接口,同时设定 MTU 的数值!

</ol>

<p>
[root@www ~]# ifconfig eth0 mtu 9000
</p>
<ol>
<li>
仅修改该接口的 MTU 数值,其他的保持不动!

</ol>

<p>
[root@www ~]# ifconfig eth0:0 192.168.50.50
</p>
<ol>
<li>
仔细看那个界面是 eth0:0 那就是在该实体网卡上,再仿真一个网络接口, 即是在一张网络卡上面设定多个 IP。 

</ol>

<p>
[root@www ~]# ifconfig
eth0   Link encap:Ethernet HWaddr 08:00:27:71:85:BD
</p>
<blockquote>
inet addr:192.168.100.100 Bcast:192.168.100.127
Mask:255.255.255.128
inet6 addr: fe80::a00:27ff:fe71:85bd/64 Scope:Link
UP BROADCAST RUNNING MULTICAST MTU:9000 Metric:1
RX packets:2555 errors:0 dropped:0 overruns:0 frame:0
TX packets:70 errors:0 dropped:0 overruns:0 carrier:0
collisions:0 txqueuelen:1000
RX bytes:239892 (234.2 KiB) TX bytes:11153 (10.8 KiB)
</blockquote>

<p>
eth0:0 Link encap:Ethernet HWaddr 08:00:27:71:85:BD
</p>
<blockquote>
inet addr:192.168.50.50 Bcast:192.168.50.255
Mask:255.255.255.0
UP BROADCAST RUNNING MULTICAST MTU:9000 Metric:1
</blockquote>

<p>
与硬件有关的信息都相同，因为是同一张网卡。
</p>

<p>
如果想要将刚刚建立的那张 eth0:0 关闭, 不影响原有的 eth0
</p>

<p>
[root@www ~]# ifconfig eth0:0 down
</p>
<ol>
<li>
关掉 eth0:0 这个界面。

</ol>

<p>
那如果想用默认值启动 eth1: ifconfig eth1 up 即可达成
</p>

<p>
范例三:将手动的处理全部取消,使用原有的设定值重建网络参数:
</p>

<p>
[root@www ~]# /etc/init.d/network restart
</p>

<p>
这样刚刚设定的数据全部失效,会以 ifcfg-ethX 的设定为主!
</p>

<p>
可以利用 /etc/init.d/network restart 来重新启动整个网络接口,那么之前手动的设定数据会全部失效。
</p>

<p>
另外, 要启动某个网络接口,但又不让他具有 IP 参数时,直接给他 ifconfig eth0 up 即可! 这个动作经常在无线网卡当中会进行,因为我们必须要启动无线网卡让他去侦测 AP 存在与否啊!
</p>




<ol>
<li>
===========================

</ol>
<p>
#
</p>
<ol>
<li>
route

</ol>
<p>
#
</p>
<ol>
<li>
===========================

</ol>

<p>
只要有网络接口, 接口就会产生一个路由, 所以主机有一个 eth0 的接口, 看起来就会是这样:
</p>

<p>
[root@www ~]# route [-nee]
[root@www ~]# route add [-net|-host] [网域或主机] netmask [mask] [gw|dev]
[root@www ~]# route del [-net|-host] [网域或主机] netmask [mask] [gw|dev]
</p>

<p>
参数说明:
</p>

<p>
	-n :不要使用通讯协议或主机名,直接使用 IP 或 port number;
	-ee :使用更详细的信息来显示
</p>

<p>
增加 (add) 与删除 (del) 路由的相关参数:
</p>

<p>
	-net :表示后面接的路由为一个网域;
	-host :表示后面接的为连接到单部主机的路由;
	netmask :与网域有关,可以设定 netmask 决定网域的大小;
	gw :gateway 的简写,后续接的是 IP 的数值喔,与 dev 不同;
	dev :如果只是要指定由那一块网络卡联机出去,则使用这个设定, 后面接 eth0 等
</p>

<p>
范例一:单纯的观察路由状态
</p>

<p>
┌─(morgan@morgan-laptop:pts/3)────────────────────────(~/workspace/study/net)─┐
└─(130:19:40:%)── route                                         ──(Wed,Sep12)─┘
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
default         192.168.1.1     0.0.0.0         UG    0      0        0 wlan0
link-local      *               255.255.0.0     U     1000   0        0 wlan0
192.168.1.0     *               255.255.255.0   U     2      0        0 wlan0
</p>

<p>
┌─(morgan@morgan-laptop:pts/3)────────────────────────(~/workspace/study/net)─┐
└─(19:40:%)── route -n                                          ──(Wed,Sep12)─┘
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
0.0.0.0         192.168.1.1     0.0.0.0         UG    0      0        0 wlan0
169.254.0.0     0.0.0.0         255.255.0.0     U     1000   0        0 wlan0
192.168.1.0     0.0.0.0         255.255.255.0   U     2      0        0 wlan0
</p>

<p>
不加-n会去查主机名。有加 -n 参数的主要是显示出 IP，所以加了-n能省去了查IP的时间。
</p>

<p>
从上面也可以知道 default = 0.0.0.0/0.0.0.0
</p>

<p>
Destination, Genmask:这两个玩意儿就是分别是 network 与 netmask 啦!  所以这两个就组合成为一个完整的网域!
Gateway:该网域是通过哪个 gateway 连接出去的?如果显示 0.0.0.0 表示该路由是直接由本机传送,亦即可以透过局域网络的 MAC 直接传讯;如果有显示 IP 的话,表示该路由需要经过路由器 (通讯闸) 的帮忙才能够传送出去。
Flags:总共有多个旗标,代表的意义如下: 
	U (route is up):该路由是启动的;
	H (target is a host):目标是一部主机 (IP) 而非网域;
	G (use gateway):需要透过外部的主机 (gateway) 来转递封包;
	R (reinstate route for dynamic routing):使用动态路由时,恢复路由信息的旗标;
	D (dynamically installed by daemon or redirect):已经由服务或转 port 功能设定为动态路由
	M (modified from routing daemon or redirect):路由已经被修改了;
	! (reject route): 这个路由将不会被接受(用来抵挡不安全的网域!)
Iface:这个路由传递封包的接口。
</p>

<p>
此外,观察一下上面的路由排列顺序喔,依序是由小网域 (192.168.1.0/24 是 Class C),逐渐到大网域 (169.254.0.0/16 Class B) 最后则是预设路由 (0.0.0.0/0.0.0.0)。 然后当我们要判断某个网络封包应该如何传送的时候,该封包会经由这个路由的过程来判断喔! 
</p>

<p>
举例来说,我上头仅有三个路由,若我有一个传往 192.168.1.20 的封包要传递, 那首先会找 192.168.1.0/24 这个网域的路由, 找到了! 所以直接由 eth0 传送出去;
</p>

<p>
如果是传送到 Yahoo 的主机呢? Yahoo 的主机 IP 是 119.160.246.241, 我们通过判断 
1)不是 192.168.1.0/24 
2)不是 169.254.0.0/16 
3)到达0.0.0.0/0时,OK!  传出去了,把封包传给一条的网关192.168.1.1主机
所以说,路由是有顺序的。
</p>

<p>
因此当你重复设定多个同样的路由时, 例如在你的主机上的两张网络卡设定为相同网域的 IP 时,会出现如下的情况:
</p>

<p>
┌─(morgan@morgan-laptop:pts/3)────────────────────────(~/workspace/study/net)─┐
└─(19:40:%)── route -n                                          ──(Wed,Sep12)─┘
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
192.168.1.0     0.0.0.0         255.255.255.0   U     2      0        0 eth0 
192.168.1.0     0.0.0.0         255.255.255.0   U     2      0        0 eth1
</p>

<p>
也就是说, 由于路由是依照顺序来排列与传送的, 所以不论封包是由那个界面 (eth0, eth1) 所接收,都会由上述的 eth0 传送出去, 所以,在一部主机上面设定两个相同 网域的 IP 本身没有什么意义!有点多此一举就是了。 除非是类似虚拟机 (Xen, VMware 等软件) 所架设的多主机时,才会有这个必要。
</p>

<ol>
<li>
范例二:路由的增加与删除

</ol>

<p>
[root@www ~]# route del -net 169.254.0.0 netmask 255.255.0.0 dev eth0
</p>

<p>
上面这个动作可以删除掉 169.254.0.0/16 这个网域。请注意,在删除的时候,需要将路由表上面出现的信息都写入包括 netmask , dev 等等参数。
</p>

<p>
[root@www ~]# route add -net 192.168.100.0 netmask 255.255.255.0 dev eth0
</p>

<p>
透过 route add 来增加一个路由!请注意,这个路由的设定必须要能够与你的网络互通。举例来说,如果我下达底下的指令就会显示错误:
</p>

<p>
route add -net 192.168.200.0 netmask 255.255.255.0 gw 192.168.200.254
</p>

<p>
因为我的主机内仅有 192.168.1.11 这个 IP ,所以不能直接与 192.168.200.254这个网段直接使用 MAC 互通。
</p>

<p>
[root@www ~]# route add default gw 192.168.1.250
增加预设路由的方法!请注意,只要有一个预设路由就够了喔!
同样的,那个 192.168.1.250 的 IP 也需要能与你的 LAN 沟通才行!
在这个地方如果你随便设定后,记得使用底下的指令重新设定你的网络
/etc/init.d/network restart
</p>

<p>
其实,使用 man route里面的数据就很丰富了!仔细查阅一下! 你只要记得,当出现『SIOCADDRT: Network is unreachable』 这个错误时,肯定是由于 gw 后面接的 IP 无法直接与你的网域沟通 (Gateway 并不在你的网域内), 所以,赶紧检查一下是否输入错误啊!
</p>

<p>
Tips:
一般来说,鸟哥如果接触到一个新的环境内的主机,在不想要更动
原系统的配置文件情况下,然后预计使用本书的网络环境设定时,
手动的处理就变成:『ifconfig eth0 192.168.1.100; route add
default gw 192.168.1.254』这样就搞定了! 直接联网与测试。等
到完成测试后,
再给她 /etc/init.d/network restart 恢复原系统
的网络即可
</p>




<ol>
<li>
===========================

</ol>
<p>
#
</p>
<ol>
<li>
ip

</ol>
<p>
#
</p>
<ol>
<li>
===========================

</ol>

<p>
ip 是指令喔！K不是那 TCP/IP 的 IP 啦！@ ip 指令的功能可多了！基本上，他就是整合了 ifconfig c route @指令印不^， ip 可以_成的功能s又多更多！真是相害的指令。如果你有d趣的，自行 vi /sbin/ifup ，就知道整 ifup 就是利用 ip @指令磉_成的。好了，如何使用呢？我砬埔磺葡龋
</p>

<p>
[root@www ~]# ip [option] [幼] [指令]
</p>

<p>
xc担
</p>

<p>
option ：O定的担主要有：
</p>
<blockquote>
-s ：@示出b置的y(statistics)，例如接受封包档龋
</blockquote>

<p>
幼鳎阂嗉词强梢葬δ男┚W路颠M行幼鳎包括有：
</p>
<blockquote>
link  ：P於b置 (device) 的相PO定，包括 MTU, MAC 位址等等
addr/address ：P於~外的 IP f定，例如多 IP 的_成等等；
route ：c路由有P的相PO定
</blockquote>

<p>
底下我就分三部分 (link, addr, route) 斫榻B@ ip 指令吧！
</p>


<ol>
<li>
===========================

</ol>
<p>
#
</p>
<ol>
<li>
ip link

</ol>
<p>
#
</p>
<ol>
<li>
===========================

</ol>

<p>
P於b置介面 (device) 的相PO定： ip link
</p>

<p>
ip link 可以O定cb置 (device) 有P的相P担包括 MTU 以及W路介面的 MAC 等等，然也可以 (up) 或P] (down) 某W路介面啦！整Z法是@拥模
</p>

<p>
[root@www ~]# ip [-s] link show  &lt;== 渭的查b置相P的Y
[root@www ~]# ip link set [device] [幼髋c]
xc担
show：H@示出@b置的相P热荩如果加上 -s @示更多y；
set ：可以_始O定目， device 指的是 eth0, eth1 等等介面代；
幼髋c担喊括有底下的@些幼鳎
   up|down  ： (up) 或P] (down) 某介面，其他凳褂妙AO的乙太W路；
   address  ：如果@b置可以更改 MAC 的，用@敌薷模
   name     ：o予@b置一特殊的名字；
   mtu      ：就是最大鬏卧啊！
</p>

<ol>
<li>
例一：@示出所有的介面Y

</ol>
<p>
[root@www ~]# ip link show
1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 16436 qdisc noqueue state UNKNOWN
</p>
<blockquote>
link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
</blockquote>
<p>
2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP qlen 1000
</p>
<blockquote>
link/ether 08:00:27:71:85:bd brd ff:ff:ff:ff:ff:ff
</blockquote>
<p>
3: eth1: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN qlen 1000
</p>
<blockquote>
link/ether 08:00:27:2a:30:14 brd ff:ff:ff:ff:ff:ff
</blockquote>
<p>
4: sit0: &lt;NOARP&gt; mtu 1480 qdisc noop state DOWN
</p>
<blockquote>
link/sit 0.0.0.0 brd 0.0.0.0
</blockquote>

<p>
[root@www ~]# ip -s link show eth0
2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP qlen 1000
</p>
<blockquote>
link/ether 08:00:27:71:85:bd brd ff:ff:ff:ff:ff:ff
RX: bytes  packets  errors  dropped overrun mcast
314685     3354     0       0       0       0
TX: bytes  packets  errors  dropped carrier collsns
27200      199      0       0       0       0
</blockquote>

<p>
使用 ip link show 可以@示出整b置介面的硬w相PY，如上所示，包括W卡位址(MAC)、MTU等等， 比^有趣的是那 sit0 的介面了，那 sit0 的介面是用在 IPv4 及 IPv6 的封包DQ上的， 於我H使用 IPv4 的W路是]有作用的。 lo 及 sit0 都是主C炔克自行O定的。 而如果加上 -s 的滇幔t@W路卡的相PyY就被列出恚 包括接收 (RX) 及魉 (TX) 的封包盗康鹊龋的热菖c ifconfig 所出的Y果相同的。
</p>

<ol>
<li>
例二：印㈥P]cO定b置的相PY

</ol>
<p>
[root@www ~]# ip link set eth0 up
</p>
<ol>
<li>
 eth0 @b置介面；

</ol>

<p>
[root@www ~]# ip link set eth0 down
</p>
<ol>
<li>
阿就P]啊！蔚囊命～

</ol>

<p>
[root@www ~]# ip link set eth0 mtu 1000
</p>
<ol>
<li>
更改 MTU 的值，_到 1000 bytes，挝痪褪 bytes 啊！

</ol>

<p>
更新W路卡的 MTU 使用 ifconfig 也可以_成啊！]啥了不起，不^，如果是要更改『W路卡代、 MAC 位址的Y』的，那可就得使用 ip 印不^，O定前可能得要先P]W路卡，否t不成功。 如下所示：
</p>

<ol>
<li>
例三：修改W路卡代、MAC 等

</ol>
<p>
[root@www ~]# ip link set eth0 name vbird
SIOCSIFNAME: Device or resource busy
</p>
<ol>
<li>
因樵b置目前是拥模所以不能@幼鲈O定。你要@幼觯

</ol>

<p>
[root@www ~]# ip link set eth0 down       &lt;==P]介面
[root@www ~]# ip link set eth0 name vbird &lt;==重新O定
[root@www ~]# ip link show                &lt;==^察一下
2: vbird: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP qlen 1000
</p>
<blockquote>
link/ether 08:00:27:71:85:bd brd ff:ff:ff:ff:ff:ff
</blockquote>
<ol>
<li>
怕了吧！BW路卡代都可以改！不^，玩玩後得改回戆。

<li>
因槲的 ifcfg-eth0 是使用原本的b置代！避免有}，要改回

</ol>

<p>
[root@www ~]# ip link set vbird name eth0 &lt;==介面改回
</p>

<p>
[root@www ~]# ip link set eth0 address aa:aa:aa:aa:aa:aa
[root@www ~]# ip link show eth0
</p>
<ol>
<li>
如果你的W路卡支援硬w位址(MAC)可以更改的，上面@幼骶涂梢愿改

<li>
你的W路卡位址了！害吧！不^，是那句老，y完之後立刻改回戆。

</ol>

<p>
在@b置的硬w相PYO定上面，包括 MTU, MAC 以及鬏的模式等等，都可以在@eO定。 有趣的是那 address 的目，那目後面接的可是硬w位址 (MAC) 而不是 IP 喔！ 很容易搞e啊！切切！更多的硬w悼梢允褂 man ip 查一下c ip link 有P的O定。
</p>




<ol>
<li>
===========================

</ol>
<p>
#
</p>
<ol>
<li>
ip addr

</ol>
<p>
#
</p>
<ol>
<li>
===========================

</ol>

<p>
如果f ip link 是c OSI 七f定 的第二淤Y料BA佑嘘P的，那N ip address (ip addr) 就是c第三泳W路佑嘘P的道玻 主要是在O定c IP 有P的各担包括 netmask, broadcast 等等。
</p>

<p>
[root@www ~]# ip address show   &lt;==就是查 IP 蛋。
</p>

<p>
[root@www ~]# ip address [add|del] [IP] [dev b置名] [相P]
xc担
show    ：渭的@示出介面的 IP Y啊；
add|del ：M行相P档脑黾 (add) 或h除 (del) O定，主要有：
</p>
<blockquote>
IP 担褐饕就是W域的O定，例如 192.168.100.100/24 之的O定喔；
dev    ：@ IP 邓要O定的介面，例如 eth0, eth1 等等；
相P担褐饕有底下@些：
broadcast：O定V播位址，如果O定值是 + 表示『系y自佑算』
label    ：亦即是@b置的e名，例如 eth0:0 就是了！
scope    ：@介面的I域，通常是@大：
global ：允S碜运有碓吹倪B；
site   ：H支援 IPv6 ，H允S本主C的B；
link   ：H允S本b置自我B；
host   ：H允S本主C炔康倪B；
所以然是使用 global 樱☆AO也是 global 啦！
</blockquote>

<p>
例一：@示出所有的介面之 IP 担
</p>

<p>
[root@www ~]# ip address show
1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 16436 qdisc noqueue state UNKNOWN
</p>
<blockquote>
link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
inet 127.0.0.1/8 scope host lo
inet6 ::1/128 scope host
valid_lft forever preferred_lft forever
</blockquote>
<p>
2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP qlen 1000
</p>
<blockquote>
link/ether 08:00:27:71:85:bd brd ff:ff:ff:ff:ff:ff
inet 192.168.1.100/24 brd 192.168.1.255 scope global eth0
inet6 fe80::a00:27ff:fe71:85bd/64 scope link
valid_lft forever preferred_lft forever
</blockquote>
<p>
3: eth1: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN qlen 1000
</p>
<blockquote>
link/ether 08:00:27:2a:30:14 brd ff:ff:ff:ff:ff:ff
</blockquote>
<p>
4: sit0: &lt;NOARP&gt; mtu 1480 qdisc noop state DOWN
</p>
<blockquote>
link/sit 0.0.0.0 brd 0.0.0.0
</blockquote>

<p>
看到上面那
</p>
<blockquote>
inet 192.168.1.100/24 brd 192.168.1.255 scope global eth0
</blockquote>
<p>
]e！那就是 IP 道玻∫彩 ip address 最主要的功能。 底下我M一步硇略鎏M的W路介面看看：
</p>

<p>
例二：新增一介面，名Q假O eth0:vbird 
</p>

<p>
[root@www ~]# ip address add 192.168.50.50/24 broadcast + \
&gt; dev eth0 label eth0:vbird
[root@www ~]# ip address show eth0
2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP qlen 1000
</p>
<blockquote>
link/ether 08:00:27:71:85:bd brd ff:ff:ff:ff:ff:ff
inet 192.168.1.100/24 brd 192.168.1.255 scope global eth0
inet 192.168.50.50/24 brd 192.168.50.255 scope global eth0:vbird
inet6 fe80::a00:27ff:fe71:85bd/64 scope link
valid_lft forever preferred_lft forever
</blockquote>

<p>
看到上面的
这一行了吧？多出了一行新的介面，且名Q是 eth0:vbird
至於那 broadcast + 也可以成 broadcast 192.168.50.255 啦！
</p>

<p>
[root@www ~]# ifconfig
eth0:vbird Link encap:Ethernet  HWaddr 08:00:27:71:85:BD
</p>
<blockquote>
inet addr:192.168.50.50  Bcast:192.168.50.255  Mask:255.255.255.0
UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
</blockquote>

<p>
如果使用 ifconfig 就能蚩吹竭@怪|西了！可郯桑 <sup><small>_</small></sup>
</p>

<ol>
<li>
例三：的介面h除 

</ol>
<p>
[root@www ~]# ip address del 192.168.50.50/24 dev eth0
</p>
<ol>
<li>
h除就比^伟。 <sup><small>_</small></sup>

</ol>




<ol>
<li>
===========================

</ol>
<p>
#
</p>
<ol>
<li>
ip route

</ol>
<p>
#
</p>
<ol>
<li>
===========================

</ol>

<p>
[root@www ~]# ip route show  &lt;==渭的@示出路由的O定而已
[root@www ~]# ip route [add|del] [IP或W域] [via gateway] [dev b置]
xc担
show ：渭的@示出路由表，也可以使用 list ；
add|del ：增加 (add) 或h除 (del) 路由的意思。
</p>
<blockquote>
IP或W域：可使用 192.168.50.0/24 之的W域或者是渭的 IP ；
via     ：哪 gateway 出去，不一定需要；
dev     ：由那b置B出去，@就需要了！
mtu     ：可以~外的O定 MTU 的抵掂福
</blockquote>

<ol>
<li>
例一：@示出目前的路由Y料

</ol>
<p>
[root@www ~]# ip route show
192.168.1.0/24 dev eth0  proto kernel  scope link  src 192.168.1.100
169.254.0.0/16 dev eth0  scope link  metric 1002
default via 192.168.1.254 dev eth0
</p>

<p>
如上表所示，最蔚墓δ芫褪秋@示出目前的路由Y，其跟 route @指令相同啦！ 指示必要注意小|西：
</p>
<blockquote>
proto：此路由的路由f定，主要有 redirect, kernel, boot, static, ra 等， 其中 kernel 指的是直接由核心判嘧釉O定。
scope：路由的，主要是 link ，亦即是c本b置有P的直接B。
</blockquote>

<ol>
<li>
例二：增加路由，主要是本C直接可贤ǖ木W域

</ol>
<p>
[root@www ~]# ip route add 192.168.5.0/24 dev eth0
</p>
<ol>
<li>
ΡC直接贤ǖ木W域O定好路由，不需要透^外部的路由器

</ol>
<p>
[root@www ~]# ip route show
192.168.5.0/24 dev eth0  scope link
....(以下省略)....
</p>

<ol>
<li>
例三：增加可以通往外部的路由，需透^ router 喔！

</ol>
<p>
[root@www ~]# ip route add 192.168.10.0/24 via 192.168.5.100 dev eth0
[root@www ~]# ip route show
192.168.5.0/24 dev eth0  scope link
....(其他省略)....
192.168.10.0/24 via 192.168.5.100 dev eth0
</p>
<ol>
<li>
仔看喔，因槲矣 192.168.5.0/24 的路由存在 (我的W卡直接M)，

<li>
所以才可以 192.168.10.0/24 的路由Go 192.168.5.100 

<li>
那部主C兔鬟f喔！c之前提到的 route 指令是一拥南拗疲

</ol>

<ol>
<li>
例四：增加AO路由

</ol>
<p>
[root@www ~]# ip route add default via 192.168.1.254 dev eth0
</p>
<ol>
<li>
那 192.168.1.254 就是我的AO路由器 (gateway) 的意思啊！ <sup><small>_</small></sup>

<li>
真的得，只要一AO路由就 OK ！

</ol>

<ol>
<li>
例五：h除路由

</ol>
<p>
[root@www ~]# ip route del 192.168.10.0/24
[root@www ~]# ip route del 192.168.5.0/24
</p>




<ol>
<li>
===========================

</ol>
<p>
#
</p>
<ol>
<li>
手动使用DHCP

</ol>
<p>
#
</p>
<ol>
<li>
===========================

</ol>

<p>
[root@www ~]# dhclient eth0
</p>

<p>
蚝伟桑∵@泳涂梢粤⒖探形的W路卡以 dhcp f定去L取得 IP 喔！
</p>




<ol>
<li>
===========================

</ol>
<p>
#
</p>
<ol>
<li>
两部主机连通测试 ping

</ol>
<p>
#
</p>
<ol>
<li>
===========================

</ol>

<p>
[root@www ~]# ping [xc] IP
xc担
-c 抵担横崦娼拥氖绦 ping 的次担例如 -c 5 ；
-n     ：在出Y料r不M行 IP c主C名Q的反查，直接使用 IP 出(速度^快)；
-s 抵担喊l送出去的 ICMP 封包大小，AO 56bytes，不^你可以放大此一抵担
-t 抵担TTL 的抵担AO是 255，每^一c就少一；
-W 抵担旱却回Ψ街C的秒怠
-M [do|dont] ：主要在yW路的 MTU 抵荡笮。常的目是：
   do  ：代表魉鸵 DF (Don't Fragment) 旗耍封包不能重新拆包c打包；
   dont：代表不要魉 DF 旗耍表示封包可以在其他主C上拆包c打包
</p>

<ol>
<li>
例一：y一下 168.95.1.1 @部 DNS 主C是否存在？

</ol>
<p>
[root@www ~]# ping -c 3 168.95.1.1
PING 168.95.1.1 (168.95.1.1) 56(84) bytes of data.
64 bytes from 168.95.1.1: icmp_seq=1 ttl=245 time=15.4 ms
64 bytes from 168.95.1.1: icmp_seq=2 ttl=245 time=10.0 ms
64 bytes from 168.95.1.1: icmp_seq=3 ttl=245 time=10.2 ms
</p>

<p>
--- 168.95.1.1 ping statistics ---
3 packets transmitted, 3 received, 0% packet loss, time 2047ms
rtt min/avg/max/mdev = 10.056/11.910/15.453/2.506 ms
</p>

<p>
ping 最蔚墓δ芫褪魉 ICMP 封包去要求Ψ街C回是否存在於W路h境中，上面的回息中，重要的目是@拥模
</p>
<blockquote>
64 bytes：表示@次魉偷 ICMP 封包大小 64 bytes @N大，@是AO值， 在某些特殊龊现校例如要搜索整W路茸畲蟮 MTU r，可以使用 -s 2000 之的抵砣〈；
</blockquote>
<blockquote>
icmp_seq=1：ICMP 所yM行的次担第一次 1 ；
</blockquote>
<blockquote>
ttl=243：TTL c IP 封包鹊 TTL 是相同的，每^一в MAC 的c (node) r，例如 router, bridge r， TTL 就p少一，AO的 TTL  255 ， 你可以透^ -t 150 之的方法碇匦略O定AO TTL 抵担
</blockquote>
<blockquote>
time=15.4 ms：回rg，挝挥 ms(0.001秒)及 us(0.000001秒)， 一般碚f，越小的回rg，表示刹恐C之g的W路B越良好！
</blockquote>

<p>
特e注意一下，如果你的主Cc待y主CK不在同一W域龋 那N TTL AO使用 255 ，如果是同一W域龋那N TTL AOt使用 64 喔！
</p>



<p>
例}：
一支_本程式 ping.sh ，透^@支_本程式，你可以用 ping y整W域的主C是否有回。此外，每部主C的yH等待一秒，也Hy一次。
答：
由於Hy一次且等待一秒，因此 ping 的x椋 -W1 -c1 ，而位於本C所在的^W 192.168.1.0/24 ，所以可以@ (vim /root/bin/ping.sh)：
</p>

<p>
#!/bin/bash
for siteip in $(seq 1 254)
do
	site="192.168.1.${siteip}"
	ping -c1 -W1 ${site} &amp;&gt; /dev/null
	if [ "$?" == "0" ]; then
		echo "$site is UP"
	else
		echo "$site is DOWN"
	fi
done
</p>




<p>
用 ping 追路街械淖畲 MTU 抵
</p>

<p>
我由第二章的W路基Ae面到加大框 (frame) r， 於W路效能是有椭的，因榉獍打包的次p少，加上如果整鬏的媒w都能蚪邮苓@ frame 而不需要重新M行封包的拆解c重M的，那N效能然更好，那修改 frame 大小的稻褪 MTU 啦！
</p>

<p>
好了，F在我知道W路卡的 MTU 修改可以透^ ifconfig 或者是 ip 等指令磉_成，那N追整W路鬏的最大 MTU r，又如何查？呵呵！最蔚姆椒ó然是透^ ping 魉鸵大封包， K且不S中^的路由器或 switch ⒃封包重M，那就能蛱理啦！]e！可以@拥模
</p>

<ol>
<li>
例二：找出最大的 MTU 抵

</ol>
<p>
[root@www ~]# ping -c 2 -s 1000 -M do 192.168.1.254
PING 192.168.1.254 (192.168.1.254) 1000(1028) bytes of data.
1008 bytes from 192.168.1.254: icmp_seq=1 ttl=64 time=0.311 ms
</p>
<ol>
<li>
如果有回，那就是可以接受@封包，如果o回，那就表示@ MTU 太大了。

</ol>

<p>
[root@www ~]# ping -c 2 -s 8000 -M do 192.168.1.254
PING 192.168.1.254 (192.168.1.254) 8000(8028) bytes of data.
From 192.168.1.100 icmp_seq=1 Frag needed and DF set (mtu = 1500)
</p>
<ol>
<li>
@e`息是f，本地端的 MTU 才到 1500 而已，你要y 8000 的 MTU

<li>
根本就是o法_成的！那要如何是好？用前一小介B的 ip link 磉M行 MTU O定吧！

</ol>

<p>
不^，你需要知道的是，由於 IP 封包表^ (不含 options) 就已子昧 20 bytes ，再加上 ICMP 的表^有 8 bytes ，所以然你在使用 -s size 的r候，那封包的大小就得要先扣除 (20+8=28) 的大小了。 因此如果要使用 MTU  1500 r，就得要下_『 ping -s 1472 -M do xx.yy.zz.ip 』才行啊！
</p>

<p>
另外，由於本地端的W路卡 MTU 也影到y，所以如果想要y整鬏媒w的 MTU 抵担 那N每可以{整的主C就得要先使用 ifcofig 或 ip 先 MTU {大，然後再去M行y， 否t就出F像上面提供的案例一樱可能出Fe`息的！
</p>

<p>
不^@ MTU 不要S便{整啊！除非真的有}。通常{整 MTU 的rg是在@r候：
</p>
<blockquote>
因槿部的主C群都是在炔康^W，例如布架 (cluster) 的h境下， 由於炔康木W路c都是我可以控制的，因此可以透^修改 MTU 碓鲞MW路效能；
因樽I系yAO的 MTU c你的W域不符，е履承┚W站可以利B，某些W站to法B。 以 Windows 作I系y作檫B分享的主Cr，在 Client 端挺容易l生@}；
</blockquote>


<p>
如果是要B上 Internet 的主C，注意不要S便{整 MTU ，因槲o法知道 Internet 上面的每部C器能蛑г的 MTU 到多大，因......不是我能蚬艿牡降穆 <sup><small>_</small></sup>！ 另外，其每NB方式都有不同的 MTU 值，常的各N介面的 MTU 值分e椹U
</p>

<p>
W路介面		MTU
Ethernet		1500
PPPoE			1492
Dial-up(Modem)	576
</p>








<ol>
<li>
===========================

</ol>
<p>
#
</p>
<ol>
<li>
两部主机之间节点的分析： traceroute

</ol>
<p>
#
</p>
<ol>
<li>
===========================

</ol>

<p>
我前面到的指令大多刀际轻χC的W路翟O定所需要的，而 ping 是刹恐C之g的回c否判啵 那N有]有指令可以追刹恐C之g通^的各c (node) 通r的好哪兀颗e例碚f，如果我B到 yahoo 的速度比平常慢，你X得是 (1)自己的W路h境有}？ (2)是外部的 Internet 有}？如果是 (1) 的，我然需要z查自己的W路h境啊，看看是否又有l中毒了？但如果是 Internet 的}呢？那只有『等等等』啊！ 判嗍 (1) 是 (2) 就得要使用 traceroute @指令啦！
</p>

<p>
[root@www ~]# traceroute [xc] IP
xc担
-n ：可以不必M行主C的名Q解析，渭用 IP ，速度^快！
-U ：使用 UDP 的 port 33434 磉M行y，@是AO的yf定；
-I ：使用 ICMP 的方式磉M行y；
-T ：使用 TCP 磉M行y，一般使用 port 80 y
-w ：若Ψ街C在酌腌]有回就宣告不治...AO是 5 秒
-p 埠：若不想使用 UDP c TCP 的AO埠y，可在此改埠。
-i b置：用在比^}s的h境，如果你的W路介面很多很}sr，才用到@担
</p>
<blockquote>
e例碚f，你有l ADSL 可以B接到外部，那你的主C有 ppp，
你可以使用 -i 磉x袷 ppp0 是 ppp1 啦！
</blockquote>
<p>
-g 路由：c -i 的迪喾拢只是 -g 後面接的是 gateway 的 IP 就是了。
</p>

<ol>
<li>
例一：y本C到 yahoo 去的各cBB

</ol>
<p>
[root@www ~]# traceroute -n tw.yahoo.com
traceroute to tw.yahoo.com (119.160.246.241), 30 hops max, 40 byte packets
 1  192.168.1.254  0.279 ms  0.156 ms  0.169 ms
 2  172.20.168.254  0.430 ms  0.513 ms  0.409 ms
 3  10.40.1.1  0.996 ms  0.890 ms  1.042 ms
 4  203.72.191.85  0.942 ms  0.969 ms  0.951 ms
 5  211.20.206.58  1.360 ms  1.379 ms  1.355 ms
 6  203.75.72.90  1.123 ms  0.988 ms  1.086 ms
 7  220.128.24.22  11.238 ms  11.179 ms  11.128 ms
 8  220.128.1.82  12.456 ms  12.327 ms  12.221 ms
 9  220.128.3.149  8.062 ms  8.058 ms  7.990 ms
10  * * *
11  119.160.240.1  10.688 ms  10.590 ms 119.160.240.3  10.047 ms
12  * * * &lt;==可能有防火b置等情rl生所致
</p>

<p>
@ traceroute 挺有意思的，@指令τB接的目的地之所有 node M行 UDP 的逾r等待， 例如上面的例子中，由B哥的主CB接到 Yahoo r，他^ 12 c以上，traceroute 主拥@ 12 c做 UDP 的回等待，Ky回覆的rg，每cy三次，最K回飨裆项^@示的Y果。 你可以lF每c其回覆的rg大s在 50 ms 以龋算是可以的 Internet h境了。
</p>

<p>
比^特殊的算是第 10/12 ，回餍翘的，代表 node 可能O有某些防o措施，我l送的封包Y被G所致。 因槲是直接透^路由器Df封包，K]有M入路由器去取得路由器的使用Y源，所以某些路由器H支援封包Df， K不接受碜杂舳说母黜y啦！此r就出F上述的}。因 traceroute AO使用 UDP 封包，如果你想L使用其他封包， 那N -I 或 -T 可以看看樱
</p>

<p>
由於目前 UDP/ICMP 的攻映霾桓F，因此很多路由器可能就此取消@封包的回功能。所以我可以使用 TCP y呦！ 例如使用同拥姆椒ǎ透^等待rg 1 秒，以及 TCP 80 埠口的情r下，可以@幼觯
</p>

<p>
[root@www ~]# traceroute -w 1 -n -T tw.yahoo.com
</p>








<ol>
<li>
===========================

</ol>
<p>
#
</p>
<ol>
<li>
查看本机与网络的后门： netstat

</ol>
<p>
#
</p>
<ol>
<li>
===========================

</ol>

<p>
如果你X得你的某W路服彰髅骶恿耍但是就是o法造成B的，那N怎Nk？ 首先你要查一下自己的W路介面所O的埠口 (port) 砜纯词欠裾娴挠樱因橛r候幕上面@示的 [OK] K不一定是 OK 啊！ <sup><small>_</small></sup>
</p>

<p>
[root@www ~]# netstat -[rn]       &lt;==c路由有P的
[root@www ~]# netstat -[antulpc]  &lt;==cW路介面有P的
</p>

<p>
xc担
</p>

<p>
c路由 (route) 有P的嫡f明：
	-r  ：列出路由表(route table)，功能如同 route @指令；
	-n  ：不使用主C名Qc服彰Q，使用 IP c port number ，如同 route -n
</p>

<p>
cW路介面有P的担
	-a  ：列出所有的BB，包括 tcp/udp/unix socket 等；
	-t  ：H列出 TCP 封包的B；
	-u  ：H列出 UDP 封包的B；
	-l  ：H列出有在 Listen (O) 的服罩W路B；
	-p  ：列出 PID c Program 的n名；
	-c  ：可以O定酌腌後自痈新一次，例如 -c 5 每五秒更新一次W路B的@示；
</p>

<ol>
<li>
例一：列出目前的路由表B，且以 IP 及 port number @示：

</ol>

<p>
[root@www ~]# netstat -rn
Kernel IP routing table
Destination     Gateway         Genmask         Flags   MSS Window  irtt Iface
192.168.1.0     0.0.0.0         255.255.255.0   U         0 0          0 eth0
169.254.0.0     0.0.0.0         255.255.0.0     U         0 0          0 eth0
0.0.0.0         192.168.1.254   0.0.0.0         UG        0 0          0 eth0
</p>

<ol>
<li>
其@稻透 route -n 一模一樱Π桑∵@不是 netstat 的主要功能啦！

</ol>

<ol>
<li>
例二：列出目前的所有W路BB，使用 IP c port number

</ol>

<p>
[root@www ~]# netstat -an
Active Internet connections (servers and established)
Proto Recv-Q Send-Q Local Address     Foreign Address     State
....(中g省略)....
tcp        0      0 127.0.0.1:25      0.0.0.0:*           LISTEN
tcp        0     52 192.168.1.100:22  192.168.1.101:1937  ESTABLISHED 
tcp        0      0 :::22             :::*                LISTEN
....(中g省略)....
Active UNIX domain sockets (servers and established)
Proto RefCnt Flags    Type    State      I-Node Path
unix  2      [ ACC ]  STREAM  LISTENING  11075  @/var/run/hald/dbus-uukdg1qMPh
unix  2      [ ACC ]  STREAM  LISTENING  10952  /var/run/dbus/system_bus_socket
unix  2      [ ACC ]  STREAM  LISTENING  11032  /var/run/acpid.socket
....(底下省略)....
</p>

<p>
netstat 的出主要分纱蟛糠郑分e是 TCP/IP 的W路介面部分，以及鹘y的 Unix socket 部分。 得我在基A篇e面曾到n案的型幔磕 socket c FIFO n案得吧？ 那就是在 Unix 介面用碜槌淌劫Y料交流的介面了，也就是上^表格瓤吹降 Active Unix domain sockets 的热印
</p>

<p>
通常B哥都是建h加上『 -n 』@档模因榭梢员苓^主C名Qc服彰Q的反查，直接以 IP 及埠口a (port number) 盹@示，@示的速度上快很多！至於在出的息中， 我先碚一P於W路BB的出部分，他主要是分榈紫大：
</p>
<blockquote>
Proto：B的封包f定，主要 TCP/UDP 等封包；
Recv-Q：非由使用者程式B接所}u而淼目 bytes 担
Send-Q：由h端主C所魉投恚但不具有 ACK 苏I的 bytes 担 意指主舆B SYN 或其他苏I的封包所椎 bytes 担
Local Address：本地端的位址，可以是 IP (-n 荡嬖r)， 也可以是完整的主C名Q。使用的格是就是『 IP:port 』只是 IP 的格式有 IPv4 及 IPv6 的差。 如上所示，在 port 22 的介面中，使用的 :::22 就是 IPv6 的@示，事上他就相同於 0.0.0.0:22 的意思。 至於 port 25 H lo 介面_放，意指 Internet 基本上是o法B接到我本C的 25 埠口啦！
Foreign Address：h端的主C IP c port number
stat：B列，主要的B含有：
ESTABLISED：已建立B的B；
SYN_SENT：l出主舆B (SYN 苏I) 的B封包；
SYN_RECV：接收到一要求B的主舆B封包；
FIN_WAIT1：插槽服(socket)已中啵B正在嗑中；
FIN_WAIT2：B已啵但正在等待Ψ街C回嗑_J的封包；
TIME_WAIT：B已啵但 socket 在W路上等待Y束；
LISTEN：通常用在服盏谋O port ！可使用『 -l 』挡殚。
</blockquote>

<p>
基本上，我常常到的 netstat 的功能，就是在^察W路的BB了，而W路BB中， 又以^察『我目前_了多少的 port 在等待用舳说倪B』以及 『目前我的W路BB中，有多少B已建立或a生}』最常。 那你如何t解c^察呢？通常B哥是@犹理的：
</p>

<ol>
<li>
例三：秀出目前已拥木W路服

</ol>

<p>
[root@www ~]# netstat -tulnp
Active Internet connections (only servers)
Proto Recv-Q Send-Q Local Address  Foreign Address   State   PID/Program name
tcp        0      0 0.0.0.0:34796  0.0.0.0:*         LISTEN 987/rpc.statd
tcp        0      0 0.0.0.0:111    0.0.0.0:*         LISTEN 969/rpcbind
tcp        0      0 127.0.0.1:25   0.0.0.0:*         LISTEN 1231/master
tcp        0      0 :::22          :::*              LISTEN 1155/sshd
udp        0      0 0.0.0.0:111    0.0.0.0:*                969/rpcbind
....(底下省略)....
</p>
<ol>
<li>
上面最重要的其是那 -l 的担因榭梢H列出有在 Listen 的 port

</ol>

<p>
你可以lF很多的W路服掌HΡC的 lo _放而已，WHW路是B接不到埠口c服盏摹 而由上述的Y料我也可以看到， port 111 的，其就是 rpcbind 那b程式，那如果想要P]@埠口， 你可以使用 kill h除 PID 969，也可以使用 killall h除 rpcbind @程序即可。如此一恚 很p的你就能知道哪程式恿四男┎嚎樱
</p>

<ol>
<li>
例四：^察本C上^所有的W路BB

</ol>

<p>
[root@www ~]# netstat -atunp
Active Internet connections (servers and established)
Proto Recv-Q Send-Q Local Address     Foreign Address     State       PID/Program
tcp        0      0 0.0.0.0:111       0.0.0.0:*           LISTEN      969/rpcbind
tcp        0      0 0.0.0.0:22        0.0.0.0:*           LISTEN      1155/sshd
tcp        0      0 127.0.0.1:25      0.0.0.0:*           LISTEN      1231/master
tcp        0     52 192.168.1.100:22  192.168.1.101:1937  ESTABLISHED 4716/0
....(底下省略)....
</p>

<p>
看到上^的最后一行吧？那代表目前已建立B的一lW路B，他是由h端主C 192.168.1.101 右大於 1024 的埠口向本地端主C 192.168.1.100 的 port 22 M行的一lB， 你必要想起淼氖牵骸Client 端是SC取一大於 1024 以上的 port M行B』，此外『只有 root 可以有§ 1024 以下的 port 』，那就看的懂上^那lB樱∪绻@lB你想要砍掉他的， 看到最右的 4716 了]？ kill 用吧！ <sup><small>_</small></sup>
</p>

<p>
至於鹘y的 Unix socket 的Y料，得使用 man netstat 查一下吧！ @ Unix socket 通常是用在一些H在本C上\作的程式所_⒌牟宀劢槊n， 例如 X Window 不都是在本C上\作而已幔磕呛伪泳W路的 port 呢？然可以使用 Unix socket 樱另外，例如 Postfix @一的W路伺服器，由於很多幼鞫际窃诒C上^硗瓿傻模 所以以子煤芏嗟 Unix socket 喔！
</p>

<p>
例}： f明服彰Qc port number 的在 Linux 中，是用那n案碓O定的？
  答： /etc/services 
</p>









<ol>
<li>
===========================

</ol>
<p>
#
</p>
<ol>
<li>
查看主机名：host

</ol>
<p>
#
</p>
<ol>
<li>
===========================

</ol>

<p>
@指令可以用聿槌瞿主C名Q的 IP 喔！e例碚f，我想要知道 tw.yahoo.com 的 IP r，可以@幼觯
</p>

<p>
[root@www ~]# host [-a] hostname [server]
</p>

<p>
xc担
	-a ：列出主C的各主C名QO定Y料
	[server] ：可以使用非 /etc/resolv.conf 的 DNS 伺服器 IP 聿樵。
</p>

<ol>
<li>
例一：列出 tw.yahoo.com 的 IP 

</ol>

<p>
[root@www ~]# host tw.yahoo.com
tw.yahoo.com is an alias for tw-cidr.fyap.b.yahoo.com.
tw-cidr.fyap.b.yahoo.com is an alias for tw-tpe-fo.fyap.b.yahoo.com.
tw-tpe-fo.fyap.b.yahoo.com has address 119.160.246.241
</p>

<p>
瞧！IP 是 119.160.246.241 啊！很尉涂梢圆樵到 IP 了！那N@ IP 是向l查的呢？其就是在 /etc/resolv.conf 那n案鹊 DNS 伺服器 IP 啦！如果不想要使用n案鹊闹C聿樵，也可以@幼觯
</p>

<p>
[root@www ~]# host tw.yahoo.com 168.95.1.1
Using domain server:
Name: 168.95.1.1
Address: 168.95.1.1#53
Aliases:
</p>

<p>
tw.yahoo.com is an alias for tw-cidr.fyap.b.yahoo.com.
tw-cidr.fyap.b.yahoo.com is an alias for tw-tpe-fo.fyap.b.yahoo.com.
tw-tpe-fo.fyap.b.yahoo.com has address 119.160.246.241
</p>

<p>
告V我所使用聿樵的主C是哪一部龋∵@泳蚯宄了吧！不^，再怎N清楚也比不^ dig @指令的，所以@指令H是⒖⒖祭玻
</p>








<ol>
<li>
===========================

</ol>
<p>
#
</p>
<ol>
<li>
查看主机名：nslookup

</ol>
<p>
#
</p>
<ol>
<li>
===========================

</ol>

<p>
@玩意旱挠猛九c host 基本上是一拥模就是用碜 IP c主C名Q的z查， 同邮鞘褂 /etc/resolv.conf @n案碜 DNS 伺服器的碓催x瘛
</p>

<p>
[root@www ~]# nslookup [-query=[type]] [hostname|IP]
</p>

<p>
xc担
	-query=type：查的型，除了鹘y的 IP c主C名Q外，DNS 有很多Y，
</p>
<blockquote>
所以我可以查很多不同的Y，包括 mx, cname 等等，
例如： -query=mx 的查方法！
</blockquote>

<ol>
<li>
例一：找出 www.google.com 的 IP

</ol>

<p>
[root@www ~]# nslookup www.google.com
Server:         168.95.1.1
Address:        168.95.1.1#53
</p>

<p>
Non-authoritative answer:
www.google.com  canonical name = www.l.google.com.
Name:   www.l.google.com
Address: 74.125.71.106
....(底下省略)....
</p>

<ol>
<li>
例二：找出 168.95.1.1 的主C名Q

</ol>

<p>
[root@www ~]# nslookup 168.95.1.1
Server:         168.95.1.1
Address:        168.95.1.1#53
</p>

<p>
1.1.95.168.in-addr.arpa name = dns.hinet.net.
</p>

<p>
如何，看起砼c host 差不多吧！不^，@ nslookup 可以由 IP 找出主C名Q喔！ 例如那例二，他的主C名Q是： dns.hinet.net 哩！目前大家都建h使用 dig @指令砣〈 nslookup ，我在第十九章 DNS 伺服器那r再砗煤谜一吧！
</p>








<ol>
<li>
===========================

</ol>
<p>
#
</p>
<ol>
<li>
抓包工具：tcpdump

</ol>
<p>
#
</p>
<ol>
<li>
===========================

</ol>

<p>
f在的，於 tcpdump @w碚f，你甚至可以f@w其就是客w， 因樗不但可以分析封包的流向，B封包的热菀部梢赃M行『O』， 如果你使用的鬏Y料是明a的，不得了，在 router 或 hub 上面就可能被人家O走了！ 我在第二章到的 CSMA/CD 流程中，不是f^有所^的『Ow』幔窟@ tcpdump 就是啦！ 很可怕龋∷以，我也要聿t解一下@w啊！(]：@ tcpdump 必使用 root 的身份绦)
</p>

<p>
[root@www ~]# tcpdump [-AennqX] [-i 介面] [-w Υn名] [-c 次] \
</p>
<blockquote>
[-r n案] [所欲X取的封包Y料格式]
</blockquote>

<p>
xc担
	-A ：封包的热菀 ASCII @示，通常用碜饺 WWW 的W封包Y料。
	-e ：使用Y料B接 (OSI 第二) 的 MAC 封包Y料盹@示；
	-nn：直接以 IP 及 port number @示，而非主C名c服彰Q
	-q ：H列出^楹短的封包Y，每一行的热荼容^精
	-X ：可以列出十六M位 (hex) 以及 ASCII 的封包热荩於O封包热莺苡杏
	-i ：後面接要『O』的W路介面，例如 eth0, lo, ppp0 等等的介面；
	-w ：如果你要⒈O所得的封包Y料Υ嫦恚用@稻α耍♂崦娼n名
	-r ：尼崦娼拥n案⒎獍Y料x出怼Ｄ『n案』是已存在的n案，
		 K且@『n案』是由 -w 所u作出淼摹
	-c ：O的封包担如果]有@担 tcpdump 持m不嗟谋O，
		 直到使用者入 [ctrl]-c 橹埂
</p>

<p>
所欲X取的封包Y料格式：我可以ｉTδ承┩ㄓf定或者是 IP 碓催M行封包X取，
	 那就可以化出的Y果，K取得最有用的Y。常的表示方法有：
	 'host foo', 'host 127.0.0.1' ：尾恐C磉M行封包X取
	 'net 192.168' ：δW域磉M行封包的X取；
	 'src host 127.0.0.1' 'dst net 192.168'：同r加上碓(src)或目(dst)限制
	 'tcp port 21'：可以νㄓf定y，如 tcp, udp, arp, ether 等
	 可以利用 and c or 磉M行封包Y料的整合@示呢！
</p>

<ol>
<li>
例一：以 IP c port number 捉下 eth0 @W路卡上的封包，持m 3 秒

</ol>

<p>
[root@www ~]# tcpdump -i eth0 -nn
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on eth0, link-type EN10MB (Ethernet), capture size 65535 bytes
17:01:47.360523 IP 192.168.1.101.1937 &gt; 192.168.1.100.22: Flags [.], ack 196, win 65219, 
17:01:47.362139 IP 192.168.1.100.22 &gt; 192.168.1.101.1937: Flags [P.], seq 196:472, ack 1,
17:01:47.363201 IP 192.168.1.100.22 &gt; 192.168.1.101.1937: Flags [P.], seq 472:636, ack 1,
17:01:47.363328 IP 192.168.1.101.1937 &gt; 192.168.1.100.22: Flags [.], ack 636, win 64779,
&lt;==按下 [ctrl]-c 之後Y束
6680 packets captured              &lt;==捉下淼姆獍盗
14250 packets received by filter   &lt;==由^V所得的封包盗
7512 packets dropped by kernel     &lt;==被核心所G的封包
</p>

<p>
如果你是第一次看 tcpdump 的 man page r，肯定一^大，因 tcpdump 缀醵际欠治龇獍的表^Y料，使用者如果]有易的W路封包基A，要看懂粉y龋 所以，至少你得要回到W路基Ae面去 TCP 封包的表^Y料理解理解才好啊！ <sup><small>_</small></sup>！至於那例一所a生的出例中，我可以s略^分谖唬 我以例一中第二行碚f明一下：
</p>
<blockquote>
17:01:47.362139：@是此封包被X取的rg，『r:分:秒』的挝唬
IP：透^的通f定是 IP ；
192.168.1.100.22 &gt; ：魉投耸 192.168.1.100 @ IP，而魉偷 port number  22，你必要t解的是，那大於 (&gt;) 的符指的是封包的鬏方向喔！
192.168.1.101.1937：接收端的 IP 是 192.168.1.101， 且主C_ port 1937 斫邮眨
[P.], seq 196:472：@封包в PUSH 的Y料鬏苏I， 且鬏的Y料檎wY料的 196~472 byte；
ack 1：ACK 的相PY料。
</blockquote>

<p>
最蔚恼f法，就是封包是由 192.168.1.100 鞯 192.168.1.101，透^的 port 是由 22 到 1937 ， 使用的是 PUSH 的旗耍而不是 SYN 之的主舆B苏I。呵呵！不容易看的懂吧！所以f，上^才v毡氐 TCP 表^Y料的部分去瞧一瞧的啊！
</p>

<p>
再恚一W路B很忙的主C上面，你想要取得某部主Cδ氵B的封包Y料而已r， 使用 tcpdump 配合管命令c正表示法也可以，不^，竟不好捉取！ 我可以透^ tcpdump 的表示法功能，就能蜉p易的⑺需要的Y料立的取出怼 在上面的例一中，我H eth0 做O，所以整 eth0 介面上面的Y料都被@示到幕上， 不好分析啊！那N我可以化幔坷如只取出 port 21 的B封包，可以@幼觯
</p>

<p>
[root@www ~]# tcpdump -i eth0 -nn port 21
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on eth0, link-type EN10MB (Ethernet), capture size 96 bytes
01:54:37.96 IP 192.168.1.101.1240 &gt; 192.168.1.100.21: . ack 1 win 65535
01:54:37.96 IP 192.168.1.100.21 &gt; 192.168.1.101.1240: P 1:21(20) ack 1 win 5840
01:54:38.12 IP 192.168.1.101.1240 &gt; 192.168.1.100.21: . ack 21 win 65515
01:54:42.79 IP 192.168.1.101.1240 &gt; 192.168.1.100.21: P 1:17(16) ack 21 win 65515
01:54:42.79 IP 192.168.1.100.21 &gt; 192.168.1.101.1240: . ack 17 win 5840
01:54:42.79 IP 192.168.1.100.21 &gt; 192.168.1.101.1240: P 21:55(34) ack 17 win 5840
</p>

<p>
瞧！@泳H提出 port 21 的Y而已，且仔看的，你lF封包的鬟f都是p向的， client 端l出『要求』而 server 端t予以『回』，所以，然是有去有回啊！ 而我也就可以^@封包的流向聿t解到封包\作的^程。e例碚f：
</p>
<blockquote>
我先在一K端C窗入『 tcpdump -i lo -nn 』 的O，
再另_一K端C窗ΡC (127.0.0.1) 登入『ssh localhost』
</blockquote>

<p>
那N出的Y果是如何？
</p>

<p>
[root@www ~]# tcpdump -i lo -nn
 1 tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
 2 listening on lo, link-type EN10MB (Ethernet), capture size 96 bytes
 3 11:02:54.253777 IP 127.0.0.1.32936 &gt; 127.0.0.1.22: S 933696132:933696132(0) 
   win 32767 &lt;mss 16396,sackOK,timestamp 236681316 0,nop,wscale 2&gt;
 4 11:02:54.253831 IP 127.0.0.1.22 &gt; 127.0.0.1.32936: S 920046702:920046702(0) 
   ack 933696133 win 32767 &lt;mss 16396,sackOK,timestamp 236681316 236681316,nop,
   wscale 2&gt;
 5 11:02:54.253871 IP 127.0.0.1.32936 &gt; 127.0.0.1.22: . ack 1 win 8192 &lt;nop,
   nop,timestamp 236681316 236681316&gt;
 6 11:02:54.272124 IP 127.0.0.1.22 &gt; 127.0.0.1.32936: P 1:23(22) ack 1 win 8192 
   &lt;nop,nop,timestamp 236681334 236681316&gt;
 7 11:02:54.272375 IP 127.0.0.1.32936 &gt; 127.0.0.1.22: . ack 23 win 8192 &lt;nop,
   nop,timestamp 236681334 236681334&gt;
</p>

<p>
上表@示的^尚惺 tcpdump 的基本f明，然後：
</p>
<blockquote>
第 3 行@示的是『碜 client 端，в SYN 主舆B的封包』，
第 4 行@示的是『碜 server 端，除了回 client 端之外(ACK)，в SYN 主舆B的苏I；
第 5 行t@示 client 端回 server _定B建立 (ACK)
第 6 行以後t_始M入Y料鬏的步E。
</blockquote>

<p>
牡 3-5 行的流程砜矗熟不熟悉啊？]e！那就是三向交握的基A流程啦！蛴腥ぐ桑 不^ tcpdump 之所以被Q轳客w之一可不止上^介B的功能龋 上面介B的功能可以用碜槲主C的封包Bc鬏的流程分析， @⒂兄於我t解到封包的\作，同rt解到主C的防火O定t是否有需要修的地方。
</p>

<p>
更神奇的使用要砝玻∪绻我使用 tcpdump 在 router 上面O『明a』的鬏Y料r， 例如 FTP 鬏f定，你X得l生什N}呢？ 我先在主C端下_『 tcpdump -i lo port 21 -nn -X 』然後再以 ftp 登入本C，K入ぬc密a， Y果你就可以lF如下的r：
</p>

<p>
[root@www ~]# tcpdump -i lo -nn -X 'port 21'
</p>
<blockquote>
0x0000:  4500 0048 2a28 4000 4006 1286 7f00 0001  E..H*(@.@.......
0x0010:  7f00 0001 0015 80ab 8355 2149 835c d825  .........U!I.\.%
0x0020:  8018 2000 fe3c 0000 0101 080a 0e2e 0b67  .....&lt;.........g
0x0030:  0e2e 0b61 3232 3020 2876 7346 5450 6420  ...a220.(vsFTPd.
0x0040:  322e 302e 3129 0d0a                      2.0.1)..
</blockquote>
<blockquote>
0x0000:  4510 0041 d34b 4000 4006 6959 7f00 0001  E..A.K@.@.iY....
0x0010:  7f00 0001 80ab 0015 835c d825 8355 215d  .........\.%.U!]
0x0020:  8018 2000 fe35 0000 0101 080a 0e2e 1b37  .....5.........7
0x0030:  0e2e 0b67 5553 4552 2064 6d74 7361 690d  ...gUSER.dmtsai.
0x0040:  0a                                       .
</blockquote>
<blockquote>
0x0000:  4510 004a d34f 4000 4006 694c 7f00 0001  E..J.O@.@.iL....
0x0010:  7f00 0001 80ab 0015 835c d832 8355 217f  .........\.2.U!.
0x0020:  8018 2000 fe3e 0000 0101 080a 0e2e 3227  .....&gt;........2'
0x0030:  0e2e 1b38 5041 5353 206d 7970 6173 7377  ...8PASS.mypassw
0x0040:  6f72 6469 7379 6f75 0d0a                 ordisyou..
</blockquote>

<p>
上面的出Y果已被化^了，你必要自行在你的出Y果中搜は嚓P的字串才行。 纳厦孑出Y果的特殊字w中，我可以lF『 FTP w使用的是 vsftpd ，K且使用者入 dmtsai @ぬ名Q，且密a是 mypasswordisyou』 嘿嘿！你f可不可怕啊！如果使用的是明a的方式鬏你的W路Y料？ 所以我才常常在v啊，W路是很不安全滴！
</p>

<p>
另外你得t解，榱俗W路介面可以 tcpdump O，所以绦 tcpdump rW路介面釉 『ey模式 (promiscuous)』，所以你在 /var/log/messages e面看到很多的警告息， 通知你f你的W路卡被O定成殄ey模式！e心，那是正常的。至於更多的用，⒖ man tcpdump 樱
</p>

<p>
例}： 如何使用 tcpdump O 
(1)碜 eth0 介面卡且 
(2)通f定 port 22 ，
(3)封包碓 192.168.1.101 的封包Y料？
</p>

<p>
答：
</p>

<p>
tcpdump -i eth0 -nn 'port 22 and src host 192.168.1.101'
</p>








<ol>
<li>
===========================

</ol>
<p>
#
</p>
<ol>
<li>
启动 TCP/UDP 端口连接： nc

</ol>
<p>
#
</p>
<ol>
<li>
===========================

</ol>


</body>
</html>
