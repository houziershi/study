<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">

<script type="text/javascript" src="../../vimwiki-theme/code/theme/scripts/jquery-1.4.2.min.js"></script>

<link type="text/css" rel="stylesheet" href="../../vimwiki-theme/hightlight-code/styles/shCore.css"/>
<link type="text/css" rel="stylesheet" href="../../vimwiki-theme/hightlight-code/styles/shCoreRDark.css"/>
<link type="text/css" rel="stylesheet" href="../../vimwiki-theme/hightlight-code/styles/shThemeRDark.css"/>
<script type="text/javascript" src="../../vimwiki-theme/hightlight-code/scripts/shCore.js"></script>
<script type="text/javascript" src="../../vimwiki-theme/hightlight-code/scripts/shAutoloader.js"></script>

<link type="text/css" rel="stylesheet" href="../../vimwiki-theme/code/theme/styles/style.css" />

<script type="text/javascript" src="../../vimwiki-theme/code/theme/scripts/script.js"></script>


<title>java.concurrency.class</title>
</head>
<body  onresize='changeTocSize()'>
	<div class="note-main"> 

<h1 id="toc_1">非线程安全类</h1>

<p>
迭代非线程安全集合会抛出<code>ConcurrentModifyException</code>。
</p>


<h1 id="toc_2">原子操作</h1>

<p>
<code>java.utils.concurrent.atomic</code>包装器把对象包装成原子操作。
</p>

<p>
<code>AtomicLong</code>类的原子方法<code>incrementAndGet()</code>和<code>decresmentAndGet()</code>。
</p>

<p>
包装集合为不可变版本：<code>Collections.unmodifiableLists(list)</code>
</p>

<p>
包装同步版：<code>SynchronizedMap m = Collection.SynchronizedMap(new HashMap())</code>
</p>

<h1 id="toc_3">并发类</h1>

<p>
并发类如：<code>ConcurrentHashMap</code>等为并发环境设计。为了优化性能不只用了一个锁，内部
分多个块用多个锁同步。所以增加了并发性能。
</p>

<h1 id="toc_4">队列</h1>

<h2 id="toc_4.1">常用</h2>

<ul>
<li>
<code>Queue</code>不阻塞，空时取返回空；满时放抛异常。

<li>
<code>SynchrousQueue</code>会同步插入与删除操作。

<li>
<code>BlockingQueue</code>存取操作会阻塞。

<li>
<code>PriorityBlockingQueue</code>带优先级的队列。

</ul>

<h2 id="toc_4.2">阻塞队列</h2>

<p>
简单的阻塞队列可以用<code>LinkedblockingQueue</code>或<code>ArrayBlockingQueue</code>。
</p>

<p>
对于队列空取或满存的情况有四种策略：
</p>

<ul>
<li>
抛出异常。

<li>
特殊值。空取时为<code>null</code>；满存时为<code>false</code>。

<li>
阻塞。

<li>
超时。只会阻塞指定的时间。

</ul>

<table>
<tr>
<td>
&nbsp;
</td>
<td>
抛出异常
</td>
<td>
特殊值
</td>
<td>
阻塞
</td>
<td>
超时
</td>
</tr>
<tr>
<td>
插入
</td>
<td>
add(e)
</td>
<td>
offer(e)
</td>
<td>
put(e)
</td>
<td>
offer(e, time, unit)
</td>
</tr>
<tr>
<td>
移除
</td>
<td>
remove()
</td>
<td>
poll()
</td>
<td>
take()
</td>
<td>
poll(time, unit)
</td>
</tr>
<tr>
<td>
检查
</td>
<td>
element()
</td>
<td>
peek()
</td>
<td>
不可用
</td>
<td>
不可用
</td>
</tr>
</table>

<h2 id="toc_4.3">饱和策略</h2>

<ul>
<li>
<code>Abort</code>：抛异常，调用者处理异常。

<li>
<code>Discard</code>：丢掉任务。

<li>
<code>DiscardOlds</code>：丢掉最老的任务。

<li>
<code>DiscardPolicy</code>：丢掉优先级最低的。

<li>
<code>Caller_Runs</code>：不抛异常，退回给调用者。用一个<code>execute()</code>执行它。

</ul>

<h2 id="toc_4.4">队列工作的问题</h2>

<p>
请求来太快了把等待队列也占满了。太长或是无限的队列，用<code>SynchronizeQueue</code>避免
队列任务。它不是真的队列而是一个移交机制（相当于只有一个容量的队列），前一个
请求没有处理完后一个请求会被拒绝。
</p>
 </div>
</body>
</html>
