<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">

<script type="text/javascript" src="../../vimwiki-theme/code/theme/scripts/jquery-1.4.2.min.js"></script>

<link type="text/css" rel="stylesheet" href="../../vimwiki-theme/hightlight-code/styles/shCore.css"/>
<link type="text/css" rel="stylesheet" href="../../vimwiki-theme/hightlight-code/styles/shCoreRDark.css"/>
<link type="text/css" rel="stylesheet" href="../../vimwiki-theme/hightlight-code/styles/shThemeRDark.css"/>
<script type="text/javascript" src="../../vimwiki-theme/hightlight-code/scripts/shCore.js"></script>
<script type="text/javascript" src="../../vimwiki-theme/hightlight-code/scripts/shAutoloader.js"></script>

<link type="text/css" rel="stylesheet" href="../../vimwiki-theme/code/theme/styles/style.css" />

<script type="text/javascript" src="../../vimwiki-theme/code/theme/scripts/script.js"></script>


<title>并发类</title>
</head>
<body  onresize='changeTocSize()'>
	<div class="note-main"> 


<h1>并发类</h1>
<div class="toc">
<ul>
<li><a href="#toc_1">原子操作</a>
<ul>
<li><a href="#toc_1.1">原子操作类</a>
<li><a href="#toc_1.2">原子包装器</a>
</ul>
<li><a href="#toc_2">并发容器</a>
<ul>
<li><a href="#toc_2.1">并发队列</a>
<ul>
<li><a href="#toc_2.1.1">阻塞队列</a>
<li><a href="#toc_2.1.2">饱和策略</a>
<li><a href="#toc_2.1.3">队列工作的问题</a>
</ul>
<li><a href="#toc_2.2">ConCurrentHashMap</a>
<ul>
<li><a href="#toc_2.2.1">额外的原子操作</a>
</ul>
</ul>
<li><a href="#toc_3">应用：生产者－消费者模式</a>
<ul>
<li><a href="#toc_3.1">双端队列与工作密取</a>
<li><a href="#toc_3.2">恢复中断</a>
</ul>
<li><a href="#toc_4">闭锁（Latch）</a>
<li><a href="#toc_5">Callable</a>
<li><a href="#toc_6">FutureTask</a>
<li><a href="#toc_7">信号量（Semaphore）</a>
<li><a href="#toc_8">栅栏（Barrier）</a>
</ul>
</div>


<h1 id="toc_1">原子操作</h1>

<h2 id="toc_1.1">原子操作类</h2>

<p>
<code>java.utils.concurrent.atomic</code>包装器把对象包装成原子操作。
</p>

<p>
<code>AtomicLong</code>类的原子方法<code>incrementAndGet()</code>和<code>decresmentAndGet()</code>。
</p>

<h2 id="toc_1.2">原子包装器</h2>

<p>
包装集合为不可变版本：<code>Collections.unmodifiableLists(list)</code>
</p>

<p>
包装同步版：<code>SynchronizedMap m = Collection.SynchronizedMap(new HashMap())</code>
</p>

<p>
把一个引用包装成原子访问：
</p>

<pre class="brush: java">
private final AtomicReferency&lt;BigInteger&gt; lastNumber = 
	new AtomicReferency&lt;BigInteger&gt;()
	
private final AtomicReferency&lt;BigInteger&gt; firstNumber = 
	new AtomicReferency&lt;BigInteger&gt;()
</pre>

<p>
但注意上面的例子，虽然每个数字的访问是原子性的，但一起操作两个数字的方法不是
线程安全的。
</p>



<h1 id="toc_2">并发容器</h1>

<p>
Java 5中新加入的并发类为并发环境进行了优化。<code>Queue</code>和<code>BlockingQueue</code>实现了队列，
</p>

<p>
<code>CuncurrentHashMap</code>实现并发Map。
</p>

<p>
Java 6引入了<code>ConcurrentSkipListMap</code>和<code>ConcurrentSkipListSet</code>对应<code>Sortedmap</code>和
<code>SortedSet</code>。
</p>

<p>
并发容器的迭代器不会抛出<code>ConcurrentModificationExcetpion</code>，可以不加锁就进行迭代
。这样的迭代器具有弱一致性（Weakly Consistent），而不是“及时失败”。弱一致性可以
容忍并发的修改，当创建迭代器时会遍历已有的元素，并可以（但不保证）在迭代器被构造
后将修改操作反映给容器。
</p>

<p>
对于并发容器来说<code>size</code>或<code>isEmpty</code>这样的方法返回的结果可能是已经过期的结果。但
在并发环境下这样的状态总是在不断变化的，所以这样的方法意义不大。
</p>

<h2 id="toc_2.1">并发队列</h2>

<p>
常用队列：
</p>

<ul>
<li>
<code>Queue</code>不阻塞，空时取返回空；满时放抛异常。

<li>
<code>SynchrousQueue</code>会同步插入与删除操作。

<li>
<code>BlockingQueue</code>存取操作会阻塞。

<li>
<code>PriorityBlockingQueue</code>带优先级的队列。

</ul>


<h3 id="toc_2.1.1">阻塞队列</h3>

<p>
简单的阻塞队列可以用<code>LinkedblockingQueue</code>或<code>ArrayBlockingQueue</code>。
</p>

<p>
对于队列空取或满存的情况有四种策略：
</p>

<ul>
<li>
抛出异常。

<li>
特殊值。空取时为<code>null</code>；满存时为<code>false</code>。

<li>
阻塞。

<li>
超时。只会阻塞指定的时间。

</ul>

<table>
<tr>
<td>
&nbsp;
</td>
<td>
抛出异常
</td>
<td>
特殊值
</td>
<td>
阻塞
</td>
<td>
超时
</td>
</tr>
<tr>
<td>
插入
</td>
<td>
add(e)
</td>
<td>
offer(e)
</td>
<td>
put(e)
</td>
<td>
offer(e, time, unit)
</td>
</tr>
<tr>
<td>
移除
</td>
<td>
remove()
</td>
<td>
poll()
</td>
<td>
take()
</td>
<td>
poll(time, unit)
</td>
</tr>
<tr>
<td>
检查
</td>
<td>
element()
</td>
<td>
peek()
</td>
<td>
不可用
</td>
<td>
不可用
</td>
</tr>
</table>

<h3 id="toc_2.1.2">饱和策略</h3>

<ul>
<li>
<code>Abort</code>：抛异常，调用者处理异常。

<li>
<code>Discard</code>：丢掉任务。

<li>
<code>DiscardOlds</code>：丢掉最老的任务。

<li>
<code>DiscardPolicy</code>：丢掉优先级最低的。

<li>
<code>Caller_Runs</code>：不抛异常，退回给调用者。用一个<code>execute()</code>执行它。

</ul>

<h3 id="toc_2.1.3">队列工作的问题</h3>

<p>
请求来太快了把等待队列也占满了。太长或是无限的队列，用<code>SynchronizeQueue</code>避免
队列任务。它不是真的队列而是一个移交机制（相当于只有一个容量的队列），前一个
请求没有处理完后一个请求会被拒绝。
</p>

<p>
阻塞队列不能用循环忙等待，标志位退出的方式。可以在队列里放一个特殊成员，读到它
就表示应该退出。
</p>



<h2 id="toc_2.2">ConCurrentHashMap</h2>

<p>
<code>ConcurrentHashMap</code>等为并发环境设计。为了优化性能不只用了一个锁，而是采用分段锁
（Lock Striping），所以增加了并发性能。
</p>

<p>
<code>ConcurrentHashMap</code>是为了强化并发环境下使用，所以没有办法对它的<code>Map</code>加锁以独占
访问。这是弱化独占访问而加强了<code>get</code>、<code>put</code>、<code>containsKey</code>、<code>remove</code>等方法的
并发性的取舍。
</p>


<h3 id="toc_2.2.1">额外的原子操作</h3>

<p>
虽然不能加锁独占方问，但为一些复合操作为提供了原子操作。如：“没有则添加”、“相等
则替换”。
</p>

<pre class="brush: java">
public interface ConcurrentMap&lt;K,V&gt; extends Map&lt;K,V&gt; {

	// Insert into map only if no value is mapped from K
	V putIfAbsent(K key, V value);

	// Remove only if K is mapped to V
	boolean remove(K key, V value);

	// Replace value only if K is mapped to oldValue
	boolean replace(K key, V oldValue, V newValue);

	// Replace value only if K is mapped to some value
	V replace(K key, V newValue);

}
</pre>



<h1 id="toc_3">应用：生产者－消费者模式</h1>

<p>
利用队列实现生产者－消费者模式。
</p>

<h2 id="toc_3.1">双端队列与工作密取</h2>

<p>
工作密取模式：生产者生成任务加到任务队列中，消费者在处理过程中会产生新的任务。
所以消费都也可以把任务加到工作队列中。
</p>

<p>
例如：对于网络爬虫来说，一个链接就是一个任务。爬虫把链接加入到队列中，解析器在
解析网页时会发现网页上有的链接，这又是新的任务。解析器要把新的链接再加到队列中
去。
</p>

<p>
Java 6增加了两种容器类型<code>Deque</code>（发音为deck）与<code>BlockingDeque</code>，分别对应<code>Queue</code>
和<code>BlockingQueue</code>扩展为双端队列，可以实现工作密取模式。
</p>

<h2 id="toc_3.2">恢复中断</h2>

<p>
必须处理<code>InterruptedException</code>，不然其他的线程就没有办法中断当前线程了：
</p>

<pre class="brush: java">
public class TaskRunnable implements Runnable {
	BlockingQueue&lt;Task&gt; queue;

	//...

	public void run() {
		try {
			processTask(queue.take());
		} catch (InterruptedException e) {
			// 中断当前线程
			Thread.currentThread().interrupt();
		}
	}
}
</pre>


<h1 id="toc_4">闭锁（Latch）</h1>

<p>
Latch让多个线程等待把准备工作完成，再一起向下执行。
</p>

<p>
<code>CountDownLatch</code>是一个实现，通过计数器来控制：
</p>

<ul>
<li>
子线程调用<code>countDown</code>方法把计数器减1。

<li>
主线程调用<code>await</code>方法等待，等计数器到0了启动。

</ul>

<p>
在任务没有返回值的情况下，<code>CountDownLatch</code>比用<code>Future</code>更合适。
</p>

<p>
例：在计时测试中使用<code>CountDownLatch</code>来启动与停止线程：
</p>

<pre class="brush: java; highlight: [11, 13, 25, 26]">
public class TestHarness {
    public long timeTasks(int nThreads, final Runnable task)
            throws InterruptedException {
        final CountDownLatch startGate = new CountDownLatch(1);
        final CountDownLatch endGate = new CountDownLatch(nThreads);

        for (int i = 0; i &lt; nThreads; i++) {
            Thread t = new Thread() {
                public void run() {
                    try {
                        startGate.await();
                        try {
                            task.run();
                        } finally {
                            endGate.countDown();
                        }
                    } catch (InterruptedException ignored) {
                    }
                }
            };
            t.start();
        }

        long start = System.nanoTime();
        startGate.countDown();
        endGate.await();
        long end = System.nanoTime();
        return end - start;
    }
}
</pre>



<h1 id="toc_5">Callable</h1>

<p>
<code>Runnable</code>不能有返回值、也不能抛出异常，所以<code>Callable</code>更加好。<code>Callable</code>相当于
可以有返回结果的<code>Runnable</code>。例如一个返回<code>void</code>的<code>Callable</code>就是<code>Callable&lt;void&gt;</code>
。而且还可以抛出受检查或非受检查异常。
</p>

<p>
<code>Callable</code>的接口方法是<code>call()</code>。
</p>


<h1 id="toc_6">FutureTask</h1>

<p>
<code>FutureTask</code>实现了<code>Future</code>语义，表示一个会有结果的计算。计算过程是通过<code>Callable</code>
接口实现的。<code>FutureTask</code>可以三种状态：
</p>

<ul>
<li>
等待运行。

<li>
正在运行。

<li>
已经完成。

</ul>

<p>
当任务处于完成状态以后就一直停在这个状态了。
</p>

<p>
<code>Future</code>通过<code>get</code>方法取得计算结果。取结果的行为取决于状态：
</p>

<ul>
<li>
如果任务已经完成<code>get</code>会立即返回结果。

<li>
如果还没有完成就阻塞等待。然后成功返回结果或是抛异常。

</ul>

<p>
<code>FutureTask</code>确保安全地计算结果从执行计算的线程传递到需要结果的线程。
</p>

<p>
如下面用<code>Future</code>来处理会花费大量时间的数据库访问任务：
</p>

<pre class="brush: java; highlight: [6, 19, 20]">
public class Preloader {
    ProductInfo loadProductInfo() throws DataLoadException {
        return null;
    }

    private final FutureTask&lt;ProductInfo&gt; future =
        new FutureTask&lt;ProductInfo&gt;(new Callable&lt;ProductInfo&gt;() {
            public ProductInfo call() throws DataLoadException {
                return loadProductInfo();
            }
        });
    private final Thread thread = new Thread(future);

    public void start() { thread.start(); }

    public ProductInfo get()
            throws DataLoadException, InterruptedException {
        try {
            return future.get();
        } catch (ExecutionException e) {
            Throwable cause = e.getCause();
            if (cause instanceof DataLoadException)
                throw (DataLoadException) cause;
            else
                throw LaunderThrowable.launderThrowable(cause);
        }
    }

    interface ProductInfo { }
}

class DataLoadException extends Exception { }
</pre>

<p>
<code>Callable</code>会抛出异常，并且任何代码都会抛出<code>Error</code>。无论抛出了什么在<code>Future.get</code>
里都会被封装成<code>ExecutionException</code>以及<code>CancellationException</code>。由于这里抛出的
类型都是被作为<code>Throwable</code>返回的，所以处理起来有些复杂：
</p>

<p>
因为要判断抛出的类型是<code>CheckedException</code>？<code>RuntimeException</code>？还是<code>Error</code>？
</p>

<p>
如果是我们预想中的<code>DataLoadException</code>，走我们预计的处理方式。其他的可能性用
下面的工具类<code>LaunderThrowable</code>来处理异常。它会把强制把未检查的异常转为
<code>RuntimeException</code>：
</p>

<pre class="brush: java">
public class LaunderThrowable {
    /**
     * Coerce an unchecked Throwable to a RuntimeException
     * &lt;p/&gt;
     * If the Throwable is an Error, throw it; if it is a
     * RuntimeException return it, otherwise throw IllegalStateException
     */
    public static RuntimeException launderThrowable(Throwable t) {
        if (t instanceof RuntimeException)
            return (RuntimeException) t;
        else if (t instanceof Error)
            throw (Error) t;
        else
            throw new IllegalStateException("Not unchecked", t);
    }
}
</pre>




<h1 id="toc_7">信号量（Semaphore）</h1>

<p>
信号量控制访问的总数。它的操作提原子的：
</p>

<ul>
<li>
指定资源的总量：<code>Semaphore sem = new Semaphore(num);</code>

<li>
新访问记录占用资源：<code>sem.acquire();</code>

<li>
结束后记录放开资源：<code>sem.release();</code>

</ul>


<h1 id="toc_8">栅栏（Barrier）</h1>

<pre class="brush: java">
</pre>



<pre class="brush: java">
</pre>



<pre class="brush: java">
</pre>



<pre class="brush: java">
</pre>



<pre class="brush: java">
</pre>



<pre class="brush: java">
</pre>



<pre class="brush: java">
</pre>



<pre class="brush: java">
</pre>



<pre class="brush: java">
</pre>



<pre class="brush: java">
</pre>
 </div>
</body>
</html>
