<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">

<script type="text/javascript" src="../../vimwiki-theme/code/theme/scripts/jquery-1.4.2.min.js"></script>

<link type="text/css" rel="stylesheet" href="../../vimwiki-theme/hightlight-code/styles/shCore.css"/>
<link type="text/css" rel="stylesheet" href="../../vimwiki-theme/hightlight-code/styles/shCoreRDark.css"/>
<link type="text/css" rel="stylesheet" href="../../vimwiki-theme/hightlight-code/styles/shThemeRDark.css"/>
<script type="text/javascript" src="../../vimwiki-theme/hightlight-code/scripts/shCore.js"></script>
<script type="text/javascript" src="../../vimwiki-theme/hightlight-code/scripts/shAutoloader.js"></script>

<link type="text/css" rel="stylesheet" href="../../vimwiki-theme/code/theme/styles/style.css" />

<script type="text/javascript" src="../../vimwiki-theme/code/theme/scripts/script.js"></script>


<title>java.concurrency.Lock</title>
</head>
<body  onresize='changeTocSize()'>
	<div class="note-main"> 

<h1 id="toc_1">外部锁（显示锁）</h1>

<p>
JDK5还提供了外部锁：<code>java.util.concurrent.locks.Lock</code>。补充<code>synchronized</code>对应
的内置锁。
</p>

<ul>
<li>
内置锁在<code>synchronized</code>代码结束后自动释放。

<li>
内置锁无法实现非阻塞结构的加锁规则。

<li>
外部锁必须手动释放，所以一定要在<code>finally</code>块中释放。

</ul>

<h2 id="toc_1.1">创建外部锁</h2>

<p>
<code>Lock</code>的实现类<code>ReentrantLock</code>可能对已经获得锁的线程重新请示锁。
</p>

<pre class="brush: java">
Lock lock = new ReentrantLock();

lock.lock();
try {
	/* do something */ 
} finally {
	lock.unlock();
}
</pre>


<h2 id="toc_1.2">避免死锁</h2>

<p>
内置锁容易死锁，外部锁<code>tryLock()</code>方法尽量避免死锁。因为这个方法会在取不到锁时
退回，下次再试。
</p>

<p>
如下面的在两个账户之间的转账程序：
</p>

<pre class="brush: java">
public void transferMoney(Account fromAccount, Account toAccount, 
		BigDecimal amt) 
{
	while (true) {
		if (fromAccount.lock.tryLock()) {
			try {
				if (toAccount.lock.tryLock()) {
					try {
						if (fromAccount.getBalance().Compareto(amount) &lt; 0) {
							throw new InsufficientFundsException(); // 余额不足
						} else {
							fromAccount.debit(amount);
							toAccount.credit(amount);
					} finally {
						toAccount.lock.unlock();
					}
				}
			} finally {
				fromAccount.lock.unlock();
			}
		}
	}
}
</pre>

<p>
还可以指定时限：
</p>

<pre class="brush: java">
if (!lock.tryLock(time, NANOSECONDS))
	return false;
try {
	/* do something */
} finally {
	lock.unlock();
}
</pre>

<p>
还可以指定取锁过程中可以中断。这样还要再处理中断异常的：
</p>

<pre class="brush: java">
try {
	lock.lockInterruptibly(); // 可中断
	try {
		// do something 
	} finally {
		lock.unlock();
	}
} catch (InterruptedException) {
	// do something
}
</pre>


<h2 id="toc_1.3">分开读写锁</h2>

<p>
分开读写锁以取得更加细的控制：
</p>

<pre class="brush: java">
private final ReadWriteLock monitor = new ReentrantReadWriteLock();

monitor.readLock.lock()
monitor.readLock.unlock()

monitor.writeLock.lock()
monitor.writeLock.unlock()
</pre>

<p>
例：成员变量有<code>a</code>、<code>b</code>两个，操作有三个：
</p>

<ul>
<li>
读<code>a</code>

<li>
读<code>b</code>

<li>
同时修改<code>a</code>与<code>b</code>

</ul>

<p>
可以用读锁控制前两个操作，写锁控制后一个。这样两个读操作就看不到第三个操作执行
了一半，只改了<code>a</code>还没有修改<code>b</code>这样的情况。
</p>


<pre class="brush: java">
</pre>



<pre class="brush: java">
</pre>
 </div>
</body>
</html>
