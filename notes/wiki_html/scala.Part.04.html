<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">

<script type="text/javascript" src="../../vimwiki-theme/3rd-libs/jquery-1.4.2.min.js"></script>

<link type="text/css" rel="stylesheet" href="../../vimwiki-theme/3rd-libs/hightlight-code/styles/shCore.css"/>
<link type="text/css" rel="stylesheet" href="../../vimwiki-theme/3rd-libs/hightlight-code/styles/shThemeDefault.css"/>
<script type="text/javascript" src="../../vimwiki-theme/3rd-libs/hightlight-code/scripts/shCore.js"></script>
<script type="text/javascript" src="../../vimwiki-theme/3rd-libs/hightlight-code/scripts/shAutoloader.js"></script>

<script type="text/javascript" src="../../vimwiki-theme/3rd-libs/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

<script type="text/javascript" src="../../vimwiki-theme/templates/code-default/scripts/script.js"></script>
<link type="text/css" rel="stylesheet" href="../../vimwiki-theme/templates/code-default/styles/style.css" />


<title>Part IV</title>
</head>
<body  onresize='changeTocSize()'>
	<div class="note-main"> 

<h1>Part IV</h1>
<div class="toc">
<ul>
<li><a href="#toc_1">使用列表</a>
<ul>
<li><a href="#toc_1.1">列表字面量</a>
<li><a href="#toc_1.2">列表类型</a>
<li><a href="#toc_1.3">构造列表</a>
<li><a href="#toc_1.4">列表的基本操作</a>
<li><a href="#toc_1.5">列表模式</a>
<li><a href="#toc_1.6">List类的一阶方法</a>
<ul>
<li><a href="#toc_1.6.1">连接列表</a>
<li><a href="#toc_1.6.2">分治原则</a>
<li><a href="#toc_1.6.3">列表长度</a>
<li><a href="#toc_1.6.4">取头和尾</a>
<li><a href="#toc_1.6.5">反转列表</a>
<li><a href="#toc_1.6.6">前缀与后缀</a>
<li><a href="#toc_1.6.7">取得指定元素</a>
<li><a href="#toc_1.6.8">zip</a>
<li><a href="#toc_1.6.9">toString 和 mkString</a>
<li><a href="#toc_1.6.10">列表的转换</a>
<li><a href="#toc_1.6.11">例：归并排序</a>
</ul>
<li><a href="#toc_1.7">List类的高阶函数</a>
<ul>
<li><a href="#toc_1.7.1">列表间映射</a>
<li><a href="#toc_1.7.2">过滤</a>
<li><a href="#toc_1.7.3">列表论断</a>
<li><a href="#toc_1.7.4">reduce与folder</a>
<ul>
<li><a href="#toc_1.7.4.1">化简（reduce）</a>
<li><a href="#toc_1.7.4.2">折叠（folder）</a>
</ul>
<li><a href="#toc_1.7.5">应用场景</a>
<ul>
<li><a href="#toc_1.7.5.1">例子：统计字母出现次数</a>
<li><a href="#toc_1.7.5.2">例子：使用折叠实现列表反转</a>
</ul>
<li><a href="#toc_1.7.6">扫描（scan）</a>
<li><a href="#toc_1.7.7">排序</a>
</ul>
<li><a href="#toc_1.8">List伴生对象的方法</a>
<ul>
<li><a href="#toc_1.8.1">通过元素创建列表</a>
<li><a href="#toc_1.8.2">按数值范围创建列表</a>
<li><a href="#toc_1.8.3">创建重复元素的列表</a>
<li><a href="#toc_1.8.4">解除Zip列表</a>
<li><a href="#toc_1.8.5">连接列表</a>
<li><a href="#toc_1.8.6">映射与测试配对</a>
</ul>
<li><a href="#toc_1.9">了解Scala的类型推断方法</a>
</ul>
<li><a href="#toc_2">集合类型</a>
<ul>
<li><a href="#toc_2.1">概览</a>
<li><a href="#toc_2.2">序列</a>
<ul>
<li><a href="#toc_2.2.1">列表</a>
<li><a href="#toc_2.2.2">列表缓存</a>
<li><a href="#toc_2.2.3">数组</a>
</ul>
<li><a href="#toc_2.3">数组缓存</a>
<ul>
<li><a href="#toc_2.3.1">队列</a>
<li><a href="#toc_2.3.2">栈</a>
<li><a href="#toc_2.3.3">字符串</a>
</ul>
<li><a href="#toc_2.4">Set与Map</a>
<ul>
<li><a href="#toc_2.4.1">使用Set</a>
<li><a href="#toc_2.4.2">Map</a>
<li><a href="#toc_2.4.3">默认的Set和Map</a>
<li><a href="#toc_2.4.4">有序的集体和映射</a>
<li><a href="#toc_2.4.5">同步的Set和Map</a>
</ul>
<li><a href="#toc_2.5">可变与不可变类型的比较</a>
<li><a href="#toc_2.6">初始化集合</a>
<ul>
<li><a href="#toc_2.6.1">数组与列表之间转换</a>
<li><a href="#toc_2.6.2">Set与Map的可变与不可变互转</a>
<li><a href="#toc_2.6.3">元组</a>
</ul>
<li><a href="#toc_2.7">惰性求值</a>
<ul>
<li><a href="#toc_2.7.1">迭代器</a>
<li><a href="#toc_2.7.2">流</a>
<li><a href="#toc_2.7.3">用迭代器创建流</a>
<li><a href="#toc_2.7.4">懒视图</a>
<ul>
<li><a href="#toc_2.7.4.1">应用场景</a>
</ul>
</ul>
<li><a href="#toc_2.8">与Java集合互操作</a>
<li><a href="#toc_2.9">线程安全的集合</a>
<li><a href="#toc_2.10">并发操作集合</a>
<ul>
<li><a href="#toc_2.10.1"><code>for-yield</code>循环按顺序执行</a>
<li><a href="#toc_2.10.2">不要用共享变量</a>
<li><a href="#toc_2.10.3">ParIterable接口</a>
<li><a href="#toc_2.10.4">适用范围</a>
<ul>
<li><a href="#toc_2.10.4.1">reduce</a>
<li><a href="#toc_2.10.4.2">fold</a>
<li><a href="#toc_2.10.4.3">aggregate</a>
</ul>
</ul>
</ul>
</ul>
</div>

<h1 id="toc_1">使用列表</h1>

<h2 id="toc_1.1">列表字面量</h2>

<p>
再简单回顾一下：
</p>

<pre class="brush: scala">
  val fruit = List("apples", "oranges", "pears")
  val nums = List(1, 2, 3, 4)
  val diag3 =
    List(
      List(1, 0, 0),
      List(0, 1, 0),
      List(0, 0, 1)
    )
  val empty = List()"brush: scala"
</pre>

<p>
注意列表是不可变的。
</p>

<h2 id="toc_1.2">列表类型</h2>

<p>
列表是同质化的（homogeneous），所有的成员都有相同的类型，中括号描述成员类型
<code>List[T]</code>。
</p>

<pre class="brush: scala">
val fruit: List[String] = List("apples", "oranges", "pears")
  val nums: List[Int] = List(1, 2, 3, 4)
  val diag3: List[List[Int]] =
    List(
      List(1, 0, 0),
      List(0, 1, 0),
      List(0, 0, 1)
    )
  val empty: List[Nothing] = List()
</pre>

<p>
Scala里的列表类是协变的（covariant）。如果<code>S</code>是<code>T</code>的子类，那<code>List[S]</code>也是
<code>List[T]</code>的子类。
</p>

<p>
由于<code>Nothing</code>是所有类的子类，所以<code>List[Nothing]</code>是所有<code>List[T]</code>类型的子类：
</p>

<pre class="brush: scala">
  // List() is also of type List[String]!
  val xs: List[String] = List()
</pre>

<h2 id="toc_1.3">构造列表</h2>

<p>
<code>Nil</code>代表空列表；<code>::</code>（发音为“cons”），<code>elm::list</code>把单个元素<code>elm</code>接在列表<code>list</code>的前面。
</p>

<pre class="brush: scala">
  val fruit = "apples" :: ("oranges" :: ("pears" :: Nil))
  val nums = 1 :: (2 :: (3 :: (4 :: Nil)))
  val diag3 = (1 :: (0 :: (0 :: Nil))) ::
              (0 :: (1 :: (0 :: Nil))) ::
              (0 :: (0 :: (1 :: Nil))) :: Nil
  val empty = Nil
</pre>

<p>
由于操作符<code>::</code>是右结合性，所以：
</p>

<pre class="brush: scala">
A :: (B :: C)
</pre>

<p>
相当于：
</p>

<pre class="brush: scala">
A :: B :: C
</pre>

<p>
所以前一个例子中很多括号都可以省略：
</p>

<pre class="brush: scala">
  val nums = 1 :: 2 :: 3 :: 4 :: Nil
</pre>

<h2 id="toc_1.4">列表的基本操作</h2>

<p>
三个基本操作：<code>head</code>、<code>tail</code>、<code>isEmpty</code>。
</p>

<pre class="brush: scala">
  val fruit = "apples" :: "oranges" :: "pears" :: Nil
  val nums = 1 :: 2 :: 3 :: 4 :: Nil
  val diag3 = (1 :: (0 :: (0 :: Nil))) ::
              (0 :: (1 :: (0 :: Nil))) ::
              (0 :: (0 :: (1 :: Nil))) :: Nil
  val empty = Nil
  
empty.isEmpty // true
fruit.isEmpty // flase
fruit.head // "apples"
fruit.tail.head // "organges"
diag3.head // List(1, 0, 0)
</pre>

<p>
<code>head</code>与<code>tail</code>只能用在非空列表上，不然抛异常：
</p>

<pre class="brush: scala">
  scala&gt; Nil.head
  java.util.NoSuchElementException: head of empty list
</pre>

<p>
一个排序的例子，使用插入排序：对于非空列表<code>x::xs</code>可以先排序<code>xs</code>。然后再把<code>x</code>插入
正确的地方：
</p>

<pre class="brush: scala">
  def isort(xs: List[Int]): List[Int] =
    if (xs.isEmpty) Nil
    else insert(xs.head, isort(xs.tail))

  def insert(x: Int, xs: List[Int]): List[Int] =
    if (xs.isEmpty || x &lt;= xs.head) x :: xs
    else xs.head :: insert(x, xs.tail)
</pre>


<h2 id="toc_1.5">列表模式</h2>

<p>
简单的模式匹配，在确定长度的情况下取出列表里的元素：
</p>

<pre class="brush: scala">
  scala&gt; val List(a, b, c) = fruit
  a: String = apples
  b: String = oranges
  c: String = pears
</pre>

<p>
不确定具体长度但知道至少有几个，或是只要取前几个：
</p>

<pre class="brush: scala">
  scala&gt; val a :: b :: rest = fruit
  a: String = apples
  b: String = oranges
  rest: List[String] = List(pears)
</pre>

<p>
要注意这里的<code>List(...)</code>和<code>::</code>并不是之前定义的模式匹配。
</p>

<p>
实际上<code>List(...)</code>是将来会在抽取器章节介绍的抽取器模式。
</p>

<p>
“cos”模式<code>x::xs</code>是中缀操作符模式的特例，一般中缀表达式<code>p op q</code>视为<code>p.op(q)</code>。
但是如果作为模式，其实是被当作构造器模式的<code>op(p,q)</code>形式。
</p>

<p>
对应这个构造器模式的类是<code>scala.::</code>，它可以创建非空列表的类。还有一个<code>List</code>类的
方法<code>::</code>用来实例化<code>scala.::</code>的对象。在将来的“实现列表”章节中会有进一步的描述。
</p>

<p>
再次用模式匹配的方式来实现前面已经实现过的插入排序法：
</p>

<pre class="brush: scala">
  def isort(xs: List[Int]): List[Int] = xs match {
    case List() =&gt; List()
    case x :: xs1 =&gt; insert(x, isort(xs1))
  }

  def insert(x: Int, xs: List[Int]): List[Int] = xs match {
    case List() =&gt; List(x)
    case y :: ys =&gt; if (x &lt;= y) x :: xs
                    else y :: insert(x, ys)
  }
</pre>

<h2 id="toc_1.6">List类的一阶方法</h2>

<p>
这里介绍的方法是List类的方法，所以是在独立的对象上被调用。
</p>

<h3 id="toc_1.6.1">连接列表</h3>

<p>
连接两个列表的操作符是<code>:::</code>，例如：
</p>

<pre class="brush: scala">
  scala&gt; List(1, 2) ::: List(3, 4, 5)
  res0: List[Int] = List(1, 2, 3, 4, 5)

  scala&gt; List() ::: List(1, 2, 3)
  res1: List[Int] = List(1, 2, 3)

  scala&gt; List(1, 2, 3) ::: List(4)
  res2: List[Int] = List(1, 2, 3, 4)
</pre>

<p>
它也是右结合的：
</p>

<pre class="brush: scala">
xs ::: ys ::: zs
</pre>

<p>
相当于：
</p>

<pre class="brush: scala">
xs ::: (ys ::: zs)
</pre>


<h3 id="toc_1.6.2">分治原则</h3>

<p>
手动实现一个连接列表的<code>append</code>方法。先用模式匹配把输入的列表拆分为更加简单的样本：
</p>

<pre class="brush: scala">
  def append[T](xs: List[T], ys: List[T]): List[T] =
    xs match {
      case List() =&gt; ys
      case x :: xs1 =&gt; x :: append(xs1, ys)
    }
</pre>

<p>
以上代码的让<code>ys</code>操持完整而<code>xs</code>被一步步拆分并放到<code>ys</code>前面，所以把注意集中到<code>xs</code>的
模式匹配上。
</p>

<p>
再通过递归调用层层套用剩下的元素，通过添加单个元素的方法<code>::</code>连接列表。
</p>

<h3 id="toc_1.6.3">列表长度</h3>

<pre class="brush: scala">
  scala&gt; List(1, 2, 3).length
  res3: Int = 3
</pre>

<p>
<code>length</code>方法要遍历整个列表来取得长度，所以判断是否为空一般用<code>isEmpty</code>而不用<code>length</code>。
</p>

<h3 id="toc_1.6.4">取头和尾</h3>

<p>
<code>head</code>取头，<code>tail</code>取的是除了第一个元素外剩下列表。这两个方法的运行时间是常量。
</p>

<p>
<code>last</code>取尾，<code>init</code>取最后一个以外的列表。这两个方法会遍历整个列表。
</p>

<pre class="brush: scala">
  scala&gt; val abcde = List('a', 'b', 'c', 'd', 'e')
  abcde: List[Char] = List(a, b, c, d, e)

  scala&gt; abcde.last
  res4: Char = e

  scala&gt; abcde.init
  res5: List[Char] = List(a, b, c, d)
</pre>

<p>
对于空列表会抛异常
</p>

<pre class="brush: scala">
  scala&gt; List().init
  java.lang.UnsupportedOperationException: Nil.init
   at scala.List.init(List.scala:544)
   at ...

  scala&gt; List().last
  java.util.NoSuchElementException: Nil.last
   at scala.List.last(List.scala:563)
   at ...
</pre>

<h3 id="toc_1.6.5">反转列表</h3>

<p>
<code>reverse</code>是创建了一个新列表：
</p>

<pre class="brush: scala">
  scala&gt; abcde.reverse
  res6: List[Char] = List(e, d, c, b, a)

  scala&gt; abcde
  res7: List[Char] = List(a, b, c, d, e)
</pre>

<p>
一些简单的规律：
</p>

<pre class="brush: scala">
xs.reverse.reverse equals xs

xs.reverse.init equals xs.tail.reverse
xs.reverse.tail equals xs.init.reverse
xs.reverse.head equals xs.last
xs.reverse.last equals xs.head
</pre>

<p>
通过连接在尾部添加操作<code>:::</code>来实现反转：
</p>

<pre class="brush: scala">
  def rev[T](xs: List[T]): List[T] = xs match {
    case List() =&gt; xs
    case x :: xs1 =&gt; rev(xs1) ::: List(x)
  }
</pre>

<p>
当然这样的效率低得很，因为列表要一个一个遍历才能找到最后一个元素。
</p>

<h3 id="toc_1.6.6">前缀与后缀</h3>

<p>
<code>take</code>和<code>drop</code>取得或舍去列表指定长度个元素，长度超过时不会抛异常而是返回整个列表
或空列表。
</p>

<pre class="brush: scala">
  scala&gt; abcde take 2
  res8: List[Char] = List(a, b)

  scala&gt; abcde drop 2
  res9: List[Char] = List(c, d, e)
</pre>

<p>
<code>splitAt</code>在指定位置拆分列表。
</p>

<pre class="brush: scala">
xs splitAt n

// equals

(xs take n, xs drop n)
</pre>

<p>
例：
</p>

<pre class="brush: scala">
  scala&gt; abcde splitAt 2
  res10: (List[Char], List[Char]) = (List(a, b),List(c, d, e))
</pre>

<h3 id="toc_1.6.7">取得指定元素</h3>

<p>
通过索引取得指定元素：
</p>

<pre class="brush: scala">
  scala&gt; abcde apply 2 // rare in Scala
  res11: Char = c

  scala&gt; abcde(2) // rare in Scala
  res12: Char = c
</pre>

<p>
<code>includes</code>方法取得所有的索引列表：
</p>

<pre class="brush: scala">
  scala&gt; abcde.indices
  res13: List[Int] = List(0, 1, 2, 3, 4)
</pre>

<h3 id="toc_1.6.8">zip</h3>

<p>
把两个列表组成对偶（二元组），如果长度不一样会丢弃长出来的：
</p>

<pre class="brush: scala">
  scala&gt; abcde.indices zip abcde
  res14: List[(Int, Char)] = List((0,a), (1,b), (2,c), (3,d),
  (4,e))

  scala&gt; val zipped = abcde zip List(1, 2, 3)
  zipped: List[(Char, Int)] = List((a,1), (b,2), (c,3))
</pre>

<p>
如果是为了把元素和索引zip在一起，用<code>zipWithIndex</code>方法更有效：
</p>

<pre class="brush: scala">
  scala&gt; abcde.zipWithIndex
  res15: List[(Char, Int)] = List((a,0), (b,1), (c,2), (d,3), (e,4))
</pre>

<h3 id="toc_1.6.9">toString 和 mkString</h3>

<p>
<code>toString</code>简单字符串化列表
</p>

<pre class="brush: scala">
  scala&gt; abcde.toString
  res16: String = List(a, b, c, d, e)
</pre>

<p>
<code>mkString</code>通过三个参数来指定前后包列表的字符和分隔列表元素的字符：
</p>

<pre class="brush: scala">
xs mkString (pre, sep, post)
</pre>

<p>
还有两个变体：
</p>

<pre class="brush: scala">
xs mkString sep
// equals
xs mkString ("", sep, "")

sx mkString
// equals
xs mkString ""
</pre>

<p>
例子：
</p>

<pre class="brush: scala">
  scala&gt; abcde mkString ("[", ",", "]")
  res17: String = [a,b,c,d,e]

  scala&gt; abcde mkString ""
  res18: String = abcde

  scala&gt; abcde.mkString
  res19: String = abcde

  scala&gt; abcde mkString ("List(", ", ", ")")
  res20: String = List(a, b, c, d, e)
</pre>

<p>
还有一个<code>addSting</code>变体让结果添加到<code>StringBuilder</code>中，而不是作为结果返回：
</p>

<pre class="brush: scala">
  scala&gt; val buf = new StringBuilder
  buf: StringBuilder =

  scala&gt; abcde addString (buf, "(", ";", ")")
  res21: StringBuilder = (a;b;c;d;e)
</pre>


<h3 id="toc_1.6.10">列表的转换</h3>

<p>
<code>List</code>类的<code>toArray</code>和<code>Array</code>类的<code>toList</code>，列表和数组转来转去。
</p>

<pre class="brush: scala">
  scala&gt; val arr = abcde.toArray
  arr: Array[Char] = Array(a, b, c, d, e)

  scala&gt; arr.toString
  res22: String = Array(a, b, c, d, e)

  scala&gt; arr.toList
  res23: List[Char] = List(a, b, c, d, e)
</pre>

<p>
<code>copyToArray</code>把列表复制到数组中一会连续的空间内：
</p>

<pre class="brush: scala">
  xs copyToArray (arr, start)
</pre>

<p>
<code>start</code>为开始的位置。当然还要保证数组中有足够的空间。例子：
</p>

<pre class="brush: scala">
  scala&gt; val arr2 = new Array[Int](10)
  arr2: Array[Int] = Array(0, 0, 0, 0, 0, 0, 0, 0, 0, 0)

  scala&gt; List(1, 2, 3) copyToArray (arr2, 3)

  scala&gt; arr2.toString
  res25: String = Array(0, 0, 0, 1, 2, 3, 0, 0, 0, 0)
</pre>

<p>
<code>elements</code>提供了通过枚举器访问列表元素的方法：
</p>

<pre class="brush: scala">
  scala&gt; val it = abcde.elements
  it: Iterator[Char] = non-empty iterator

  scala&gt; it.next
  res26: Char = a

  scala&gt; it.next
  res27: Char = b
</pre>

<h3 id="toc_1.6.11">例：归并排序</h3>

<p>
归并排序：如果列表长度为0或是1，就算是已经排序好的，直接返回。长度大于1的列表
可以拆成两个长度接近的，每个再递归调用完成排序，再把返回的两个排序好的列表合并。
</p>

<p>
函数的实现用到了柯里化，接收元素之间的比较大小的函数和要排序的列表：
</p>

<pre class="brush: scala">
  def msort[T](less: (T, T) =&gt; Boolean)
      (xs: List[T]): List[T] = {

    def merge(xs: List[T], ys: List[T]): List[T] =
      (xs, ys) match {
        case (Nil, _) =&gt; ys
        case (_, Nil) =&gt; xs
        case (x :: xs1, y :: ys1) =&gt;
          if (less(x, y)) x :: merge(xs1, ys)
          else y :: merge(xs, ys1)
      }

    val n = xs.length / 2
    if (n == 0) xs
    else {
      val (ys, zs) = xs splitAt n
      merge(msort(less)(ys), msort(less)(zs))
    }
  }
</pre>

<p>
使用的方法：
</p>

<pre class="brush: scala">
  scala&gt; msort((x: Int, y: Int) =&gt; x &lt; y)(List(5, 7, 1, 3))
  res28: List[Int] = List(1, 3, 5, 7)
</pre>

<p>
作为一个柯里化的例子，可以用下划线代表末指定的参数列表：
</p>

<pre class="brush: scala">
  scala&gt; val intSort = msort((x: Int, y: Int) =&gt; x &lt; y) _
  intSort: (List[Int]) =&gt; List[Int] = &lt;function&gt;
</pre>

<p>
如果要改成倒序排序的话，只要换个比较函数：
</p>

<pre class="brush: scala">
  scala&gt; val reverseIntSort = msort((x: Int, y: Int) =&gt; x &gt; y) _
  reverseIntSort: (List[Int]) =&gt; List[Int] = &lt;function&gt;
</pre>

<p>
上面的<code>intSort</code>和<code>reverseIntSort</code>都已经绑定了排序的方法，只要传入待排序的列表：
</p>

<pre class="brush: scala">
  scala&gt; val mixedInts = List(4, 1, 9, 0, 5, 8, 3, 6, 2, 7)
  mixedInts: List[Int] = List(4, 1, 9, 0, 5, 8, 3, 6, 2, 7)

  scala&gt; intSort(mixedInts)
  res0: List[Int] = List(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)

  scala&gt; reverseIntSort(mixedInts)
  res1: List[Int] = List(9, 8, 7, 6, 5, 4, 3, 2, 1, 0)
</pre>

<h2 id="toc_1.7">List类的高阶函数</h2>

<p>
这里介绍的方法是List类的方法，所以是在独立的对象上被调用。
</p>

<p>
Scala中以操作符形式出现的高阶函数更加简洁地处理Java中用循环来处理的问题。
</p>

<h3 id="toc_1.7.1">列表间映射</h3>

<p>
<code>xs map fun</code>把列表中每个元素用方法处理过后生成新列表。<code>xs</code>代表<code>List[T]</code>；<code>fun</code>
代表<code>T =&gt; U</code>的函数。
</p>

<pre class="brush: scala">
  scala&gt; List(1, 2, 3) map (_ + 1)
  res29: List[Int] = List(2, 3, 4)

  scala&gt; val words = List("the", "quick", "brown", "fox")
  words: List[java.lang.String] = List(the, quick, brown, fox)
 
  scala&gt; words map (_.length)
  res30: List[Int] = List(3, 5, 5, 3)

  scala&gt; words map (_.toList.reverse.mkString)
  res31: List[String] = List(eht, kciuq, nworb, xof)
</pre>

<p>
<code>flatMap</code>和<code>map</code>类似，但它把所有元素连成一个列表：
</p>

<pre class="brush: scala">
  scala&gt; words map (_.toList)
  res32: List[List[Char]] = List(List(t, h, e), List(q, u, i,
      c, k), List(b, r, o, w, n), List(f, o, x))

  scala&gt; words flatMap (_.toList)
  res33: List[Char] = List(t, h, e, q, u, i, c, k, b, r, o, w,
      n, f, o, x)
</pre>

<p>
<code>flatMap</code>和<code>map</code>合作建立出所有<code>1 &lt;= j &lt; i &lt; 5</code>的<code>(i, j)</code>对偶：
</p>

<pre class="brush: scala">
  scala&gt; List.range(1, 5) flatMap (
       | i =&gt; List.range(1, i) map (j =&gt; (i, j))
       | )
  res34: List[(Int, Int)] = List((2,1), (3,1), (3,2), (4,1),
      (4,2), (4,3))
</pre>

<p>
上面的代码<code>List.range(1, 5)</code>产生从1到5的整数列表。对于其中的每项<code>i</code>再产生1到<code>i</code>
的列表。<code>map</code>产生<code>(i, j)</code>元组列表，这里的<code>j&lt;i</code>。<code>flatMpa</code>对每个1到5之间的<code>i</code>产生
列表，并连接所有列表得到结果。
</p>

<p>
等同于以下循环结构：
</p>

<pre class="brush: scala">
  for (i &lt;- List.range(1, 5); j &lt;- List.range(1, i)) yield (i, j)
</pre>

<p>
<code>foreach</code>没有返回结果（或返回<code>Unit</code>）。如下对<code>sum</code>变量累加，但是没有返回值：
</p>

<pre class="brush: scala">
  scala&gt; var sum = 0
  sum: Int = 0

  scala&gt; List(1, 2, 3, 4, 5) foreach (sum += _)

  scala&gt; sum
  res36: Int = 15
</pre>

<h3 id="toc_1.7.2">过滤</h3>

<p>
<code>xs filter p</code>，<code>xs</code>代表<code>List[T]</code>，<code>p</code>代表<code>T =&gt; Boolean</code>形式的函数。返回符合的结果列表：
</p>

<pre class="brush: scala">
  scala&gt; List(1, 2, 3, 4, 5) filter (_ % 2 == 0)
  res37: List[Int] = List(2, 4)

  scala&gt; words filter (_.length == 3)
  res38: List[java.lang.String] = List(the, fox)
</pre>

<p>
<code>partition</code>方法返回的是所有符合的元素和所有不符合的元素两个列表对。
</p>

<pre class="brush: scala">
xs partition p
// equals
( xs filter p , xs filter (!p(_)) )

</pre>

<p>
例：
</p>

<pre class="brush: scala">
  scala&gt; List(1, 2, 3, 4, 5) partition (_ % 2 == 0)
  res39: (List[Int], List[Int]) = (List(2, 4),List(1, 3, 5))
</pre>

<p>
<code>find</code>方法只返回第一个符合的元素，一个都不符合返回<code>None</code>：
</p>

<pre class="brush: scala">
  scala&gt; List(1, 2, 3, 4, 5) find (_ % 2 == 0)
  res40: Option[Int] = Some(2)

  scala&gt; List(1, 2, 3, 4, 5) find (_ &lt;= 0)
  res41: Option[Int] = None
</pre>

<p>
<code>takeWhile</code>不断累积符合的结果直到遇到不符合的；<code>dropWhile</code>不断丢弃不符的元素直到
遇到符合的。
</p>

<pre class="brush: scala">
  scala&gt; List(1, 2, 3, -4, 5) takeWhile (_ &gt; 0)
  res42: List[Int] = List(1, 2, 3)

  scala&gt; words dropWhile (_ startsWith "t")
  res43: List[java.lang.String] = List(quick, brown, fox)
</pre>

<p>
<code>span</code>方法组合了<code>takeWhile</code>和<code>dropWhile</code>返回一对列表，就像是<code>splitAt</code>组合了
<code>take</code>和<code>drop</code>一样。
</p>

<pre class="brush: scala">
xs span p
// equals
(xs takeWhile p , xs dropWhile p)
</pre>

<p>
和<code>split</code>一样，<code>span</code>避免对列表的二次访问：
</p>

<pre class="brush: scala">
  scala&gt; List(1, 2, 3, -4, 5) span (_ &gt; 0)
  res44: (List[Int], List[Int]) = (List(1, 2, 3),List(-4, 5))
</pre>

<h3 id="toc_1.7.3">列表论断</h3>

<p>
<code>xs forall p</code>全部符合，<code>xs exits p</code>存在符合的元素。
</p>

<pre class="brush: scala">
  scala&gt; def hasZeroRow(m: List[List[Int]]) =
       | m exists (row =&gt; row forall (_ == 0))
  hasZeroRow: (List[List[Int]])Boolean

  scala&gt; hasZeroRow(diag3)
  res45: Boolean = false
</pre>

<h3 id="toc_1.7.4">reduce与folder</h3>

<h4 id="toc_1.7.4.1">化简（reduce）</h4>

<p>
<code>reduceLeft</code>操作：
</p>

<pre class="brush: scala">
List(1, 2, 3, 4).reduceLeft(_ + _)
// 相当于
((1 + 2) + 3) + 4
</pre>

<p>
<code>reduceRight</code>操作：
</p>

<pre class="brush: scala">
List(1, 2, 3, 4).reduceRight(_ + _)
// 相当于
((4 + 3) + 2) + 1
</pre>

<h4 id="toc_1.7.4.2">折叠（folder）</h4>

<p>
左折叠操作符<code>/:</code>，格式为：<code>(z /: xs) (op)</code>。其中<code>z</code>为开始值，<code>xs</code>为列表，<code>op</code>为二元操作。
</p>

<pre class="brush: scala">
(z /: List(a, b, c)) (op)
// equals
op(op(op(z,a), b), c)
</pre>

<p>
用树表示：
</p>

<pre class="brush: scala">
      op
     / \
    op  c
   / \
  op  b
 / \
z   a
</pre>

<p>
举例：
</p>

<pre class="brush: scala">
  scala&gt; def sum(xs: List[Int]): Int = (0 /: xs) (_ + _)
  sum: (List[Int])Int
  
  scala&gt; sum(List(1, 2, 3)) // equals 0 + 1 + 2 + 3
  res1: Int = 6

  scala&gt; def product(xs: List[Int]): Int = (1 /: xs) (_ * _)
  product: (List[Int])Int
  
  scala&gt; product(List(1, 2, 3)) // equals 1 * 1 * 2 * 3
  res2: Int = 6
</pre>

<p>
用空格连接所有单词：
</p>

<pre class="brush: scala">
  scala&gt; ("" /: words) (_ +" "+ _)
  res46: java.lang.String = the quick brown fox
</pre>

<p>
头上多了一个空格，这样去掉它：
</p>

<pre class="brush: scala">
  scala&gt; (words.head /: words.tail) (_ +" "+ _)
  res47: java.lang.String = the quick brown fox
</pre>

<p>
相对的还有右倾斜操作树<code>:\</code>：
</p>

<pre class="brush: scala">
(List(a, b, c) :\ z) (op)
// equals
op(a, op(b, op(c, z)))
</pre>

<p>
对于组合操作来说，左右折叠是等价的，但效率上有差异。下面两个把元素连接在一起的
方法：
</p>

<pre class="brush: scala">
  def flattenLeft[T](xss: List[List[T]]) =
      (List[T]() /: xss) (_ ::: _)

  def flattenRight[T](xss: List[List[T]]) =
      (xss :\ List[T]()) (_ ::: _)

</pre>

<p>
采用右折叠的<code>flattenLeft</code>需要复制第一个元素列表<code>xss.head</code>一共<code>xss.length-1</code>次，
所以效率差一些。
</p>

<p>
注意这里两个版本的实现都要对作为折叠开始值的空列表做类型标注。这是由Scala类型
推断的局限性无法推断出正确的类型。不标注的话会有以下错误：
</p>

<pre class="brush: scala">
  scala&gt; def flattenRight[T](xss: List[List[T]]) =
       | (xss :\ List()) (_ ::: _)
  &lt;console&gt;:15: error: type mismatch;
   found : List[T]
   required: List[Nothing]
             (xss :\ List()) (_ ::: _)
                                ^
</pre>

<p>
在以后的“实现列表”章节中讨论类型推断失败的原因。
</p>

<p>
如果觉得<code>/:</code>和<code>:\</code>看起来不清楚，可以用List提供的<code>foldLeft</code>和<code>foldRight</code>方法代替
。比如下面这个查找最大元素的方法：
</p>

<pre class="brush: scala">
scala&gt; def findMax(l:List[Int]) = {
     | l.foldLeft(Integer.MIN_VALUE) {Math.max}
     | }
findMax: (l: List[Int])Int

scala&gt; findMax(List(-77,99,-3,18,7,21))
res0: Int = 99
</pre>

<h3 id="toc_1.7.5">应用场景</h3>

<p>
reduce与folder更加适合：“两两操作”的结果“继承”到“下一个元素”。
</p>

<h4 id="toc_1.7.5.1">例子：统计字母出现次数</h4>

<pre class="brush: scala">
(Map[Char, Int]() /: "Mississippi") {
  (m, c) =&gt; m + (c -&gt; (m.getOrElse(c, 0) + 1))
}

res1: scala.collection.immutable.Map[Char,Int] = 
					Map(M -&gt; 1, i -&gt; 4, s -&gt; 4, p -&gt; 2)
</pre>

<h4 id="toc_1.7.5.2">例子：使用折叠实现列表反转</h4>

<pre class="brush: scala">
def reverseLeft[T](xs: List[T]) = (startvalue /: xs) (operation)
</pre>

<p>
为了写出正确的<code>startvalue</code>和<code>operation</code>，从可以出现的最小的列表<code>List()</code>开始推导：
</p>

<pre class="brush: scala">
List()
// equals
reverseLeft(List())
// equals
(startvalue /: List()) (operation)
// equals
startvalue
</pre>

<p>
所以<code>startvalue</code>一定是<code>List()</code>。再代入推导<code>operation</code>：
</p>

<pre class="brush: scala">
List(x)
// equals
reverseLeft(List(x))
// equals
(startvalue /: List(x)) (operation)
// equals
operation(List(), x)
// equals
x :: List()
</pre>

<p>
所以具体实现为：
</p>

<pre class="brush: scala">
  def reverseLeft[T](xs: List[T]) =
    (List[T]() /: xs) {(ys, y) =&gt; y :: ys}
</pre>

<h3 id="toc_1.7.6">扫描（scan）</h3>

<p>
<code>scanLeft</code>和<code>scanRight</code>是把<code>folder</code>和<code>map</code>操作结合在一起。返回的结果是包含所有
中间结果的集合：
</p>

<pre class="brush: scala">

scala&gt; (1 to 10).scanLeft(0)(_ + _)
res2: scala.collection.immutable.IndexedSeq[Int] = 
		Vector(0, 1, 3, 6, 10, 15, 21, 28, 36, 45, 55)
</pre>

<h3 id="toc_1.7.7">排序</h3>

<p>
<code>xs sort before</code>，<code>xs</code>是列表，<code>before</code>是比较元素<code>x</code>是否在<code>y</code>前面的方法。
</p>

<pre class="brush: scala">
  scala&gt; List(1, -3, 4, 2, 6) sort (_ &lt; _)
  res48: List[Int] = List(-3, 1, 2, 4, 6)

  scala&gt; words sort (_.length &gt; _.length)
  res49: List[java.lang.String] = List(quick, brown, fox, the)
</pre>

<p>
注意前面还提到过一个<code>msort</code>方法，那个是定义在列表外的。<code>sort</code>是List类的方法。
</p>

<p>
<code>sortWith</code>排序：
</p>

<pre class="brush: scala">
scala&gt; "Mary has a little lamb".split(" ").sortWith(_.length &lt; _.length)
res0: Array[String] = Array(a, has, Mary, lamb, little)
</pre>

<h2 id="toc_1.8">List伴生对象的方法</h2>

<p>
下面介绍的方法是伴生对象<code>scala.List</code>的，创建列表的工厂方法和特定类型列表的操作。
</p>

<h3 id="toc_1.8.1">通过元素创建列表</h3>

<p>
<code>apply</code>方法：
</p>

<pre class="brush: scala">
List(1, 2, 3)
// is actually
List.apply(1, 2, 3)
</pre>

<h3 id="toc_1.8.2">按数值范围创建列表</h3>

<p>
<code>range</code>参数可以是：开始、结束、步长：
</p>

<pre class="brush: scala">
  scala&gt; List.range(1, 5)
  res51: List[Int] = List(1, 2, 3, 4)

  scala&gt; List.range(1, 9, 2)
  res52: List[Int] = List(1, 3, 5, 7)

  scala&gt; List.range(9, 1, -3)
  res53: List[Int] = List(9, 6, 3)
</pre>

<h3 id="toc_1.8.3">创建重复元素的列表</h3>

<p>
<code>make</code>方法：
</p>

<pre class="brush: scala">
  scala&gt; List.make(5, 'a')
  res54: List[Char] = List(a, a, a, a, a)

  scala&gt; List.make(3, "hello")
  res55: List[java.lang.String] = List(hello, hello, hello)
</pre>

<h3 id="toc_1.8.4">解除Zip列表</h3>

<p>
<code>unzip</code>把二元组列表分成两个列表：
</p>

<pre class="brush: scala">
  scala&gt; val zipped = "abcde".toList zip List(1, 2, 3)
  zipped: List[(Char, Int)] = List((a,1), (b,2), (c,3))

  scala&gt; List.unzip(zipped)
  res56: (List[Char], List[Int]) = (List(a, b, c),
      List(1, 2, 3))
</pre>

<p>
Scala类型系统要求类方法能处理所有类型，而unzip只处理二元组列表。所以unzip不能像
zip方法一样放在类里而只能放在伴生对象里。
</p>

<h3 id="toc_1.8.5">连接列表</h3>

<p>
<code>flatten</code>方法只能处理包含子列表的列表所以不能放在List类里。只能放在伴生对象中。
</p>

<pre class="brush: scala">
  scala&gt; val xss =
       | List(List('a', 'b'), List('c'), List('d', 'e'))
  xss: List[List[Char]] = List(List(a, b), List(c), List(d, e))

  scala&gt; List.flatten(xss)
  res57: List[Char] = List(a, b, c, d, e)
</pre>

<p>
<code>concat</code>方法把多个列表作为可变长参数形式接收：
</p>

<pre class="brush: scala">
  scala&gt; List.concat(List('a', 'b'), List('c'))
  res58: List[Char] = List(a, b, c)

  scala&gt; List.concat(List(), List('b'), List('c'))
  res59: List[Char] = List(b, c)
  
  scala&gt; List.concat()
  res60: List[Nothing] = List()
</pre>


<h3 id="toc_1.8.6">映射与测试配对</h3>

<p>
<code>map2</code>方法接收两个列表，分别作为方法的两个参数：
</p>

<pre class="brush: scala">
  scala&gt; List.map2(List(10, 20), List(3, 4, 5)) (_ * _)
  res61: List[Int] = List(30, 80)
</pre>

<p>
<code>exist2</code>也是接收两个列表，分别作为方法的两个参数：
</p>

<pre class="brush: scala">
  scala&gt; List.forall2(List("abc", "de"),
       | List(3, 2)) (_.length == _)
  res62: Boolean = true

  scala&gt; List.exists2(List("abc", "de"),
       | List(3, 2)) (_.length != _)
  res63: Boolean = false
</pre>

<h2 id="toc_1.9">了解Scala的类型推断方法</h2>

<p>
Scala的类型推导器是基于流的。
</p>

<p>
下面是用占位符<code>_</code>推导出的参数类型：
</p>

<pre class="brush: scala">
  scala&gt; abcde sort (_ &gt; _)
  res65: List[Char] = List(e, d, c, b, a)
</pre>

<p>
例如对于<code>List[Char]</code>类型的列表<code>abcd</code>，<code>abcd</code>的成员都是<code>Char</code>。所以
<code>abcd.sort(_ &gt; _)</code>的两个参数也只会是<code>Char</code>。所以类型被推导为：
</p>

<pre class="brush: scala">
(_ &gt; _)
// trans to
((x: Char, y: Char) =&gt; x &gt; y)
</pre>

<p>
再来看<code>msort</code>方法：
</p>

<pre class="brush: scala">
  scala&gt; msort((x: Char, y: Char) =&gt; x &gt; y)(abcde)
  res64: List[Char] = List(e, d, c, b, a)
</pre>

<p>
<code>msort</code>方法却不能用占位符：
</p>
  
<pre class="brush: scala">
  scala&gt; msort(_ &gt; _)(abcde)
  &lt;console&gt;:12: error: missing parameter type for expanded
  function ((x$1, x$2) =&gt; x$1.$greater(x$2))
         msort(_ &gt; _)(abcde)
               ^
</pre>

<p>
原因是对于<code>func(args)</code>这样的方法，先看<code>func</code>是否有已经的类型。如果有的话这个类型
就被用来做参数预期类型的推断。而<code>msort(_ &gt; _)(abcde)</code>这个类型是柯里化的、多态的
方法类型，参数类型是<code>(T, T) =&gt; Boolean</code>，返回类型是从<code>List[T]</code>到<code>List[T]</code>的函数
。无法推断第一个参数的类型。所以类型推断器要参数的类型信息。
</p>

<p>
想要用占位符的话，只能把参数类型传给<code>msort</code>，改为<code>msort[Char]</code>：
</p>

<pre class="brush: scala">
  scala&gt; msort[Char](_ &gt; _)(abcde)
  res66: List[Char] = List(e, d, c, b, a)
</pre>

<p>
还有一个方法是交换参数顺序，这样可以用第一个列表的类型来推断比较方法的类型了：
</p>

<pre class="brush: scala">
  // same implementation as msort,
  // but with arguments swapped
  def msortSwapped[T](xs: List[T])(less:
      (T, T) =&gt; Boolean): List[T] = {
  }
  
  scala&gt; msortSwapped(abcde)(_ &gt; _)
  res67: List[Char] = List(e, d, c, b, a)
</pre>

<p>
需要推断多态方法类型时只会参考第一个参数列表，所以在柯里化方法有两个参数列表时
第二个参数不会用来决定方法类型参数。所以这种方案隐含以下的库方法设计原则：
</p>

<p>
如果参数包括若干个非函数参数与一个函数参数的组合时，要把函数参数独自放在柯里化
参数列表的最后面。这样方法的正确实例类型就可以通过非函数参数推断出来，推断出来的
类型还可以转面用来完成函数参数的类型检查。调用函数的时候也可以写出更加简洁的
字面量。
</p>

<p>
再来看更加复杂的折叠操作：
</p>

<pre class="brush: scala">
  (xss :\ List[T]()) (_ ::: _)

</pre>

<p>
上面的表达式提供了明确的类型参数的原因是这个右折叠操作的类型取决于两个变量：
</p>

<pre class="brush: scala">
  (xs :\ z) (op)
</pre>

<p>
这里把列表<code>xs</code>的类型记为<code>A</code>，如：<code>xs: List[A]</code>；而开始值<code>z</code>有可能是类型<code>B</code>。对应
的操作<code>op</code>必须以<code>A</code>和<code>B</code>的值为参数并返回类型<code>B</code>的结果，即：<code>op: (A, B) =&gt; B</code>。
</p>

<p>
从上面的描述可以看出：这里的<code>op</code>方法要知道<code>A</code>与<code>B</code>两个类型。<code>A</code>一定与<code>List</code>有关
，但是<code>B</code>不一定与<code>List</code>有关，所以推不出来。所以下面的表达式是编译不过的：
</p>

<pre class="brush: scala">
  (xss :\ List()) (_ ::: _) // this won't compile

</pre>

<p>
上面表达式中<code>z</code>的类型为<code>List[Nothing]</code>，据此推断器把<code>B</code>的类型定为<code>Nothing</code>：
</p>

<pre class="brush: scala">
  (List[T], List[Nothing]) =&gt; List[Nothing]
</pre>

<p>
这就意味着输出与输出都是空列表。
</p>

<p>
就是因为这个问题，所以在柯里化的方法中，方法类型只取决于第一段参数。但是如果不
这么做的话，推断器还是没有办法取得<code>op</code>的类型。所以只能程序员明确指定类型。
</p>

<p>
所以Scala采用的局部的、基于流的类型推断方法还是比较有局限性的；不如ML或是Haskell
采用的更加全局化的Hindley-Milner类型推断方式。但是对于面向对象的分支类型处理比
Hindley-Mlner更加优雅。由于这些局限性在比较极端的情况下才遇到，所以在极端情况下
还是明确标类型吧。
</p>

<p>
另外在遇到多态类型错误时，添加上你认为应该是正确的类型标注也是一种排错方式。
</p>




<h1 id="toc_2">集合类型</h1>

<h2 id="toc_2.1">概览</h2>

<p>
<code>scala</code>包中主要特质<code>Iterable</code>，三个子特质：
</p>

<ul>
<li>
<code>Seq</code>：有序集合。

<li>
<code>Set</code>：对于<code>==</code>方法不可重复的元素集合。

<li>
<code>Map</code>：键值映射。

</ul>

<p>
特技<code>Iterable</code>有个抽象方法<code>elements</code>：
</p>

<pre class="brush: scala">
  def elements: Iterator[A]
</pre>

<p>
注意返回类型是一个迭代器<code>iterator</code>，不是<code>iterate</code>别看错了！
</p>

<p>
迭代器用来从头到尾遍历一遍集合。如果要再遍历一遍的话，只能用<code>elements</code>方法再生成
一个新的迭代器。。
</p>

<p>
迭代器<code>Iterator</code>继承自<code>AnyRef</code>。<code>Iterator</code>提供的具体方法都实现了<code>next</code>和
<code>hasNext</code>抽象方法实现：
</p>

<pre class="brush: scala">
  def hasNext: Boolean
  def next: A
</pre>

<h2 id="toc_2.2">序列</h2>

<h3 id="toc_2.2.1">列表</h3>

<p>
列表不能通过索引直接访问元素，只能遍历；但可以支持在头上快速添加和删除。这点像是
链式表。使用模式匹配的方式可以很好地在头上快速添加和删除元素。
</p>

<p>
但是因为只能对列表头快速访问，而尾部不行。所以如果要操作尾部的话可以先建一个反序
的列表，再<code>reverse</code>把顺序反过来。
</p>

<h3 id="toc_2.2.2">列表缓存</h3>

<p>
还有一人方式是使用<code>scala.collection.mutable.ListBuffer</code>。
</p>

<p>
<code>+=</code>在尾部添加元素；<code>+:</code>加在头上；完成之后用<code>toList</code>生成<code>List</code>：
</p>

<pre class="brush: scala">
  scala&gt; import scala.collection.mutable.ListBuffer
  import scala.collection.mutable.ListBuffer

  scala&gt; val buf = new ListBuffer[Int]
  buf: scala.collection.mutable.ListBuffer[Int] = ListBuffer()

  scala&gt; buf += 1

  scala&gt; buf += 2

  scala&gt; buf
  res11: scala.collection.mutable.ListBuffer[Int]
    = ListBuffer(1, 2)

  scala&gt; 3 +: buf
  res12: scala.collection.mutable.Buffer[Int]
    = ListBuffer(3, 1, 2)

  scala&gt; buf.toList
  res13: List[Int] = List(3, 1, 2)
</pre>

<p>
<code>List</code>结合前置添加元素和递归算法增长列表时，如果用的递归算法不是尾递归，就有栈
溢出的风险；而<code>ListBuffer</code>可以结合循环替代递归。
</p>

<h3 id="toc_2.2.3">数组</h3>

<p>
数组适合按索引快速访问元素。
</p>

<p>
按长度产数组：
</p>

<pre class="brush: scala">
  scala&gt; val fiveInts = new Array[Int](5)
  fiveInts: Array[Int] = Array(0, 0, 0, 0, 0)
</pre>

<p>
按元素产数组：
</p>

<pre class="brush: scala">
  scala&gt; val fiveToOne = Array(5, 4, 3, 2, 1)
  fiveToOne: Array[Int] = Array(5, 4, 3, 2, 1)
</pre>

<p>
通过<code>()</code>指定索引：
</p>

<pre class="brush: scala">
  scala&gt; fiveInts(0) = fiveToOne(4)

  scala&gt; fiveInts
  res1: Array[Int] = Array(1, 0, 0, 0, 0)
</pre>

<h2 id="toc_2.3">数组缓存</h2>

<p>
<code>ArrayBuffer</code>可以在头尾添加元素，但在尾部的添加移除是高效的。常见的用法是先用
<code>ArrayBuffer</code>构建然后用它的<code>toArray</code>方法生成不可变的数组：
</p>

<pre class="brush: scala">
  scala&gt; import scala.collection.mutable.ArrayBuffer
  import scala.collection.mutable.ArrayBuffer

  scala&gt; val buf = new ArrayBuffer[Int]()
  buf: scala.collection.mutable.ArrayBuffer[Int] =
    ArrayBuffer()

  scala&gt; buf += 12
  scala&gt; buf += 15

  scala&gt; buf
  res16: scala.collection.mutable.ArrayBuffer[Int] =
    ArrayBuffer(12, 15)

  scala&gt; buf.length
  res17: Int = 2

  scala&gt; buf(0)
  res18: Int = 12
</pre>

<h3 id="toc_2.3.1">队列</h3>

<p>
不可变的队列：
</p>

<pre class="brush: scala">
  scala&gt; import scala.collection.immutable.Queue
  import scala.collection.immutable.Queue

  scala&gt; val empty = new Queue[Int]
  empty: scala.collection.immutable.Queue[Int] = Queue()

// add one element
  scala&gt; val has1 = empty.enqueue(1)
  has1: scala.collection.immutable.Queue[Int] = Queue(1)

// use collection to add many elements
  scala&gt; val has123 = has1.enqueue(List(2, 3))
  has123: scala.collection.immutable.Queue[Int] = Queue(1,2,3)

  scala&gt; val (element, has23) = has123.dequeue
  element: Int = 1
  has23: scala.collection.immutable.Queue[Int] = Queue(2,3)
</pre>

<p>
注意上面取后一个出队操作<code>dequeue</code>返回的是一个二元组，包括出来的元素和剩下的队列
。
</p>

<p>
可变的队列也差不多，就是用<code>+=</code>和<code>++=</code>添加元素，<code>dequeue</code>方法只返回一个出除的元素。
</p>

<pre class="brush: scala">
  scala&gt; import scala.collection.mutable.Queue
  import scala.collection.mutable.Queue

  scala&gt; val queue = new Queue[String]
  queue: scala.collection.mutable.Queue[String] = Queue()

  scala&gt; queue += "a"

  scala&gt; queue ++= List("b", "c")

  scala&gt; queue
  res21: scala.collection.mutable.Queue[String] = Queue(a, b, c)

  scala&gt; queue.dequeue
  res22: String = a

  scala&gt; queue
  res23: scala.collection.mutable.Queue[String] = Queue(b, c)
</pre>

<h3 id="toc_2.3.2">栈</h3>

<p>
可变的栈：
</p>

<pre class="brush: scala">
  scala&gt; import scala.collection.mutable.Stack
  import scala.collection.mutable.Stack

  scala&gt; val stack = new Stack[Int]
  stack: scala.collection.mutable.Stack[Int] = Stack()

  scala&gt; stack.push(1)

  scala&gt; stack
  res1: scala.collection.mutable.Stack[Int] = Stack(1)

  scala&gt; stack.push(2)

  scala&gt; stack
  res3: scala.collection.mutable.Stack[Int] = Stack(1, 2)

  scala&gt; stack.top
  res8: Int = 2

  scala&gt; stack
  res9: scala.collection.mutable.Stack[Int] = Stack(1, 2)

  scala&gt; stack.pop
  res10: Int = 2

  scala&gt; stack
  res11: scala.collection.mutable.Stack[Int] = Stack(1)
</pre>

<p>
不可变的栈略。
</p>

<h3 id="toc_2.3.3">字符串</h3>

<p>
因为<code>Predef</code>包含了从<code>String</code>到<code>RichString</code>的隐式转换，所以可以把任何字符串当作
<code>Seq[Char]</code>。
</p>

<pre class="brush: scala">
  scala&gt; def hasUpperCase(s: String) = s.exists(_.isUpperCase)
  hasUpperCase: (String)Boolean

  scala&gt; hasUpperCase("Robert Frost")
  res14: Boolean = true

  scala&gt; hasUpperCase("e e cummings")
  res15: Boolean = false
</pre>

<p>
<code>exists</code>方法不在<code>String</code>里，所以隐匿转换为包含<code>exists</code>方法的<code>RichString</code>类。
</p>

<h2 id="toc_2.4">Set与Map</h2>

<p>
因为<code>Predef</code>对象通过<code>type</code>关键字指定默认引用了Set与Map的不可变版本：
</p>

<pre class="brush: scala">
  object Predef {
    type Set[T] = scala.collection.immutable.Set[T]
    type Map[K, V] = scala.collection.immutable.Map[K, V]
    val Set = scala.collection.immutable.Set
    val Map = scala.collection.immutable.Map
    // ...
  }
</pre>

<p>
所以可变版的要手动声明：
</p>

<pre class="brush: scala">
  scala&gt; import scala.collection.mutable
  import scala.collection.mutable

  scala&gt; val mutaSet = mutable.Set(1, 2, 3)
  mutaSet: scala.collection.mutable.Set[Int] = Set(3, 1, 2)
</pre>

<h3 id="toc_2.4.1">使用Set</h3>

<p>
Set的关键在于用对象的<code>==</code>检查唯一性。
</p>

<p>
例子：统计出现的单词
</p>

<p>
用正则<code>[ !,.]+</code>分隔成单词:
</p>

<pre class="brush: scala">
  scala&gt; val text = "See Spot run. Run, Spot. Run!"
  text: java.lang.String = See Spot run. Run, Spot. Run!

  scala&gt; val wordsArray = text.split("[ !,.]+")
  wordsArray: Array[java.lang.String] =
     Array(See, Spot, run, Run, Spot, Run)
</pre>

<p>
建立Set并存入：
</p>

<pre class="brush: scala">
  scala&gt; val words = mutable.Set.empty[String]
  words: scala.collection.mutable.Set[String] = Set()

  scala&gt; for (word &lt;- wordsArray)
       | words += word.toLowerCase

  scala&gt; words
  res25: scala.collection.mutable.Set[String] =
    Set(spot, run, see)
</pre>

<p>
常用方法：
</p>

<table>
<tr>
<td>
val nums = Set(1, 2, 3)
</td>
<td>
建立集合
</td>
</tr>
<tr>
<td>
nums + 5
</td>
<td>
添加元素
</td>
</tr>
<tr>
<td>
nums - 3
</td>
<td>
去除元素
</td>
</tr>
<tr>
<td>
nums ++ List(5, 6)
</td>
<td>
添加多个元素
</td>
</tr>
<tr>
<td>
nums -- List(1, 2)
</td>
<td>
去除多个元素
</td>
</tr>
<tr>
<td>
nums ** Set(1, 3, 5, 7)
</td>
<td>
交集（返回Set(1,3)）
</td>
</tr>
<tr>
<td>
nums.size
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
nums.contains(3)
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
import scala.collection.mutable
</td>
<td>
引入可变的
</td>
</tr>
<tr>
<td>
val words = mutable.Set.empty[String]
</td>
<td>
创建空的可变集
</td>
</tr>
<tr>
<td>
words += "the"
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
words -= "the"
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
words ++= List("do", "re", "mi")
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
words --= List("do", "re")
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
words.clear
</td>
<td>
清空所有元素
</td>
</tr>
</table>

<h3 id="toc_2.4.2">Map</h3>

<p>
使用可变的Map：
</p>

<pre class="brush: scala">
  scala&gt; val map = mutable.Map.empty[String, Int]
  map: scala.collection.mutable.Map[String,Int] = Map()

  scala&gt; val map = mutable.Map.empty[String, Int]
  map: scala.collection.mutable.Map[String,Int] = Map()

  scala&gt; map("hello") = 1

  scala&gt; map("there") = 2

  scala&gt; map
  res28: scala.collection.mutable.Map[String,Int] =
    Map(hello -&gt; 1, there -&gt; 2)

  scala&gt; map("hello")
  res29: Int = 1
</pre>

<p>
统计单词出现次数的例子：
</p>

<pre class="brush: scala">
  scala&gt; def countWords(text: String) = {
       |   val counts = mutable.Map.empty[String, Int]
       |   for (rawWord &lt;- text.split("[ ,!.]+")) {
       |     val word = rawWord.toLowerCase
       |     val oldCount =
       |       if (counts.contains(word)) counts(word)
       |       else 0
       |     counts += (word -&gt; (oldCount + 1))
       |   }
       |   counts
       | }
  countWords: (String)scala.collection.mutable.Map[String,Int]
  

  scala&gt; countWords("See Spot run! Run, Spot. Run!")
  res30: scala.collection.mutable.Map[String,Int] =
    Map(see -&gt; 1, run -&gt; 3, spot -&gt; 2)
</pre>

<p>
常用方法：
</p>

<table>
<tr>
<td>
val nums = Map("i"-&gt;1, "ii"-&gt;2)
</td>
<td>
创建不可变
</td>
</tr>
<tr>
<td>
nums + ("vi"-&gt;6)
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
nums - "ii"
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
nums ++ List("iii"-&gt;3, "v"-&gt;5)
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
nums -- List("i", "ii")
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
nums.size
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
nums.contains("ii")
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
nums("ii")
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
nums.keys
</td>
<td>
返回key迭代器
</td>
</tr>
<tr>
<td>
nums.keySet
</td>
<td>
返回key的集合(Set)
</td>
</tr>
<tr>
<td>
nums.values
</td>
<td>
返回value迭代器
</td>
</tr>
<tr>
<td>
nums.isEmpty
</td>
<td>
返回value的集合(Set)
</td>
</tr>
<tr>
<td>
import scala.collection.mutable
</td>
<td>
引入可变的版本
</td>
</tr>
<tr>
<td>
val words = mutalbe.Map.empty[String, Int]
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
words += ("one"-&gt;1)
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
words -= "one"
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
words ++= List("one"-&gt;1, "two"-&gt;2, "three"-&gt;3))
</td>
<td>
&nbsp;
</td>
</tr>
<tr>
<td>
words --= List("one", "two")
</td>
<td>
&nbsp;
</td>
</tr>
</table>

<h3 id="toc_2.4.3">默认的Set和Map</h3>

<p>
不可变的Set与Map会根据元素的数量优化一些工厂方法，这样返回的类就不一定是指定的
类型。
</p>

<p>
不可变的<code>scala.collection.immutable.Set()</code>工厂方法返回：
</p>

<table>
<tr>
<th>
元素的数量
</th>
<th>
实现
</th>
</tr>
<tr>
<td>
0
</td>
<td>
scala.collection.immutable.EmptySet
</td>
</tr>
<tr>
<td>
1
</td>
<td>
scala.collection.immutable.Set1
</td>
</tr>
<tr>
<td>
2
</td>
<td>
scala.collection.immutable.Set2
</td>
</tr>
<tr>
<td>
3
</td>
<td>
scala.collection.immutable.Set3
</td>
</tr>
<tr>
<td>
4
</td>
<td>
scala.collection.immutable.Set4
</td>
</tr>
<tr>
<td>
&gt;=5
</td>
<td>
scala.collection.immutable.HashSet
</td>
</tr>
</table>

<p>
不可变的<code>scala.collection.immutable.Map()</code>工厂方法返回：
</p>

<table>
<tr>
<th>
元素的数量
</th>
<th>
实现
</th>
</tr>
<tr>
<td>
0
</td>
<td>
scala.collection.immutable.EmptyMap
</td>
</tr>
<tr>
<td>
1
</td>
<td>
scala.collection.immutable.Map1
</td>
</tr>
<tr>
<td>
2
</td>
<td>
scala.collection.immutable.Map2
</td>
</tr>
<tr>
<td>
3
</td>
<td>
scala.collection.immutable.Map3
</td>
</tr>
<tr>
<td>
4
</td>
<td>
scala.collection.immutable.Map4
</td>
</tr>
<tr>
<td>
&gt;=5
</td>
<td>
scala.collection.immutable.HashMap
</td>
</tr>
</table>

<h3 id="toc_2.4.4">有序的集体和映射</h3>

<p>
<code>TreeSet</code>和<code>TreeMap</code>分别实现了<code>SortedSet</code>和<code>SortedMap</code>特质。都用红黑树保存元素，
顺序由<code>Ordered</code>特质决定。这些类只有不可变的版本：
</p>

<pre class="brush: scala">
  scala&gt; import scala.collection.immutable.TreeSet
  import scala.collection.immutable.TreeSet

  scala&gt; val ts = TreeSet(9, 3, 1, 8, 0, 2, 7, 4, 6, 5)
  ts: scala.collection.immutable.SortedSet[Int] =
    Set(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)

  scala&gt; val cs = TreeSet('f', 'u', 'n')
  cs: scala.collection.immutable.SortedSet[Char] = Set(f, n, u)


  scala&gt; import scala.collection.immutable.TreeMap
  import scala.collection.immutable.TreeMap

  scala&gt; var tm = TreeMap(3 -&gt; 'x', 1 -&gt; 'x', 4 -&gt; 'x')
  tm: scala.collection.immutable.SortedMap[Int,Char] =
    Map(1 -&gt; x, 3 -&gt; x, 4 -&gt; x)

  scala&gt; tm += (2 -&gt; 'x')

  scala&gt; tm
  res38: scala.collection.immutable.SortedMap[Int,Char] =
    Map(1 -&gt; x, 2 -&gt; x, 3 -&gt; x, 4 -&gt; x)
</pre>

<h3 id="toc_2.4.5">同步的Set和Map</h3>

<p>
把<code>SynchronizedMap</code>特质混入到实现中。下面单例对象中的<code>makeMap</code>方法：
</p>

<pre class="brush: scala">
  import scala.collection.mutable.{Map,
      SynchronizedMap, HashMap}

  object MapMaker {

    def makeMap: Map[String, String] = {

        new HashMap[String, String] with
            SynchronizedMap[String, String] {

          override def default(key: String) =
            "Why do you want to know?"
        }
    }
  }
</pre>

<p>
上面的方法会返回一个<code>HashMap</code>并且重写了<code>default</code>方法在没有对应的key时有默认的返回。
</p>

<p>
单线程访问的情况如下：
</p>

<pre class="brush: scala">
  scala&gt; val capital = MapMaker.makeMap
  capital: scala.collection.mutable.Map[String,String] = Map()

  scala&gt; capital ++ List("US" -&gt; "Washington",
       | "Paris" -&gt; "France", "Japan" -&gt; "Tokyo")
  res0: scala.collection.mutable.Map[String,String] =
    Map(Paris -&gt; France, US -&gt; Washington, Japan -&gt; Tokyo)

  scala&gt; capital("Japan")
  res1: String = Tokyo

  scala&gt; capital("New Zealand")
  res2: String = Why do you want to know?

  scala&gt; capital += ("New Zealand" -&gt; "Wellington")

  scala&gt; capital("New Zealand")
  res3: String = Wellington
</pre>

<p>
类似地，也可以实现同步的Set：
</p>

<pre class="brush: scala">
  val synchroSet =
    new mutable.HashSet[Int] with
        mutable.SynchronizedSet[Int]
</pre>

<h2 id="toc_2.5">可变与不可变类型的比较</h2>

<p>
为了方便在可变与不可变类型之间地转换，Scala提供了一些语法糖。
</p>

<p>
如，不可变类型不支持<code>+=</code>操作：
</p>

<pre class="brush: scala">
  scala&gt; val people = Set("Nancy", "Jane")
  people: scala.collection.immutable.Set[java.lang.String] =
    Set(Nancy, Jane)

  scala&gt; people += "Bob"
  &lt;console&gt;:6: error: reassignment to val
         people += "Bob"
                ^
</pre>

<p>
但是如果把变量从<code>val</code>改成<code>var</code>，Scala还是可以返回一个添加后的新对象来模拟：
</p>

<pre class="brush: scala">
  scala&gt; var people = Set("Nancy", "Jane")
  people: scala.collection.immutable.Set[java.lang.String] =
    Set(Nancy, Jane)
 
  scala&gt; people += "Bob"

  scala&gt; people
  res42: scala.collection.immutable.Set[java.lang.String] =
    Set(Nancy, Jane, Bob)
</pre>

<p>
类似的还有其他的操作：
</p>

<pre class="brush: scala">
  scala&gt; people -= "Jane"

  scala&gt; people ++= List("Tom", "Harry")

  scala&gt; people
  res45: scala.collection.immutable.Set[java.lang.String] =
    Set(Nancy, Bob, Tom, Harry)
</pre>

<p>
这样的语法糖方便在可变与不可变类型之间转换：
</p>

<pre class="brush: scala">
  var capital = Map("US" -&gt; "Washington", "France" -&gt; "Paris")
  capital += ("Japan" -&gt; "Tokyo")
  println(capital("France"))

  import scala.collection.mutable.Map // only change needed!
  var capital = Map("US" -&gt; "Washington", "France" -&gt; "Paris")
  capital += ("Japan" -&gt; "Tokyo")
  println(capital("France"))
</pre>

<p>
这样的语法糖还可以用在其他类型上。如浮点：
</p>

<pre class="brush: scala">
  scala&gt; var roughlyPi = 3.0
  roughlyPi: Double = 3.0

  scala&gt; roughlyPi += 0.1

  scala&gt; roughlyPi += 0.04

  scala&gt; roughlyPi
  res48: Double = 3.14
</pre>

<p>
基本上<code>+=</code>、<code>-=</code>、<code>*=</code>这类以<code>=</code>结尾的操作符都可以。
</p>

<h2 id="toc_2.6">初始化集合</h2>

<p>
最典型的是用伴生对象的工厂方法：
</p>

<pre class="brush: scala">
  scala&gt; List(1, 2, 3)
  res0: List[Int] = List(1, 2, 3)

  scala&gt; Set('a', 'b', 'c')
  res1: scala.collection.immutable.Set[Char] = Set(a, b, c)

  scala&gt; import scala.collection.mutable
  import scala.collection.mutable

  scala&gt; mutable.Map("hi" -&gt; 2, "there" -&gt; 5)
  res2: scala.collection.mutable.Map[java.lang.String,Int] =
    Map(hi -&gt; 2, there -&gt; 5)

  scala&gt; Array(1.0, 2.0, 3.0)
  res3: Array[Double] = Array(1.0, 2.0, 3.0)
</pre>

<p>
会根据工厂方法推断类型：
</p>

<pre class="brush: scala">
  scala&gt; import scala.collection.mutable
  import scala.collection.mutable

  scala&gt; val stuff = mutable.Set(42)
  stuff: scala.collection.mutable.Set[Int] = Set(42)

  scala&gt; stuff += "abracadabra"
  &lt;console&gt;:7: error: type mismatch;
   found : java.lang.String("abracadabra")
   required: Int
         stuff += "abracadabra"
                  ^
</pre>

<p>
但是可以手动声明类型：
</p>

<pre class="brush: scala">
  scala&gt; val stuff = mutable.Set[Any](42)
  stuff: scala.collection.mutable.Set[Any] = Set(42)
</pre>

<p>
还有一种情况，不能直接把<code>List</code>传递给<code>Set</code>的工厂方法：
</p>

<pre class="brush: scala">
  scala&gt; val colors = List("blue", "yellow", "red", "green")
  colors: List[java.lang.String] =
    List(blue, yellow, red, green)


  scala&gt; import scala.collection.immutable.TreeSet
  import scala.collection.immutable.TreeSet

  scala&gt; val treeSet = TreeSet(colors)
  &lt;console&gt;:6: error: no implicit argument matching
    parameter type (List[java.lang.String]) =&gt;
      Ordered[List[java.lang.String]] was found.
         val treeSet = TreeSet(colors)
                       ^
</pre>

<p>
可行的方案是建立空的<code>TreeSet[String]</code>对象并用<code>TreeSet</code>的<code>++</code>操作把元素加进去：
</p>

<pre class="brush: scala">
  scala&gt; val treeSet = TreeSet[String]() ++ colors
  treeSet: scala.collection.immutable.SortedSet[String] =
     Set(blue, green, red, yellow)
</pre>

<h3 id="toc_2.6.1">数组与列表之间转换</h3>

<pre class="brush: scala">
  scala&gt; treeSet.toList
  res54: List[String] = List(blue, green, red, yellow)

  scala&gt; treeSet.toArray
  res55: Array[String] = Array(blue, green, red, yellow)
</pre>

<p>
由于实现机制是一个一个元素地复制，所以元素多的话速度会慢。
</p>

<h3 id="toc_2.6.2">Set与Map的可变与不可变互转</h3>

<p>
在转为不可变类型时，一般是建一个空的不可变集，再一个一个加上去：
</p>

<pre class="brush: scala">
  scala&gt; import scala.collection.mutable
  import scala.collection.mutable

  scala&gt; treeSet
  res5: scala.collection.immutable.SortedSet[String] =
    Set(blue, green, red, yellow)

  scala&gt; val mutaSet = mutable.Set.empty ++ treeSet
  mutaSet: scala.collection.mutable.Set[String] =
    Set(yellow, blue, red, green)

  scala&gt; val immutaSet = Set.empty ++ mutaSet
  immutaSet: scala.collection.immutable.Set[String] =
    Set(yellow, blue, red, green)

  scala&gt; val muta = mutable.Map("i" -&gt; 1, "ii" -&gt; 2)
  muta: scala.collection.mutable.Map[java.lang.String,Int] =
     Map(ii -&gt; 2, i -&gt; 1)

  scala&gt; val immu = Map.empty ++ muta
  immu: scala.collection.immutable.Map[java.lang.String,Int] =
     Map(ii -&gt; 2, i -&gt; 1)
</pre>

<h3 id="toc_2.6.3">元组</h3>

<p>
元组可以存放不同的类型：
</p>

<pre class="brush: scala">
  (1, "hello", Console)
</pre>

<p>
元组经常被用来返回多个函数结果，如下面的函数要同时返回单词和索引：
</p>

<pre class="brush: scala">
  def longestWord(words: Array[String]) = {
    var word = words(0)
    var idx = 0
    for (i &lt;- 1 until words.length)
      if (words(i).length &gt; word.length) {
        word = words(i)
        idx = i
      }
    (word, idx)
  }
  
  scala&gt; val longest =
       | longestWord("The quick brown fox".split(" "))
  longest: (String, Int) = (quick,1)
</pre>

<p>
然后可以访问各个元素：
</p>

<pre class="brush: scala">
  scala&gt; longest._1
  res56: String = quick

  scala&gt; longest._2
  res57: Int = 1
</pre>

<p>
还可以赋值给自己的变量（其实就是模式匹配）：
</p>

<pre class="brush: scala">
  scala&gt; val (word, idx) = longest
  word: String = quick
  idx: Int = 1

  scala&gt; word
  res58: String = quick
</pre>

<p>
注意括号不能去掉，不然就是给两个变量赋值了两份：
</p>

<pre class="brush: scala">
  scala&gt; val word, idx = longest
  word: (String, Int) = (quick,1)
  idx: (String, Int) = (quick,1)
</pre>

<h2 id="toc_2.7">惰性求值</h2>

<h3 id="toc_2.7.1">迭代器</h3>

<p>
迭代器相对于集合来说是一个惰性求值的替代品，不会为没有取得的元素消耗资源。
</p>

<h3 id="toc_2.7.2">流</h3>

<p>
迭代器有个缺点：只能一个方向向后走。如果需要访问已经走过元组，可以用流来实现。
</p>

<p>
流是一个不可变的列表，但尾部的元素是被惰性求值的，只有用到时才会被计算。
</p>

<p>
操作符<code>#::</code>用于构造一个流，例：
</p>

<pre class="brush: scala">
scala&gt; def numsFrom(n: BigInt): Stream[BigInt] = n #:: numsFrom(n + 1)
numsFrom: (n: BigInt)Stream[BigInt]
</pre>

<p>
它所产生的流对象尾部的内容都是未知的：
</p>

<pre class="brush: scala">
scala&gt; val tenOrMore = numsFrom(10)
tenOrMore: Stream[BigInt] = Stream(10, ?)
</pre>

<p>
在被使用到时才会求值，如用<code>tail</code>来取下一个值：
</p>

<pre class="brush: scala">
scala&gt; tenOrMore.tail.tail.tail
res0: scala.collection.immutable.Stream[BigInt] = Stream(13, ?)
</pre>

<p>
对应的操作也是惰性求值的：
</p>

<pre class="brush: scala">
scala&gt; val squares = numsFrom(1).map(x =&gt; x * x)
squares: scala.collection.immutable.Stream[scala.math.BigInt] = Stream(1, ?)
</pre>

<p>
可用<code>tail</code>来取下一个元素，也可用<code>take(num)</code>来取多个元素，再用<code>force</code>强制计算这些
结果：
</p>

<pre class="brush: scala">
scala&gt; squares.take(5).force
res0: scala.collection.immutable.Stream[scala.math.BigInt] = Stream(1, 4, 9, 16, 25)
</pre>

<p>
警告：因为之前定义的<code>numsFrom()</code>方法是一个无限递归的方法，所以是一定要在<code>force</code>
前加上<code>take(num)</code>限制个数。
</p>

<h3 id="toc_2.7.3">用迭代器创建流</h3>

<p>
<code>Iterator.toStream</code>方法可以创建一个流，例：
</p>

<p>
文本文件：
</p>

<pre class="brush: bash">
11111
22222
33333
44444
55555
66666
77777
88888
</pre>

<pre class="brush: scala">
scala&gt; val words = Source.fromFile("tmp/test.txt").getLines.toStream
words: scala.collection.immutable.Stream[String] = Stream(11111, ?)

scala&gt; words
res3: scala.collection.immutable.Stream[String] = Stream(11111, ?)

scala&gt; words(5)
res4: String = 66666

scala&gt; words
res5: scala.collection.immutable.Stream[String] = Stream(11111, 22222, 33333, 44444, 55555, 66666, ?)
</pre>

<h3 id="toc_2.7.4">懒视图</h3>

<p>
对于集合类型，可以使用它们的<code>view</code>方法来取得一个懒求值的集合版本。
</p>

<p>
例：
</p>

<pre class="brush: scala">
scala&gt; import scala.math._
import scala.math._

scala&gt; val powers = (0 until 1000).view.map(pow(10, _))
powers: scala.collection.SeqView[Double,Seq[_]] = SeqViewM(...)
</pre>

<p>
对于流来说，第一个元素会求出值，而上面的视图中连第一个值也没有求出。
</p>

<p>
下面的代码求出的是<code>pow(10,100)</code>：
</p>

<pre class="brush: scala">
scala&gt; powers(100)
res0: Double = 1.0E100
</pre>

<p>
集合中其他的值并没有被计算。注意这里和流不一样，得到的结果不会被缓存，如果再次
调用，得到的值还是一样的：
</p>

<pre class="brush: scala">
scala&gt; powers(100)
res0: Double = 1.0E100
</pre>

<p>
和流一样可用<code>force</code>方法强制求值。
</p>

<h4 id="toc_2.7.4.1">应用场景</h4>

<p>
懒集合常见的应用场景是当需要以多种方式进行变换的大型集合，因为它省去了构建大型
中间集合的操作。
</p>

<p>
例：
</p>

<pre class="brush: scala">
scala&gt; (0 to 1000).map(pow(10, _)).map(1 / _)
res2: scala.collection.immutable.IndexedSeq[Double] = Vector(1.0, 0.1, ... 
</pre>

<p>
这里会先对每个元素按\(10^n\)建立一个集合，在这个集合的基础上再对每个元素执行
\(\frac{1}{n}\)。
</p>

<p>
如果是以懒视图，就只会在用到中间值时才会计算中间值。相当于就是对每个元素连续执行
两个操作：
</p>

<pre class="brush: scala">
scala&gt; (0 to 1000).view.map(pow(10, _)).map(1 / _).force
res3: Seq[Double] = Vector(1.0, 0.1, 0.01, 0.001, 1.0E-4, 1.0E-5 ...
</pre>

<h2 id="toc_2.8">与Java集合互操作</h2>

<p>
<code>JavaConversions</code>对象提供了很多工具：
</p>

<pre class="brush: scala">
scala&gt; import scala.collection.JavaConversions._
</pre>

<p>
也可以只导入指定的转换方法：
</p>

<pre class="brush: scala">
scala&gt; import scala.collection.JavaConversions.propertiesAsScalaMap
import scala.collection.JavaConversions.propertiesAsScalaMap

scala&gt; val props: scala.collection.mutable.Map[String, String] =
     | System.getProperties()
props: scala.collection.mutable.Map[String,String] = 
</pre>

<p>
这里转换出来的<code>props</code>是包装器。它会调用Java对象的接口。
</p>

<pre class="brush: scala">
props("com.horstmann.scala") = "impatient"
</pre>

<p>
实际会调用Java中<code>Properties</code>对象的方法<code>put("com.horstmann.scala","impatient")</code>。
</p>

<p>
Scala集合转Java
</p>

<table>
<tr>
<th>
隐式转换函数
</th>
<th>
从scala.collection
</th>
<th>
到java.util
</th>
</tr>
<tr>
<td>
asJavaCollection
</td>
<td>
Iterable
</td>
<td>
Collection
</td>
</tr>
<tr>
<td>
asJavaIterable
</td>
<td>
Iterable
</td>
<td>
iterable
</td>
</tr>
<tr>
<td>
asjavaIterator
</td>
<td>
Iterator
</td>
<td>
Iterator
</td>
</tr>
<tr>
<td>
asJavaEnumeration
</td>
<td>
Iterator
</td>
<td>
Enumeration
</td>
</tr>
<tr>
<td>
seqAsJavaList
</td>
<td>
Seq
</td>
<td>
List
</td>
</tr>
<tr>
<td>
mutableSeqAsjavaList
</td>
<td>
mutable.Seq
</td>
<td>
List
</td>
</tr>
<tr>
<td>
bufferAsJavaList
</td>
<td>
mutable.Buffer
</td>
<td>
List
</td>
</tr>
<tr>
<td>
setAsJavaSet
</td>
<td>
Set
</td>
<td>
Set
</td>
</tr>
<tr>
<td>
mutableSetAsJavaMap
</td>
<td>
mutable.Set
</td>
<td>
Set
</td>
</tr>
<tr>
<td>
mapAsJavaMap
</td>
<td>
Map
</td>
<td>
Map
</td>
</tr>
<tr>
<td>
mutableMapAsJavaMap
</td>
<td>
mutable.Map
</td>
<td>
Map
</td>
</tr>
<tr>
<td>
asJavaDirectionary
</td>
<td>
Map
</td>
<td>
Dictionary
</td>
</tr>
<tr>
<td>
asJavaCurrentMap
</td>
<td>
mutable.CurrentMap
</td>
<td>
concurrent.ConcurrentMap
</td>
</tr>
</table>

<p>
从Java集合到Scala集合
</p>

<table>
<tr>
<th>
方法
</th>
<th>
从java.util
</th>
<th>
到scala.collection
</th>
</tr>
<tr>
<td>
collectionAsScalaIterable
</td>
<td>
Collection
</td>
<td>
Iterable
</td>
</tr>
<tr>
<td>
iterableAsScalaIterable
</td>
<td>
Iterable
</td>
<td>
Iterable
</td>
</tr>
<tr>
<td>
asScalaIterator
</td>
<td>
Iterator
</td>
<td>
Iterator
</td>
</tr>
<tr>
<td>
enumerationAsScalaIterator
</td>
<td>
Enumeration
</td>
<td>
Iterator
</td>
</tr>
<tr>
<td>
asScalaBuffer
</td>
<td>
List
</td>
<td>
mutable.Buffer
</td>
</tr>
<tr>
<td>
asScalaSet
</td>
<td>
Set
</td>
<td>
mutable.Set
</td>
</tr>
<tr>
<td>
mapAsScalaMap
</td>
<td>
Map
</td>
<td>
mutable.Map
</td>
</tr>
<tr>
<td>
dictionaryAsScalaMap
</td>
<td>
Dictionary
</td>
<td>
mutable.Map
</td>
</tr>
<tr>
<td>
propertiesAsScalaMap
</td>
<td>
Properties
</td>
<td>
mutable.Map
</td>
</tr>
<tr>
<td>
asScalaConcurrentMap
</td>
<td>
concurrent.ConcurrentMap
</td>
<td>
mutable.ConcurrentMap
</td>
</tr>
</table>

<h2 id="toc_2.9">线程安全的集合</h2>

<p>
Scala类库提供的六个特质，混入它们就可以让集合操作变成同步：
</p>

<ul>
<li>
SynchronizedBuffer

<li>
SynchronizedMap

<li>
SynchronizedPriorityQueue

<li>
SynchronizedQueue

<li>
SynchronizedSet

<li>
SynchronizedStack

</ul>

<p>
例，得到一个同步的对象：
</p>

<pre class="brush: scala">
scala&gt; val scores = new scala.collection.mutable.HashMap[String, Int] with
     | scala.collection.mutable.SynchronizedMap[String, Int]
scores: scala.collection.mutable.HashMap[String,Int] with scala.collection.mutable.SynchronizedMap[String,Int] = Map()
</pre>

<h2 id="toc_2.10">并发操作集合</h2>

<p>
<code>par</code>方法会把一个集合的遍历操作分成多个段并行操作，多个段的结果汇总在一起。
</p>

<p>
如，统计偶数个数：
</p>

<pre class="brush: scala">
scala&gt; val coll = 0 until 100

scala&gt; coll.par.count(_ % 2 == 0)
res6: Int = 50
</pre>

<p>
通过下面的例子可以看出，顺序是并行执行的：
</p>

<pre class="brush: scala">
scala&gt; for (i &lt;- (0 until 100).par) print( i + ", ")
0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 
22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41,
42, 43, 44, 45, 46, 47, 48, 49, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86,
87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 62, 63, 64, 65, 66, 67, 68,
69, 70, 71, 72, 73, 74, 56, 57, 58, 59, 60, 61, 50, 51, 52, 53, 54, 55, 
</pre>


<h3 id="toc_2.10.1"><code>for-yield</code>循环按顺序执行</h3>

<p>
但是在<code>for-yield</code>循环中是按顺序执行的：
</p>

<pre class="brush: scala">
scala&gt; for (i &lt;- (0 until 100).par) yield i
res8: scala.collection.parallel.immutable.ParSeq[Int] = ParVector(0, 1, 2, 3, 
		4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 
		24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 
		43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 
		62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 
		81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99)
</pre>

<h3 id="toc_2.10.2">不要用共享变量</h3>

<p>
绝对不要这样写，结果不要预知：
</p>

<pre class="brush: scala">
var count = 0
for (c &lt;- coll.par) { if (c % 2 == 0) count += 1 }
</pre>

<h3 id="toc_2.10.3">ParIterable接口</h3>

<p>
<code>par</code>方法返回的并行集合类型扩展自<code>ParIterable</code>接口的子接口，如<code>ParSeq</code>、<code>ParSet</code>
或<code>ParMap</code>特质。
</p>

<p>
注意<code>Parable</code>不是<code>Iterable</code>的子类型，所以不能把并行集合传递给<code>Iterable</code>、<code>Seq</code>
、<code>set</code>与<code>Map</code>，但可以用<code>ser</code>方法转过去。还可以传递给通用的类型<code>GenIterable</code>、
<code>GenSeq</code>、<code>GenSet</code>、<code>GenMap</code>
</p>

<h3 id="toc_2.10.4">适用范围</h3>

<p>
并不是所有的方法都可以并行化，因为有些操作关系到操作顺序。
</p>

<h4 id="toc_2.10.4.1">reduce</h4>

<p>
<code>reduceLeft</code>和<code>reduceRight</code>是顺序相关的。
</p>

<p>
<code>reduce</code>方法无关顺序，但具体执行的操作可能与顺序相关。如：\((a+b)+c = a+(b+c)\)，
但是\((a-b)-c \neq a-(b-c)\)。
</p>

<h4 id="toc_2.10.4.2">fold</h4>

<p>
<code>fold</code>方法的两个操作参数必须都是当前集合的成员，如：<code>coll.par.fold(0)(_ + _)</code>，
不能进行如<code>foldLeft</code>和<code>foldRight</code>该当那样更加复杂的折叠操作。
</p>

<h4 id="toc_2.10.4.3">aggregate</h4>

<p>
解决方案是用<code>aggregate</code>方法将操作应用于于集合的不同部分，然后再用另一个操作符
组合各部分的结果。例：
</p>

<pre class="brush: scala">
str.par.aggregate(Set[Char]())(_ + _, _ ++ _)
</pre>

<p>
等同于：
</p>

<pre class="brush: scala">
str.foldLeft(Set[Char]())(_ + _)
</pre>

<p>
产出的结果是一个<code>str</code>里所有不同的字符集。
</p>
 </div>
</body>
</html>
