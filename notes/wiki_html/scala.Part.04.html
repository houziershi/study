<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">

<script type="text/javascript" src="../../vimwiki-theme/code/theme/scripts/jquery-1.4.2.min.js"></script>

<link type="text/css" rel="stylesheet" href="../../vimwiki-theme/hightlight-code/styles/shCore.css"/>
<link type="text/css" rel="stylesheet" href="../../vimwiki-theme/hightlight-code/styles/shCoreRDark.css"/>
<link type="text/css" rel="stylesheet" href="../../vimwiki-theme/hightlight-code/styles/shThemeRDark.css"/>
<script type="text/javascript" src="../../vimwiki-theme/hightlight-code/scripts/shCore.js"></script>
<script type="text/javascript" src="../../vimwiki-theme/hightlight-code/scripts/shAutoloader.js"></script>

<link type="text/css" rel="stylesheet" href="../../vimwiki-theme/code/theme/styles/style.css" />

<script type="text/javascript" src="../../vimwiki-theme/code/theme/scripts/script.js"></script>


<title>Part IV</title>
</head>
<body  onresize='changeTocSize()'>
	<div class="note-main"> 


<h1>Part IV</h1>
<div class="toc">
<ul>
<li><a href="#toc_1">有状态的对象</a>
<ul>
<li><a href="#toc_1.1">案例：离散事件模拟</a>
<li><a href="#toc_1.2">为数字电路定制语言</a>
<li><a href="#toc_1.3">Simulation API</a>
<li><a href="#toc_1.4">电路模拟</a>
<ul>
<li><a href="#toc_1.4.1">Wire类</a>
<li><a href="#toc_1.4.2">反转操作</a>
<li><a href="#toc_1.4.3">与门和或门操作</a>
<li><a href="#toc_1.4.4">模拟输出</a>
<li><a href="#toc_1.4.5">运行模拟器</a>
</ul>
</ul>
<li><a href="#toc_2">参数类型化</a>
<ul>
<li><a href="#toc_2.1">开发纯函数式队列</a>
<li><a href="#toc_2.2">信息隐藏</a>
<ul>
<li><a href="#toc_2.2.1">私有构造器及工厂方法</a>
<li><a href="#toc_2.2.2">可选方案：私有类</a>
</ul>
<li><a href="#toc_2.3">变化型注解</a>
<ul>
<li><a href="#toc_2.3.1">变化型和数组</a>
</ul>
<li><a href="#toc_2.4">检查变化型注解</a>
<ul>
<li><a href="#toc_2.4.1">变化型注解的验证方式</a>
</ul>
<li><a href="#toc_2.5">下界</a>
<li><a href="#toc_2.6">逆变</a>
<li><a href="#toc_2.7">对象私有数据</a>
<li><a href="#toc_2.8">上界</a>
</ul>
<li><a href="#toc_3">抽象成员</a>
<ul>
<li><a href="#toc_3.1">抽象成员的快速浏览</a>
<li><a href="#toc_3.2">类型成员</a>
<li><a href="#toc_3.3">抽象val</a>
<li><a href="#toc_3.4">抽象var</a>
<li><a href="#toc_3.5">初始化抽象val</a>
<ul>
<li><a href="#toc_3.5.1">fields预初始化字段</a>
<li><a href="#toc_3.5.2">懒加载val</a>
</ul>
<li><a href="#toc_3.6">抽象类型</a>
<li><a href="#toc_3.7">路径依赖类型</a>
<li><a href="#toc_3.8">枚举</a>
<li><a href="#toc_3.9">案例研究：货币</a>
</ul>
<li><a href="#toc_4">隐式转换和参数</a>
<ul>
<li><a href="#toc_4.1">隐式转换</a>
<li><a href="#toc_4.2">隐式操作规则</a>
<li><a href="#toc_4.3">隐式转换为期望的类型</a>
<li><a href="#toc_4.4">转换方法调用的接收者</a>
<ul>
<li><a href="#toc_4.4.1">与新类型的交互操作</a>
<li><a href="#toc_4.4.2">模拟新的语法</a>
</ul>
<li><a href="#toc_4.5">隐式参数</a>
<li><a href="#toc_4.6">视界</a>
<ul>
<li><a href="#toc_4.6.1">视界与上界</a>
</ul>
<li><a href="#toc_4.7">隐式操作的调试</a>
<ul>
<li><a href="#toc_4.7.1">没有对应的转换规则</a>
<li><a href="#toc_4.7.2">被其他转换规则干扰</a>
</ul>
</ul>
</ul>
</div>


<h1 id="toc_1">有状态的对象</h1>

<p>
类似于JavaBean的getter和setter方法，Scala对象的非私有<code>var x</code>有自动生成的访问方法
<code>x</code>和设值方法<code>x_=</code>。
</p>

<p>
对于类中的字段：
</p>

<pre class="brush: scala">
var hour = 12
</pre>

<p>
会有额外的getter方法<code>hour</code>和setter方法<code>hour_=</code>。方法的访问性与字段一致。
</p>

<p>
拿这个例子来说：
</p>

<pre class="brush: scala">
  class Time {
    var hour = 12
    var minute = 0
  }
</pre>

<p>
和下面的代码是一样的：
</p>

<pre class="brush: scala">
  class Time {

    private[this] var h = 12
    private[this] var m = 0

    def hour: Int = h
    def hour_=(x: Int) { h = x }

    def minute: Int = m
    def minute_=(x: Int) { m = x }
  }
</pre>

<p>
所以可以直接定义getter和setter。
</p>

<p>
下面的代码在setter前进行检查：
</p>

<pre class="brush: scala">
  class Time {

    private[this] var h = 12
    private[this] var m = 12

    def hour: Int = h
    def hour_= (x: Int) {
      require(0 &lt;= x &amp;&amp; x &lt; 24)
      h = x
    }

    def minute = m
    def minute_= (x: Int) {
      require(0 &lt;= x &amp;&amp; x &lt; 60)
      m = x
    }
  }
</pre>

<p>
再看一个温度的例子：
</p>

<pre class="brush: scala">
  class Thermometer {

    var celsius: Float = _

    def fahrenheit = celsius * 9 / 5 + 32
    def fahrenheit_= (f: Float) {
      celsius = (f - 32) * 5 / 9
    }
    override def toString = fahrenheit +"F/"+ celsius +"C"
  }
</pre>

<p>
注意：变量<code>celsius</code>的值为<code>_</code>，表示初始化值。对于数值代表<code>0</code>，对于布尔类型代表
<code>false</code>，引用类型则代表<code>null</code>。
</p>

<p>
Scala中的初始化器<code>=_</code>，如果写成：
</p>

<pre class="brush: scala">
var celsius
</pre>

<p>
这样就成了抽象变量（以后到了“抽象成员”这一章介绍），而不是一个没有初始化的变量。
这个和Java的习惯很不一样。
</p>

<p>
使用的例子：
</p>

<pre class="brush: scala">
  scala&gt; val t = new Thermometer
  t: Thermometer = 32.0F/0.0C

  scala&gt; t.celsius = 100

  scala&gt; t
  res3: Thermometer = 212.0F/100.0C

  scala&gt; t.fahrenheit = -40

  scala&gt; t
  res4: Thermometer = -40.0F/-40.0C
</pre>

<h2 id="toc_1.1">案例：离散事件模拟</h2>

<p>
来个SICP（Structure and Interpretation of Computer Programs，计算机程序的构造与
解释）里的例子。
</p>

<h2 id="toc_1.2">为数字电路定制语言</h2>

<p>
<img src="images/scala/18.01.png" />
</p>

<p>
为了实现这三种基本的门，我们建立一个<code>Wire</code>类代表线路。可以这样构造线路：
</p>

<pre class="brush: scala">
val a = new Wire
val b = new Wire
val c = new Wire
</pre>

<p>
或简洁地写成：
</p>

<pre class="brush: scala">
val a, b, c = new Wire
</pre>

<p>
三个基本的门电路由以下三个过程模拟：
</p>

<pre class="brush: scala">
  def inverter(input: Wire, output: Wire)
  def andGate(a1: Wire, a2: Wire, output: Wire)
  def orGate(o1: Wire, o2: Wire, output: Wire)
</pre>

<p>
注意这里的过程都没有返回值。按照函数式的思想，应该是返回构造好的门对象。但是在
这里我们选择了没有返回值，而是通过副作用来模拟门电路。副作用让一步步渐进地构造
复杂的电路更加容易，如<code>inverter(a,b)</code>在<code>a</code>与<code>b</code>之间放置反转电路。
</p>

<p>
还有这里的方法名没有用动词而是用了名词，这是为了方便说明制造的是哪个门电路。这
反映了DSL说明的本质：应该描述电路，而不是如何制造它。
</p>

<p>
下面是一个半加法器（half-adder）。它根据两个输入<code>a</code>和<code>b</code>产生累加和<code>s</code>。
</p>

<p>
累加的定义为：<code>s= (a+b)%2</code>及进位<code>c</code>，其中的<code>c = (a+b)/2</code>。
</p>

<p>
半加法器电路图：
</p>

<p>
<img src="images/scala/18.02.png" />
</p>

<p>
用我们的代码描述：
</p>

<pre class="brush: scala">
  def halfAdder(a: Wire, b: Wire, s: Wire, c: Wire) {
    val d, e = new Wire
    orGate(a, b, d)
    andGate(a, b, c)
    inverter(c, e)
    andGate(d, e, s)
  }
</pre>

<p>
接下来是一个全加法器，定义为根据参数<code>a</code>和<code>b</code>还有进位<code>cin</code>得到两个输出。一个是和
<code>sum = (a+b+cin)%2</code>，另一个是进位输出<code>count = (a+b+cin)/2</code>：
</p>

<p>
<img src="images/scala/18.03.png" />
</p>

<p>
代码为：
</p>

<pre class="brush: scala">
  def fullAdder(a: Wire, b: Wire, cin: Wire,
      sum: Wire, cout: Wire) {

    val s, c1, c2 = new Wire
    halfAdder(a, cin, s, c1)
    halfAdder(b, s, sum, c2)
    orGate(c1, c2, cout)
  }
</pre>

<p>
这是内部DSL很好的例子：通过宿主语言将特定的语言定义为库面不是完全实现这种语言。
</p>


<h2 id="toc_1.3">Simulation API</h2>

<p>
完成了对电路的模拟以后，再来分析对时间的模拟。模拟时间包括在指定时间执行指定的
动作。
</p>

<p>
私有变量保存时间，但提供对时间的公开访问：
</p>

<pre class="brush: scala">
  private var curtime: Int = 0

  def currentTime: Int = curtime
</pre>

<p>
定义动作：在我们的例子中，把参数列表和返回都为空的过程<code>() =&gt; Unit</code>作为基本的动作
。给这样类型的过程起个别名叫<code>Action</code>：
</p>

<pre class="brush: scala">
type Action = () =&gt; Unit
</pre>

<p>
在特定时间执行的的操作定义为工作项目（work item）：
</p>

<pre class="brush: scala">
  case class WorkItem(time: Int, action: Action)
</pre>

<p>
注意这里用的是样本类，所以用工厂方法创建实例就可以自动获得访问构造器参数<code>time</code>和
<code>action</code>的方法。
</p>

<p>
还有一个类来保存末执行工作条目的排程表（agenda），注意它是按时间排序的：
</p>

<pre class="brush: scala">
  private var agenda: List[WorkItem] = List()
</pre>

<p>
提供在一定 时延后加入新的工作条目的方法，注意加入操作也要排序：
</p>

<pre class="brush: scala">
  def afterDelay(delay: Int)(block: =&gt; Unit) {
    val item = WorkItem(currentTime + delay, () =&gt; block)
    agenda = insert(agenda, item)
  }

  private def insert(ag: List[WorkItem],
      item: WorkItem): List[WorkItem] = {
    if (ag.isEmpty || item.time &lt; ag.head.time) item :: ag
    else ag.head :: insert(ag.tail, item)
  }
</pre>

<p>
核心是<code>run</code>方法：
</p>

<pre class="brush: scala">
  def run() {
    afterDelay(0) {
      println("*** simulation started, time = "+
          currentTime +" ***")
    }
    while (!agenda.isEmpty) next()
  }
  
  private def next() {
    (agenda: @unchecked) match {
      case item :: rest =&gt;
        agenda = rest
        curtime = item.time
        item.action()
    }
  }
</pre>

<p>
注意这里为了方便去掉了空列表的情况。为了防止编译器警告我们在模式匹配里故意漏掉了列表为空的情况，在
这里使用了<code>(agenda: @unchecked) match</code>而不是<code>agenda match</code>。
</p>

<p>
完整的代码在包<code>org.stairwaybook.simulation</code>里：
</p>

<pre class="brush: scala">
  abstract class Simulation {

    type Action = () =&gt; Unit

    case class WorkItem(time: Int, action: Action)

    private var curtime = 0
    def currentTime: Int = curtime

    private var agenda: List[WorkItem] = List()

    private def insert(ag: List[WorkItem],
        item: WorkItem): List[WorkItem] = {

      if (ag.isEmpty || item.time &lt; ag.head.time) item :: ag
      else ag.head :: insert(ag.tail, item)
    }

    def afterDelay(delay: Int)(block: =&gt; Unit) {
      val item = WorkItem(currentTime + delay, () =&gt; block)
      agenda = insert(agenda, item)
    }

    private def next() {
      (agenda: @unchecked) match {
        case item :: rest =&gt;
          agenda = rest
          curtime = item.time
          item.action()
      }
    }

    def run() {
      afterDelay(0) {
        println("*** simulation started, time = "+
            currentTime +" ***")
      }
      while (!agenda.isEmpty) next()
    }
  }
</pre>



<h2 id="toc_1.4">电路模拟</h2>

<p>
这里创建了<code>BasicCircuitSiomulation</code>来模拟电路。
</p>

<p>
为了模拟电路和延迟声明了三个方法：<code>InverterDelay</code>、<code>AndGateDelay</code>、<code>OrGateDelay</code>。由于
不同模拟电路的技术参数不同，所以这三个方法是抽象方法。
</p>

<h3 id="toc_1.4.1">Wire类</h3>

<p>
需要支持的三种基本动作：
</p>

<p>
<code>getSignal: Boolean</code>：返回当前线路上的信号。
</p>

<p>
<code>setSignal(sig: Boolean)</code>：设置线路信号。
</p>

<p>
<code>addAction(p: Action)</code>：添加动作到线路上。基本思想是所有附加在某线路上的动作过程在每次信号改变
时被执行。通过连接组件可以为线路添加该组件的功能。加上的动作会在被加到线路时以及每次线路信号改变时
被执行。
</p>

<p>
实现代码<code>sigVal</code>代表当前信号，<code>actions</code>是附加的动作过程。需要注意的是<code>setSignal</code>方法，当信号
改变时，新的信号首先被保存在变量<code>sigVal</code>中，然后执行所有线路附加动作：
</p>

<pre class="brush: scala">
  class Wire {
    private var sigVal = false
    private var actions: List[Action] = List()

    def getSignal = sigVal

    def setSignal(s: Boolean) =
      if (s != sigVal) {
        sigVal = s
        actions foreach (_ ())
      }

    def addAction(a: Action) = {
      actions = a :: actions
      a()
    }
  }
</pre>

<p>
注意上面的缩写格式：<code>actions forearch(_())</code>代表对每个元素执行<code>_()</code>。在“函数和装饰”这一章的
“占位符”部分说明过，函数<code>_()</code>是<code>f =&gt; f()</code>的缩写，代表空参数函数。
</p>

<h3 id="toc_1.4.2">反转操作</h3>

<p>
<code>inverter</code>方法会在安装之后以及每次线路信号变化时被调用。它通过<code>setSignal</code>把输出设为输入的反值。
</p>

<p>
另外，由于还要模拟电路的响应时间，所以输入值改变以后，还要等<code>InverterDelay</code>单位的模拟时间后，
才发生改变：
</p>

<pre class="brush: scala">
  def inverter(input: Wire, output: Wire) = {
    def invertAction() {
      val inputSig = input.getSignal
      afterDelay(InverterDelay) {
        output setSignal !inputSig
      }
    }
    input addAction invertAction
  }
</pre>

<p>
注意这里的<code>afterDelay</code>方法是把这个操作加到队列的最后面。
</p>

<h3 id="toc_1.4.3">与门和或门操作</h3>

<p>
大致思想和上面类似：
</p>

<pre class="brush: scala">
  def andGate(a1: Wire, a2: Wire, output: Wire) = {
    def andAction() = {
      val a1Sig = a1.getSignal
      val a2Sig = a2.getSignal
      afterDelay(AndGateDelay) {
        output setSignal (a1Sig &amp; a2Sig)
      }
    }
    a1 addAction andAction
    a2 addAction andAction
  }

  def orGate(o1: Wire, o2: Wire, output: Wire) {
    def orAction() {
      val o1Sig = o1.getSignal
      val o2Sig = o2.getSignal
      afterDelay(OrGateDelay) {
        output setSignal (o1Sig | o2Sig)
      }
    }
    o1 addAction orAction
    o2 addAction orAction
  }
</pre>

<h3 id="toc_1.4.4">模拟输出</h3>

<p>
通过探针（probe）观察线路上信号的改变。
</p>

<p>
还是在信号改变时被调用，显示输出线路的名称、模拟时间、信号值：
</p>

<pre class="brush: scala">
  def probe(name: String, wire: Wire) {
    def probeAction() {
      println(name +" "+ currentTime +
          " new-value = "+ wire.getSignal)
    }
    wire addAction probeAction
  }
</pre>

<h3 id="toc_1.4.5">运行模拟器</h3>

<p>
<code>BasicCircuitSimulation</code>继承了<code>CircuitSimulation</code>
</p>

<pre class="brush: scala">
  package org.stairwaybook.simulation

  abstract class CircuitSimulation
    extends BasicCircuitSimulation {

    def halfAdder(a: Wire, b: Wire, s: Wire, c: Wire) {
      val d, e = new Wire
      orGate(a, b, d)
      andGate(a, b, c)
      inverter(c, e)
      andGate(d, e, s)
    }

    def fullAdder(a: Wire, b: Wire, cin: Wire,
        sum: Wire, cout: Wire) {

      val s, c1, c2 = new Wire
      halfAdder(a, cin, s, c1)
      halfAdder(b, s, sum, c2)
      orGate(c1, c2, cout)
    }
  }
</pre>

<p>
剩下的电路延迟时间和定义被模拟的电路都留在Scala交互Shell中实现：
</p>

<pre class="brush: scala">
  scala&gt; import org.stairwaybook.simulation._
  import org.stairwaybook.simulation._
</pre>

<p>
定义延迟时间：
</p>

<pre class="brush: scala">
  scala&gt; object MySimulation extends CircuitSimulation {
       | def InverterDelay = 1
       | def AndGateDelay = 3
       | def OrGateDelay = 5
       | }
  defined module MySimulation
</pre>

<p>
定义一下简化以后对<code>MySimulation</code>的引用：
</p>

<pre class="brush: scala">
  scala&gt; import MySimulation._
  import MySimulation._
</pre>

<p>
定义线路的部分。先定义四根线路，再把探针放在其中的两根上。探针会立即输出结果：
</p>

<pre class="brush: scala">
  scala&gt; val input1, input2, sum, carry = new Wire
  input1: MySimulation.Wire =
      simulator.BasicCircuitSimulation$Wire@111089b
  input2: MySimulation.Wire =
      simulator.BasicCircuitSimulation$Wire@14c352e
  sum: MySimulation.Wire =
      simulator.BasicCircuitSimulation$Wire@37a04c
  carry: MySimulation.Wire =
      simulator.BasicCircuitSimulation$Wire@1fd10fa

  scala&gt; probe("sum", sum)
  sum 0 new-value = false

  scala&gt; probe("carry", carry)
  carry 0 new-value = false
</pre>

<p>
加上半加法器：
</p>

<pre class="brush: scala">
  scala&gt; halfAdder(input1, input2, sum, carry)
</pre>

<p>
逐次把两根输入线信号设为<code>true</code>，并执行模拟过程：
</p>

<pre class="brush: scala">
  scala&gt; input1 setSignal true

  scala&gt; run()
  *** simulation started, time = 0 ***
  sum 8 new-value = true

  scala&gt; input2 setSignal true

  scala&gt; run()
  *** simulation started, time = 8 ***
  carry 11 new-value = true
  sum 15 new-value = false
</pre>

<p>
全部代码如下：
</p>

<pre class="brush: scala">
package org.stairwaybook.simulation

abstract class BasicCircuitSimulation extends Simulation {

  def InverterDelay: Int
  def AndGateDelay: Int
  def OrGateDelay: Int

  class Wire {

    private var sigVal = false
    private var actions: List[Action] = List()

    def getSignal = sigVal

    def setSignal(s: Boolean) =
      if (s != sigVal) {
        sigVal = s
        actions foreach (_ ())
      }

    def addAction(a: Action) = {
      actions = a :: actions
      a()
    }
  }

  def inverter(input: Wire, output: Wire) = {
    def invertAction() {
      val inputSig = input.getSignal
      afterDelay(InverterDelay) {
        output setSignal !inputSig
      }
    }
    input addAction invertAction
  }

  // continued in Listing 18.10...
  // ...continued from Listing 18.9
  def andGate(a1: Wire, a2: Wire, output: Wire) = {
    def andAction() = {
      val a1Sig = a1.getSignal
      val a2Sig = a2.getSignal
      afterDelay(AndGateDelay) {
        output setSignal (a1Sig &amp; a2Sig)
      }
    }
    a1 addAction andAction
    a2 addAction andAction
  }

  def orGate(o1: Wire, o2: Wire, output: Wire) {
    def orAction() {
      val o1Sig = o1.getSignal
      val o2Sig = o2.getSignal
      afterDelay(OrGateDelay) {
        output setSignal (o1Sig | o2Sig)
      }
    }
    o1 addAction orAction
    o2 addAction orAction
  }

  def probe(name: String, wire: Wire) {
    def probeAction() {
      println(name +" "+ currentTime +
          " new-value = "+ wire.getSignal)
    }
    wire addAction probeAction
  }
}

abstract class Simulation {

  type Action = () =&gt; Unit

  case class WorkItem(time: Int, action: Action)

  private var curtime = 0
  def currentTime: Int = curtime

  private var agenda: List[WorkItem] = List()

  private def insert(ag: List[WorkItem],
      item: WorkItem): List[WorkItem] = {

    if (ag.isEmpty || item.time &lt; ag.head.time) item :: ag
    else ag.head :: insert(ag.tail, item)
  }

  def afterDelay(delay: Int)(block: =&gt; Unit) {
    val item = WorkItem(currentTime + delay, () =&gt; block)
    agenda = insert(agenda, item)
  }

  private def next() {
    (agenda: @unchecked) match {
      case item :: rest =&gt;
        agenda = rest
        curtime = item.time
        item.action()
    }
  }

  def run() {
    afterDelay(0) {
      println("*** simulation started, time = "+
          currentTime +" ***")
    }
    while (!agenda.isEmpty) next()
  }
}


abstract class CircuitSimulation
  extends BasicCircuitSimulation {

  def halfAdder(a: Wire, b: Wire, s: Wire, c: Wire) {
    val d, e = new Wire
    orGate(a, b, d)
    andGate(a, b, c)
    inverter(c, e)
    andGate(d, e, s)
  }

  def fullAdder(a: Wire, b: Wire, cin: Wire,
      sum: Wire, cout: Wire) {

    val s, c1, c2 = new Wire
    halfAdder(a, cin, s, c1)
    halfAdder(b, s, sum, c2)
    orGate(c1, c2, cout)
  }
}

 object MySimulation extends CircuitSimulation {
           def InverterDelay = 1
           def AndGateDelay = 3
           def OrGateDelay = 5

  def main(args: Array[String]) {
    val input1, input2, sum, carry = new Wire

    probe("sum", sum)
    probe("carry", carry)
    halfAdder(input1, input2, sum, carry)

    input1 setSignal true
    run()

    input2 setSignal true
    run()
  }
}
</pre>

<h1 id="toc_2">参数类型化</h1>

<p>
类型化参数能实现编写泛型类和特质。Scala中的泛型实例都应该写明具体类型（如：Set[Int]，Set[Int]
），而不像Java中可以不带泛型类型。
</p>

<h2 id="toc_2.1">开发纯函数式队列</h2>

<p>
函数式的队列是不可变的，添加元素操作会返回一个新的队列。三个基本方法：
</p>

<ul>
<li>
<code>head</code>返回队列的第一个元素。

<li>
<code>tail</code>返回第一个元素以外的队列。

<li>
<code>append</code>返回在尾部添加指定元素的列队。

</ul>

<p>
理想情况下，希望三种基本操作都可以在常量时间中完成。
</p>

<p>
一个实现方案是以<code>List</code>作为功能表达类型，可以用现成的<code>head</code>和<code>tail</code>方法。<code>append</code>方法调用连接
操作：
</p>

<pre class="brush: scala">
  class SlowAppendQueue[T](elems: List[T]) { // Not efficient
    def head = elems.head
    def tail = new SlowAppendQueue(elems.tail)
    def append(x: T) = new SlowAppendQueue(elems ::: List(x))
  }
</pre>

<p>
但这样<code>append</code>操作的时间会按元素的数量而增加，那换一种思路，把列表倒过来排序，这样会让原来最后
加进来的元素出现在列表的最前面：
</p>

<pre class="brush: scala">
  class SlowHeadQueue[T](smele: List[T]) { // Not efficient
    // smele is elems reversed
    def head = smele.last
    def tail = new SlowHeadQueue(smele.init)
    def append(x: T) = new SlowHeadQueue(x :: smele)
  }
</pre>

<p>
现在表现也倒过来了：<code>append</code>操作时间为常量，但<code>head</code>和<code>tail</code>耗时与元素数量成正比了。
</p>

<p>
试一下结合两种列表的方案：
</p>


<p>
用两个列表<code>leading</code>放前面一半；<code>trailing</code>放后一半反向排的元素。这样全部内容就是：
</p>

<pre class="brush: scala">
leading ::: trailing.reverse
</pre>

<p>
添加新元素：
</p>

<pre class="brush: scala">
i :: trailing
</pre>

<p>
这样常量时间就可以完成。但这样前一半的<code>leading</code>就不放进内容了，所以在对空的<code>leading</code>进行第一次<code>head</code>或<code>tail</code>操作前都要把<code>trailing</code>反转并复制给<code>leading</code>。这个操作被定义为<code>mirror</code>。
</p>

<p>
虽然<code>mirror</code>操作与队列长度成正比，但是这只发生在<code>leading</code>为空时才会被调用。因为如果<code>leading</code>不为空它将直接返回。<code>head</code>与<code>tail</code>操作会调用到<code>mirror</code>，所以这两个方法的复杂度与队列长度呈线性关系。然而队列越长，<code>mirror</code>被调用的次数就越以级数方式递减。
</p>

<pre class="brush: scala">
  class Queue[T](
    private val leading: List[T],
    private val trailing: List[T]
  ) {
    private def mirror =
      if (leading.isEmpty)
        new Queue(trailing.reverse, Nil)
      else
        this

    def head = mirror.leading.head

    def tail = {
      val q = mirror
      new Queue(q.leading.tail, q.trailing)
    }

    def append(x: T) =
      new Queue(leading, x :: trailing)
  }
</pre>

<h2 id="toc_2.2">信息隐藏</h2>

<p>
前面的<code>Queue</code>实现暴露了太多实现细节，比如构造器的两个参数还有一个是反转的。
</p>

<h3 id="toc_2.2.1">私有构造器及工厂方法</h3>

<pre class="brush: scala">
  class Queue[T] private (
    private val leading: List[T],
    private val trailing: List[T]
  )
</pre>

<p>
这样防止外部调用主构造器：
</p>

<pre class="brush: scala">
  scala&gt; new Queue(List(1, 2), List(3))
  &lt;console&gt;:6: error: constructor Queue cannot be accessed in
    object $iw
         new Queue(List(1, 2), List(3))
         ^
</pre>

<p>
客户代码只能调用辅助构造器：
</p>

<pre class="brush: scala">
  def this() = this(Nil, Nil)
</pre>

<p>
改良一下，让它可以带上初始队列元素列表：
</p>

<pre class="brush: scala">
  def this(elems: T*) = this(elems.toList, Nil)
</pre>

<p>
其中的<code>T*</code>是重复参数标记，在前面“函数与闭包”一章中已经介绍。
</p>

<p>
还有一种让客户代码构造的方法是在类定义同一个文件内建立伴生类的工厂方法：
</p>

<pre class="brush: scala">
  object Queue {
    // constructs a queue with initial elements `xs'
    def apply[T](xs: T*) = new Queue[T](xs.toList, Nil)
  }
</pre>

<h3 id="toc_2.2.2">可选方案：私有类</h3>

<p>
除了私有构造器和私有成员，还可以直接隐藏掉类本身，只提供暴露类公共接口的特质：
</p>

<pre class="brush: scala">
  trait Queue[T] {
    def head: T
    def tail: Queue[T]
    def append(x: T): Queue[T]
  }

  object Queue {

    def apply[T](xs: T*): Queue[T] =
      new QueueImpl[T](xs.toList, Nil)

    private class QueueImpl[T](
      private val leading: List[T],
      private val trailing: List[T]
    ) extends Queue[T] {

      def mirror =
        if (leading.isEmpty)
          new QueueImpl(trailing.reverse, Nil)
        else
          this

      def head: T = mirror.leading.head

      def tail: QueueImpl[T] = {
        val q = mirror
        new QueueImpl(q.leading.tail, q.trailing)
      }

      def append(x: T) =
        new QueueImpl(leading, x :: trailing)
    }
  }
</pre>


<h2 id="toc_2.3">变化型注解</h2>

<p>
上面的<code>Queue</code>特质创建实例时一定要加类型参数：
</p>

<pre class="brush: scala">
  scala&gt; def doesNotCompile(q: Queue) {}
  &lt;console&gt;:5: error: trait Queue takes type parameters
         def doesNotCompile(q: Queue) {}
</pre>

<p>
当然<code>AnyRef</code>也是一种类型：
</p>

<pre class="brush: scala">
  scala&gt; def doesCompile(q: Queue[AnyRef]) {}
  doesCompile: (Queue[AnyRef])Unit
</pre>

<p>
Scala的泛型在默认情况下是非协变的（nonvariant），即<code>Queue[String]</code>不是
<code>Queue[AnyRef]</code>的子类。但还是可以设置为协变（covariant）的。
</p>

<p>
用<code>+</code>表明子类型化协变，即<code>Queue[String]</code>是<code>Queue[AnyRef]</code>的子类：
</p>

<pre class="brush: scala">
  trait Queue[+T] { ... }
</pre>

<p>
用<code>-</code>表示逆变（contravariant）子类型化，如果<code>T</code>类型是<code>S</code>的子类型，将隐含
<code>Queue[S]</code>是<code>Queue[T]</code>的子类型：
</p>

<pre class="brush: scala">
  trait Queue[-T] { ... }
</pre>

<p>
协变、逆变与非协变都被称为参数变化类型。
</p>

<p>
在纯函数式中，许多类型都是自然协变的。然而一旦引入了可变数据，情况就改变了。假设
一个简单的只能读写一个元素的单元格（Cell）类型：
</p>

<pre class="brush: scala">
  class Cell[T](init: T) {
    private[this] var current = init
    def get = current
    def set(x: T) { current = x }
  }
</pre>

<p>
上面的<code>Cell</code>是非协变的。我们现成假设它是协变的，声明为<code>Cell[+T]</code>并发送给Scala
编译器。于是我们可以构建如下存在问题的语句序列：
</p>

<pre class="brush: scala">
  val c1 = new Cell[String]("abc")
</pre>

<p>
建立<code>String</code>放在<code>c1</code>中，OK。
</p>

<pre class="brush: scala">
  val c2: Cell[Any] = c1
</pre>

<p>
<code>c2</code>类型是<code>Cell[Any]</code>，把<code>Cell[String]</code>的<code>c1</code>赋值给它也OK。
</p>

<pre class="brush: scala">
  c2.set(1)
</pre>

<p>
<code>c2</code>是<code>Cell[Any]</code>，所以存数字也OK。
</p>

<pre class="brush: scala">
  val s: String = c1.get
</pre>

<p>
<code>c1</code>里的字符串，赋给字符串也OK。
</p>

<p>
上面四行都OK，但是看看这四行放在一起，就出问题了：
</p>

<pre class="brush: scala">
  val c1 = new Cell[String]("abc")
  val c2: Cell[Any] = c1
  c2.set(1)
  val s: String = c1.get

  Cell.scala:7: error: covariant type T occurs in
  contravariant position in type T of value x
     def set(x: T) = current = x
                ^
</pre>

<p>
这四行代码是要把整数<code>1</code>赋值给字符串<code>s</code>，这样破坏了类型声明。问题出在第二行，
<code>Cell[Any]</code>和<code>Cell[String]</code>的类型的协变引起了错误。
</p>

<h3 id="toc_2.3.1">变化型和数组</h3>

<p>
以前面的<code>Cell</code>类为例与Java中的数组比较，Java中的数组是协变的：
</p>

<pre class="brush: scala">
  // this is Java
  String[] a1 = { "abc" };
  Object[] a2 = a1;
  a2[0] = new Integer(17);
  String s = a1[0];
</pre>

<p>
虽然可以通过编译，但是运行时第四行会报错。Java运行时保存了数组元素类型，在更新时
对新元素进行合法性校验。类型错误时抛出<code>ArrayStore</code>：
</p>

<pre class="brush: scala">
  Exception in thread "main" java.lang.ArrayStoreException:
  java.lang.Integer
          at JavaArrays.main(JavaArrays.java:8)
</pre>

<p>
这样看起来好像即没有用又浪费性能。按James Gosling的说法是希望有一个通用处理数组
的简单方法，如需要排序所有元素时：
</p>

<pre class="brush: scala">
  void sort(Object[] a, Comparator cmp) { ... }
</pre>

<p>
这样确保任意参数类型的数组都可以传入排序方法。当然后来Java有了泛型以后数组的协变
不再有用了，为了向以前老版本兼容才留着。
</p>

<p>
Scala中数组是不可协变的：
</p>

<pre class="brush: scala">
  scala&gt; val a1 = Array("abc")
  a1: Array[java.lang.String] = Array(abc)

  scala&gt; val a2: Array[Any] = a1
  &lt;console&gt;:5: error: type mismatch;
   found : Array[java.lang.String]
   required: Array[Any]
         val a2: Array[Any] = a1
                              ^
</pre>

<p>
但有时还是要数组能泛型手段与Java遗留方法进行交互。所以Scala允许把<code>T</code>类型的数组
造型为任意<code>T</code>的超类的数组：
</p>

<pre class="brush: scala">
  scala&gt; val a2: Array[Object] =
       | a1.asInstanceOf[Array[Object]]
  a2: Array[java.lang.Object] = Array(abc)
</pre>

<h2 id="toc_2.4">检查变化型注解</h2>

<p>
再看几个不合适的协变例子：
</p>

<p>
把前面的队列改成协变的，然后创建指定元素类型为<code>Int</code>的队列。并重载<code>append</code>方法
使其在添加前先输出它参数的平方根：
</p>

<pre class="brush: scala">
  class StrangeIntQueue extends Queue[Int] {
    override def append(x: Int) = {
      println(Math.sqrt(x))
      super.append(x)
    }
  }
</pre>

<p>
假设上面的代码是协变的，对应以下的调用：
</p>

<pre class="brush: scala">
  val x: Queue[Any] = new StrangeIntQueue
  x.append("abc")
</pre>

<p>
上面的因为协变所以第一行是有效的，但第二行就有问题了……对字符串求平方根……
</p>

<p>
在更加广泛的情况下，只要把泛型类型作为方法参数类型，包含它的类或特质就有可能不能
与这个类型参数一直协变，对于队列来说，<code>append</code>方法违反了以下情况：
</p>

<pre class="brush: scala">
  class Queue[+T] {
    def append(x: T) = 
     ...
  }
</pre>

<p>
所以编译器会报错：
</p>

<pre class="brush: scala">
  Queues.scala:11: error: covariant type T occurs in
  contravariant position in type T of value x
    def append(x: T) = 
               ^
</pre>

<p>
不要对可重新赋值的字段使用<code>+</code>的协变参数类型。如<code>var x:T</code>在Scala里被看作自带
<code>getter</code>方法<code>def x:T</code>、<code>def x_= (y:T)</code>，所以将不是协变的。
</p>


<h3 id="toc_2.4.1">变化型注解的验证方式</h3>

<p>
深入讲述一些概念前，首选，我们把类和特质都简单称为“类”。然后对于这些类可能会用
到类型参数的地方被分为正、负、中立。编译器检查类的类型参数的每一个用法。
</p>

<p>
<code>+</code>的类型参数只能被用在正的位置上，<code>-</code>的类型参数只能用在负的位置上。没有
变化型注解的类型可以用于任何位置，所以它是唯一能被用在类结构体的中性位置上的
类型参数。
</p>

<p>
<img src='images/scala/19.02.png' />
</p>

<p>
编译器对位置分类是从类型声明开始进入更深的内嵌层。处于声明类最顶层被划为正的位置
。默认情况下内层位置的分类会和外层一致。
</p>

<p>
但总有例外：方法值参数位置是方法外部的位置的翻转类别，这里正位置传为负，负转为正
，而中性位置仍然保持中性。
</p>

<p>
除了方法值参数位置外，方法的类型参数的当前类别也会被翻转。而类型参数的位置，如
<code>C[Arg]</code>中的<code>Arg</code>也有可以被翻转，这取决于对应类型参数的变化型：
</p>

<p>
如果<code>C</code>的类型参数标了<code>+</code>号，那么类别不变；如果标了<code>-</code>号，则当前类别被翻转；
如果<code>C</code>的类型参数没有变化型注解，那么当前类型将改为中性。
</p>


<p>
下面的例子比较生编硬造，下面类型定义中的若干位置变化弄被标了正<code>+</code>或<code>-</code>负：
</p>

<p>
类型参数<code>W</code>与两个值参数<code>volume</code>和<code>listener</code>的位置都是负的。
</p>

<p>
<img src='images/scala/19.01.png' />
</p>

<p>
注意<code>meow</code>的结果类型，第一个<code>Cat[U, T]</code>参数的位置是负的。因为<code>Cat</code>的第一个
类型参数<code>[T]</code>被标了<code>-</code>。这个参数中的类型<code>U</code>重新转为正的位置（两次翻转），而
参数中的类型<code>T</code>仍然是负位置。
</p>

<p>
总的来说：人脑想跟上变化型位置的变化是很困难的，所以Scala编译器自动来完成这项
工作。计算机变化型过程中，编译器检查每个类型参数是否仅用于分类正确的位置上。
</p>

<p>
就上面的例子来说，<code>T</code>仅用在负位置上，而<code>U</code>仅用于正的位置上。所以这个<code>Cat</code>类
是正确的。
</p>


<h2 id="toc_2.5">下界</h2>

<p>
在之前的“可选方案：私有类”这一节中展示的是没有办法协变的实现<code>Queue[T]</code>。因为类型
<code>T</code>作为参数出现在<code>append</code>方法中，而这个位置是负的。
</p>

<p>
所幸有一个办法：可能通过把<code>append</code>变为多态以使其泛型化并使用它的类型参数的下界：
</p>

<pre class="brush: scala">
  class Queue[+T] (private val leading: List[T],
      private val trailing: List[T] ) {
    def append[U &gt;: T](x: U) = 
      new Queue[U](leading, x :: trailing) // ...
  }
</pre>

<p>
<code>append</code>方法指定的类型参数<code>U</code>，并通过语法<code>U &gt;: T</code>定义了<code>T</code>为<code>U</code>的下界，即：<code>U</code>
必须是<code>T</code>的超类。这里可以把T的任意超类<code>U</code>的对象添加进来，返回类型也成了
<code>Queue[U]</code>。
</p>

<p>
对于<code>append</code>方法来说，它不知道自己处理的是某一个子类。只知道处理的是超类<code>U</code>。
所以不会有类型错误。
</p>

<p>
要注意对于同一个类来说，即是超类也是子类。所以<code>T</code>是<code>U</code>下界，用<code>T</code>传入也是可以的。
</p>

<p>
例子：对于<code>Fruit</code>和两个子类<code>Orange</code>和<code>Apple</code>，可以把<code>Orange</code>对象传入
<code>Queue[Apple]</code>而返回<code>Queue[Fruit]</code>。
</p>

<p>
从技术角度来看，这里的情况发生了下界的翻转：类型参数<code>U</code>处于负位置（1次翻转），而
下界<code>&gt;: T</code>处于正的位置（两次翻转）。
</p>


<h2 id="toc_2.6">逆变</h2>

<p>
前面所有的例子不是协变的就是非协变的。还有一些情况下会有逆变：
</p>

<p>
对于两个类<code>U</code>和<code>T</code>。如果可以用<code>T</code>可以提供<code>U</code>要用到的功能，并且用起来限制更少，
就可以假设<code>T</code>是<code>U</code>的子类（里氏原则：Liskov Substitution Principle，LSP）。例如：
</p>

<pre class="brush: scala">
  trait OutputChannel[-T] {
    def write(x: T)
  }
</pre>

<p>
这种情况下<code>OutputChannel[AnyRef]</code>作为<code>OutputChannel[String]</code>的子类型。因为它们都
支持<code>write</code>操作。而且<code>OutputChannel[AnyRef]</code>参数仅要<code>AnyRef</code>就可以，但
<code>OutputChannel[String]</code>的参数一定要是<code>String</code>才行。
</p>

<p>
所以把一个<code>OutputChannel[AnyRef]</code>赋给<code>OutputChannel[String]</code>是安全的，反过来把一个
<code>OutputChannel[String]</code>赋给<code>OutputChannel[AnyRef]</code>却是不安全的。
</p>

<p>
Scala函数特质中协变与逆变混在一起用的情况会比较多。对于<code>S =&gt; T</code>类型的函数会定义
<code>Function[S, T]</code>，这时对参数<code>S</code>逆变而对结果<code>T</code>协变就是一种有用的策略：
</p>

<pre class="brush: scala">
  trait Function1[-S, +T] {
    def apply(x: S): T
  }
</pre>

<p>
应用的例子：
</p>

<p>
父类出版物的构造函数有一个标题参数，子类书的构造函数会调用父类的构造函数。
</p>

<pre class="brush: scala">
class Publication(val title: String)
class Book(title: String) extends Publication(title)
</pre>

<p>
单例对象<code>Library</code>定义了书的集，以及打印书单的方法<code>printBookList</code>的唯一参数是以
<code>Book =&gt; AnyRef</code>类型的方法为参数。
</p>

<pre class="brush: scala">
object Library {
 val books: Set[Book] =
   Set(
     new Book("Programming in Scala"),
     new Book("Walden")
   )
 def printBookList(info: Book =&gt; AnyRef) {
   for (book &lt;- books) println(info(book))
 }
}
</pre>

<p>
单例对象<code>Customer</code>定义了方法<code>getTitle</code>根据出版物取得标题。最后一行调用<code>Library</code>
的打印书单方法：
</p>

<pre class="brush: scala">
object Customer extends Application {
 def getTitle(p: Publication): String = p.title
 Library.printBookList(getTitle)
}
</pre>

<p>
关键是<code>printBookList</code>的形参是<code>Book =&gt; AnyRef</code>，但实参是<code>Publication =&gt; String</code>。参数
是父类（<code>Book</code>的父类<code>Publication</code>）而结果是子类（<code>AnyRef</code>的子类<code>String</code>）。
</p>

<p>
<code>printBookList</code>中的<code>println</code>方法会用到<code>toString</code>，这对所有<code>String</code>及<code>AnyRef</code>子类都有用
，这里用到了函数结果类型的协变。
</p>

<h2 id="toc_2.7">对象私有数据</h2>

<p>
之前的<code>Queue</code>类待改进内容：当<code>leading</code>列表为空时如果重复调用<code>head</code>，那么<code>mirror</code>
操作会重复地把<code>trailing</code>复制到<code>leading</code>列表。
</p>

<p>
改动：
</p>

<p>
<code>leading</code>和<code>trailing</code>都是可变变量，<code>mirror</code>操作在当前列表上产生副作用而不是返回
新的队列。由于它们都是对外不可见的私有变量，所以<code>Queue</code>还是算纯函数对象。
</p>

<pre class="brush: scala">
 class Queue[+T] private (
   private[this] var leading: List[T], 
   private[this] var trailing: List[T]
 ) {

   private def mirror() = 
     if (leading.isEmpty) {
       while (!trailing.isEmpty) {
         leading = trailing.head :: leading
         trailing = trailing.tail
       }
     }

   def head: T = { 
     mirror()
     leading.head 
   }

   def tail: Queue[T] = { 
     mirror()
     new Queue(leading.tail, trailing) 
   }

   def append[U &gt;: T](x: U) = 
     new Queue[U](leading, x :: trailing)
 }
</pre>

<p>
在两个可变私有成员变量的情况下<code>Queue</code>还可以使用协变。因为对于对象的私有值访问
来说不可能有比定义的对象类型更弱的静态类型对象引用。
</p>

<p>
所以Scala的类型变化检查对于对象私有成员，在遇到带有<code>+</code>或<code>-</code>的类型参数只出现在
具有相同变化型分类的位置上时，会被忽略。
</p>

<p>
所以如果去掉<code>private</code>修饰符的<code>[this]</code>限定会编译不过：
</p>

<pre class="brush: scala">
  Queues.scala:1: error: covariant type T occurs in 
  contravariant position in type List[T] of parameter of
  setter leading_=
  class Queue[+T] private (private var leading: List[T],
                                       ^
  Queues.scala:1: error: covariant type T occurs in 
  contravariant position in type List[T] of parameter of
  setter trailing_=
                           private var trailing: List[T]) {
                                       ^
</pre>

<p>
上面分别报错的原因是：协变类型<code>T</code>出现在setter函数<code>leading_=</code>参数类型List[T]的
逆变位置上；协变类型<code>T</code>出现在setter函数<code>trailing_=</code>参数类型List[T]的逆变位置上。
</p>


<h2 id="toc_2.8">上界</h2>

<p>
之前在“使用列表”章的第一节“列表字面量”中实现一个归并排序的方法。它的第一个参数
是比较函数，第二个柯里化的参数是要排序的列表。对这个函数的另一种组织方法大概就是
把列表类型混入到<code>ordered</code>特质中。
</p>

<p>
通过把<code>Ordered</code>特质混入到类中并实现抽象比较方法<code>Compare</code>就可以对实例进行比较：
</p>

<pre class="brush: scala">
  class Person(val firstName: String, val lastName: String)
      extends Ordered[Person] {

    def compare(that: Person) = {
      val lastNameComparison =
        lastName.compareToIgnoreCase(that.lastName)
      if (lastNameComparison != 0)
        lastNameComparison
      else
        firstName.compareToIgnoreCase(that.firstName)
    }

    override def toString = firstName +" "+ lastName
  }
</pre>

<pre class="brush: scala">
  scala&gt; val robert = new Person("Robert", "Jones")
  robert: Person = Robert Jones

  scala&gt; val sally = new Person("Sally", "Smith")
  sally: Person = Sally Smith

  scala&gt; robert &lt; sally
  res0: Boolean = true
</pre>

<p>
为了让列表类型混入到<code>Ordered</code>中，需要使用上界，符号<code>&lt;:</code>。
</p>

<p>
<code>T &lt;:  Ordered[T]</code>表明类型必须是<code>Ordered</code>的子类型。比如<code>Person</code>，因为<code>Person</code>
混入了<code>Ordered</code>特质：
</p>

<pre class="brush: scala">
  def orderedMergeSort[T &lt;: Ordered[T]](xs: List[T]): List[T] = {
    def merge(xs: List[T], ys: List[T]): List[T] =
      (xs, ys) match {
        case (Nil, _) =&gt; ys
        case (_, Nil) =&gt; xs
        case (x :: xs1, y :: ys1) =&gt;
          if (x &lt; y) x :: merge(xs1, ys)
          else y :: merge(xs, ys1)
      }
    val n = xs.length / 2
    if (n == 0) xs
    else {
      val (ys, zs) = xs splitAt n
      merge(orderedMergeSort(ys), orderedMergeSort(zs))
    }
  }
</pre>

<p>
使用：
</p>

<pre class="brush: scala">
  scala&gt; val people = List(
       |   new Person("Larry", "Wall"),
       |   new Person("Anders", "Hejlsberg"),
       |   new Person("Guido", "van Rossum"),
       |   new Person("Alan", "Kay"),
       |   new Person("Yukihiro", "Matsumoto")
       | )
  people: List[Person] = List(Larry Wall, Anders Hejlsberg,
    Guido van Rossum, Alan Kay, Yukihiro Matsumoto)


  scala&gt; val sortedPeople = orderedMergeSort(people)
  sortedPeople: List[Person] = List(Anders Hejlsberg, Alan Kay,
    Yukihiro Matsumoto, Guido van Rossum, Larry Wall)
</pre>

<p>
以上的解决方案还是有限制，比如不能适应整数列表。因为<code>Int</code>不是<code>Ordered[Int]</code>的
子类：
</p>

<pre class="brush: scala">
  scala&gt; val wontCompile = orderedMergeSort(List(3, 2, 1))
  &lt;console&gt;:5: error: inferred type arguments [Int] do
     not conform to method orderedMergeSort's type
       parameter bounds [T &lt;: Ordered[T]]
         val wontCompile = orderedMergeSort(List(3, 2, 1))
                           ^
</pre>

<p>
在以后的“隐式类型转换和参数”的“视界”一节中介绍通过采用隐式参数与检查约束来实现
更加通用的方案。
</p>



<h1 id="toc_3">抽象成员</h1>

<p>
Scala中不仅可以指定方法为抽象，还可以声明字段甚至抽象类型为类和特质的成员。
</p>

<h2 id="toc_3.1">抽象成员的快速浏览</h2>

<p>
在特质中分别对类型（T）、方法（transform）、val（initial）、var（current）的
抽象声明做出了一个例子：
</p>

<pre class="brush: scala">
  trait Abstract {
    type T
    def transform(x: T): T
    val initial: T
    var current: T
  }
</pre>

<p>
实现：
</p>

<pre class="brush: scala">
  class Concrete extends Abstract {
    type T = String
    def transform(x: String) = x + x
    val initial = "hi"
    var current = initial
  }
</pre>

<h2 id="toc_3.2">类型成员</h2>

<p>
（略）
</p>

<h2 id="toc_3.3">抽象val</h2>

<p>
val是不可变的，抽象的val指定了类型与变量名，不指定值：
</p>

<pre class="brush: scala">
  val initial: String
</pre>

<p>
实现时指定值：
</p>

<pre class="brush: scala">
  val initial = "hi"
</pre>

<p>
如果不知道类中定义的确切内容，但是确定对于每个实例来说值都是不可变的。在这样的
情况下可以使用抽象的val声明。
</p>

<p>
可以注意到，抽象val的格式非常类似于下面的抽象无参数方法声明：
</p>

<pre class="brush: scala">
  def initial: String
</pre>

<p>
客户代码将使用统一的<code>obj.initial</code>方法引用val及方法。如果<code>initial</code>是抽象val，那么
客户就可以保证每次引用都将得到同样的值。如果<code>initial</code>是抽象方法那就无法保证，
因为在不同的实现中<code>initial</code>可以被实现为每次调用都返回不同的值。
</p>

<p>
换句话说抽象的val限制了合法实现的方式：任何实现都必须是<code>val</code>类型的定义不可以是
<code>var</code>。另一方面，抽象方法声明可以被实现为具体的方法定义或具体的<code>val</code>定义。
</p>

<p>
所以在下面的代码中，<code>Apple</code>是合法的子类面<code>BadApple</code>不是：
</p>

<pre class="brush: scala">
  abstract class Fruit {
    val v: String // `v' for value
    def m: String // `m' for method
  }

  abstract class Apple extends Fruit {
    val v: String
    val m: String // OK to override a `def' with a `val'
  }

  abstract class BadApple extends Fruit {
    def v: String // ERROR: cannot override a `val' with a `def'
    def m: String
  }
</pre>

<h2 id="toc_3.4">抽象var</h2>

<p>
在特质里使用，只声明类型与名称，没有初始值：
</p>

<pre class="brush: scala">
  trait AbstractTime {
    var hour: Int
    var minute: Int
  }
</pre>

<p>
也会有自动扩展的<code>getter</code>与<code>setter</code>方法，上面的代码相当于：
</p>

<pre class="brush: scala">
  trait AbstractTime {
    def hour: Int          // getter for `hour'
    def hour_=(x: Int)     // setter for `hour'
    def minute: Int        // getter for `minute'
    def minute_=(x: Int)   // setter for `minute'
  }
</pre>

<h2 id="toc_3.5">初始化抽象val</h2>

<p>
结合特质来使用，抽象val可以让子类扩展提供父类没有的参数与细节。因为特质缺省能
用来传递参数的构造器。
</p>

<p>
拿前面的实数类来作例子，以下特质：
</p>

<pre class="brush: scala">
  trait RationalTrait { 
    val numerArg: Int 
    val denomArg: Int 
  } 
</pre>

<p>
为了实例化这个特质，先要实现val。在这里我们要用到新的<code>new</code>语法结构：
</p>

<pre class="brush: scala">
  new RationalTrait {
    val numerArg = 1
    val denomArg = 2
  }
</pre>

<p>
上面的代码会产混入了物质的匿名类实例，类似于<code>new Rational(1, 2)</code>。当然区别还是
有的：
</p>

<pre class="brush: scala">
  new Rational(expr1, expr2)
</pre>

<p>
上面的两个表达式会在类初始化前计算，而相反的：
</p>

<pre class="brush: scala">
  new RationalTrait {
    val numerArg = expr1
    val denomArg = expr2
  }
</pre>

<p>
上面的两个表达式会作为匿名类初始化的一部分计算。而匿名类初始化在<code>RationalTrait</code>
之后执行，所以<code>numerArg</code>和<code>denomArg</code>的值在<code>RationalTrait</code>初始化期间还没有准备好
，都是<code>Int</code>类型的默认值<code>0</code>。
</p>

<p>
所以对下面的代码来说，这会成为一个问题，因为其中定义了经过约分后的分子与分母：
</p>

<pre class="brush: scala">
  trait RationalTrait { 
    val numerArg: Int 
    val denomArg: Int 
    require(denomArg != 0)
    private val g = gcd(numerArg, denomArg)
    val numer = numerArg / g
    val denom = denomArg / g
    private def gcd(a: Int, b: Int): Int = 
      if (b == 0) a else gcd(b, a % b)
    override def toString = numer +"/"+ denom
  }
</pre>

<p>
如果尝试使用某种分子和分母的表达式面不是简单的字面量实例化这个特质，会引起以下
错误：
</p>

<pre class="brush: scala">
  scala&gt; val x = 2
  x: Int = 2

  scala&gt; new RationalTrait {
       |   val numerArg = 1 * x
       |   val denomArg = 2 * x
       | }
  java.lang.IllegalArgumentException: requirement failed
          at scala.Predef$.require(Predef.scala:107)
          at RationalTrait$class.$init$(&lt;console&gt;:7)
          at $anon$1.&lt;init&gt;(&lt;console&gt;:7)
          ....
</pre>

<p>
解决方案有两个，分别是预初始化字段和懒加载val。
</p>


<h3 id="toc_3.5.1">fields预初始化字段</h3>

<p>
给字段定义加上花括号，放在超类的构造器之前：
</p>

<pre class="brush: scala">
  scala&gt; new { 
       |   val numerArg = 1 * x
       |   val denomArg = 2 * x 
       | } with RationalTrait
  res15: java.lang.Object with RationalTrait = 1/2
</pre>

<p>
不仅匿名类可以用预加载，有名称的类和对象也可以。
</p>

<p>
注意要放在关键字<code>extends</code>后面：
</p>

<pre class="brush: scala">
  object twoThirds extends {
    val numerArg = 2
    val denomArg = 3
  } with RationalTrait
</pre>

<p>
由于预初始化的字段的超类构造器调用前被初始化，所以不能引用正在被构造的对象。所以
对于<code>this</code>实际指向的是正被构造的类或对象的对象，而来是被构造的对象本身：
</p>

<pre class="brush: scala">
  scala&gt; new {
     |   val numerArg = 1
     |   val denomArg = this.numerArg * 2
     | } with RationalTrait
  &lt;console&gt;:8: error: value numerArg is not a
       member of object $iw
           val denomArg = this.numerArg * 2
                               ^
</pre>

<p>
因为实例还没有构建完成，所以会报错。<code>$iw</code>是合成对象，解释器把用户输出语句放在
这个对象中。
</p>

<pre class="brush: scala">
  class RationalClass(n: Int, d: Int) extends {
    val numerArg = n
    val denomArg = d
  } with RationalTrait {
    def + (that: RationalClass) = new RationalClass(
      numer * that.denom + that.numer * denom,
      denom * that.denom
    )
  }
</pre>



<h3 id="toc_3.5.2">懒加载val</h3>

<p>
懒加载让表达式在<code>val</code>第一次被使用的时候才计算机。格式为把<code>lazy</code>修饰加在<code>val</code>上。
</p>

<p>
普通情况下初始化与类初始化一起的：
</p>

<pre class="brush: scala">
  scala&gt; object Demo {
       |   val x = { println("initializing x"); "done" }
       | }
  defined module Demo


  scala&gt; Demo
  initializing x
  res19: Demo.type = Demo$@97d1ff

  scala&gt; Demo.x
  res20: java.lang.String = done
</pre>

<p>
使用了懒加载以后，<code>val</code>的初始化延迟到第一次使用时：
</p>

<pre class="brush: scala">
  scala&gt; object Demo {
       |   lazy val x = { println("initializing x"); "done" }
       | }
  defined module Demo

  scala&gt; Demo
  res21: Demo.type = Demo$@d81341

  scala&gt; Demo.x
  initializing x
  res22: java.lang.String = done
</pre>

<p>
上面的情况有点像是用<code>def</code>把<code>x</code>定义为一个无参的方法，不同于<code>def</code>的是计算只进行一次。
</p>

<p>
通过上面两个例子可以看出，单例对象的初始化也很像懒加载。它们在第一次被使用时进行
初始化。
</p>

<p>
通过懒加载重新实现<code>RationalTrait</code>，与前一版本的主要变化是<code>require</code>子句从特质的
方法体移动到了计算<code>numerArg</code>和<code>denomArg</code>最大公约数的私有字段<code>g</code>的初始化器中。
所以这个版本中<code>LazyRationalTrait</code>初始化器已经用不干啥事儿了：
</p>

<pre class="brush: scala">
  trait LazyRationalTrait { 
    val numerArg: Int 
    val denomArg: Int 
    lazy val numer = numerArg / g
    lazy val denom = denomArg / g
    override def toString = numer +"/"+ denom
    private lazy val g = {
      require(denomArg != 0)
      gcd(numerArg, denomArg)
    }
    private def gcd(a: Int, b: Int): Int = 
      if (b == 0) a else gcd(b, a % b)
  }


  scala&gt; val x = 2
  x: Int = 2

  scala&gt; new LazyRationalTrait {
       |   val numerArg = 1 * x
       |   val denomArg = 2 * x
       | }
  res1: java.lang.Object with LazyRationalTrait = 1/2
</pre>

<p>
在特质中的两个懒加载对象<code>number</code>和<code>denom</code>是在<code>toString</code>方法调用时才初始化。计算
它们的表达式要用到同样是懒加载的<code>g</code>。
</p>

<p>
应用懒加载还是要注意副作用，在有副作用的情况下跟踪加载顺序是很重要的事情。
无副作用的纯函数式应用配合懒加载是相当合适的。
</p>



<h2 id="toc_3.6">抽象类型</h2>

<p>
抽象类型声明<code>type T</code>应用在尚不可知的类型上，不同的子类可以提供不同的<code>T</code>实现。
</p>

<p>
以一个动物食性的例子来解释应用环境，动物吃食物：
</p>

<pre class="brush: scala">
  class Food
  abstract class Animal {
    def eat(food: Food)
  }
</pre>

<p>
会在想让它们的子类牛吃草时遇到麻烦。<code>eat</code>方法不能重写，因为参数不能从<code>Food</code>转为
子类<code>Grass</code>：
</p>

<pre class="brush: scala">
  class Grass extends Food
  class Cow extends Animal {
    override def eat(food: Grass) {} // This won't compile
  }

  BuggyAnimals.scala:7: error: class Cow needs to be
  abstract, since method eat in class Animal of type
      (Food)Unit is not defined
  class Cow extends Animal {
        ^
  BuggyAnimals.scala:8: error: method eat overrides nothing
    override def eat(food: Grass) {}
                 ^
</pre>

<p>
这样看来类型检查太严格了，应该允许子类？但是如果这样做的话又会失去类型检验保障。
</p>

<p>
比如说喂牛吃鱼：
</p>

<pre class="brush: scala">
  class Food
  abstract class Animal {
    def eat(food: Food)
  }
  class Grass extends Food
  class Cow extends Animal {
    override def eat(food: Grass) {} // This won't compile,
  }                                  // but if it did,...
  class Fish extends Food
  val bessy: Animal = new Cow
  bessy eat (new Fish)     // ...you could feed fish to cows.
</pre>

<p>
更加精确的方式是能按不同的动物决定食物的种类，父类中指定动物只能吃食物：
</p>

<pre class="brush: scala">
  class Food
  abstract class Animal {
    type SuitableFood &lt;: Food
    def eat(food: SuitableFood)
  }
</pre>

<p>
<code>SuitableFood</code>被定义为抽象类，而且有上界<code>Food</code>。以后动物类中指定具体的食物子类：
</p>

<pre class="brush: scala">
  class Grass extends Food
  class Cow extends Animal {
    type SuitableFood = Grass
    override def eat(food: Grass) {}
  }
</pre>

<p>
现在得到了比较合适的类型检查：
</p>

<pre class="brush: scala">
  scala&gt; class Fish extends Food
  defined class Fish

  scala&gt; val bessy: Animal = new Cow
  bessy: Animal = Cow@674bf6

  scala&gt; bessy eat (new Fish)
  &lt;console&gt;:10: error: type mismatch;
   found   : Fish
   required: bessy.SuitableFood
         bessy eat (new Fish)
                    ^
</pre>



<h2 id="toc_3.7">路径依赖类型</h2>

<p>
看一下前面例子的最后一条错误信息。它说明需要的类型是<code>bessy.SuitableFood</code>，这里的
<code>SuitableFood</code>是<code>bessy</code>引用的对象的成员。
</p>

<p>
这样的类型被称为路径依赖类型，路径指的是对象的引用。不同路径将产不同的类型：
</p>

<pre class="brush: scala">
  class DogFood extends Food
  class Dog extends Animal {
    type SuitableFood = DogFood
    override def eat(food: DogFood) {}
  }

  scala&gt; val bessy = new Cow
  bessy: Cow = Cow@10cd6d

  scala&gt; val lassie = new Dog
  bootsie: Dog = Dog@d11fa6

  scala&gt; lassie eat (new bessy.SuitableFood)
  &lt;console&gt;:13: error: type mismatch;
   found   : Grass
   required: DogFood
         lassie eat (new bessy.SuitableFood)
                     ^
</pre>

<p>
<code>bessy.SuitableFood</code>不能匹配<code>lassie.SuitableFood</code>，但如果同样是<code>Dog</code>的话，情况又
不同。因为<code>Dog</code>的<code>SuitableFood</code>被定义为<code>DogFood</code>类的别名，所以实际上是一样的：
</p>

<pre class="brush: scala">
  scala&gt; val bootsie = new Dog
  bootsie: Dog = Dog@54ca71

  scala&gt; lassie eat (new bootsie.SuitableFood)
</pre>

<p>
路径依赖有点像Java里的内部类，但区别是：路径依赖表达了外在的对象，而内部类表达了
外在的类。Java的内部类在Scala表达为两个类：
</p>

<pre class="brush: scala">
  class Outer {
    class Inner
  }
</pre>

<p>
与Java的<code>Outer.Inner</code>不同，Scala中表达为<code>Outer#Inner</code>。
</p>

<p>
<code>注意：</code>
</p>

<p>
总之，要注意。路径依赖是在对象中的类，而不是Java那样类中的类。
</p>

<p>
<code>.</code>语法留给对象使用：
</p>

<pre class="brush: scala">
  val o1 = new Outer
  val o2 = new Outer
</pre>

<p>
虽然<code>o1.Inner</code>和<code>o2.Inner</code>是不同的两个路径依赖类型，但两个都能匹配更加通用的<code>Outer#Inner</code>。
</p>

<p>
和Java中一样，Scala的内部类实例也有对外部类实例的引用。所以不能只有内部类实例面没有外部类实例。有两个方式实例化内部类：
</p>

<p>
1）直接在外部类方法体中实例化，这样可以用<code>this</code>引用外部类对象。
</p>

<p>
2）使用路径依赖类型。如<code>o1.Inner</code>。返回的内部类有对<code>01</code>的引用。例子如下：
</p>

<pre class="brush: scala">
  scala&gt; new o1.Inner
  res1: o1.Inner = Outer$Inner@13727f
</pre>

<p>
相对的，类型<code>Outer#Inner</code>是没有指向对象的引用的，所以不能创建它的实例：
</p>

<pre class="brush: scala">
  scala&gt; new Outer#Inner
  &lt;console&gt;:6: error: Outer is not a legal prefix for
    a constructor
         new Outer#Inner
                   ^
</pre>


<h2 id="toc_3.8">枚举</h2>

<p>
标准库中的类<code>scala.Enumeration</code>用来扩展枚举类：
</p>

<pre class="brush: scala">
  object Color extends Enumeration {
    val Red = Value
    val Green = Value
    val Blue = Value
  }
</pre>

<p>
<code>注意：</code>
</p>

<p>
枚举是和路径依赖一样，是对象中的类，不是类中的类。
</p>

<p>
还可以简化：
</p>

<pre class="brush: scala">
  object Color extends Enumeration {
    val Red, Green, Blue = Value
  }
</pre>

<p>
可以<code>Color</code>的全部成员，然后直接写颜色名：
</p>

<pre class="brush: scala">
  import Color._
</pre>

<p>
前面定义的<code>Red</code>、<code>Green</code>和<code>Blue</code>这些值的类型为<code>Enumeration</code>定义的内部类，名为<code>Value</code>。同名无参数方法<code>Value</code>返回该类的新对象，即<code>Color.Red</code>类的值类型是<code>Color.Value</code>。而且是依赖路径的。如：
</p>

<pre class="brush: scala">
  object Direction extends Enumeration {
    val North, East, South, West = Value
  }
</pre>

<p>
上面就定义了一个完全不同的类型，因为路径不同。
</p>

<p>
还可以重载<code>Value</code>方法把名称与值对应起来：
</p>

<pre class="brush: scala">
  object Direction extends Enumeration {
    val North = Value("North")
    val East = Value("East")
    val South = Value("South")
    val West = Value("West")
  }
</pre>

<p>
<code>Direction</code>与<code>Color</code>的<code>Value</code>也是不同的类。
</p>

<p>
遍历：
</p>

<pre class="brush: scala">
  scala&gt; for (d &lt;- Direction) print(d +" ")
  North East South West 
</pre>

<p>
枚举的值从<code>0</code>开始增加，用成员方法<code>id</code>可以取出值：
</p>

<pre class="brush: scala">
  scala&gt; Direction.East.id
  res5: Int = 1
</pre>

<p>
反过来也可以通过非零整数取得<code>id</code>：
</p>

<pre class="brush: scala">
  scala&gt; Direction(1)
  res6: Direction.Value = East
</pre>

<h2 id="toc_3.9">案例研究：货币</h2>

<p>
设计一个货币类能处理不同的货币。定义抽象类可以扩展为具体不同的货币。当然第一个版本肯定是不完善的：
</p>

<pre class="brush: scala">
  // A first (faulty) design of the Currency class
  abstract class Currency {
    val amount: Long
    def designation: String 
    override def toString = amount +" "+ designation
    def + (that: Currency): Currency = ...
    def * (x: Double): Currency = ...
  }
</pre>

<p>
<code>amount</code>和<code>designation</code>分别代表金额和表示金额的符号。其他方法还有加法和乘法操作。这个版本的问题是，在语法上两个不同的子类可以相加：
</p>

<pre class="brush: scala">
  abstract class Dollar extends Currency {
    def designation = "USD"
  }
  abstract class Euro extends Currency {
    def designation = "Euro"
  }
</pre>

<p>
这样不同货币的相加是有问题的。所以下一个改进版本用抽象类型来标明末知的类型：
</p>

<pre class="brush: scala">
  abstract class AbstractCurrency {
    type Currency &lt;: AbstractCurrency
    val amount: Long
    def designation: String 
    override def toString = amount +" "+ designation
    def + (that: Currency): Currency = ...
    def * (x: Double): Currency = ...
  }
</pre>

<p>
每个子类都要把<code>Currency</code>指定为这个类自身，扩展实现是类似于这样：
</p>

<pre class="brush: scala">
  abstract class Dollar extends AbstractCurrency {
    type Currency = Dollar
    def designation = "USD"
  }
</pre>

<p>
这个版本的问题在于加法与乘法的定义。首先想到的把金额转为正确类型的货币的方法可能是这样的：
</p>

<pre class="brush: scala">
  def + (that: Currency): Currency = new Currency {
    val amount = this.amount + that.amount
  }
</pre>

<p>
但这通不过编译，因为Scala不能用抽象类型<code>new</code>出实例来，即使是作为其他类型的父类：
</p>

<pre class="brush: scala">
  error: class type required
    def + (that: Currency): Currency = new Currency {
</pre>

<p>
使用工厂方法是个解决方案：用声明抽象方法代替直接创建抽象类的实例：
</p>

<pre class="brush: scala">
  abstract class AbstractCurrency {
    type Currency &lt;: AbstractCurrency // abstract type
    def make(amount: Long): Currency  // factory method
    ...                               // rest of class
  }
</pre>

<p>
但这样有别的问题，因为这样不得不把工厂方法放到<code>AbstractCurrency</code>类中，所有的实例都可以调用<code>make</code>方法，也就都有了创建货币的能力：
</p>

<pre class="brush: scala">
  myDollar.make(100)  // here are a hundred more!
</pre>

<p>
所以把工厂方法移到一个新的类中，新的类叫<code>CurrencyZone</code>。把<code>AbstractCurrency</code>和<code>Currency</code>也作为它的内部类：
</p>

<pre class="brush: scala">
  abstract class CurrencyZone {
    type Currency &lt;: AbstractCurrency
    def make(x: Long): Currency
    abstract class AbstractCurrency {
      val amount: Long
      def designation: String 
      override def toString = amount +" "+ designation
      def + (that: Currency): Currency = 
        make(this.amount + that.amount)
      def * (x: Double): Currency = 
        make((this.amount * x).toLong)
    }
  }
</pre>

<p>
这样按不同货币来扩展：
</p>

<pre class="brush: scala">
  object US extends CurrencyZone {
    abstract class Dollar extends AbstractCurrency {
      def designation = "USD"
    }
    type Currency = Dollar
    def make(x: Long) = new Dollar { val amount = x }
  }
</pre>

<p>
<code>US</code>中定义了类<code>Dollar</code>。它的类型是<code>US.Dollar</code>。
</p>

<p>
继续改进设计：关于单位，单位不仅是美元，还有美分。所以让<code>amount</code>以美分为单位更加合适。所以用多一个字段<code>CurrencyUnit</code>记录单位：
</p>

<pre class="brush: scala">
  class CurrencyZone { 
    ... 
    val CurrencyUnit: Currency 
  } 
</pre>

<p>
子类里再加上两个方法直接把1美元代表100美分的逻辑描述出来：
</p>

<pre class="brush: scala">
  object US extends CurrencyZone {
    abstract class Dollar extends AbstractCurrency {
      def designation = "USD"
    }
    type Currency = Dollar
    def make(cents: Long) = new Dollar {
      val amount = cents
    }
    val Cent = make(1)
    val Dollar = make(100)
    val CurrencyUnit = Dollar
  }
</pre>

<p>
还有显示问题，用多数内部类型上都带的<code>format</code>方法格式化美元与美分的小数显示，如“<code>10.23 USD</code>”：
</p>

<pre class="brush: scala">
    ((amount.toDouble / CurrencyUnit.amount.toDouble)
     formatted ("%."+ decimals(CurrencyUnit.amount) +"f")
     +" "+ designation)
</pre>

<p>
输出字符的长度是通过<code>decimals</code>方法得出的。<code>decimals</code>方法返回十进制数字所要占用的字符长度。如对于<code>decimals(10)</code>代表0到9，会占用一个字符，而<code>decimals</code>(100)是0到99会占用两个字符。<code>decimals</code>方法通过简单递归实现：
</p>

<pre class="brush: scala">
  private def decimals(n: Long): Int = 
    if (n == 1) 0 else 1 + decimals(n / 10)
</pre>

<p>
相对的看一下欧元的实现：
</p>

<pre class="brush: scala">
  object Europe extends CurrencyZone {
    abstract class Euro extends AbstractCurrency {
      def designation = "EUR"
    }
    type Currency = Euro
    def make(cents: Long) = new Euro {
      val amount = cents
    }
    val Cent = make(1)
    val Euro = make(100)
    val CurrencyUnit = Euro
  }

  object Japan extends CurrencyZone {
    abstract class Yen extends AbstractCurrency {
      def designation = "JPY"
    }
    type Currency = Yen
    def make(yen: Long) = new Yen {
      val amount = yen
    }
    val Yen = make(1)
    val CurrencyUnit = Yen
  }
</pre>

<p>
再改进一下，增加汇率的功能。先用一个新的对象来记录汇率：
</p>

<pre class="brush: scala">
  object Converter {
    var exchangeRate = Map(
      "USD" -&gt; Map("USD" -&gt; 1.0   , "EUR" -&gt; 0.7596, 
                   "JPY" -&gt; 1.211 , "CHF" -&gt; 1.223),
      "EUR" -&gt; Map("USD" -&gt; 1.316 , "EUR" -&gt; 1.0   , 
                   "JPY" -&gt; 1.594 , "CHF" -&gt; 1.623),
      "JPY" -&gt; Map("USD" -&gt; 0.8257, "EUR" -&gt; 0.6272, 
                   "JPY" -&gt; 1.0   , "CHF" -&gt; 1.018),
      "CHF" -&gt; Map("USD" -&gt; 0.8108, "EUR" -&gt; 0.6160, 
                   "JPY" -&gt; 0.982 , "CHF" -&gt; 1.0  )
    )
  }
</pre>

<p>
在货币中增加根据汇率来转换的功能。接收一个外币类型，把自己的金额转成这个外币的金额：
</p>

<pre class="brush: scala">
  def from(other: CurrencyZone#AbstractCurrency): Currency = 
    make(Math.round(
      other.amount.toDouble * Converter.exchangeRate
        (other.designation)(this.designation)))
</pre>

<p>
参数是末知的<code>CurrencyZone#AbstractCurrency</code>，所以能处理任意外币类型。
</p>

<p>
全部的货币代码，假设都放在<code>org.stairwaybook.currencies</code>包中：
</p>

<pre class="brush: scala">
  abstract class CurrencyZone {

    type Currency &lt;: AbstractCurrency
    def make(x: Long): Currency

    abstract class AbstractCurrency {

      val amount: Long
      def designation: String 

      def + (that: Currency): Currency = 
        make(this.amount + that.amount)
      def * (x: Double): Currency = 
        make((this.amount * x).toLong)
      def - (that: Currency): Currency = 
        make(this.amount - that.amount)
      def / (that: Double) = 
        make((this.amount / that).toLong)
      def / (that: Currency) = 
        this.amount.toDouble / that.amount

      def from(other: CurrencyZone#AbstractCurrency): Currency = 
        make(Math.round(
          other.amount.toDouble * Converter.exchangeRate
            (other.designation)(this.designation)))

      private def decimals(n: Long): Int = 
        if (n == 1) 0 else 1 + decimals(n / 10)

      override def toString = 
        ((amount.toDouble / CurrencyUnit.amount.toDouble)
         formatted ("%."+ decimals(CurrencyUnit.amount) +"f")
         +" "+ designation)
    }

    val CurrencyUnit: Currency
  }
</pre>

<p>
调用的例子：
</p>

<pre class="brush: scala">
  scala&gt; import org.stairwaybook.currencies._

  scala&gt; Japan.Yen from US.Dollar * 100
  res16: Japan.Currency = 12110 JPY

  scala&gt; Europe.Euro from res16
  res17: Europe.Currency = 75.95 EUR

  scala&gt; US.Dollar from res17
  res18: US.Currency = 99.95 USD
</pre>

<p>
相同类型的货币可以相加，不同类型的不可以相加：
</p>

<pre class="brush: scala">
  scala&gt; US.Dollar * 100 + res18
  res19: currencies.US.Currency = 199.95


  scala&gt; US.Dollar + Europe.Euro
  &lt;console&gt;:7: error: type mismatch;
   found   : currencies.Europe.Euro
   required: currencies.US.Currency
         US.Dollar + Europe.Euro
                            ^
</pre>

<p>
类型抽象实现了不同货币不能相加的功能。像是1999年9月23日，混用英制单位和公制单位引起的火星航天器坠毁事件不会再重演了。
</p>



<h1 id="toc_4">隐式转换和参数</h1>

<h2 id="toc_4.1">隐式转换</h2>

<p>
Scala里有一个很有用的特质<code>RandomAccessSeq[T]</code>提供了可以随机访问的序列。它有很多功能，所以它的子类都自动继承这些功能。
</p>

<p>
现在有个问题，我们要用到<code>String</code>没有混入<code>RandomAccessSeq</code>特质，所以用不到那些方便的功能。
</p>

<p>
隐式转换可以让<code>String</code>表现得像<code>RandomAccessSeq</code>的子类。为了达到这一目的，需要定义从<code>String</code>到<code>RandomAccessSeq</code>的隐匿转换。
</p>

<pre class="brush: scala">
  implicit def stringWrapper(s: String) = 
    new RandomAccessSeq[Char] {
      def length = s.length
      def apply(i: Int) = s.charAt(i)
    }
</pre>

<p>
然后就可以转换它了：
</p>

<pre class="brush: scala">
  scala&gt; stringWrapper("abc123") exists (_.isDigit)
  res0: Boolean = true
</pre>

<p>
也可以省略转换直接当作<code>RandomAccessSeq</code>来用：
</p>

<pre class="brush: scala">
  scala&gt; "abc123" exists (_.isDigit)
  res1: Boolean = true
</pre>

<p>
隐式转换的优点是可以在某个点转成需要的类型。
</p>

<p>
顺便提一下：<code>Predef</code>对象已经用类似的方式定义了<code>stringWrapper</code>转换，所以其实不用定义也可以隐匿转换了。
</p>


<h2 id="toc_4.2">隐式操作规则</h2>

<dl>
<dt>标记规则 </dt>
<dd>只有标记为<code>implicit</code>的定义才是可用的。可以用来标记任何变量、函数或对象定义。</dd>
</dl>

<dl>
<dt>作用域规则 </dt>
<dd>必须以单一标识符的形式处于作用域中，或与转换的源或目标类型关联在一起。</dd>
</dl>

<p>
就是不能用<code>aaa.convert(x)</code>，这不是单一的。要先<code>import aaa</code>，然后<code>convert(x)</code>，这样才是单一的。
</p>

<p>
“单一标识符”规则有个例外。转换的“目标”与“源”的类型的“伴生对象”中的隐式转换定义会被编译器找到。如从<code>Dollar</code>转为<code>Euro</code>，可以把隐匿转换放在这两者之一的的伴生对象中：
</p>

<pre class="brush: scala">
  object Dollar {
    implicit def dollarToEuro(x: Dollar): Euro = ...
  }
  class Dollar { ... }
</pre>

<p>
这样就不用手动引入了。
</p>

<dl>
<dt>无歧义规则 </dt>
<dd>不能有其他转换，如果有两个可用的从类A到类B的转换，会报错。可以移除一个转换函数，或是显式指明一个方法，如：<code>convertFunc2(x) + y</code></dd>
</dl>

<dl>
<dt>单一调用原则 </dt>
<dd>不会嵌套地转换，如：<code>convert1(convert2(x)) + y</code>。</dd>
</dl>

<dl>
<dt>显式操作先行规则 </dt>
<dd>如果不用转换类型就可以用，编译器不会再画蛇添足地转换。</dd>
</dl>

<p>
这是一个供程序员把握的度：如果代码太冗长，用隐式转换来精简代码；如果代码看起来太简单不明确，用显式的转换来减少歧义和二义性。
</p>

<dl>
<dt>命名隐式转换 </dt>
<dd>转换方法的命名可以随意，但要考虑到两个情况：是不是需要在方法应用中明确写明，以及决定在哪个隐式转换在程序的任何地方都有效。</dd>
</dl>

<p>
拿第二点来说，设一个对象带两个隐式转换：
</p>

<pre class="brush: scala">
  object MyConversions {
    implicit def stringWrapper(s: String):
        RandomAccessSeq[Char] = ...
    implicit def intToString(x: Int): String = ...
  }
</pre>

<p>
现在只需要<code>stringWrapper</code>，不想要<code>intToString</code>。可以只引入一个：
</p>

<pre class="brush: scala">
  import MyConversions.stringWrapper
  ... // code making use of stringWrapper
</pre>

<p>
这样的情况下会用到转换方法的名字。
</p>

<p>
Scala中有三个地方会用到隐式转换：转换为需要的类型、指定（方法）调用者的转换、隐式参数。接下来的三节分别讨论这三种情况。
</p>


<h2 id="toc_4.3">隐式转换为期望的类型</h2>

<p>
有一个双精度数，但是表达式要用到整数，所以就要隐式转换：
</p>

<pre class="brush: scala">
  scala&gt; val i: Int = 3.5
  &lt;console&gt;:5: error: type mismatch;
   found   : Double(3.5)
   required: Int
         val i: Int = 3.5
                      ^
</pre>

<p>
定义隐式转换就可以用了：
</p>

<pre class="brush: scala">
  scala&gt; implicit def doubleToInt(x: Double) = x.toInt
  doubleToInt: (Double)Int

  scala&gt; val i: Int = 3.5
  i: Int = 3
</pre>

<p>
相当于：
</p>

<pre class="brush: scala">
  val i: Int = doubleToInt(3.5)
</pre>

<p>
因为从<code>Double</code>到<code>Int</code>会丢失精度，所以<code>Predef</code>中没有默认定义；但是反过来在<code>Predef</code>中已经有定义了：
</p>

<pre class="brush: scala">
  implicit def int2double(x: Int): Double = x.toDouble
</pre>


<h2 id="toc_4.4">转换方法调用的接收者</h2>

<p>
如果<code>obj</code>没有<code>doIt</code>方法，但程序里有这一行，就试着转成有<code>doIt</code>的类型。
</p>

<h3 id="toc_4.4.1">与新类型的交互操作</h3>

<p>
给新类型加上它没有实现的功能。以实数类为例：
</p>

<pre class="brush: scala">
  class Rational(n: Int, d: Int) {
    ...
    def + (that: Rational): Rational = ...
    def + (that: Int): Rational = ...
  }
</pre>

<p>
加法可以处理<code>Rational</code>和<code>Int</code>：
</p>

<pre class="brush: scala">
  scala&gt; val oneHalf = new Rational(1, 2)
  oneHalf: Rational = 1/2

  scala&gt; oneHalf + oneHalf
  res4: Rational = 1/1

  scala&gt; oneHalf + 1
  res5: Rational = 3/2
</pre>

<p>
但是一个<code>Int</code>没有办法加上<code>Rational</code>：
</p>

<pre class="brush: scala">
  scala&gt; 1 + oneHalf
  &lt;console&gt;:6: error: overloaded method value + with
  alternatives (Double)Double &lt;and&gt; ... cannot be applied
  to (Rational)
       1 + oneHalf
         ^
</pre>

<p>
办法是让<code>Int</code>转为<code>Rational</code>：
</p>

<pre class="brush: scala">
  scala&gt; implicit def intToRational(x: Int) = 
       |   new Rational(x, 1)
  intToRational: (Int)Rational
  
  scala&gt; 1 + oneHalf
  res6: Rational = 3/2
</pre>

<p>
相当于：
</p>

<pre class="brush: scala">
  intToRational(1) + oneHalf
</pre>

<h3 id="toc_4.4.2">模拟新的语法</h3>

<p>
隐式转换还可以用来模拟新的语法。以我们熟悉的<code>Map</code>构建为例：
</p>

<pre class="brush: scala">
  Map(1 -&gt; "one", 2 -&gt; "two", 3 -&gt; "three")
</pre>

<p>
其实<code>Map</code>对象里的<code>-&gt;</code>根本就不是内建语法。实际上是定义在<code>scala.Predef</code>中的类<code>ArrowAssoc</code>的方法。还定义了从<code>Any</code>到<code>ArrowAssoc</code>的隐式转换。
</p>

<p>
拿上面的<code>1 -&gt; "one"</code>来说。这其实是从<code>1</code>到<code>ArrowAssoc</code>的转换。相差定义如下：
</p>

<pre class="brush: scala">
  package scala
  object Predef {
    class ArrowAssoc[A](x: A) {
      def -&gt; [B](y: B): Tuple2[A, B] = Tuple2(x, y)
    }
    implicit def any2ArrowAssoc[A](x: A): ArrowAssoc[A] = 
      new ArrowAssoc(x)
    ...
  }
</pre>

<h2 id="toc_4.5">隐式参数</h2>

<p>
省略柯里化后的参数列表。编译器会用<code>someCall(a)(b,c,d)</code>代替<code>someCall(a)</code>。能这样做的前题是不仅<code>b</code><code>c</code><code>d</code>三个要定义<code>implicit</code>，连<code>someCall</code>或<code>someCall</code>定义的最后一个参数列表都必须被标记为<code>implicit</code>。
</p>

<p>
举例有一个类实现了命令行提示符：
</p>

<pre class="brush: scala">
  class PreferredPrompt(val preference: String)
</pre>

<p>
还有一个<code>Greeter</code>类的方法<code>greet</code>有两个参数列表。分别是用户名和前面的命令行提示符类：
</p>

<pre class="brush: scala">
  object Greeter {
    def greet(name: String)(implicit prompt: PreferredPrompt) {
      println("Welcome, "+ name +". The system is ready.")
      println(prompt.preference)
    }
  }
</pre>

<p>
后一个参数列表被声明为<code>implicit</code>，表示可以隐式提供。当然要显式提供也可以：
</p>

<pre class="brush: scala">
  scala&gt; val bobsPrompt = new PreferredPrompt("relax&gt; ")
  bobsPrompt: PreferredPrompt = PreferredPrompt@ece6e1

  scala&gt; Greeter.greet("Bob")(bobsPrompt)                    
  Welcome, Bob. The system is ready.
  relax&gt; 
</pre>

<p>
为了隐式提供参数，要定义<code>implicit</code>修饰期望类型的变量：
</p>

<pre class="brush: scala">
  object JoesPrefs {
    implicit val prompt = new PreferredPrompt("Yes, master&gt; ")
  }
</pre>

<p>
注意它本身也要被定义为<code>implicit</code>，不然是不会被用来作为隐式变量的。而且如果不是在同一作用域的话，也不能用：
</p>

<pre class="brush: scala">
  scala&gt; Greeter.greet("Joe")
  &lt;console&gt;:7: error: no implicit argument matching parameter
    type PreferredPrompt was found.
         Greeter.greet("Joe")
                 ^
</pre>

<p>
不过引入后就可以用了：
</p>

<pre class="brush: scala">
  scala&gt; import JoesPrefs._         
  import JoesPrefs._

  scala&gt; Greeter.greet("Joe")
  Welcome, Joe. The system is ready.
  Yes, master&gt; 
</pre>

<p>
注意<code>implicit</code>关键字要用于全体参数列表而不是单独参数。下面的例子中<code>Greeter</code>的<code>greet</code>方法最后的参数列表再次被标记为<code>implicit</code>，它有两个参数：<code>prompt: PrefferredPrompt</code>和<code>drink: PrefferedDrink</code>。
</p>

<pre class="brush: scala">
  class PreferredPrompt(val preference: String)
  class PreferredDrink(val preference: String)

  object Greeter {
    def greet(name: String)(implicit prompt: PreferredPrompt,
        drink: PreferredDrink) {

      println("Welcome, "+ name +". The system is ready.")
      print("But while you work, ")
      println("why not enjoy a cup of "+ drink.preference +"?")
      println(prompt.preference)
    }
  }

  object JoesPrefs {
    implicit val prompt = new PreferredPrompt("Yes, master&gt; ")
    implicit val drink = new PreferredDrink("tea")
  }
</pre>

<p>
伴生对象中定义了两个隐式的变量，只要它们不作为单一标识符处于作用域内，不然就不能用来填充缺少的参数列表：
</p>

<pre class="brush: scala">
  scala&gt; Greeter.greet("Joe") 
  &lt;console&gt;:8: error: no implicit argument matching parameter
    type PreferredPrompt was found.
         Greeter.greet("Joe")
                 ^
</pre>

<p>
用<code>import</code>导入：
</p>

<pre class="brush: scala">
  scala&gt; import JoesPrefs._
  import JoesPrefs._
</pre>

<p>
可以自动填充了：
</p>

<pre class="brush: scala">
  scala&gt; Greeter.greet("Joe")(prompt, drink)
  Welcome, Joe. The system is ready.
  But while you work, why not enjoy a cup of tea?
  Yes, master&gt; 


  scala&gt; Greeter.greet("Joe")
  Welcome, Joe. The system is ready.
  But while you work, why not enjoy a cup of tea?
  Yes, master&gt; 
</pre>

<p>
注意这里的没有用<code>String</code>这样的常用类型来作为<code>prompt</code>或<code>drink</code>的类型。就是为了防止被过多地匹配到隐式转换。
</p>

<p>
隐式类型转换常见用法是为了提供显式标明的参数列表信息。考虑下面的代码，它返回传入的列表参数中的最大元素：
</p>

<pre class="brush: scala">
  def maxListUpBound[T &lt;: Ordered[T]](elements: List[T]): T = 
    elements match {
      case List() =&gt;
        throw new IllegalArgumentException("empty list!")
      case List(x) =&gt; x
      case x :: rest =&gt;
        val maxRest = maxListUpBound(rest)
        if (x &gt; maxRest) x
        else maxRest
    }
</pre>

<p>
注意参数类型已经被限制为<code>T &lt;: Ordered[T]</code>，就是说列表的元素<code>T</code>要实现<code>Ordered[T]</code>物质。所以列表是可排序元素的列表。但是缺点是<code>Int</code>列表不行，因为<code>Int</code>没有实现物质<code>Ordered</code>，所以不是<code>Ordered[T]</code>的子类。
</p>

<p>
更加泛用的方法是不限制类型，但是再加一个参数，这个参数是把<code>T</code>转为<code>Ordered[T]</code>的函数。
</p>

<p>
下面的例子中第二个参数被标记为<code>implicit</code>。
</p>

<pre class="brush: scala">
  def maxListImpParm[T](elements: List[T])
        (implicit orderer: T =&gt; Ordered[T]): T =

    elements match {
      case List() =&gt; 
        throw new IllegalArgumentException("empty list!")
      case List(x) =&gt; x
      case x :: rest =&gt;
        val maxRest = maxListImpParm(rest)(orderer)
        if (orderer(x) &gt; maxRest) x
        else maxRest
    }
</pre>

<p>
要排序的列表是必须显式提供的，所以元素的类型<code>T</code>是在编译时就确定的。确定了类型<code>T</code>之后就可以判断<code>T =&gt; Ordered[T]</code>类型的隐式定义是否存在于作用域中。如果存在就隐式传入排序函数<code>order</code>。
</p>

<p>
这种方式在很多Scala的通用库中也用到，它们提供了隐式的排序方法。所以我们上面写的方法可以用在很多类型上：
</p>

<pre class="brush: scala">
  scala&gt; maxListImpParm(List(1,5,10,3))
  res10: Int = 10

  scala&gt; maxListImpParm(List(1.5, 5.2, 10.7, 3.14159))
  res11: Double = 10.7

  scala&gt; maxListImpParm(List("one", "two", "three"))
  res12: java.lang.String = two
</pre>

<dl>
<dt>隐式参数样式规则 </dt>
<dd>就是在要用到隐式转换的地方最好是从自定义的类型开始转而不是从<code>String</code>这样的很常见的类型开始转。如果<code>maxListImpParm</code>直接写成下面这样的方法签名：</dd>
</dl>

<pre class="brush: scala">
  def maxListPoorStyle[T](elments: List[T])
        (implicit orderer: (T, T) =&gt; Boolean): T
</pre>

<p>
这样<code>(T,T) =&gt; Boolean</code>的类型太常见了，很容易被匹配到到不希望匹配到的方法上去。
</p>

<p>
所以简单地说：至少用一个确定的名称为隐式参数类型命名。
</p>


<h2 id="toc_4.6">视界</h2>

<p>
前面的例子还可以再用陷式操作强化。如果把<code>implicit</code>用在参数上，编译器不仅会尝试用隐式值补足这个参数，还会把这个参数当作可用的隐式操作而使用于方法体中。因此方法体中<code>orderer</code>的两处应用都可以被省略。
</p>

<pre class="brush: scala">
  def maxList[T](elements: List[T])
        (implicit orderer: T =&gt; Ordered[T]): T =

    elements match {
      case List() =&gt; 
        throw new IllegalArgumentException("empty list!")
      case List(x) =&gt; x
      case x :: rest =&gt;
        val maxRest = maxList(rest)  // (orderer) is implicit
        if (x &gt; maxRest) x           // orderer(x) is implicit
        else maxRest
    }
</pre>

<p>
编译器会发现上面代码的类型不能匹配。比如如<code>T</code>类型的<code>x</code>不存在<code>&gt;</code>方法，所以<code>x &gt; maxRest</code>不起作用。
</p>

<p>
但编译器在这个时候并不会马上停止，而是先查找能修复这个问题的隐式转换。在这个例子中换成了<code>orderer(x) &gt; maxRest</code>，并且同样把<code>maxList(rest)</code>换成了<code>maxList(rest)(ordered)</code>。
</p>

<p>
回过来看<code>maxList</code>方法中没有提到有<code>ordered</code>参数的地方，所有对<code>ordered</code>的使用都是隐式的。这是一个很常用的代码模式：隐式参数只是用来转换，所以它本身也可以被隐式地使用。
</p>

<p>
在现在的版本，　因为参数名没有被显式调用，所以名称也可以随便定。如，只要不改变<code>maxList</code>的方法体，对于只改变参数名称来说，方法的行为没有任何改变：
</p>

<pre class="brush: scala">
  def maxList[T](elements: List[T])
        (implicit converter: T =&gt; Ordered[T]): T =
    // same body...
</pre>

<p>
改成这样也没有问题：
</p>

<pre class="brush: scala">
  def maxList[T](elements: List[T])
        (implicit iceCream: T =&gt; Ordered[T]): T =
    // same body...
</pre>

<p>
因为这样的方法非常常用，所以Scala可以让代码省略这个参数的名称并使用视界缩短方法头。<code>maxList</code>方法签名可以是这样：
</p>

<pre class="brush: scala">
  def maxList[T &lt;% Ordered[T]](elements: List[T]): T =
    elements match {
      case List() =&gt; 
        throw new IllegalArgumentException("empty list!")
      case List(x) =&gt; x
      case x :: rest =&gt;
        val maxRest = maxList(rest)  // (orderer) is implicit
        if (x &gt; maxRest) x           // orderer(x) is implicit
        else maxRest
    }
</pre>

<p>
可以把<code>T &lt;% Ordered[T]</code>理解为：“T是能被当作<code>Ordered[T]</code>的任何类型”。编译器将调用声明在<code>Predef</code>中的隐式鉴别函数：
</p>

<pre class="brush: scala">
implicit def identity[A](x: A): A = x
</pre>

<p>
如果传入的类型正好就是<code>Ordered[T]</code>，那上面的转换什么也不做，只是简单地把传入的参数再返回出来。
</p>

<h3 id="toc_4.6.1">视界与上界</h3>

<p>
注意这不同于上界表达的意思，上界<code>T &lt;: Ordered[T]</code>的意思是：“<code>T</code>是<code>Ordered[T]</code>”。
</p>

<p>
相比之前用到的上界版本的<code>maxListUpBound</code>方法，唯一的区别就是上界符号与视界符号的不同，但是我们的视界版本可以支持更多类型。
</p>


<h2 id="toc_4.7">隐式操作的调试</h2>

<p>
隐式操作很强大，但也很难调试。这一节包含了一些技巧。
</p>

<h3 id="toc_4.7.1">没有对应的转换规则</h3>

<p>
在程序员认为应该隐式转换但编译器没有转换时，手动把转换调用写出来。这样如果有报错就知道没有隐式转换的原因了。如下面的代码错把<code>stringWrapper</code>当成<code>String</code>转到<code>List</code>而不是<code>RandomAccessSeq</code>：
</p>

<pre class="brush: scala">
scala&gt; val chars: List[Char] = "xyz"
&lt;console&gt;:7: error: type mismatch;
 found   : java.lang.String("xyz")
 required: List[Char]
       val chars: List[Char] = "xyz"
                               ^
</pre>

<h3 id="toc_4.7.2">被其他转换规则干扰</h3>

<p>
如果手动指定转换以后错误消失，那就很有可以是其他的转换规则覆盖了你想要的替换规则。
</p>

<pre class="brush: scala">
  scala&gt; val chars: List[Char] = stringWrapper("xyz")
  &lt;console&gt;:12: error: type mismatch;
   found   : java.lang.Object with RandomAccessSeq[Char]
   required: List[Char]
         val chars: List[Char] = stringWrapper("xyz")
                                 ^
</pre>

<p>
编译器的<code>-Xprint:typer</code>显示隐式转换的信息。如下面的代码中：
</p>

<pre class="brush: scala">
  object Mocha extends Application {

    class PreferredDrink(val preference: String)

    implicit val pref = new PreferredDrink("mocha")

    def enjoy(name: String)(implicit drink: PreferredDrink) {
      print("Welcome, "+ name)
      print(". Enjoy a ")
      print(drink.preference)
      println("!")
    }

    enjoy("reader")
  }
</pre>

<p>
最后一行的：
</p>

<pre class="brush: scala">
  enjoy("reader")
</pre>

<p>
已经被扩展为了：
</p>

<pre class="brush: scala">
  Mocha.this.enjoy("reader")(Mocha.this.pref)
</pre>

<p>
<code>scala - Xprint:typer</code>：
</p>

<pre class="brush: scala">
  $ scalac -Xprint:typer mocha.scala
  [[syntax trees at end of typer]]// Scala source: mocha.scala
  package &lt;empty&gt; {
    final object Mocha extends java.lang.Object with Application
        with ScalaObject {

      // ...

      private[this] val pref: Mocha.PreferredDrink =
        new Mocha.this.PreferredDrink("mocha");
      implicit &lt;stable&gt; &lt;accessor&gt;
        def pref: Mocha.PreferredDrink = Mocha.this.pref;
      def enjoy(name: String)
          (implicit drink: Mocha.PreferredDrink): Unit = {
        scala.this.Predef.print("Welcome, ".+(name));
        scala.this.Predef.print(". Enjoy a ");
        scala.this.Predef.print(drink.preference);
        scala.this.Predef.println("!")
      };
      Mocha.this.enjoy("reader")(Mocha.this.pref)
    }
  }
</pre>
 </div>
</body>
</html>
