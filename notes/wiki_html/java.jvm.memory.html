<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">

<script type="text/javascript" src="../../vimwiki-theme/code/theme/scripts/jquery-1.4.2.min.js"></script>

<link type="text/css" rel="stylesheet" href="../../vimwiki-theme/hightlight-code/styles/shCore.css"/>
<link type="text/css" rel="stylesheet" href="../../vimwiki-theme/hightlight-code/styles/shThemeDefault.css"/>
<script type="text/javascript" src="../../vimwiki-theme/hightlight-code/scripts/shCore.js"></script>
<script type="text/javascript" src="../../vimwiki-theme/hightlight-code/scripts/shAutoloader.js"></script>

<script type="text/javascript" src="../../vimwiki-theme/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

<script type="text/javascript" src="../../vimwiki-theme/code/theme/scripts/script.js"></script>
<link type="text/css" rel="stylesheet" href="../../vimwiki-theme/code/theme/styles/style.css" />


<title>虚拟机内存</title>
</head>
<body  onresize='changeTocSize()'>
	<div class="note-main"> 


<h1>虚拟机内存</h1>
<div class="toc">
<ul>
<li><a href="#toc_1">内存区域</a>
<ul>
<li><a href="#toc_1.1">Java堆（Java Heap）</a>
<li><a href="#toc_1.2">虚拟机栈（JVM Statck）</a>
<li><a href="#toc_1.3">本地方法栈（Native Statck）</a>
<li><a href="#toc_1.4">方法区（Method Area）</a>
<ul>
<li><a href="#toc_1.4.1">常量池（Runtime Constant Pool）</a>
</ul>
<li><a href="#toc_1.5">直接内存区（Direct Memory）</a>
</ul>
<li><a href="#toc_2">GC与内存分配策略</a>
<ul>
<li><a href="#toc_2.1">回收算法</a>
<ul>
<li><a href="#toc_2.1.1">新生代</a>
<li><a href="#toc_2.1.2">老年代</a>
<li><a href="#toc_2.1.3">空间分配担保</a>
</ul>
<li><a href="#toc_2.2">垃圾收集器种类</a>
<ul>
<li><a href="#toc_2.2.1">新生代收集器</a>
<ul>
<li><a href="#toc_2.2.1.1">Serial</a>
<li><a href="#toc_2.2.1.2">ParNew</a>
<li><a href="#toc_2.2.1.3">Parallel Scavenge</a>
</ul>
<li><a href="#toc_2.2.2">老年代收集器</a>
<ul>
<li><a href="#toc_2.2.2.1">Serial Old</a>
<li><a href="#toc_2.2.2.2">CMS</a>
</ul>
<li><a href="#toc_2.2.3">G1收集器</a>
<li><a href="#toc_2.2.4">收集器参数</a>
</ul>
</ul>
</ul>
</div>

<h1 id="toc_1">内存区域</h1>

<h2 id="toc_1.1">Java堆（Java Heap）</h2>

<pre class="brush: bash">
-Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError
</pre>

<p>
运行该命令通知JVM拍摄一个“堆转储快照”，并将其保存在一个文件中以便处理，通常使用
<code>jhat</code>工具。您可以使用相应的<code>-XX:HeapDumpPath</code>标志指定到保存文件的实际路径。
</p>

<p>
<code>-XX:+HeapDumpOnCtrlBreak</code>参数在<code>Control + Break</code>时产生转储文件。
</p>

<h2 id="toc_1.2">虚拟机栈（JVM Statck）</h2>

<p>
HotSpot模拟机中<code>-Xoss</code>没有用的，栈容量由<code>-Xss</code>设定。
</p>

<h2 id="toc_1.3">本地方法栈（Native Statck）</h2>

<p>
基本同上。
</p>

<h2 id="toc_1.4">方法区（Method Area）</h2>

<p>
设置大小：<code>-XX:PermSize</code>和<code>-XX:MaxPermSize</code>
</p>

<p>
不对类进行回收：<code>-Xnoclassgc</code>
</p>

<p>
查看类加载与卸载信息：<code>-=verbose:class</code>、<code>-XX:+TraceClassLoading</code>、
<code>-XX:+TraceClassUnLoading</code>
</p>

<p>
<code>-=verbose:class</code>、<code>-XX:+TraceClassLoading</code>可以在Product版JVM中使用。
<code>-XX:+TraceClassUnLoading</code>只能在fastdebug版中使用。
</p>

<h3 id="toc_1.4.1">常量池（Runtime Constant Pool）</h3>

<h2 id="toc_1.5">直接内存区（Direct Memory）</h2>

<p>
<code>-XX:MaxDirectMemorySize</code>默认和<code>-Xmx</code>的一样。
</p>


<h1 id="toc_2">GC与内存分配策略</h1>

<p>
收集器日志：<code>-XX:+PrintGCDetails</code>
</p>

<p>
跨代码快速运行<code>grep</code>，就会发现清单1所示的问题—原始Java性能反模式如手动调用GC:
</p>

<pre class="brush: java">
System.gc();
</pre>

<p>
显式垃圾收集是一个非常糟糕的主意——就像将您和一个疯狂的斗牛犬锁在一个电话亭里。
尽管调用的语法是依赖实现的，但如果您的JVM正在运行一个分代的垃圾回收器（大多数是
）<code>System.gc()</code>;强迫VM执行一个堆的“全部清扫”，虽然有的没有必要。全部清扫比一个
常规GC操作要昂贵好几个数量级，这只是个简单数学问题。
</p>

<p>
Sun的工程师为这个特殊的人工错误提供一个JVM标志：<code>-XX:+DisableExplicitGC</code>。自动将
<code>System.gc()</code>调用转换成一个空操作，提供运行代码的机会。您自己看看<code>System.gc()</code>
对于整个JVM执行有害还是有利。
</p>


<h2 id="toc_2.1">回收算法</h2>

<h3 id="toc_2.1.1">新生代</h3>

<p>
新生代大小：<code>-Xmn10M</code>
</p>

<p>
新生代中Eden与Survivor比例，默认8比1：<code>-XX:SurvivorRatio=8</code>
</p>

<h3 id="toc_2.1.2">老年代</h3>

<p>
设置大对象直接放老年代：<code>-XX:PretenureSizeThreshold=3145728</code>单位是<code>B</code>不能用<code>M</code>。
</p>

<p>
每活过一次GC的对象年龄加一岁。默认一岁放在Servivor里，15岁放到老年代：
<code>-XX:MaxTenuringThreshold=15</code>。但即使不到年龄，如果相同年龄的占空间大小点到了
Survivor的一半，也入老年代。
</p>

<h3 id="toc_2.1.3">空间分配担保</h3>

<p>
防止分配担保失败时过多调用Full GC：<code>-XX:+HandlePromotionFailure</code>
</p>


<h2 id="toc_2.2">垃圾收集器种类</h2>

<h3 id="toc_2.2.1">新生代收集器</h3>

<h4 id="toc_2.2.1.1">Serial</h4>

<p>
Client模式下默认收集器。开关：<code>UseSerialGC</code>
</p>

<h4 id="toc_2.2.1.2">ParNew</h4>

<p>
Serial多线程版本<code>-XX:+UseParNewGC</code>。
</p>

<p>
CMS收集器（Concurrent Mark Sweep）作为老年代收集器，不能用Parallel Scavenge配合
。所以这种情况下只能用ParNew或Serial。
</p>

<p>
要用<code>-XX:+UseConcMarkSweepGC</code>选项让ParNew配CMS，当CMS抛Concurrent Mode Failure
失败后换Serial Old新生代收集器。
</p>

<h4 id="toc_2.2.1.3">Parallel Scavenge</h4>

<p>
吞吐量优先更加高效。
</p>

<p>
控制收集停顿时间：<code>-XX:MaxGCPauseMillis</code>；
</p>

<p>
设置时间比<code>(1/(1+值))</code>：<code>-XX:GCTimeRatio</code>。默认值99，即(1/(1+99))等于1%。
</p>

<p>
策略参数<code>-XX:+UseAdaptiveSizePolicy</code>，设以后不用手工设置新生代大小<code>-Xmm</code>、Eden与
Survivor区的比例<code>-XX:PretenureSizeThreshold</code>等细节。
</p>

<h3 id="toc_2.2.2">老年代收集器</h3>

<h4 id="toc_2.2.2.1">Serial Old</h4>

<p>
单线程，Client模式下使用。
</p>

<h4 id="toc_2.2.2.2">CMS</h4>

<p>
默认在老年代使用了70%后触发。设置触发百分比： 
<code>-XX:CMSInitiatingOccupancyFraction</code>
</p>

<p>
由于算法基于标记回收产生碎片较多，<code>-XX:+UseCMSCompactAtFullCollection</code>在Full GC
后整理碎片。
</p>

<h3 id="toc_2.2.3">G1收集器</h3>

<h3 id="toc_2.2.4">收集器参数</h3>

<table>
<tr>
<td>
UseSerialGC
</td>
<td>
Client模式默认，Serial与Serial Old组合
</td>
</tr>
<tr>
<td>
UseParNewGC
</td>
<td>
ParNew与Serial Old组合
</td>
</tr>
<tr>
<td>
UseConcMarkSweepGC
</td>
<td>
ParNew配CMS，当CMS抛并发模式异常换Serial Old
</td>
</tr>
<tr>
<td>
UseParallelGC
</td>
<td>
Sever模式默认，Parallel Scavenge与Serial Old组合
</td>
</tr>
<tr>
<td>
UseParallelOldGC
</td>
<td>
使用Parallel Scavenge与Parallel Old组合
</td>
</tr>
<tr>
<td>
SurvivorRatio
</td>
<td>
<code>Eden</code>与<code>Survivor</code>容量比，默认8比1
</td>
</tr>
<tr>
<td>
PretenureSizeThreshold
</td>
<td>
多大的对象直接入老年代
</td>
</tr>
<tr>
<td>
MaxTenuringThreshold
</td>
<td>
进入老年代的年龄
</td>
</tr>
<tr>
<td>
UseAdaptiveSizePolicy
</td>
<td>
动态调整Java堆中各区域大小及进入老年代的年龄
</td>
</tr>
<tr>
<td>
HandlePromotionFailure
</td>
<td>
分配担保失败，老年代放不下Eden和Survivor的情况
</td>
</tr>
<tr>
<td>
ParallelGCThreads
</td>
<td>
并行GC时内存回收的线程数
</td>
</tr>
<tr>
<td>
GCTimeRatio
</td>
<td>
GC占有时间比
</td>
</tr>
</table>

<p>
Parallel Scavenge
</p>

<table>
<tr>
<td>
MaxGCPauseMillis
</td>
<td>
GC最大停顿时间
</td>
</tr>
</table>

<p>
CMS收集器参数
</p>
<table>
<tr>
<td>
CMSInitiatingOccupancyFraction
</td>
<td>
老年代使用多少次后触发GC
</td>
</tr>
<tr>
<td>
UseCMSCompactAtFullCollection
</td>
<td>
是否在完成GC后整理内存
</td>
</tr>
<tr>
<td>
CMSFullGCsBeforeCompaction
</td>
<td>
进行若干次GC后再内存整理一次
</td>
</tr>
</table>
 </div>
</body>
</html>
