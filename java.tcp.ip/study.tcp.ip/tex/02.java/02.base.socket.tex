
\chapter{基本套接字}

	现在我们可以学习如何编写自己的套接字应用程序了。我们首先通过使用 InetAddress类和 SocketAddress 类来示范 Java 应用程序如何识别网络主机。然后,举了一个使用 TCP协议的客户端和服务器端例子来展示 Socket 类和 ServerSocket 类的用法。同样,我们举了一个使用 UDP 协议的客户端和服务器端例子来展示 DatagramSocket 类的用法。对于每个类对应的网络抽象,列举出了各个类中最重要的方法,根据这些方法的不同用途进行了分组,并简要描述了它们的功能。

	\section{套接字地址}

		回顾前面章节所讲的内容,一个客户端要发起一次通信,首先必须知道运行服务器端程序的主机的 IP 地址。然后由网络的基础结构利用目标地址(destination address),将客户端发送的信息传递到正确的主机上。在 Java 中,地址可以由一个字符串来定义,这个字符串可以是数字型的地址(不同版本的 IP 地址有不同的型式,如 192.0.2.27 是一个 IPv4 地址,fe20:12a0::0abc:1234 是一个 IPv6 地址),也可以是主机名(如 server.example.com)。在后面的例子中,主机名必须被解析(resolved)成数字型地址才能用来进行通信。

		InetAddress 类代表了一个网络目标地址,包括主机名和数字类型的地址信息。该类有两个子类,Inet4Address 和 Inet6Address,分别对应了目前 IP 地址的两个版本。InetAddress实例是不可变的,一旦创建,每个实例就始终指向同一个地址。我们将通过一个示例程序来示范 InetAddress 类的用法。在这个例子中,首先打印出与本地主机关联的所有 IP 地址,包括 IPv4 和 IPv6,然后对于每个在命令行中指定的主机,打印出其相关的主机名和地址。为了获得本地主机地址,示例程序利用了 NetworkInterface 类的功能。前面已经讲过,IP 地址实际上是分配给了主机与网络之间的连接,而不是主机本身。NetworkInterface 类提供了访问主机所有接口的信息的功能。这个功能非常有用,比如当一个程序需要通知其他程序其 IP 地址时就会用到。

		\lstinputlisting[]{src/ch02/InetAddressExample.java}

		1.获取主机的网络接口列表:第18-19行

		静态方法 getNetworkInterfaces()返回一个列表,其中包含了该主机每一个接口所对应的NetworkInterface 类实例。

		2. 空列表检测:第 20-22 行

		通常情况下,即使主机没有任何其他网络连接,回环接口也总是存在的。因此,只要当一个主机根本没有网络子系统时,列表检测才为空。

		3. 获取并打印出列表中每个接口的地址:第 23-47 行

		打印接口名:第 15 行getName()方法为接口返回一个本地名称。接口的本地名称通常由字母与数字的联合组成,代表了接口的类型和具体实例,如"lo0"或"eth0"。

		获取与接口相关联的地址:第 26-27 行

		getInetAddresses()方法返回了另一个 Enumeration 类对象,其中包含了 InetAddress 类的实例,即该接口所关联的每一个地址。根据主机的不同配置,这个地址列表可能只包含 IPv4或 IPv6 地址,或者是包含了两种类型地址的混合列表。

		空列表检测:第 28-31 行

		列表的迭代,打印出每个地址:第 32-46 行

		对每个地址实例进行检测以判断其属于哪个 IP 地址子类(目前 InetAddress 的子类只有上面列出的那些,但可以想像到,将来也许还会有其他子类)。InetAddress 类的getHostAddress()方法返回一个字符串来代表主机的数字型地址。不同类型的地址对应了不同的格式:IPv4 是点分形式,IPv6 是冒号分隔的 16 进制形式。参考下文中的"字符串表示法"概要,其对不同类型的 IP 地址格式进行了描述。

		4. 捕获异常:第 49-52 行

		对 getNetworkInterfaces()方法的调用将会抛出 SocketException 异常。

		5. 获取从命令行输入的每个参数所对应的主机名和地址:第 34-44 行

		获取给定主机/地址的相关地址列表:第 60 行

		迭代列表,打印出列表中的每一项:第 61-64 行

		对于列表中的每个主机,我们通过调用 getHostName()方法来打印主机名,并把调用getHostAddress()方法所获得的数字型地址打印在主机名后面。

		为了使用这个应用程序来获取本地主机信息、出版社网站(www.mkp.com)服务器信息、一个虚假地址信息(blah.blah)、以及一个IP地址的信息,需要在命令行中运行如下代码:

		\lstinputlisting[language=Bash,firstline=1,lastline=3]{src/ch02/InetAddressExample.txt}

		得到的结果为：

		\lstinputlisting[language=Bash,firstline=5,lastline=17]{src/ch02/InetAddressExample.txt}

		你也许已经注意到,一些 IPv6 地址带有\%d 型式的后缀,其中 d 是一个数字。这样的地址在一个有限的范围内(通常它们是本地链接),其后缀表明了该地址所关联的特定范围。这就保证了列出的每个地址字符串都是唯一的。IPv6 的本地链接地址由 fe8 开头。

		你可能还注意到,当程序解析 blah.blah 这个虚假地址时,会有一定的延迟。地址解析器在放弃对一个主机名的解析之前,会到多个不同的地方查找该主机名。如果由于某些原因使名字服务失效(例如由于程序所运行的机器并没有连接到所有的网络),试图通过名字来定位一个主机就可能失败。而且这还将耗费大量的时间,因为系统将尝试各种不同的方法来将主机名解析成 IP 地址,因此最好能直接使用点分形式的 IP 地址来访问一个主机。在本书的所有例子中,如果远程主机由名字指定,运行示例程序的主机必须配置为能够将名字解析成地址,否则示例程序将无法正确运行。如果能通过主机的名字 ping 到该主机(如,在命令行窗口中执行命令"ping server.example.com"),那么在示例程序中就可以使用主机名。如果 ping 测试失败或示例程序挂起,可以尝试使用 IP 地址来定位主机,这就完全避免了从名字到地址的转换。(参见后文将要讨论的 InetAddress 类的 isReachable()方法) 

		InetAddress类中创建与访问实例方法：

		\lstinputlisting[language=Bash,firstline=21,lastline=29]{src/ch02/InetAddressExample.txt}

		这些静态工厂方法所返回的实例能够传递给另一个套接字方法来指定一个主机。这些方法的输入字符串可以是一个域名,如"skeezix"或 "farm.example.com",也可以是一个代表数字型地址的字符串。对于 IPv6 地址,第 1 章所提到的缩写形式同样适用。一个名字可能关联了多个数字地址,getAllByName()方法用于返回一组与给定主机名相关联的所有地址的实例。

		getAddress()方法返回一个适当长度的字节数组,代表地址的二进制的形式。如果是一个 Inet4Address 实例,该数组长 4 个字节;如果是 Inet6Address 实例,则长 16 字节。返回的数组的第一个元素是该地址中最重要的字节。

		我们已看到,一个 InetAddress 实例可以通过多种方式转换成字符串形式。

		InetAddress类中字符串显示方法：

		\lstinputlisting[language=Bash,firstline=41,lastline=56]{src/ch02/InetAddressExample.txt}

		上面这些方法返回主机名或数字型地址,或者以一定格式的字符串返回两者的联合形式。toString()方法重写了 Object 类的方法,返回如"hostname.example.com/192.0.2.127"或"never.example.net/2000::620:1a30:95b2 "形式的字符串。单一的数字型地址表示形式由getHostAddress()方法返回。对于 IPv6 地址,字符串中总是包含了完整的 8 组数字(即显示地列出了 7 个":"),这样做是为了消除二义性。因为通常情况下,地址字符串后还会附有由另一个分号隔开的端口号,后面我们将看到这样的例子。而且,对于有范围限制的 IPv6地址,如本地链接地址,还会在后面附有一个范围标识符(scope identifier)。这只是一个用于消除二义性(因为同样的本地链接地址能用于不同的链接中)的本地标识符,不是数据报文中所传输的地址的一部分。

		最后两个方法只返回主机名,它们的区别在于:如果实例最初通过主机名创建,getHostName()则直接返回这个名字,没有解析的步骤;否则,getHostName()要通过系统配置的名字解析机制将地址解析成名字。另一方面,getCanonicalName()方法总是尝试对地址进行解析,以获取主机域名全称(fully qualified domain name),如"ns1.internat.net" 或"bam.example.com"。注意,如果不同名字映射到了同一地址,该方法所返回的主机名可能与最初用于创建实例的主机名不同。如果名字解析失败,两个方法都将返回数字型地址,而且在发送任何消息之前,都将用安全管理器进行许可检查。

		InetAddress 类还支持地址属性的检查,如判断其是否属于 1.2 节提到的"特殊用途"地址中的某一类,以及检测其可达性,即与主机进行报文交互的能力。

		InetAddress类中检查属性的方法：

		\lstinputlisting[language=Bash,firstline=61,lastline=77]{src/ch02/InetAddressExample.txt}

		这些方法检查一个地址是否属于某个特定类型。它们对 IPv4 地址和 IPv6 地址都适用。上述前三个方法分别检查地址实例是否属于"任意"本地地址,本地链接地址,以及回环地址(匹配 127.*.*.* 或 ::1 的形式)。第 4 个方法检查其是否为一个多播地址(见 4.3.2 节),而 isMC...()形式的方法检测多播地址的各种范围(scopes)。(范围粗略地定义了到达该目的地址的数据报文从它的起始地址开始,所能传递的最远距离。)

		最后两个方法检查是否真能与 InetAddress 地址确定的主机进行数据报文交换。注意,与其他句法检查方法不一样的是,这些方法引起网络系统执行某些动作,即发送数据报文。系统不断尝试发送数据报文,直到指定的时间(以毫秒为单位)用完才结束。后面这种形式更详细:它明确指出数据报文必须经过指定的网络接口(NetworkInterface),并检查其是否能在指定的生命周期(time-to-live,TTL)内联系上目的地址。TTL 限制了一个数据报文在网络上能够传输的距离。后面两个方法的有效性通常还受到安全管理配置方面的限制。

		NetworkInterface 类提供了更多的方法,其中有很多方法不属于本书的讨论范围。下面,我们只对与我们所讨论的问题最有用的方法进行描述。

		NetworkInterface创建与获取的方法：

		\lstinputlisting[language=Bash,firstline=91,lastline=96]{src/ch02/InetAddressExample.txt}

		上面第一个方法非常有用,使用它可以很容易获取到运行程序的主机的 IP 地址:通过getNetworkInterfaces()方法可以获取一个接口列表,再使用实例的 getInetAddresses()方法就可以获取每个接口的所有地址。注意:这个列表包含了主机的所有接口,包括不能够向网络中的其他主机发送或接收消息的虚拟回环接口。同样,列表中可能还包括外部不可达的本地链接地址。由于这些列表都是无序的,所以你不能简单地认为,列表中第一个接口的第一个地址一定能够通过互联网访问,而是要通过前面提到的 InetAddress 类的属性检查方法,来判断一个地址不是回环地址,不是本地链接地址等等。

		getName()方法返回一个接口(interface)的名字(不是主机名)。这个名字由字母字符串加上一个数字组成,如 eth0。在很多系统中,回环地址的名字都是 lo0。

	\section{TCP套接字}

		Java 为 TCP 协议提供了两个类:Socket 类和 ServerSocket 类。一个 Socket 实例代表了TCP 连接的一端。一个 TCP 连接(TCP connection)是一条抽象的双向信道,两端分别由 IP地址和端口号确定。在开始通信之前,要建立一个 TCP 连接,这需要先由客户端 TCP 向服务器端 TCP 发送连接请求。ServerSocket 实例则监听 TCP 连接请求,并为每个请求创建新的 Socket 实例。也就是说,服务器端要同时处理 ServerSocket 实例和 Socket 实例,而客户端只需要使用 Socket 实例。

		我们从一个简单的客户端例子开始介绍。

		\subsection{TCP客户端}

		客户端向服务器发起连接请求后,就被动地等待服务器的响应。典型的 TCP 客户端要经过下面三步:

		1.创建一个 Socket 实例:构造器向指定的远程主机和端口建立一个 TCP 连接。

		2. 通过套接字的输入输出流(I/O streams)进行通信:一个 Socket 连接实例包括一个InputStream 和一个 OutputStream,它们的用法同于其他 Java 输入输出流。(见 2.2.3 节)

		3. 使用 Socket 类的 close()方法关闭连接。

		我们的第一个 TCP 应用程序叫 TCPEchoClient.java,这是一个通过 TCP 协议与回馈服务器(echo server)进行通信的客户端。回馈服务器的功能只是简单地将收到的信息返回给客户端。在这个程序中,要回馈的字符串以命令行参数的型式传递给我们的客户端。很多系统都包含了用于进行调试和测试的回馈服务程序。你也许可以使用 telnet 程序来检测你的系统上是否运行了标准的回馈服务程序(如在命令行中输入"telnet server.example.com 7"),或者继续阅读本书,并运行下一节的服务器端示例程序。

		\lstinputlisting[]{src/ch02/TCPEchoClient.java}

		1. 应用程序设置与参数解析:第 13-29 行

		转换回馈字符串:第 15 行TCP 套接字发送和接收字节序列信息。String 类的 getBytes()方法将返回代表该字符串的一个字节数组。(见 3.1 节讨论的字符编码)

		确定回馈服务器的端口号:第 29 行

		默认端口号是 7。如果我们给出了第三个参数,Integer.parseInt()方法就将第三个参数字符串转换成相应的整数,并作为端口号。

		2.创建 TCP 套接字:第 32 行

		Socket 类的构造函数将创建一个套接字,并将其连接到由名字或 IP 地址指定的服务器,再将该套接字返回给程序。注意,底层的 TCP 协议只能处理 IP 地址,如果给出的是主机的名字,Socket 类具体实现的时候会将其解析成相应的地址。若因某些原因连接失败,构造函数将抛出一个 IOException 异常。

		3.获取套接字的输入输出流:第 35-36 行

		每个 Socket 实例都关联了一个 InputStream 和一个 OutputStream 对象。就像使用其他流一样,我们通过将字节写入套接字的 OutputStream 来发送数据,并通过从 InputStream 读取信息来接受数据。

		4.发送字符串到回馈服务器:第 38 行

		OutputStream 类的 write()方法将指定的字节数组通过之前建立好的连接,传送到指定的服务器。

		5.从回馈服务器接受回馈信息:第 40-49 行

		既然已经知道要从回馈服务器接收的字节数,我们就能重复执行接收过程,直到接收了与发送的字节数相等的信息。这个特殊型式的 read()方法需要 3 个参数:
		
		1)接收数据的字节数组,
		
		2)接收的第一个字节应该放入数组的位置,即字节偏移量,
		
		3)放入数组的最大字节数。
		
		read()方法在没有可读数据时会阻塞等待,直到有新的数据可读,然后读取指定的最大字节数,并返回实际放入数组的字节数(可能少于指定的最大字节数)。循环只是简单地将数据填入 data 字节数组,直到接收的字节数与发送的字节数一样。如果 TCP 连接被另一端关闭,read()方法返回-1。对于客户端来说,这表示服务器端提前关闭了套接字。为什么不只用一个 read 方法呢?TCP 协议并不能确定在 read()和 write()方法中所发送信息的界限,也就是说,虽然我们只用了一个 write()方法来发送回馈字符串,回馈服务器也可能从多个块(chunks)中接受该信息。即使回馈字符串在服务器上存于一个块中,在返回的时候,也可能被 TCP 协议分割成多个部分。对于初学者来说,最常见的错误就是认为由一个 write()方法发送的数据总是会由一个 read()方法来接收。

		6. 打印回馈字符串:第 51 行

		要打印服务器的响应信息,我们必须通过默认的字符编码将字节数组转换成一个字符串。

		7.关闭套接字:第 53 行

		当客户端接收到所有的回馈数据后,将关闭套接字。

		我们可以使用以下两种方法来与一个名叫 server.example.com,IP 地址为 192.0.2.1 的回馈服务器进行通信。

		Socket：创建

		\lstinputlisting[language=Java,firstline=1,lastline=7]{src/ch02/TCPEchoClient.txt}

		前四个构造函数在创建了一个 TCP 套接字后,先连接到(connect)指定的远程地址和端口号,再将其返回给程序。前两个构造函数没有指定本地地址和端口号,因此将采用默认地址和可用的端口号。在有多个接口的主机上指定本地地址是有用的。指定的目的地址字符串参数可以使用与 InetAddress 构造函数的参数相同的型式。最后一个构造函数创建一个没有连接的套接字,在使用它进行通信之前,必须进行显式连接(通过 connect()方法,见下文)。

		Socket：操作

		\lstinputlisting[language=Java,firstline=11,lastline=17]{src/ch02/TCPEchoClient.txt}

		connect()方法将使指定的终端打开一个 TCP 连接。SocketAddress 抽象类代表了套接字地址的一般型式,它的子类 InetSocketAddress 是针对 TCP/IP 套接字的特殊型式(见下文介绍) 与远程主机的通信是通过与套接字相关联的输入输出流实现的。可以使用 get...Stream()方法来获取这些流。

		close()方法关闭套接字及其关联的输入输出流,从而阻止对其的进一步操作。shutDownInput()方法关闭 TCP 流的输入端,任何没有读取的数据都将被舍弃,包括那些已经被套接字缓存的数据、正在传输的数据以及将要到达的数据。后续的任何从套接字读取数据的尝试都将抛出异常。shutDownOutput()方法在输出流上也产生类似的效果,但在具体实现中,已经写入套接字输出流的数据,将被尽量保证能发送到另一端。详情见 4.5 节。

		注意:默认情况下,Socket 是在 TCP 连接的基础上实现的,但是在 Java 中,你可以改变 Socket 的底层连接。由于本书是关于 TCP/IP 的,因此为了简便我们假设所有这些网络类的底层实现都与默认情况一致。

		Socket：获取／检测属性

		\lstinputlisting[language=Java,firstline=21,lastline=26]{src/ch02/TCPEchoClient.txt}

		这些方法返回套接字的相应属性。实际上,本书中所有返回 SocketAddress 的方法返回的都是 InetSocketAddress 实例,而 InetSocketAddress 中封装了一个 InetAddress 和一个端口号。

		Socket 类实际上还有大量的其他相关属性,称为套接字选项(socket options)。这些属性对于编写基本应用程序是不必要的,因此我们推迟到第 4.4 节才对它们进行介绍。

		InetSocketAddress: 创建与访问

		\lstinputlisting[language=Java,firstline=31,lastline=43]{src/ch02/TCPEchoClient.txt}


		InetSocketAddress 类为主机地址和端口号提供了一个不可变的组合。只接收端口号作为参数的构造函数将使用特殊的"任何"地址来创建实例,这点对于服务器端非常有用。接收字符串主机名的构造函数会尝试将其解析成相应的 IP 地址,而 createUnresolved()静态方法允许在不对主机名进行解析情况下创建实例。如果在创建 InetSocketAddress 实例时没有对主机名进行解析,或解析失败,isUnresolved()方法将返回 true。get...()系列方法提供了对指定属性的访问,getHostName()方法将返回 InetSocketAddress 内部 InetAddress 所关联的主机名。toString()方法重写了 Object 类的 toString()方法,返回一个包含了主机名、数字型地址(如果已知)和端口号的字符串。其中,主机名与地址之间由'/'(斜线)隔开,地址和端口号之间由':'(冒号)隔开。如果 InetSocketAddress 的主机名没有解析,则冒号前只有创建实例时的主机名字符串。

	\subsection{TCP服务端}

		服务器端的工作是建立一个通信终端并等待客户端的连接。典型的工作有：

		1）建立一个ServerSocket实例并指定到本地端口，侦听该端口收到的所有连接。

		2）重复执行以下步骤：

		a）调用ServletSocket的accept()方法获取下一个客户端的连接。基于新的客户端连接，创建一个Socket()实例，并由accept()方法返回。

		b）通过得到的Socket的输入输出流进行通信。

		c）通信完成，使用Socket的close()方法关闭连接。

		服务器端的示例如下：

		\lstinputlisting[]{src/ch02/TCPEchoServer.java}

		ServerSocket的构造函数有：

		\lstinputlisting[language=Java,firstline=51,lastline=54]{src/ch02/TCPEchoClient.txt}

		注意参数中的队列长度不是一个严格限制，也不能用来控制客户端的总数。

		如果指定了本地地址，这个地址就一定要是本主机的网络接口之一；如果没有指定，套接字会接受指向本主机任何IP地址的连接，这对于有多个接口的服务器非常有用。

		没有参数的构造函数生产的实例在使用前，必须使用bind()方法为其绑定一个端口号。

		ServerSocket常用操作：

		\lstinputlisting[language=Java,firstline=61,lastline=64]{src/ch02/TCPEchoClient.txt}

		bind()方法为套接字关联一个本地的端口。如果该实例已经关联了一个端口，或指定的端口已经被战胜，则抛出IOException异常。

		ServerSocket取得属性：

		\lstinputlisting[language=Java,firstline=71,lastline=73]{src/ch02/TCPEchoClient.txt}
		
	\subsection{输入输出流}

		OutputStream操作：

		\lstinputlisting[language=Java,firstline=81,lastline=85]{src/ch02/TCPEchoClient.txt}
		
		输出一个字节的write方法只将整形参数的低8位输出。注意如果输出流上的输出在另一端还没有被read()方法读取时会产生阻塞。

		InputStream操作：

		\lstinputlisting[language=Java,firstline=91,lastline=95]{src/ch02/TCPEchoClient.txt}

		available()方法作用是返回当前可读字节的总数。
		
