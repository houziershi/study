package ch03;

public class BruteForceCoding {

	/**
	 * 把长度为size个字节的变量long存入数组dst，dst前offset个字节已经存放了其他内容了。
	 * 
	 * @param dst
	 *            存放消息的数组
	 * @param offset
	 *            存放的起始位置
	 * @param val
	 *            要存放的值
	 * @param size
	 *            存放的值占几个字节
	 * @return 存放后数组被使用了多少个字节（新的offset）
	 */
	public static int encodeIntBigEndian(byte[] dst, int offset, long val,
			int size) {
		// Warning: Untested preconditions (e.g., 0 <= size <= 8)
		for (int i = 0; i < size; i++) {
			// 先通过位移把要取的那8位移到最低，
			// 通过强制转换把最低的8位转为一个byte。
			dst[offset++] = (byte) (val >> ((size - i - 1) * Byte.SIZE));
		}
		return offset;
	}

	/**
	 * 从数组中取出数据
	 * 
	 * @param val
	 *            存放消息的数组
	 * @param offset
	 *            存放的起始位置
	 * @param size
	 *            存放的值占几个字节
	 * @return
	 */
	public static long decodeIntBigEndian(byte[] val, int offset,//
			int size) {
		// Warning: Untested preconditions (e.g., 0 <= size <= 8)
		long rtn = 0;
		for (int i = 0; i < size; i++) {
			rtn = (rtn << Byte.SIZE) | ((long) val[offset + i] & 0xFF);
		}
		return rtn;
	}

	public static void main(String[] args) {
		byte byteVal = 101;
		short shortVal = 10001;
		int intVal = 100000001;
		long longVal = 1000000000001L;
		System.out.print("       In Logic: ");
		System.out.print(Integer.toHexString(byteVal).toUpperCase());
		System.out.print(" ");
		System.out.print(Integer.toHexString(shortVal).toUpperCase());
		System.out.print(" ");
		System.out.print(Integer.toHexString(intVal).toUpperCase());
		System.out.print(" ");
		System.out.println(Long.toHexString(longVal).toUpperCase());

		/*
		 * 
		 */
		int BSIZE = Byte.SIZE / Byte.SIZE;
		int SSIZE = Short.SIZE / Byte.SIZE;
		int ISIZE = Integer.SIZE / Byte.SIZE;
		int LSIZE = Long.SIZE / Byte.SIZE;
		byte[] message = new byte[BSIZE + SSIZE + ISIZE + LSIZE];
		// Encode the fields in the target byte array
		int offset = 0;
		offset = encodeIntBigEndian(message, offset, byteVal, BSIZE);
		offset = encodeIntBigEndian(message, offset, shortVal, SSIZE);
		offset = encodeIntBigEndian(message, offset, intVal, ISIZE);
		offset = encodeIntBigEndian(message, offset, longVal, LSIZE);
		System.out.println("Encoded message: "
				+ byteArrayToDecimalString(message));

		// Decode several fields
		long value = decodeIntBigEndian(message, BSIZE, SSIZE);
		System.out.println("Decoded short = " + value);
		value = decodeIntBigEndian(message, BSIZE + SSIZE + ISIZE, LSIZE);
		System.out.println("Decoded long = " + value);

		// Demonstrate dangers of conversion
		offset = 4;
		value = decodeIntBigEndian(message, offset, BSIZE);
		System.out.println("Decoded value (offset " + offset + ", size "
				+ BSIZE + ") = " + value);
		byte bVal = (byte) decodeIntBigEndian(message, offset, BSIZE);
		System.out.println("Same value as byte = " + bVal);
	}

	// 用十进制显示数组中的每个字节
	public static String byteArrayToDecimalString(byte[] bArray) {
		StringBuilder rtn = new StringBuilder();
		for (byte b : bArray) {
			// 用十六进制字符串显示一个字节的内容
			rtn.append(transByteToHexString(b)).append(" ");
		}
		return rtn.toString();
	}

	// 用十六进制字符串显示一个字节的内容
	public static String transByteToHexString(byte b) {
		StringBuffer sb = new StringBuffer();
		// 位与，结果是最低的8位
		String hexString = Integer.toHexString(b & 0xFF).toUpperCase();
		if (hexString.length() < 2) {
			sb.append("0");
		}
		sb.append(hexString);
		return sb.toString();
	}
}
